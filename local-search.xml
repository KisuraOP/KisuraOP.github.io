<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【题解】2025 蓝桥杯国赛 CA（更新中）</title>
    <link href="/posts/c80723a0.html"/>
    <url>/posts/c80723a0.html</url>
    
    <content type="html"><![CDATA[<h3 id="e.-树">E. 树</h3><p>令 <span class="math inline">\(dp[x][0/1/2]\)</span> 表示在以 <span class="math inline">\(x\)</span> 为根的子树中，不同选取情况对应的方案数。</p><ul><li><span class="math inline">\(dp[x][0]\)</span>：节点 <span class="math inline">\(x\)</span> 被选中。</li><li><span class="math inline">\(dp[x][1]\)</span>：节点 <span class="math inline">\(x\)</span> 未被选中，但其恰好一个儿子被选中。</li><li><span class="math inline">\(dp[x][2]\)</span>：节点 <span class="math inline">\(x\)</span> 未被选中，且其所有儿子也未被选中。</li></ul><p>转移如下</p><p><span class="math display">\[\large dp[x][0]=\prod_{y\in son[x]}dp[y][2]\]</span></p><p><span class="math display">\[\large dp[x][1]=\sum_{y\in son[x]}\left(dp[y][0]\prod_{z\in son[x],z\neq y}\left(dp[z][1]+dp[z][2]\right)\right)\]</span></p><p><span class="math display">\[\large dp[x][2]=\prod_{y\in son[x]}(dp[y][1]+dp[y][2])\]</span></p><p>答案是 <span class="math inline">\(dp[1][0]+dp[1][1]+dp[1][2]-1\)</span>，减一是为了减去空集。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % mod) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % mod;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span> &amp;&amp; adj[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;dp[x][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;dp[x][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> s0 = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> s1 = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);s0 = s0 * dp[y][<span class="hljs-number">2</span>] % mod;s1 = s1 * (dp[y][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">2</span>]) % mod;&#125;dp[x][<span class="hljs-number">0</span>] = s0;dp[x][<span class="hljs-number">2</span>] = s1;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> inv = <span class="hljs-built_in">qpow</span>(dp[y][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">2</span>], mod - <span class="hljs-number">2</span>);dp[x][<span class="hljs-number">1</span>] = (dp[x][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">0</span>] * s1 % mod * inv % mod) % mod;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans = (dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - <span class="hljs-number">1</span> + mod) % mod;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="f.-连锁反应">F. 连锁反应</h3><p>暴力做法就是对于两个炸弹 <span class="math inline">\(x, y\)</span>，如果 <span class="math inline">\(x\)</span> 炸了能顺带把 <span class="math inline">\(y\)</span> 炸了，就连一条 <span class="math inline">\(x\to y\)</span>。</p><p>将这张图缩点，得到一个 DAG，此时只用数有多少个点入度为 <span class="math inline">\(0\)</span> 即可（我们可以从这些点开始引爆）。</p><p>注意到对于每个炸弹，能被它连锁引爆的炸弹形成一个区间，我们可以二分找到这个区间，从该点向这个区间连边，也就是线段树优化建图。具体的，从这个炸弹对应的叶节点向线段树上被这个区间包含的 <span class="math inline">\(O(\log n)\)</span> 个节点连边。</p><p>问题就在，线段树结构边的存在，使得缩点后我们不能单纯地找入度为 <span class="math inline">\(0\)</span> 的点了。</p><p>但我们仍然可以构建出炸弹的传递链：从所有包含炸弹的 SCC 出发 BFS，标记可达的点。而没被这些点指向的包含炸弹的 SCC，就是一个可行的引爆点。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegEdge</span> &#123;<span class="hljs-type">int</span> n, all;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; id;<span class="hljs-built_in">SegEdge</span>() &#123;&#125;<span class="hljs-built_in">SegEdge</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;all = <span class="hljs-number">4</span> * n;adj.<span class="hljs-built_in">resize</span>(all + <span class="hljs-number">1</span>);id.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> id[l] = p, <span class="hljs-built_in">void</span>();adj[p].<span class="hljs-built_in">push_back</span>(p &lt;&lt; <span class="hljs-number">1</span>);adj[p].<span class="hljs-built_in">push_back</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> rx, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;adj[x].<span class="hljs-built_in">push_back</span>(p);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (lx &lt;= mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, lx, rx, x);<span class="hljs-keyword">if</span> (rx &gt; mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, lx, rx, x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtoS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, id[x]);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>); <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> p, l, r;cin &gt;&gt; p &gt;&gt; l &gt;&gt; r;a[i] = &#123;p, l, r&#125;;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;b[i] = a[i][<span class="hljs-number">0</span>];&#125;<span class="hljs-function">SegEdge <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">auto</span> [p, l, r] = a[i];<span class="hljs-type">int</span> L = <span class="hljs-built_in">lower_bound</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), p - l) - b.<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> R = <span class="hljs-built_in">upper_bound</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), p + r) - b.<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (L &lt; R) &#123;seg.<span class="hljs-built_in">PtoS</span>(i, L, R);&#125;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = seg.all;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">stk</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> tarjan = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;dfn[x] = low[x] = ++tim;vis[x] = <span class="hljs-literal">true</span>;stk[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : seg.adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">self</span>(self, y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span> &#123;now = stk[top--];vis[now] = <span class="hljs-literal">false</span>;c[now] = cnt;&#125; <span class="hljs-keyword">while</span>(x != now);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<span class="hljs-keyword">if</span> (!dfn[i]) &#123;<span class="hljs-built_in">tarjan</span>(tarjan, i);&#125;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">Adj</span>(cnt + <span class="hljs-number">1</span>);vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; s;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= N; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : seg.adj[x]) &#123;<span class="hljs-keyword">if</span> (c[x] != c[y]) &#123;s.<span class="hljs-built_in">push_back</span>(&#123;c[x], c[y]&#125;);Adj[c[x]].<span class="hljs-built_in">push_back</span>(c[y]);&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">act</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">reach</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x = c[seg.id[i]];act[x] = <span class="hljs-literal">true</span>;reach[x] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(x);&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;<span class="hljs-keyword">if</span> (!reach[y]) &#123;reach[y] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : s) &#123;<span class="hljs-keyword">if</span> (reach[x]) &#123;deg[y]++;&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<span class="hljs-keyword">if</span> (act[i] &amp;&amp; deg[i] == <span class="hljs-number">0</span>) &#123;ans++;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-翻转硬币">G. 翻转硬币</h3><p>下标按<span class="math inline">\(\bmod \text{LCM}(1,2,3)=6\)</span> 分组，每组建一棵线段树。</p><p>第一种操作要么对<span class="math inline">\(\bmod 0,2,4\)</span> 对应的三棵线段树操作，要么对<span class="math inline">\(\bmod 1, 3, 5\)</span> 对应的三棵线段树操作。</p><p>第二种操作，同理每次对两棵线段树操作。</p><p>第三种操作，对所有线段树操作。</p><p>对于每一棵线段树，维护懒标记 <span class="math inline">\(\text{rev}\)</span> 表示是否翻转，再维护一个区间和即可。</p><p>容易错的地方是怎么把区间 <span class="math inline">\([l,r]\)</span> 映射到某棵线段树上对应的区间 <span class="math inline">\([L,R]\)</span> 找到，比较稳妥的方式是二分。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazySegmentTree</span> &#123;    <span class="hljs-type">int</span> n;    vector&lt;Info&gt; tr;    vector&lt;Tag&gt; tag;    <span class="hljs-built_in">LazySegmentTree</span>() &#123;&#125;    <span class="hljs-built_in">LazySegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;    <span class="hljs-built_in">init</span>(a);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(vector&lt;Info&gt; &amp;a)</span> </span>&#123;n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = (<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>;tr.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Info</span>());tag.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Tag</span>());<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);    &#125;    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = a[l];            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(ls, l, m, a);        <span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        tr[p] = tr[ls] + tr[rs];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        tr[p].<span class="hljs-built_in">apply</span>(x);        tag[p].<span class="hljs-built_in">apply</span>(x);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-built_in">apply</span>(ls, tag[p]);        <span class="hljs-built_in">apply</span>(rs, tag[p]);        tag[p] = <span class="hljs-built_in">Tag</span>();    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-keyword">return</span> tr[p];        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-keyword">if</span> (qr &lt;= m) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ql &gt;= m + <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);        &#125;    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (ql &gt; qr) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-built_in">apply</span>(p, x);            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">modify</span>(ls, l, m, ql, qr, x);        <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, x);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (ql &gt; qr) &#123;    <span class="hljs-keyword">return</span> ;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, x);    &#125;&#125;; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tag</span> &#123;    <span class="hljs-type">int</span> rev = <span class="hljs-number">0</span>;    <span class="hljs-built_in">Tag</span>() &#123;&#125;    <span class="hljs-built_in">Tag</span>(<span class="hljs-type">int</span> A) &#123;        rev = A;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;        rev ^= t.rev;    &#125;&#125;; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;        <span class="hljs-built_in">Info</span>() &#123;&#125;    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B) &#123;        sum = A;        l = r = B;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;    <span class="hljs-keyword">if</span> (t.rev) &#123;        sum = (r - l + <span class="hljs-number">1</span>) - sum;    &#125;    &#125;&#125;; Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;    Info c;    c.sum = a.sum + b.sum;    c.l = <span class="hljs-built_in">min</span>(a.l, b.l);    c.r = <span class="hljs-built_in">max</span>(a.r, b.r);    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pos</span>(<span class="hljs-number">6</span>, &#123;<span class="hljs-number">0</span>&#125;);vector&lt;vector&lt;Info&gt;&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">6</span>, &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;&#125;);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tot</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;pos[i % <span class="hljs-number">6</span>].<span class="hljs-built_in">push_back</span>(i);a[i % <span class="hljs-number">6</span>].<span class="hljs-built_in">push_back</span>(&#123;x, ++tot[i % <span class="hljs-number">6</span>]&#125;);&#125;vector&lt;LazySegmentTree&lt;Info, Tag&gt;&gt; <span class="hljs-built_in">seg</span>(<span class="hljs-number">6</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;seg[i].<span class="hljs-built_in">init</span>(a[i]);&#125;&#125;<span class="hljs-keyword">auto</span> get = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &#123;<span class="hljs-type">int</span> L = <span class="hljs-built_in">lower_bound</span>(pos[i].<span class="hljs-built_in">begin</span>(), pos[i].<span class="hljs-built_in">end</span>(), l) - pos[i].<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> R = <span class="hljs-built_in">upper_bound</span>(pos[i].<span class="hljs-built_in">begin</span>(), pos[i].<span class="hljs-built_in">end</span>(), r) - pos[i].<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> &#123;L, R&#125;;&#125;;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> op, l, r;cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l % <span class="hljs-number">6</span>, j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; i = (i + <span class="hljs-number">2</span>) % <span class="hljs-number">6</span>, j++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> [L, R] = <span class="hljs-built_in">get</span>(i, l, r);seg[i].<span class="hljs-built_in">modify</span>(L, R, &#123;<span class="hljs-number">1</span>&#125;);&#125;&#125; &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l % <span class="hljs-number">6</span>, j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; i = (i + <span class="hljs-number">3</span>) % <span class="hljs-number">6</span>, j++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> [L, R] = <span class="hljs-built_in">get</span>(i, l, r);seg[i].<span class="hljs-built_in">modify</span>(L, R, &#123;<span class="hljs-number">1</span>&#125;);&#125;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> [L, R] = <span class="hljs-built_in">get</span>(i, l, r);seg[i].<span class="hljs-built_in">modify</span>(L, R, &#123;<span class="hljs-number">1</span>&#125;);&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> [L, R] = <span class="hljs-built_in">get</span>(i, l, r);ans += seg[i].<span class="hljs-built_in">query</span>(L, R).sum;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="h.-斐波那契数列">H. 斐波那契数列</h3><p>纸上展开几项易得： <span class="math display">\[\large G_n=G_1^{F_{n-2}}G_2^{F_{n-1}}(n\ge 3)\]</span> 令 <span class="math inline">\(H_n=\prod\limits_{i=1}^{n}G_i\)</span>，<span class="math inline">\(S_n=\sum\limits_{i=1}^{n}F_i\)</span>，纸上画一下也有 <span class="math display">\[\large H_n=G_1^{S_{n-2}+1}G_2^{S_{n-1}}(n\ge 3)\]</span> 斐波那契数列有性质 <span class="math display">\[\large S_n=F_{n+2}-1\]</span> 和 <span class="math inline">\(G_1=2,G_2=3\)</span> 一起代入，得 <span class="math display">\[\large H_n=2^{F_n}\cdot3^{F_{n+1}-1}\]</span> 令 <span class="math inline">\(p=998244353\)</span>，由欧拉定理，我们相当于求 <span class="math display">\[\large 2^{F_n\bmod (p-1)}\cdot 3^{F_{n+1}-1\bmod (p-1)}\bmod p\]</span> 至于求 <span class="math inline">\(F_n\)</span>，用一个经典的递推 <span class="math display">\[\large \begin{pmatrix} F_n \\ F_{n-1} \end{pmatrix} = \begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{pmatrix} \begin{pmatrix} F_{n-1} \\ F_{n-2} \end{pmatrix}\]</span> 也就是 <span class="math display">\[\large \begin{pmatrix} F_n \\ F_{n-1} \end{pmatrix} = \begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}^{n-2} \begin{pmatrix} F_{2} \\ F_{1} \end{pmatrix}\]</span> 在 <span class="math inline">\(\bmod (p-1)\)</span> 下矩阵快速幂即可。</p><p>时间复杂度 <span class="math inline">\(O(2^3\log n+\log p)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span> &#123;<span class="hljs-type">int</span> n, m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(n), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)) &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)) &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, k)) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cin &gt;&gt; a[i][j];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m - <span class="hljs-number">1</span>];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(n, m); i++) &#123;a[i][i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function">matrix <span class="hljs-title">tp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(m, n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;z.a[j][i] = a[i][j];&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;&#125;;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244352</span>;matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> matrix &amp;x, <span class="hljs-type">const</span> matrix &amp;y) &#123;<span class="hljs-built_in">assert</span>(x.m == y.n);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(x.n, y.m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; x.m; k++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; y.m; j++) &#123;z.a[i][j] += x.a[i][k] * y.a[k][j] % modp;z.a[i][j] %= modp;&#125;&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function">matrix <span class="hljs-title">qpow</span><span class="hljs-params">(matrix a, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-built_in">assert</span>(a.n == a.m);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(a.n)</span></span>;z.<span class="hljs-built_in">build</span>();<span class="hljs-keyword">for</span> ( ; k; k &gt;&gt;= <span class="hljs-number">1</span>, a = a * a) &#123;<span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) z = z * a;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % mod) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % mod;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">matrix <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span></span>;A.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;A.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;A.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-function">matrix <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span></span>;S.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;S.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> T = <span class="hljs-built_in">qpow</span>(A, n - <span class="hljs-number">1</span>) * S;<span class="hljs-type">int</span> p = T.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<span class="hljs-type">int</span> q = (T.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> + modp) % modp;<span class="hljs-type">int</span> ans = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, p) * <span class="hljs-built_in">qpow</span>(<span class="hljs-number">3</span>, q) % mod;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="i.-游戏">I. 游戏</h3><p>结论：答案至多为 <span class="math inline">\(2\)</span>。</p><p>考虑如下构造：</p><ul><li>先连一条 <span class="math inline">\((n-2,n)\)</span>，此时你可以将位于 <span class="math inline">\(n-1\)</span> 和 <span class="math inline">\(n-2\)</span> 上的数进行交换。</li><li>再连一条 <span class="math inline">\((1,n)\)</span>，这样你就可以循环位移了。</li></ul><p>那能循环位移，你每次就可以把要交换的两个相邻的数移到最后进行交换。</p><p>也就是说，你可以自由交换相邻的数了，也就一定能排序，得证。</p><p>接下来考虑什么时候答案为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>。</p><ul><li>一开始就排好序就是 <span class="math inline">\(0\)</span>。</li><li>若能通过至多一次区间循环位移排好序就是 <span class="math inline">\(1\)</span>。</li><li>否则就是 <span class="math inline">\(2\)</span>。</li></ul><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_sorted</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>())) &#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (a[l] == l) &#123;l++;&#125;<span class="hljs-keyword">while</span> (a[r] == r) &#123;r--;&#125;<span class="hljs-type">int</span> p = <span class="hljs-built_in">min_element</span>(a.<span class="hljs-built_in">begin</span>() + l, a.<span class="hljs-built_in">begin</span>() + r + <span class="hljs-number">1</span>) - a.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p + <span class="hljs-number">1</span>, lst = p; i != p; i++) &#123;<span class="hljs-keyword">if</span> (i == r + <span class="hljs-number">1</span>) &#123;i = l;&#125;<span class="hljs-keyword">if</span> (a[i] != a[lst] + <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125; lst = i;&#125;cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="j.-公路">J. 公路</h3><p>拆贡献。枚举每一种颜色（即边权），把和该颜色相同的边全部拆掉，整棵树被拆分为若干连通块，设每个连通块的点数分别为 <span class="math inline">\(T_1,T_2,\ldots,T_m\)</span>。那么，这种颜色的贡献就是： <span class="math display">\[n(n-1)-\sum_{i=1}^{m}T_i(T_i-1)\]</span> 最终的答案就是每种颜色的贡献之和。</p><p>选定任意一个点为根，一个朴素的想法是对每种颜色建出虚树（取对应颜色的边下面的点，以及根节点），这确实是可行的。</p><p>设 <span class="math inline">\(sz[x]\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树大小，称虚树上在我们选取的点集中的点称为黑点（特别的，包括根节点），其它点称为白点。</p><p>那么我们可以对每个黑点 <span class="math inline">\(x\)</span> 算出它所在的连通块的大小，即 <span class="math display">\[sz[x]-\sum_{y,\ y\text{ 是 } x \text{ 子树中的黑点 }, \text{ 且 } x\to y \text{ 的路径上没有其它黑点}} sz[y]\]</span> 具体的，如果 <span class="math inline">\(y\)</span> 上面的点是白点，就可以把 <span class="math inline">\(sz[y]\)</span> 传递上去。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>，但实际 T 了，跑了 1.1s。</p><p>下面的代码经过刻意卡常，洛谷上跑了 860ms。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;vector&lt;<span class="hljs-type">int</span>&gt; col[N];vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; adj[N];<span class="hljs-type">int</span> tim, tot, fa[N][<span class="hljs-number">20</span>], sz[N], dfn[N], dep[N], id[N], rid[N], f[N];<span class="hljs-type">bool</span> inTree[N];<span class="hljs-keyword">using</span> _node = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">VirtualTree</span> &#123;<span class="hljs-type">int</span> n;<span class="hljs-built_in">VirtualTree</span>(<span class="hljs-type">int</span> size) &#123;<span class="hljs-keyword">this</span>-&gt;n = size;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath)</span> </span>&#123;dfn[x] = ++tim;fa[x][<span class="hljs-number">0</span>] = fath;dep[x] = dep[fath] + <span class="hljs-number">1</span>;sz[x] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= __lg(dep[x]) + <span class="hljs-number">1</span>; i++) &#123;fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (y != fath) &#123;col[w].<span class="hljs-built_in">push_back</span>(y);<span class="hljs-built_in">dfs</span>(y, x);sz[x] += sz[y];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<span class="hljs-built_in">dfs</span>(rt, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;<span class="hljs-keyword">while</span> (dep[x] &gt; dep[y]) &#123;x = fa[x][__lg(dep[x] - dep[y])];&#125;<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(dep[x]); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i]) &#123;x = fa[x][i];y = fa[y][i];&#125;&#125;<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];&#125;vector&lt;<span class="hljs-type">int</span>&gt; b;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(_node &amp;Adj, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">// cout &lt;&lt; &quot;Add (&quot; &lt;&lt; x &lt;&lt; &quot; -&gt; &quot; &lt;&lt; y &lt;&lt; &quot;)\n&quot;; </span><span class="hljs-keyword">if</span> (id[x] == <span class="hljs-number">0</span>) &#123;id[x] = ++tot;rid[tot] = x;b.<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">if</span> (id[y] == <span class="hljs-number">0</span>) &#123;id[y] = ++tot;rid[tot] = y;b.<span class="hljs-built_in">push_back</span>(y);&#125;Adj[id[x]].<span class="hljs-built_in">push_back</span>(id[y]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span> (!b.<span class="hljs-built_in">empty</span>()) &#123;id[b.<span class="hljs-built_in">back</span>()] = <span class="hljs-number">0</span>;b.<span class="hljs-built_in">pop_back</span>();&#125;tot = <span class="hljs-number">0</span>;&#125;<span class="hljs-function">_node <span class="hljs-title">getTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-built_in">Del</span>();<span class="hljs-type">int</span> sz = <span class="hljs-number">2</span> * a.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> top = <span class="hljs-number">1</span>;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), [&amp;] (<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;i, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;j) &#123;<span class="hljs-keyword">return</span> dfn[i] &lt; dfn[j];&#125;);<span class="hljs-function">_node <span class="hljs-title">Adj</span><span class="hljs-params">(sz + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stk</span><span class="hljs-params">(sz + <span class="hljs-number">1</span>)</span></span>;stk[top] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> lca = <span class="hljs-built_in">LCA</span>(x, stk[top]);<span class="hljs-keyword">if</span> (lca != stk[top]) &#123;<span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span> &amp;&amp; dfn[stk[top - <span class="hljs-number">1</span>]] &gt; dfn[lca]) &#123;<span class="hljs-built_in">Add</span>(Adj, stk[top - <span class="hljs-number">1</span>], stk[top]);top--;&#125;<span class="hljs-keyword">if</span> (lca != stk[top - <span class="hljs-number">1</span>]) &#123;Adj[id[lca]].<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">Add</span>(Adj, lca, stk[top]);stk[top] = lca;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">Add</span>(Adj, lca, stk[top]);top--;&#125;&#125;Adj[id[x]].<span class="hljs-built_in">clear</span>();stk[++top] = x;&#125;<span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">Add</span>(Adj, stk[top - <span class="hljs-number">1</span>], stk[top]);top--;&#125;<span class="hljs-keyword">return</span> Adj;&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">VirtualTree <span class="hljs-title">G</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;G.<span class="hljs-built_in">add</span>(x, y, w);&#125;G.<span class="hljs-built_in">init</span>(<span class="hljs-number">1</span>);<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (col[i].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1ll</span> * n * (n - <span class="hljs-number">1</span>);col[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : col[i]) &#123;inTree[x] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">auto</span> Adj = G.<span class="hljs-built_in">getTree</span>(col[i]);<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (inTree[rid[x]]) &#123;f[x] = sz[rid[x]];&#125; <span class="hljs-keyword">else</span> &#123;f[x] = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);<span class="hljs-keyword">if</span> (!inTree[rid[x]]) &#123;f[x] += f[y];&#125;&#125;<span class="hljs-keyword">if</span> (inTree[rid[x]]) &#123;<span class="hljs-type">int</span> g = f[x];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;g -= f[y];&#125;res -= <span class="hljs-number">1ll</span> * g * (g - <span class="hljs-number">1</span>);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, id[<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : col[i]) &#123;inTree[x] = <span class="hljs-literal">false</span>;&#125;ans += res;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-600</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】2025 四川省赛</title>
    <link href="/posts/977db6c9.html"/>
    <url>/posts/977db6c9.html</url>
    
    <content type="html"><![CDATA[<p>挺匆忙的，到乐山就吃了一顿跷脚牛肉。</p><p>参赛体验的话，场地太热容易红温，蚊虫也多，除此之外都还好。</p><p>Mid 都不怎么开得出来啊，要努力加训了。</p><p>以下题解按个人主观难度排序。</p><hr /><h3 id="i.-本质不同的后缀">I. 本质不同的后缀</h3><p><a href="https://codeforces.com/gym/105949/submission/323473043">Code</a></p><p>逆序将每个字符串插进 Trie，最后 Trie 的结点数就是答案。</p><p>时间复杂度 <span class="math inline">\(O(\sum |S_i|\cdot 26)\)</span>。</p><hr /><h3 id="f.-逆序对">F. 逆序对</h3><p><a href="https://codeforces.com/gym/105949/submission/323396253">Code</a></p><p>填 <code>?</code> 的策略肯定是：存在一个分界点，分界点前的 <code>?</code> 填 <span class="math inline">\(1\)</span>，分界点后的 <code>?</code> 填 <span class="math inline">\(0\)</span>。</p><p>考虑先让所有 <code>?</code> 都是 <span class="math inline">\(0\)</span>，然后从左到右逐个变成 <span class="math inline">\(1\)</span>，维护逆序对数。</p><p>只需要动态记录前缀 <span class="math inline">\(1\)</span> 和后缀 <span class="math inline">\(0\)</span> 的个数。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><hr /><h3 id="h.-胡图图">H. 胡图图</h3><p><a href="https://codeforces.com/gym/105949/submission/323441010">Code</a></p><p><span class="math inline">\(X\)</span> 轴和 <span class="math inline">\(Y\)</span> 轴可以分开考虑。</p><p>令 <span class="math inline">\(f[i][0/1]\)</span> 表示从 <span class="math inline">\(0\to i\)</span> 走偶数/奇数步最少需要走几步，<span class="math inline">\(dx=|x-X|\)</span>，<span class="math inline">\(dy=|y-Y|\)</span>，则 <span class="math display">\[ans = \min\begin{cases}\max(f[dx][0],f[dy][0])\\ \max(f[dx][1], f[dy][1])\end{cases}\]</span> 纸上列个表易得： <span class="math display">\[f[i][0]=\begin{cases}0 &amp;,i=0\\2\cdot \left\lfloor\dfrac{x-1}{4}\right\rfloor + 2 &amp;,\text{otherwise}\end{cases}\]</span> <span class="math display">\[f[i][1]=\begin{cases}3 &amp;,i=0\\2\cdot \left\lfloor\dfrac{x+1}{4}\right\rfloor + 1 &amp;,\text{otherwise}\end{cases}\]</span></p><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><hr /><h3 id="j.-四川省赛">J. 四川省赛</h3><p>经典的树形 dp。</p><p>令 <span class="math inline">\(f[x][i=0\sim 4]/g[x][i=0\sim 4]\)</span> 分别表示从 <span class="math inline">\(x\)</span> 子树中的某处开始，直到 <span class="math inline">\(x\)</span> 为止匹配了 <code>SCCPC</code> 中的前缀 <span class="math inline">\([0,i]\  /\)</span> 后缀 <span class="math inline">\([i,4]\)</span> 的方案数。</p><p>对于一个 <span class="math inline">\(x\)</span>，答案有两类：</p><ul><li><p>直接以 <span class="math inline">\(x\)</span> 结尾，即 <span class="math inline">\(f[x][4]+g[x][0]\)</span>。</p></li><li><p>以 <span class="math inline">\(x\)</span> 为中转两个子树拼起来，枚举中转点 <span class="math inline">\(i\)</span>，即</p></li></ul><p><span class="math display">\[\sum_{y\in son[x]}\sum_{i=1}^{3}f[y][i-1]\cdot (sg[i+1]-g[y][i+1])\]</span></p><p>其中 <span class="math inline">\(sg[i]=\sum\limits_{y\in son[x]}g[y][i]\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><hr /><h3 id="k.-点分治">K. 点分治</h3><p><a href="https://codeforces.com/gym/105949/submission/323477922">Code</a></p><p>正难则反，倒着扫描序列。</p><p>对于一个 <span class="math inline">\(x=p[i]\)</span>，遍历 <span class="math inline">\(x\)</span> 的邻居 <span class="math inline">\(y\)</span>，如果 <span class="math inline">\(y\)</span> 被访问过，设 <span class="math inline">\(y\)</span> 所在连通块中 "在 <span class="math inline">\(p[i\sim n]\)</span> 中最靠前的点" 为 <span class="math inline">\(z\)</span>，则可以确定 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(z\)</span> 的父亲，接着将 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 用并查集并起来。</p><p>不难发现，此时 <span class="math inline">\(y\)</span> 所在连通块中 "在 <span class="math inline">\(\{p\}\)</span> 中最靠前的点" 变成了 <span class="math inline">\(x\)</span>。编写代码时，可以直接将当前扫描到的点作为新连通块的根，这样 <span class="math inline">\(z\)</span> 就能直接 find 得到了。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><hr /><h3 id="a.-最小乘积">A. 最小乘积</h3><p><a href="https://codeforces.com/gym/105949/submission/323538858">Code</a></p><p>这道题的关键是想到：</p><ul><li>状态设计：<span class="math inline">\(dp[x][i]\)</span> 表示所有从 <span class="math inline">\(1\to x\)</span> 的路径，路径上 <span class="math inline">\(\sum a\)</span> 为 <span class="math inline">\(i\)</span> 时，<span class="math inline">\(\sum b\)</span> 的最小值。</li><li>转移顺序：外层枚举第二维，让 <span class="math inline">\(\sum a\)</span> 小的状态先转移，不会出现环。</li></ul><p>转移方程是朴素的： <span class="math display">\[dp[y][i + a] = \min_{x\to y}(dp[x][i] + b)\]</span> 答案即 <span class="math inline">\(\min\limits_{i=1}^{n}(i\cdot dp[n][i])\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(nm\max\{a_i\})\)</span>。</p><hr /><h3 id="c.-最优时间">C. 最优时间</h3><p><a href="https://codeforces.com/gym/105949/submission/323461032">Code</a></p><p>先把所有 <span class="math inline">\(i\in [1,n]\)</span> 的 <span class="math inline">\(S(i)\)</span> 处理出来。</p><p>暴力迭代，令 <span class="math inline">\(f[x]\)</span> 表示 <span class="math inline">\(x\)</span> 的答案，则 dp 转移如下： <span class="math display">\[f[i]=\min(f[i-1],\frac{\sum_{j\in S(i)}f[j-1]}{|S(i)|})\]</span> 迭代 <span class="math inline">\(100\)</span> 次即可 AC。</p><p>官方题解证明了这个式子是收敛的，但并没有证明为什么是 <span class="math inline">\(100\)</span> 次，问就是你说过没过吧。</p><p>时间复杂度 <span class="math inline">\(O(100\cdot n\log n+q)\)</span>。</p><hr /><h3 id="l.-abc">L. abc</h3><p><a href="https://codeforces.com/gym/105949/submission/323570713">Code</a></p><p>我们用 <span class="math inline">\(c_{a/b/c}\)</span> 表示 <span class="math inline">\(a/b/c\)</span> 的出现次数。</p><p>最为关键的观察是： <span class="math display">\[\max(|c_a-c_b|,|c_a-c_c|,|c_b-c_c|)=\frac{|c_a-c_b| + |c_a-c_c| + |c_b-c_c|}{2}\]</span> 于是，我们要求的变成了： <span class="math display">\[\frac{1}{2}(\sum_{T\in S}|c_a-c_b|+\sum_{T\in S}|c_a-c_c|+\sum_{T\in S}|c_b-c_c|)\]</span> 这对吗？这不对。只有对满足 "<span class="math inline">\(a,b,c\)</span> 均出现了" 的子串 <span class="math inline">\(T\)</span> 来说，贡献才是正确的。</p><p>否则我们考虑我们把贡献算错了多少。</p><p>当 <span class="math inline">\(S\)</span> 的某个子串 <span class="math inline">\(T\)</span> 恰有 <span class="math inline">\(a,b,c\)</span> 中的一种字符时，我们期望得到 <span class="math inline">\(0\)</span>，但我们算成了 <span class="math inline">\(\dfrac{|c_a-0|+|c_a-0|+|0-0|}{2}=c_a\)</span>（这里假设 <span class="math inline">\(T\)</span> 只含 <span class="math inline">\(a\)</span>），即多算了 <span class="math inline">\(c_a=|T|\)</span>。</p><p>故我们要减去 <span class="math display">\[\sum_{T\in S,\ T \text{ 只含 } a,b,c \text{ 中的一种字符}} |T|\]</span> 怎么算这个式子？</p><ul><li>对于一个长为 <span class="math inline">\(n\)</span> 的字符串，它的所有子串的长度之和为 <span class="math inline">\(\dfrac{n(n+1)(n+2)}{6}\)</span>。</li></ul><p>所以我们只用 <span class="math inline">\(O(n)\)</span> 扫一遍，对每个极长单色段计算贡献。</p><p>当 <span class="math inline">\(S\)</span> 的某个子串 <span class="math inline">\(T\)</span> 恰有 <span class="math inline">\(a,b,c\)</span> 中的两种字符时，我们期望得到 <span class="math inline">\(|c_a-c_b|\)</span>（这里假设 <span class="math inline">\(T\)</span> 只含 <span class="math inline">\(a,b\)</span>），但我们算成了 <span class="math inline">\(\dfrac{|c_a-c_b|+|c_a-0|+|c_b-0|}{2}\)</span>，多算了 <span class="math display">\[\frac{|c_a-c_b|+c_a+c_b}{2}-|c_a-c_b|=\frac{c_a+c_b-|c_a-c_b|}{2}=\min(c_a,c_b)\]</span> 故我们要减去： <span class="math display">\[\sum_{T\in S,\ T \text{ 只含 }a,b}\min(c_a,c_b)+\sum_{T\in S,\ T \text{ 只含 }a,c}\min(c_a,c_c)+\sum_{T\in S,\ T \text{ 只含 }b,c}\min(c_b,c_c)\]</span> 怎么算这个式子？</p><p>以第一项为例，它其实等于 <span class="math display">\[\frac{1}{2}\sum_{T\in S, T \text{ 只含 } a,b}|T|-|c_a-c_b|\]</span> 搞不懂的话在纸上画两条线就搞懂了。</p><p>但这样还是很麻烦。实际上，我们还可以改写成 <span class="math display">\[\frac{1}{2}\sum_{T\in S, T \text{ 不含 } c}|T|-|c_a-c_b|\]</span> 这是因为如果 <span class="math inline">\(T\)</span> 只含一种字符的话，另一种字符的出现次数看作 <span class="math inline">\(0\)</span>，即 <span class="math inline">\(\min(c_a,c_b)=0\)</span>，完全不影响我们计数。</p><p>于是，枚举不含某个字符，找到极长连续段，计算贡献。</p><p>那现在最后的问题是，形如 <span class="math inline">\(\sum\limits_{T\in S}|c_a-c_b|\)</span> 要怎么算。</p><p>将 <span class="math inline">\(a\)</span> 看作 <span class="math inline">\(1\)</span>，<span class="math inline">\(b\)</span> 看作 <span class="math inline">\(-1\)</span>，求前缀和，记作 <span class="math inline">\(\{pre\}\)</span>，那么转化为了</p><p><span class="math display">\[\sum\limits_{0\le i &lt; j\le |S|}|pre[i]-pre[j]|\]</span> 将 <span class="math inline">\(\{pre\}\)</span> 排序，答案就是 <span class="math display">\[\sum_{i=1}^{n}(i\cdot pre[i]-\sum_{j=1}^{i-1}pre[j])\]</span> 扫一遍即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><hr /><h3 id="g.-丢番图">G. 丢番图</h3><p><a href="https://codeforces.com/gym/105949/submission/323823685">Code</a></p><p>将方程写成矩阵的形式： <span class="math display">\[\begin{pmatrix}a_1^0 &amp; a_2^0 &amp; \cdots &amp; a_n^0 \\a_1^1 &amp; a_2^1 &amp; \cdots &amp; a_n^1 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_1^{n-1} &amp; a_2^{n-1} &amp; \cdots &amp; a_n^{n-1}\end{pmatrix}\begin{pmatrix}x_1 \\x_2 \\\vdots \\x_n\end{pmatrix}=\begin{pmatrix}t^0 \\t^1 \\\vdots \\t^{n-1}\end{pmatrix}\]</span> 可见系数矩阵 <span class="math inline">\(A\)</span> 是范德蒙德矩阵的转置。</p><p>依据克莱姆法则，这个线性方程组的解为 <span class="math display">\[x_k=\frac{\det(A_k)}{\det (A)}\tag{1}\]</span> 其中 <span class="math inline">\(A_k\)</span> 是将矩阵 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(k\)</span> 列替换为列向量 <span class="math inline">\((t^0\ \  t^1\ \ \cdots \ \ t^{n-1})^{T}\)</span> 后的新矩阵。</p><p>先看分母 <span class="math inline">\(\det(A)\)</span>，依据行列式的性质有 <span class="math inline">\(\det(A)=\det(A^T)\)</span>，而 <span class="math inline">\(A^{T}\)</span> 是范德蒙德矩阵。于是</p><p><span class="math display">\[\det(A) = \prod_{1 \le i &lt; j \le n} (a_j - a_i)\]</span> 再看分子 <span class="math inline">\(\det(A^k)\)</span>，眼尖的你会发现这仍然是一个范德蒙德矩阵的转置，只不过生成元从 <span class="math inline">\((a_1\ \ a_2\ \cdots\ a_n)\)</span> 变为了 <span class="math inline">\((a_1\ \cdots \ t \ \cdots \ a_n)\)</span>。于是 <span class="math display">\[\det(A_k) = \left( \prod_{\substack{1 \le i &lt; j \le n \\ i,j \neq k}} (a_j - a_i) \right) \cdot \left( \prod_{i=1}^{k-1} (t - a_i) \right) \cdot \left( \prod_{j=k+1}^{n} (a_j - t) \right)\]</span> 将 <span class="math inline">\(\det(A)\)</span> 和 <span class="math inline">\(\det(A_k)\)</span> 的展开代入公式 <span class="math inline">\((1)\)</span>，大部分的项都可以约分，最终剩下 <span class="math display">\[\large x_k = \frac{\prod\limits_{i=1, i \neq k}^{n} (t - a_i)}{\prod\limits_{i=1, i \neq k}^{n} (a_k - a_i)}\tag{2}\]</span></p><p>到这一步，计算每个 <span class="math inline">\(x_k\)</span> 需要 <span class="math inline">\(O(n)\)</span> 时间，于是我们已经可以 <span class="math inline">\(O(n^2)\)</span> 地解决这个问题了。</p><p>接下来的优化需要引入一个辅助多项式，令</p><p><span class="math display">\[F(x) = \prod_{i=1}^{n} (x - a_i)\]</span></p><p>那么，<span class="math inline">\((2)\)</span> 的分子等价于 <span class="math inline">\(\dfrac{F(t)}{t-a_k}\)</span>。</p><p>比较困难的是 <span class="math inline">\((2)\)</span> 的分母部分，当你尝试用含 <span class="math inline">\(F(a_k)\)</span> 的式子去描述这一部分，即 <span class="math inline">\(\dfrac{F(a_k)}{(a_i-a_i)}\)</span>，分母为 <span class="math inline">\(0\)</span> 显然就不可取了。</p><p>考虑 <span class="math inline">\(F(x)\)</span> 的导数，依据乘积求导法则，有</p><p><span class="math display">\[\frac{d}{dx} F(x) = \sum_{j=1}^{n} \left( \frac{d}{dx}(x-a_j) \cdot \prod_{i=1, i \neq j}^{n}(x-a_i) \right)=\sum_{j=1}^{n} \prod_{i=1, i \neq j}^{n} (x - a_i)\]</span></p><p>直观上来看是 <span class="math inline">\(n\)</span> 项一堆乘积之和，当 <span class="math inline">\(x=a_k\)</span> 时：</p><ul><li><span class="math inline">\(j=k\)</span> 的项等价于 <span class="math inline">\(\prod\limits_{i=1, i \neq k}^{n} (a_k - a_i)\)</span>。</li><li><span class="math inline">\(j\neq k\)</span> 的项一定会有 <span class="math inline">\(i=k\)</span> 的时候，此时 <span class="math inline">\(a_k-a_i=0\)</span>，整个项就为 <span class="math inline">\(0\)</span>。</li></ul><p>于是 <span class="math inline">\((2)\)</span> 的分母就等价于 <span class="math inline">\(F&#39;(a_k)\)</span>。</p><p>总结一下，我们有 <span class="math display">\[x_k=\frac{F(t)}{(t-a_k)F&#39;(a_k)}\]</span> 其中 <span class="math inline">\(F(t)\)</span> 可以将 <span class="math inline">\(t\)</span> 代入 <span class="math inline">\(F(x)\)</span> 线性算。</p><p>问题变为如何快速对所有 <span class="math inline">\(k\in [1,n]\)</span> 求 <span class="math inline">\(F&#39;(a_k)\)</span>。</p><ul><li><span class="math inline">\(F(x)\)</span> 为 <span class="math inline">\(n\)</span> 个一次多项式相乘，可以用分治 NTT 在 <span class="math inline">\(O(n\log^2n)\)</span> 内构建。</li><li>知道了 <span class="math inline">\(F(x)\)</span> 每一项的系数，<span class="math inline">\(F&#39;(x)\)</span> 可以线性构建。</li><li>求 <span class="math inline">\(F&#39;(x)\)</span> 在 <span class="math inline">\(x=a_1,a_2,\ldots,a_n\)</span> 处的值，即<a href="https://www.luogu.com.cn/problem/P5050">【模板】多项式多点求值</a>，同样为 <span class="math inline">\(O(n\log^2 n)\)</span>。</li></ul><hr /><h3 id="e.-竞赛图">E. 竞赛图</h3><p><a href="https://codeforces.com/gym/105949/submission/324298923">Code</a></p><p>强连通 <span class="math inline">\(n(n\ge 3)\)</span> 阶竞赛图一定存在一条哈密顿回路，因此 <span class="math inline">\(k\)</span> 元环与大小为 <span class="math inline">\(k\)</span> 的强连通分量等价。</p><p>特判 <span class="math inline">\(k=2\text{ or }k&gt;n\)</span> 答案为 <span class="math inline">\(0\)</span>。问题转化为求包含至少一个大小为 <span class="math inline">\(k\)</span> 的 SCC 的 <span class="math inline">\(n\)</span> 个点的有标号竞赛图数量。</p><p>记号约定如下：</p><ul><li><span class="math inline">\(f_i\)</span>：大小为 <span class="math inline">\(i\)</span> 的有标号强连通竞赛图数量。</li><li><span class="math inline">\(g_i\)</span>：大小为 <span class="math inline">\(i\)</span> 的有标号竞赛图数量。显然 <span class="math inline">\(g(i)=2^{\Large\frac{i(i-1)}{2}}\)</span>。</li><li><span class="math inline">\(h_i\)</span>：大小为 <span class="math inline">\(i\)</span> 的所有 SCC 都 <span class="math inline">\(&lt;k\)</span> 的有标号竞赛图数量。</li></ul><p>容斥，答案是 <span class="math inline">\(g_n-h_n\)</span>。</p><p>如何求 <span class="math inline">\(h_n\)</span>？首先，竞赛图缩点后会形成一条链，链首（即入度为 <span class="math inline">\(0\)</span> 的点）向之后的所有点连边。计数时，我们从 <span class="math inline">\(n\)</span> 个点里选出 <span class="math inline">\(i\in [1,k)\)</span> 个点作为链首，这 <span class="math inline">\(i\)</span> 个点组成 SCC 的方式就是 <span class="math inline">\(f_i\)</span>，剩下 <span class="math inline">\(n-i\)</span> 个点也需要满足 "所有 SCC 都 <span class="math inline">\(&lt; k\)</span>"，所以是 <span class="math inline">\(h_{n-i}\)</span>，于是 <span class="math display">\[h_n=\sum_{i=1}^{k-1}\binom{n}{i}f_ih_{n-i}\tag{1}\]</span> 先假设我们知道 <span class="math inline">\(f_i\)</span>，来看我们如何算这个式子。</p><p>这是一个典型的使用 EGF（指数生成函数）计算的式子，但因为我是初学者，所以写一下推导过程。</p><p>将组合数展开，我们有 <span class="math display">\[h_n=\sum_{i=1}^{k-1}\frac{n!}{i!(n-i)!}f_ih_{n-i}\]</span> 移项 <span class="math display">\[\frac{h_n}{n!}=\sum_{i=1}^{k-1}\left(\frac{f_i}{i!}\right)\left(\frac{h_{n-i}}{(n-i)!}\right)\]</span> 这是一个卷积的形式。</p><p>令 <span class="math inline">\(H(x)=\sum\limits_{i=0}^{\infty}\dfrac{h_i}{i!}x^i\)</span>，<span class="math inline">\(F_{&lt;k}(x)={\sum\limits_{i=1}^{k-1}}\dfrac{f_i}{i!}x^i\)</span>，则 <span class="math display">\[H(x)=1+F_{&lt;k}(x)H(x)\]</span> 其中 <span class="math inline">\(1\)</span> 是因为 <span class="math inline">\(h_0=1\)</span>，有 <span class="math inline">\([x^0]H(x)=1\)</span>，这一项卷积里没有。</p><p>再移项，最终得到 <span class="math display">\[H(x)=\frac{1}{1-F_{&lt;k}(x)}\tag{2}\]</span> 只需要一次多项式求逆，之后 <span class="math inline">\(h_n=[x^n]H(x)\cdot n!\)</span>。</p><p>接下来看如何求 <span class="math inline">\(f_i\)</span>。</p><p>类似 <span class="math inline">\((1)\)</span>，我们能得到一个 <span class="math inline">\(g_n\)</span> 的递推式：从 <span class="math inline">\(n\)</span> 个点里选出 <span class="math inline">\(i\in [1,n]\)</span> 个点作为链首，这 <span class="math inline">\(i\)</span> 个点组成 SCC 的方式就是 <span class="math inline">\(f_i\)</span>，剩下 <span class="math inline">\(n-i\)</span> 个点只用构成竞赛图就可以了，所以是 <span class="math inline">\(g_{n-i}\)</span>，于是 <span class="math display">\[g_n=\sum_{i=1}^{n}\binom{n}{i}f_ig_{n-i}\]</span> 可以发现，除了求和上界变成了 <span class="math inline">\(n\)</span>，这简直和 <span class="math inline">\((1)\)</span> 一毛一样。</p><p>这其实是 EGF 计数有标号的一般套路，求和上界变成 <span class="math inline">\(n\)</span> 意味着我们可以用所有大小（也就是 <span class="math inline">\([1,n]\)</span>）的强连通竞赛图构成整体。而在 <span class="math inline">\((1)\)</span> 中我们只能使用大小 <span class="math inline">\(&lt;k\)</span> 的强连通竞赛图。</p><p>于是，类似 <span class="math inline">\((1)\to (2)\)</span> 的过程，我们有 <span class="math display">\[G(x)=\frac{1}{1-F(x)}\]</span> 这里 <span class="math inline">\(F(x)={\sum\limits_{i=1}^{\infty}}\dfrac{f_i}{i!}x^i\)</span>，<span class="math inline">\(G(x)={\sum\limits_{i=0}^{\infty}}\dfrac{g_i}{i!}x^i\)</span>。</p><p>移项 <span class="math display">\[F(x)=1-\frac{1}{G(x)}\]</span> 最后 <span class="math inline">\(f_i=[x^i]F(x)\cdot i!\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SCCPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】五月训练日记</title>
    <link href="/posts/9a6e3ac7.html"/>
    <url>/posts/9a6e3ac7.html</url>
    
    <content type="html"><![CDATA[<p>拼尽全力无法战胜 div2b，要重开了。(╥﹏╥)</p><figure><img src="/image/academic/remake.png" alt="remake" /><figcaption aria-hidden="true">remake</figcaption></figure><h2 id="cf2108e.-spruce-dispute"><a href="https://codeforces.com/contest/2108/problem/E">CF2108E. Spruce Dispute</a></h2><p>*2600 <a href="https://codeforces.com/contest/2108/submission/318087489">Code</a></p><p>考虑如何给删完点后的剩下 <span class="math inline">\(n-1\)</span> 个点分配颜色使得答案最大。</p><p>拆贡献，对于一条边，我们肯定想让跨过这条边的路径尽可能多。换句话说，设这条边两侧的子树大小分别为 <span class="math inline">\(a,b\ (a&lt;b)\)</span>，我们肯定想让子树大小为 <span class="math inline">\(a\)</span> 的一侧的点的颜色互不相同。</p><p>可以证明，从这棵树的重心开始按 dfs 序涂色最优。即按 dfs 顺序 <span class="math inline">\(1\to 2\to 3\to \ldots \to \left\lfloor\frac{n}{2}\right\rfloor\to 1\to 2\to \ldots\to \left\lfloor\frac{n}{2}\right\rfloor\)</span> 这么涂。</p><p>想到这么做是因为重心满足 "最大的子树不超过 <span class="math inline">\(\left\lfloor\frac{n}{2}\right\rfloor\)</span>" 这一条件。首先，按 dfs 序涂色是毋庸置疑的，这样能保证同样的颜色肯定被隔在了不同子树，一个类似结论的题是 <a href="https://atcoder.jp/contests/arc160/tasks/arc160_e">arc160e</a>。其次，考虑从一个非重心点 <span class="math inline">\(x\)</span> 向重心方向移动到 <span class="math inline">\(y\)</span> 的过程，边 <span class="math inline">\((x,y)\)</span> 两侧子树较小的那一侧在变大，能容纳更多颜色，一定不劣。</p><p>至此，以重心为根，所有颜色都被分到了不同子树，两个颜色相同的点之间的简单路径长度可以改写为两个点到重心的距离之和。因此，总答案可以改写为所有点到重心的距离和。</p><p>接着，考虑删掉哪个点。我们拥有以下两个观察：</p><ul><li>删叶子比删其它点优。因为删非叶子会让其子树内的点的深度都 <span class="math inline">\(-1\)</span>，不划算。</li><li>其次，在所有叶子中，删深度最小的。这是上一段的直接推论。</li></ul><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1450c1c2.-errich-tac-toe"><a href="https://codeforces.com/contest/1450/problem/C2">CF1450C1/C2. Errich-Tac-Toe</a></h2><p>*2100 <a href="https://codeforces.com/contest/1450/submission/318153681">Code</a>（C1）</p><p>*2300 <a href="https://codeforces.com/contest/1450/submission/318153746">Code</a>（C2）</p><p>见到 <span class="math inline">\(\lfloor\frac{k}{3}\rfloor\)</span>，可以有意识的将操作划分为三个等价类，满足三个等价类的操作数之和为 <span class="math inline">\(k\)</span>。这样根据抽屉原理，一定有一类操作的数量 <span class="math inline">\(\le \lfloor\frac{k}{3}\rfloor\)</span>。</p><p>对于 C1，令 <span class="math inline">\(t_{i,j}=(i+j)\bmod 3\)</span>，那么网格被划分成了三类。定义三种操作如下：</p><ul><li><span class="math inline">\(\forall \ t_{i,j}=0\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= X\)</span>，改为 <span class="math inline">\(O\)</span>。</li><li><span class="math inline">\(\forall \ t_{i,j}=1\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= X\)</span>，改为 <span class="math inline">\(O\)</span>。</li><li><span class="math inline">\(\forall \ t_{i,j}=2\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= X\)</span>，改为 <span class="math inline">\(O\)</span>。</li></ul><p>注意到上述任意一种操作都能实现目标（因为任意三个横着的或竖着的格子必定包含 <span class="math inline">\(t_{i,j}\)</span> 的三种取值）。</p><p>并且这三类操作的操作数之和恰好为 <span class="math inline">\(k\)</span>，根据抽屉原理，一定有一种操作满足操作数 <span class="math inline">\(\le \lfloor\frac{k}{3}\rfloor\)</span>。</p><p>对于 C2，同样令 <span class="math inline">\(t_{i,j}=(i+j)\bmod 3\)</span>，但三种操作变化如下：</p><ul><li><span class="math inline">\(\forall \ t_{i,j}=0\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= X\)</span>，改为 <span class="math inline">\(O\)</span>；<span class="math inline">\(\forall \ t_{i,j}=1\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= O\)</span>，改为 <span class="math inline">\(X\)</span>。</li><li><span class="math inline">\(\forall \ t_{i,j}=1\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= X\)</span>，改为 <span class="math inline">\(O\)</span>；<span class="math inline">\(\forall \ t_{i,j}=2\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= O\)</span>，改为 <span class="math inline">\(X\)</span>。</li><li><span class="math inline">\(\forall \ t_{i,j}=2\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= X\)</span>，改为 <span class="math inline">\(O\)</span>；<span class="math inline">\(\forall \ t_{i,j}=0\)</span> 的 <span class="math inline">\((i,j)\)</span>，若 <span class="math inline">\(s_{i,j}= O\)</span>，改为 <span class="math inline">\(X\)</span>。</li></ul><p>每种操作都由两个形如 <span class="math inline">\(X\to O\)</span>，<span class="math inline">\(O\to X\)</span> 的子操作组合而成，保证了任意三个横着的或竖着的格子都一定不全为 <span class="math inline">\(X/O\)</span>。</p><p>又对于每个 <span class="math inline">\(s_{i,j}\)</span> 不为 <code>.</code> 的格子，至多变化一次，所以上述三种操作的操作数之和仍然是 <span class="math inline">\(k\)</span>。</p><p>同理也一定有一种操作满足操作数 <span class="math inline">\(\le \lfloor\frac{k}{3}\rfloor\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="cf1450e.-capitalism"><a href="https://codeforces.com/contest/1450/problem/E">CF1450E. Capitalism</a></h2><p>*2700 <a href="https://codeforces.com/contest/1450/submission/318179144">Code</a></p><p>首先，原图一定构成二分图，按照 <span class="math inline">\(a_i\)</span> 的奇偶性分成两侧。不是二分图一定无解。</p><p>其次，考虑未定向的边 <span class="math inline">\((u,v)\)</span>，需要满足 <span class="math inline">\(a_u=a_v+1\)</span> 或 <span class="math inline">\(a_v=a_u+1\)</span>。</p><p>转换成可以使用差分约束的形式，也就是 <span class="math inline">\(a_u-a_v\le 1\)</span> 且 <span class="math inline">\(a_v-a_u\le 1\)</span>。</p><p>但这两个条件只是必要条件，若充分则还需满足 <span class="math inline">\(a_u\neq a_v\)</span>。但注意到二分图自然满足 <span class="math inline">\(a_u\neq a_v\)</span>（边权为 <span class="math inline">\(1\)</span> 且没有奇环的情况下两个相邻点的最短路的奇偶性一定不同），故判完二分图上面的转化自然充要。</p><p>接着，考虑已经定向了的边 <span class="math inline">\((u,v)\)</span>，不妨令 <span class="math inline">\(a_v=a_u+1\)</span>，则同样可以转化为：<span class="math inline">\(a_u-a_v\le -1\)</span> 且 <span class="math inline">\(a_v-a_u\le 1\)</span>。</p><p>现在可以开始跑差分约束了，但还面临两个问题：</p><ul><li>Q1：如何保证跑出来的可行解极差最大？</li><li>Q2：选出哪一个点作为起点（零势点）？</li></ul><p>A1：差分约束跑出来的可行解就是每个变量在其约束条件下的最大值。你也可以想象选定零势点后，最大值不可能超过从起点出发到某一点的最短路。</p><p>A2：我们选取每一个点都作为零势点跑 spfa，并钦定 <span class="math inline">\(0\)</span> 是最小值，这样最后若存在 <span class="math inline">\(dis&lt;0\)</span> 或负环，该方案就不合法，忽略掉就行了。</p><p>于是，做法是遍历 <span class="math inline">\(i\in [1,n]\)</span>，钦定 <span class="math inline">\(i\)</span> 为起点跑出一个 <span class="math inline">\(dis\)</span> 序列，最后取极差最大的即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2m)\)</span>。</p><h2 id="cf1445e.-team-building"><a href="https://codeforces.com/contest/1445/problem/E">CF1445E. Team-Building</a></h2><p>*2500 <a href="https://codeforces.com/contest/1445/submission/318251078">Code</a></p><p>题意概括一下：给定一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的图，有 <span class="math inline">\(k\)</span> 种颜色，每个点的颜色你也知道，问选出两种颜色，使它们的导出子图是二分图的方案数。</p><p>首先，你得会怎么用并查集判断二分图，不懂的可以做一下 <a href="https://www.luogu.com.cn/problem/P1525">P1525</a> 以及 <a href="https://www.luogu.com.cn/problem/P5787">P5787</a>。</p><p>这里总结一下，分如下几步：</p><ul><li><p>初始化一个大小为 <span class="math inline">\(2n\)</span> 的并查集。</p></li><li><p>遍历每条边 <span class="math inline">\((x,y)\)</span>：</p><ul><li>若 <span class="math inline">\(\text{dsu.same}(x,y)\)</span>，则不是二分图。</li><li><span class="math inline">\(\text{dsu.merge}(x,y+n)\)</span>，<span class="math inline">\(\text{dsu.merge}(y,x+n)\)</span>。</li><li>若 <span class="math inline">\(\text{dsu.same}(x,x+n)\)</span> 或 <span class="math inline">\(\text{dsu.same}(y,y+n)\)</span>，则不是二分图。</li></ul></li><li><p>否则是二分图。</p></li></ul><p>回到该题，我们可以把图中的所有边分为两类，第一类是连接相同颜色的边，第二类是连接不同颜色的边。</p><p>我们先把第一类边都连起来，对所有 <span class="math inline">\(k\)</span> 种颜色判断第 <span class="math inline">\(i\)</span> 种颜色构成的单色连通块是否是二分图。</p><p>一种颜色的单色连通块若不是二分图，那么这种颜色与其它颜色的导出子图就一定不是二分图。（因为二分图等价于没有奇环，有奇环的图和其它图并起来原来的奇环也不会消失）</p><p>设有 <span class="math inline">\(cnt\)</span> 种颜色的单色连通块是二分图，那么答案的上界是 <span class="math inline">\(\frac{cnt(cnt-1)}{2}\)</span>，尝试容斥一下，排除一些不是二分图的组合。</p><p>暴力的做法是 <span class="math inline">\(O(cnt^2)\)</span> 枚举两种颜色，将连接这两种颜色的边的第二类边加上，判断是否为二分图。</p><p>注意到第二类边的数量是有限的，如果改成枚举边的话，就是 <span class="math inline">\(O(m)\)</span> 的。</p><p>一种简洁且直接的做法是对每一个颜色二元组 <span class="math inline">\((col_x,col_y)\)</span> 记录有哪些边 <span class="math inline">\((u,v)\)</span> 连接了颜色分别为 <span class="math inline">\(col_x\)</span> 和 <span class="math inline">\(col_y\)</span> 的点。即用一个 <code>map&lt;array&lt;int, 2&gt;, vector&lt;array&lt;int, 2&gt;&gt;&gt;</code> 存边，虽然多了一个 <span class="math inline">\(\log\)</span>，但相比把边按颜色排序的做法会好写很多。</p><p>注意到整个判断过程第一类边一直保留，第二类边在判断完一种颜色组合后需要撤销，故用一个可撤销并查集来维护。</p><p>时间复杂度 <span class="math inline">\(O(m\log m+m\log n)\)</span>。</p><h2 id="cf2102e.-23-kingdom"><a href="https://codeforces.com/contest/2102/problem/E">CF2102E. 23 Kingdom</a></h2><p>*2200 <a href="https://codeforces.com/contest/2102/submission/319302504">Code</a></p><p>题目相当于对所有 <span class="math inline">\(i\in [1,n]\)</span>，选出至多一组 <span class="math inline">\(a_l=i\)</span>，<span class="math inline">\(a_r=i\)</span>，<span class="math inline">\(l&lt;r\)</span> 的 <span class="math inline">\(l,r\)</span>，并累加 <span class="math inline">\(r-l\)</span> 的贡献。</p><p>因为序列中的每个数只能变小不能变大，故从大到小枚举 <span class="math inline">\(i\)</span>，试图确定左右端点，没用上的位置丢进一个集合 <span class="math inline">\(S\)</span> 里备选。而用上的数将来也可能变小作为新的端点，所以这其实是一个反悔贪心问题。</p><p>现在，对于一个 <span class="math inline">\(i\)</span>，我们从 <span class="math inline">\(S\)</span> 中取出最小的数作为 <span class="math inline">\(l\)</span>，最大的数作为 <span class="math inline">\(r\)</span>。有两种选择：</p><ul><li><span class="math inline">\([l,r]\)</span> 作为一个新的线段。</li><li><span class="math inline">\(l\)</span> 替代已有线段中最大的 <span class="math inline">\(l\)</span>，<span class="math inline">\(r\)</span> 替代已有线段中最小的 <span class="math inline">\(r\)</span>。</li></ul><p>二选一怎么选？注意到已有线段中最大的 <span class="math inline">\(l\)</span> 一定小于已有线段中最小的 <span class="math inline">\(r\)</span>，否则肯定不优。</p><p>如果 <span class="math inline">\([l,r]\)</span> 加进当前线段集合后仍然满足上述条件，那么这条新线段的贡献肯定严格大于第二种情况。</p><p>反过来，如果 <span class="math inline">\((L&#39;,R&#39;)\)</span> 加进去变成 <span class="math inline">\(L\ L&#39; \ L\ R&#39; \ L\ R\ R\ R\)</span>，那就不如 <span class="math inline">\(L&#39;\)</span> 替换最后一个 <span class="math inline">\(L\)</span>，变成 <span class="math inline">\(L\ L\ L&#39;\ R\ R\ R\)</span>。</p><p>故优先判断 <span class="math inline">\([l,r]\)</span> 作为一个新线段是否可行，不行再考虑替代已有的左右端点。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2110d.-fewer-batteries"><a href="https://codeforces.com/contest/2110/problem/D">CF2110D. Fewer Batteries</a></h2><p><a href="https://codeforces.com/contest/2110/submission/321181200">Code</a></p><p>二分答案。设二分出的答案是 <span class="math inline">\(mid\)</span>，那么策略就固定了：在把电池拿到 <span class="math inline">\(mid\)</span> 个前，能拿就尽量拿。</p><p>DAG 上 dp，令 <span class="math inline">\(dp[x]\)</span> 表示从 <span class="math inline">\(1\to x\)</span> 这一段最多能拿到的电池数目： <span class="math display">\[dp[y]=\min(mid,\max_{x\to y}(dp[x]+b[y]))\]</span> 初始令 <span class="math inline">\(dp[x]=\begin{cases}\min(mid,b[1])&amp;,x=1\\-1 &amp;,x&gt;1\end{cases}\)</span>，最后 check 一下 <span class="math inline">\(dp[n]\)</span> 是否非负即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p><h2 id="cf2110e.-melody"><a href="https://codeforces.com/contest/2110/problem/E">CF2110E. Melody</a></h2><p><a href="https://codeforces.com/contest/2110/submission/321149178">Code</a></p><p>不要等到失去，才后悔那天写欧拉路径没有从非零度点开始遍历......</p><p>把两个属性看成一个二元组 <span class="math inline">\((a_i,b_i)\)</span>，不难发现对于一个合法的序列，一定是：</p><p><span class="math inline">\((a_i\)</span> 变，<span class="math inline">\(b_i\)</span> 不变<span class="math inline">\()\)</span> <span class="math inline">\(\to\)</span> <span class="math inline">\((a_i\)</span> 不变，<span class="math inline">\(b_i\)</span> 变<span class="math inline">\()\)</span> <span class="math inline">\(\to\)</span> <span class="math inline">\((a_i\)</span> 变，<span class="math inline">\(b_i\)</span> 不变<span class="math inline">\()\)</span> <span class="math inline">\(\ldots\)</span> 如此循环。</p><p>将二元组 <span class="math inline">\((a_i,b_i)\)</span> 看成一条连接 <span class="math inline">\(a_i,b_i\)</span> 的边，这里得离散化。</p><p>离散化的时候注意 <span class="math inline">\((\cdot,a_i)\)</span> 和 <span class="math inline">\((a_i,\cdot)\)</span> 是区分开的，你也可以看成二分图。</p><p>那么答案就是这张无向图的一条欧拉路径。</p><p>注意非零度点要连通。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="等待补题列表">等待补题列表</h2><p><a href="https://codeforces.com/contest/1814/problem/E">Problem - E - Codeforces</a></p><p><a href="https://codeforces.com/contest/2084/problem/E">Problem - E - Codeforces</a></p><p><a href="https://codeforces.com/contest/1749/problem/F">Problem - F - Codeforces</a></p><p><a href="https://codeforces.com/contest/1380/problem/F">Problem - F - Codeforces</a></p><p><a href="https://codeforces.com/contest/2005/problem/D">Problem - D - Codeforces</a></p><p><a href="https://codeforces.com/contest/1366/problem/F">Problem - F - Codeforces</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Atcoder</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】四月训练日记</title>
    <link href="/posts/52d312a5.html"/>
    <url>/posts/52d312a5.html</url>
    
    <content type="html"><![CDATA[<h2 id="cf1709e.-xor-tree"><a href="https://codeforces.com/contest/1709/problem/E">CF1709E. XOR Tree</a></h2><p>*2400 <a href="https://codeforces.com/contest/1709/submission/313331153">Code</a></p><p>注意到操作时改成的正整数没有大小限制，不妨改成 <span class="math inline">\(2^{k}\)</span>（<span class="math inline">\(k\)</span> 充分大），这样经过该点的路径的权值绝对不可能为 <span class="math inline">\(0\)</span>。</p><p>指定一个根节点（不妨为 <span class="math inline">\(1\)</span>），假定路径 <span class="math inline">\(x\leftrightarrow y\)</span> 是坏的（也就是异或和为 <span class="math inline">\(0\)</span>），那么容易说明修改 <span class="math inline">\(z=\text{LCA}(x,y)\)</span> 是最优的。</p><p>考虑这么一个过程：从根节点开始向下 dfs，回溯时判断当前节点 <span class="math inline">\(z\)</span> 是否能作为一条坏的路径的 <span class="math inline">\(\text{LCA}\)</span>。若能，答案 <span class="math inline">\(+1\)</span>；否则不做修改。</p><p>问题转换为如何进行这个判定。设 <span class="math inline">\(f_x\)</span> 代表从根节点开始的前缀异或和，即路径 <span class="math inline">\(1\leftrightarrow x\)</span> 的权值。那么，路径 <span class="math inline">\(x\leftrightarrow y\)</span> 是坏的等价于 <span class="math inline">\(f_x\oplus f_y\oplus a_{\text{LCA}(x,y)}=0\)</span>。</p><p>对每一个顶点 <span class="math inline">\(z\)</span> 维护一个 <code>std::set</code>，存储以 <span class="math inline">\(z\)</span> 为根的子树里的节点的 <span class="math inline">\(f\)</span> 集合。这样当我们合并 <span class="math inline">\(z\)</span> 的一个儿子（设为 <span class="math inline">\(p\)</span>）的信息时，只用遍历 <span class="math inline">\(z,p\)</span> 中较小的一个集合，在另一个集合里查有没有符合要求的元素。</p><p>若当前节点需要修改，就清空当前节点的 <code>std::set</code>，否则合并儿子的信息。</p><p>这是一个启发式合并的过程，时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="cf1981d.-turtle-and-multiplication"><a href="https://codeforces.com/contest/1981/problem/D">CF1981D. Turtle and Multiplication</a></h2><p>*2400 <a href="https://codeforces.com/contest/1981/submission/313367256">Code</a></p><p>当所有 <span class="math inline">\(a_i\)</span> 都是质数时，<span class="math inline">\(a_i\cdot a_{i+1}\not=a_j\cdot a_{j+1}\)</span> 的充要条件是无序对 <span class="math inline">\((a_i,a_{i+1})\)</span> 和无序对 <span class="math inline">\((a_j,a_{j+1})\)</span> 不同。当 <span class="math inline">\(a_i\)</span> 不都是质数时，充要条件会退化成必要条件，更劣，故优先思考 <span class="math inline">\(a_i\)</span> 都是质数时是否能构造。</p><p>将无序对 <span class="math inline">\((a_i,a_{i+1})\)</span> 看作一条无向边，那么问题转换为找到一个最小的 <span class="math inline">\(m\)</span>，满足 <span class="math inline">\(m\)</span> 个点构成的完全图存在一条覆盖 <span class="math inline">\(n-1\)</span> 条边（每条边至多被覆盖一次）的路径。</p><p>当 <span class="math inline">\(m\)</span> 为奇数时，图上所有顶点的度数都是偶数，存在一条长 <span class="math inline">\(\frac{m(m-1)}{2}+m\)</span> 的欧拉回路（<span class="math inline">\(+m\)</span> 是因为每个点都有自环，算一条边）。</p><p>当 <span class="math inline">\(m\)</span> 为偶数时，图上所有顶点的度数都是奇数。无向图存在欧拉路径的条件是有 <span class="math inline">\(0/2\)</span> 个点是奇度点，其它为偶度点。考虑删边，只留下两个奇度点，一种留下最多边的方式是删 <span class="math inline">\((2,3),(4,5),(6,7),\ldots,(m-2,m-1)\)</span>。剩余边数是 <span class="math inline">\(\frac{m(m-1)}{2}+m-\frac{m}{2}+1\)</span>。</p><p>二分出最小满足条件的 <span class="math inline">\(m\)</span>，构造出对应的 <span class="math inline">\(m\)</span> 个点的完全图（若 <span class="math inline">\(m\)</span> 是偶数还要按上述规则删边），跑出一条欧拉路径。若路径上第 <span class="math inline">\(i\)</span> 个点是 <span class="math inline">\(x\)</span>，对应到序列上 <span class="math inline">\(a_i\)</span> 就是第 <span class="math inline">\(x\)</span> 小的质数。</p><p>当 <span class="math inline">\(m=1500\)</span> 时，构造出的图有 <span class="math inline">\(1125001&gt;10^6\)</span> 条边，而第 <span class="math inline">\(1500\)</span> 小的质数是 <span class="math inline">\(12553&lt;3\cdot 10^5\)</span>，满足条件。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1981e.-turtle-and-intersected-segments"><a href="https://codeforces.com/contest/1981/problem/E">CF1981E. Turtle and Intersected Segments</a></h2><p>*2600 <a href="https://codeforces.com/contest/1981/submission/313615140">Code</a></p><p>对于三条两两相交的线段 <span class="math inline">\([l_1,r_1,a_1],[l_2,r_2,a_2],[l_3,r_3,a_3]\)</span>，设 <span class="math inline">\(a_1\le a_2\le a_3\)</span>，那么可以仅保留边 <span class="math inline">\(1\leftrightarrow 2,2\leftrightarrow 3\)</span>。（因为 <span class="math inline">\(|a_1-a_3|=|a_1-a_2|+|a_2-a_3|\)</span>，选第 <span class="math inline">\(3\)</span> 条边肯定不优）</p><p>不难发现对于每一条线段 <span class="math inline">\([l_i,r_i,a_i]\)</span>，我们只用保留两条边：</p><ol type="1"><li>与该线段相交的线段中，权值（设为 <span class="math inline">\(a_j\)</span>）最大且满足 <span class="math inline">\(a_j\le a_i\)</span> 的边。</li><li>与该线段相交的线段中，权值（设为 <span class="math inline">\(a_j\)</span>）最小且满足 <span class="math inline">\(a_j\ge a_i\)</span> 的边。</li></ol><p>扫描线，维护一个 <code>std::set</code>，扫描到一条线段的左端点时就把线段的权值加进去，扫描到右端点时就把对应的权值删掉。保留的边相当于线段在容器中的前驱和后继。</p><p>最终处理出的侯选边有 <span class="math inline">\(O(n)\)</span> 条，跑最小生成树即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="abc399e.-replace"><a href="https://atcoder.jp/contests/abc399/tasks/abc399_e">abc399e. Replace</a></h2><p><a href="https://atcoder.jp/contests/abc399/submissions/64455710">Code</a></p><p>连边 <span class="math inline">\(S_i\to T_i\)</span>。</p><p>首先每个点至多有一条出边，否则 <code>-1</code>。<span class="math inline">\(26\)</span> 个点都有入度，也为 <code>-1</code>。</p><p>否则答案的下界是图上的边数（不含自环）。</p><p>对于一个环，分两种情况：</p><ul><li>环上存在入度为 <span class="math inline">\(2\)</span> 的点。说明存在一条边 <span class="math inline">\(x\to y\)</span> 满足 <span class="math inline">\(y\)</span> 在环上而 <span class="math inline">\(x\)</span> 不在。设 <span class="math inline">\(y\)</span> 的另一条入边是 <span class="math inline">\(z\to y\)</span>，此时可以花 <span class="math inline">\(1\)</span> 的代价将 <span class="math inline">\(z\)</span> 改为 <span class="math inline">\(x\)</span>，破环成链，且不花费额外次数（即用 <span class="math inline">\(1\)</span> 次操作断了一条边，与预设 "答案是图上的边数" 相符）。</li><li>环上所有点入度为 <span class="math inline">\(1\)</span>。此时只能将环上任意一点 <span class="math inline">\(x\)</span> 替换为图中的一个孤点，最后再改回来，花费了 <span class="math inline">\(1\)</span> 点额外次数。</li></ul><p>于是答案是图上的边数 <span class="math inline">\(+\)</span> 第二类环的数量。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1139e.-maximize-mex"><a href="https://codeforces.com/problemset/problem/1139/E">CF1139E. Maximize Mex</a></h2><p>*2400 <a href="https://codeforces.com/contest/1139/submission/314383443">Code</a></p><p>考虑没有人离开社团的情况。此时二分答案，设二分的 <span class="math inline">\(\text{mex}\)</span> 是 <span class="math inline">\(mid\)</span>，那么只需要保留潜力值 <span class="math inline">\(&lt;mid\)</span> 的学生。</p><p>建出一个二分图，左部图是 <span class="math inline">\(m\)</span> 个社团，右部图对应 <span class="math inline">\(0\sim mid - 1\)</span> 这 <span class="math inline">\(mid\)</span> 个潜力值。对于一个学生，我们可以连出一条边，最终只要看最大匹配是否为 <span class="math inline">\(mid\)</span>。</p><p>若有学生离开了，相当于删掉一条边，这是不好处理的。但我们想到 Dinic 可以动态加边，于是离线下来倒着做。</p><p>但每加一条边就要重新二分枚举 <span class="math inline">\(\text{mex}\)</span> 就太低效了。注意到加边的时候 <span class="math inline">\(\text{mex}\)</span> 只增不减，换句话匹配数只增不减。我们可以从 <span class="math inline">\(1\)</span> 开始枚举 <span class="math inline">\(\text{mex}\)</span>，每次将 <span class="math inline">\(p[i]=\text{mex}-1\)</span> 的学生加到图上，若匹配数恰好为 <span class="math inline">\(\text{mex}\)</span>，就 <span class="math inline">\(\text{mex}\leftarrow \text{mex}+1\)</span>，重复这个流程。</p><p>此时，一个学生 <span class="math inline">\(i\)</span> 加入社团，分两种情况处理：</p><ol type="1"><li>加入时枚举的 <span class="math inline">\(\text{mex}\ge p[i]\)</span>。直接加边即可。</li><li>加入时枚举的 <span class="math inline">\(\text{mex}&lt;p[i]\)</span>。将学生 <span class="math inline">\(i\)</span> 加进备选名单里，等 <span class="math inline">\(\text{mex}\)</span> 枚举到的时候再加边。</li></ol><p>时间复杂度 <span class="math inline">\(O(\text{MaxFlow}(m, n))\)</span>。</p><h2 id="cf1746f.-kazaee"><a href="https://codeforces.com/contest/1746/problem/F">CF1746F. Kazaee</a></h2><p>*2800 <a href="https://codeforces.com/contest/1746/submission/314411747">Code</a></p><p>先将所有数（包括原有的 <span class="math inline">\(a_i\)</span> 与每次修改后的 <span class="math inline">\(x\)</span>）进行离散化。</p><p>一个暴力的做法是对每个数都维护一个树状数组，这样整道题能在 <span class="math inline">\(O(n^2+qn\log n)\)</span> 内解决。</p><p>面临的困难无非只有一点：对于一个区间，时间复杂度不允许我们 check 区间里每一个数的出现次数。</p><p>一个关键点是，一段区间中，如果所有数字的出现次数都是 <span class="math inline">\(k\)</span> 的倍数，其出现次数之和也一定为 <span class="math inline">\(k\)</span> 的倍数，但这是必要不充分条件。</p><p>随机化，在值域内随机选出 <span class="math inline">\(B\)</span> 个子集，对于一个询问，逐一 check 每一个子集，看每个子集里的数的出现次数之和是否为 <span class="math inline">\(k\)</span> 的倍数。</p><p>而单点修改时，遍历这 <span class="math inline">\(B\)</span> 个子集，若当前子集包含修改前/修改后的数，就相应在树状数组上修改。</p><p>为了保证正确性，每个子集按照以下方式随机：</p><ul><li><span class="math inline">\(\forall i\in [1,W]\)</span>，<span class="math inline">\(i\)</span> 有 <span class="math inline">\(\dfrac{1}{2}\)</span> 的概率选进子集。其中 <span class="math inline">\(W\)</span> 为离散化后的值域。</li></ul><p>错误率分析：最坏情况下，判错当且仅当存在一对数 <span class="math inline">\(x,y\)</span>，满足 <span class="math inline">\(k\mid cnt_x+cnt_y\)</span> 且 <span class="math inline">\(k\not\mid cnt_x\)</span>，<span class="math inline">\(k\not\mid cnt_y\)</span>。四种情况：选 <span class="math inline">\(x\)</span> 没选 <span class="math inline">\(y\)</span>，选 <span class="math inline">\(y\)</span> 没选 <span class="math inline">\(x\)</span>，没选 <span class="math inline">\(x\)</span> 没选 <span class="math inline">\(y\)</span>，选 <span class="math inline">\(x\)</span> 选 <span class="math inline">\(y\)</span>，它们在概率上各占 <span class="math inline">\(\dfrac{1}{4}\)</span>，其中仅第三第四种会犯错，占 <span class="math inline">\(\dfrac{1}{2}\)</span>。取 <span class="math inline">\(B=30\)</span>，错误率就是 <span class="math inline">\(\dfrac{1}{2^{30}}\)</span>，足够低了。</p><p>时间复杂度 <span class="math inline">\(O(nB\log n+qB\log n)\)</span>。</p><h2 id="abc401f.-add-one-edge-3"><a href="https://atcoder.jp/contests/abc401/tasks/abc401_f">abc401f. Add One Edge 3</a></h2><p><a href="https://atcoder.jp/contests/abc401/submissions/64815017">Code</a></p><p>记 <span class="math inline">\(G\)</span> 为树 <span class="math inline">\(1\)</span>，<span class="math inline">\(H\)</span> 为树 <span class="math inline">\(2\)</span>。</p><p>记 <span class="math inline">\(d_1,A_1,A_2\)</span> 为 <span class="math inline">\(G\)</span> 的直径及其两个端点，<span class="math inline">\(d_2,B_1,B_2\)</span> 为 <span class="math inline">\(H\)</span> 的直径及其两个端点。</p><p>记 <span class="math inline">\(f_x/g_x\)</span> 为以 <span class="math inline">\(G/H\)</span> 中的点 <span class="math inline">\(x\)</span> 为端点的最长的路径的长度，显然有 <span class="math inline">\(f_x=\max(dis(A_1,x),dis(A_2,x))\)</span>，<span class="math inline">\(g_x=\max(dis(B_1,x),dis(B_2,x))\)</span>。</p><p>对于一条连接了 <span class="math inline">\(G\)</span> 中点 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(H\)</span> 中点 <span class="math inline">\(j\)</span> 的边，新图直径变为 <span class="math inline">\(\max(\max(d_1,d_2),f_i+g_j+1)\)</span>。</p><p>将 <span class="math inline">\(f_x,g_x\)</span> 升序排序，枚举 <span class="math inline">\(f_i\)</span>，就能二分或双指针求出有多少个满足 <span class="math inline">\(f_i+g_j+1&gt;\max(d_1,d_2)\)</span> 的 <span class="math inline">\(g_j\)</span>，贡献就是一段 <span class="math inline">\(g\)</span> 的后缀和。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1749e.-cactus-wall"><a href="https://codeforces.com/contest/1749/problem/E">CF1749E. Cactus Wall</a></h2><p>*2400 <a href="https://codeforces.com/contest/1749/submission/316076925">Code</a></p><p>转化：相当于寻找一条 <code>#</code> 构成的路径，这条路径从第一列开始，到最后一列结束，且每次只能走对角线的四个方向。</p><p>先把图上所有可以放置 <code>#</code> 的位置找出来（包括原来就有的 <code>#</code>），称作关键点。</p><p>建图，源点 <span class="math inline">\(S\)</span> 向第一列的关键点连边，每个关键点向四个对角线方向的关键点连边，最后一列的关键点向汇点 <span class="math inline">\(T\)</span> 连边。</p><p>一条边 <span class="math inline">\((u,v)\)</span> 的边权取决于 <span class="math inline">\(v\)</span>，若 <span class="math inline">\(v\)</span> 为汇点或原来就有 <code>#</code> 的位置，边权就是 <span class="math inline">\(0\)</span>；否则边权是 <span class="math inline">\(1\)</span>（代表需要在此处新放置一个 <code>#</code>）。</p><p>跑最短路即可，记一下路径方案也就有了。</p><p>时间复杂度：<span class="math inline">\(O(nm\log nm)\)</span>。若使用 01bfs 还可以省去 <span class="math inline">\(\log\)</span>。</p><h2 id="cf2096e.-wonderful-teddy-bears"><a href="https://codeforces.com/contest/2096/problem/E">CF2096E. Wonderful Teddy Bears</a></h2><p>*2400 <a href="https://codeforces.com/contest/2096/submission/316390064">Code</a></p><p>将 <code>B</code> 看作 <span class="math inline">\(0\)</span>，<code>P</code> 看作 <span class="math inline">\(1\)</span>。</p><p>对一个长为 <span class="math inline">\(3\)</span> 的子串操作，分为以下四种情况。</p><ol type="1"><li><span class="math inline">\(010\to 001\)</span>；</li><li><span class="math inline">\(100\to 001\)</span>；</li><li><span class="math inline">\(101\to 011\)</span>；</li><li><span class="math inline">\(110\to 011\)</span>。</li></ol><p>我们将操作 <span class="math inline">\(1,3\)</span> 归为一类，称为 <span class="math inline">\(A\)</span>；操作 <span class="math inline">\(2,4\)</span> 归为一类，称为 <span class="math inline">\(B\)</span>。</p><p>之所以这么分，是因为观察到如下性质：</p><ul><li><span class="math inline">\(A\)</span> 类操作能将逆序对数 <span class="math inline">\(-1\)</span>，而 <span class="math inline">\(B\)</span> 类操作能将逆序对数 <span class="math inline">\(-2\)</span>。</li><li><span class="math inline">\(A\)</span> 类操作能改变一个 <span class="math inline">\(0\)</span> 的下标奇偶性，而 <span class="math inline">\(B\)</span> 类操作不能。</li></ul><p>令 <span class="math inline">\(c_0,c_1\)</span> 分别表示序列中 <span class="math inline">\(0/1\)</span> 的个数，<span class="math inline">\(rev\)</span> 表示逆序对数，<span class="math inline">\(tot\)</span> 表示下标为偶数的 <span class="math inline">\(0\)</span> 的数量。</p><p>想象一个排好序的的 <span class="math inline">\(01\)</span> 串：有 <span class="math inline">\(\left\lfloor\frac{c_0}{2}\right\rfloor\)</span> 个 <span class="math inline">\(0\)</span> 的下标为偶数（1-index）。</p><p>那么可以先用 <span class="math inline">\(\left|tot-\left\lfloor\frac{c_0}{2}\right\rfloor\right|\)</span> 次 <span class="math inline">\(A\)</span> 类操作调整奇偶性，再用 <span class="math inline">\(B\)</span> 类操作减少逆序对数。</p><p>可以预见的是调整奇偶性后逆序对数一定是偶数，故最后不必再用 <span class="math inline">\(A\)</span> 类操作减少逆序对数。</p><p>答案是 <span class="math inline">\(\left|tot-\left\lfloor\frac{c_0}{2}\right\rfloor\right| + \dfrac{(rev-\left|tot-\left\lfloor\frac{c_0}{2}\right\rfloor\right|)}{2}=\dfrac{rev+\left|tot-\left\lfloor\frac{c_0}{2}\right\rfloor\right|}{2}\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1977d.-xorificator"><a href="https://codeforces.com/contest/1977/problem/D">CF1977D. XORificator</a></h2><p>*2300 <a href="https://codeforces.com/contest/1977/submission/316507565">Code</a></p><p>注意到当我们钦定某个点 <span class="math inline">\((x,y)\)</span> 为那一列（即第 <span class="math inline">\(y\)</span> 列）唯一的 <span class="math inline">\(1\)</span> 时，每一行是否需要翻转就被唯一确定了（或者说整个矩阵都被确定了）。</p><p>考虑枚举每个点作为那一列唯一的 <span class="math inline">\(1\)</span>，问题转换为如何快速知道该状态下有多少列仅有一个 <span class="math inline">\(1\)</span>。</p><p>反向思考，钦定一个点作为那一列唯一的 <span class="math inline">\(1\)</span> 时，把此时的 XORificator 记录下来（题解里用的 Zobrist hashing，implement 非常精悍短小），答案就是出现次数最多的 XORificator 的出现次数。</p><p>时间复杂度 <span class="math inline">\(O(nm\log nm)\)</span>。</p><h2 id="cf1622d.-shuffle"><a href="https://codeforces.com/contest/1622/problem/D">CF1622D. Shuffle</a></h2><p>*2000 <a href="https://codeforces.com/contest/1622/submission/316676899">Code</a></p><p>要求本质不同看起来十分困难，但有个 trick 是你枚举所有区间，然后钦定这个区间的左端点和右端点都一定发生了变化，这样计数不重不漏，考虑起来就轻松很多。</p><p>先特判掉整个串的 <span class="math inline">\(1\)</span> 都不足 <span class="math inline">\(k\)</span> 个的情况。</p><p>首先，枚举的区间需要满足 "区间内 <span class="math inline">\(1\)</span> 的个数 <span class="math inline">\(\le k\)</span>"，为什么是小于等于？因为我们实际操作的区间恰有 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span>，但相对原来发生变化的区间可以是一个子集。</p><p>接着，区间两侧的数必须发生变化，非两侧的数任意排列，贡献就是一个组合数。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="cf1622e.-math-test"><a href="https://codeforces.com/contest/1622/problem/E">CF1622E. Math Test</a></h2><p>*2200 <a href="https://codeforces.com/contest/1622/submission/316688280">Code</a></p><p>trick：拆绝对值。<span class="math inline">\(|x_i-r_i|\)</span> 可以拆成 <span class="math inline">\(x_i-r_i\)</span> 和 <span class="math inline">\(r_i-x_i\)</span> 两种，时间复杂度允许我们 <span class="math inline">\(O(2^n)\)</span> 枚举每一种拆法。</p><p>贪心，我们可以统计出每道题被多少个人解决了（如果那个人是 <span class="math inline">\(x_i-r_i\)</span>，<span class="math inline">\(r_i\)</span> 的贡献是负的，就当作 <span class="math inline">\(-1\)</span> 个人；反之 <span class="math inline">\(r_i-x_i\)</span> 就看作 <span class="math inline">\(+1\)</span> 个人），给被更多人解决的题赋值一个大的 <span class="math inline">\(p_j\)</span>。</p><p>因为绝对值被拆掉了，<span class="math inline">\(\{p\}\)</span> 确定之后最终答案也确定了，取 <span class="math inline">\(\max\)</span> 即可。</p><p>时间复杂度 <span class="math inline">\(O(nm2^n)\)</span>。</p><h2 id="cf1354e.-graph-coloring"><a href="https://codeforces.com/contest/1354/problem/E">CF1354E. Graph Coloring</a></h2><p>*2100 <a href="https://codeforces.com/contest/1354/submission/317219740">Code</a></p><p>注意到 <span class="math inline">\(1,3\)</span> 作为一组，<span class="math inline">\(2\)</span> 作为一组，组间连边组内不连边，构成二分图。</p><p>故 <code>YES</code> 的必要条件是给定的图的每一个连通分量均是二分图。</p><p>接着考虑数量限制：我们只用关心 <span class="math inline">\(2\)</span> 的数量能否得到满足，<span class="math inline">\(2\)</span> 满足了 <span class="math inline">\(1,3\)</span> 自然满足。</p><p>设给定的图有 <span class="math inline">\(m\)</span> 个连通分量，第 <span class="math inline">\(i\)</span> 个连通分量有 <span class="math inline">\(L_i\)</span> 个左部点，<span class="math inline">\(R_i\)</span> 个右部点。</p><p>现在我们要对每个连通分量选出左部或者右部填 <span class="math inline">\(2\)</span>，另一部 <span class="math inline">\(1,3\)</span> 任意填。</p><p>抽象出来相当于有 <span class="math inline">\(m\)</span> 个集合，每个集合可以选 <span class="math inline">\(L_i\)</span> 或 <span class="math inline">\(R_i\)</span> 中的恰好一个，判断是否存在一种选择方案使得选出的 <span class="math inline">\(m\)</span> 个数的总和是 <span class="math inline">\(n_2\)</span>。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <span class="math inline">\(i\)</span> 个集合选出的数是否能凑成 <span class="math inline">\(j\)</span>，还需另开一个数组记录方案。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="cf1354f.-summoning-minions"><a href="https://codeforces.com/contest/1354/problem/F">CF1354F. Summoning Minions</a></h2><p>*2500 <a href="https://codeforces.com/contest/1354/submission/317254824">Code1</a> <a href="https://codeforces.com/contest/1354/submission/317268482">Code2</a></p><p>对于一个将来需要销毁的仆从，将它升级没有意义，故选择召唤之后马上销毁。</p><p>于是，最佳策略应该形如：</p><ol type="1"><li>从 <span class="math inline">\(n\)</span> 个仆从中选择 <span class="math inline">\(k-1\)</span> 个召唤。</li><li>从剩下的 <span class="math inline">\(n-k+1\)</span> 仆从中选择 <span class="math inline">\(n-k\)</span> 个召唤后立即销毁。</li><li>召唤剩下的那 <span class="math inline">\(1\)</span> 个仆从。</li></ol><p>在第一步中，假设仆从 <span class="math inline">\(i\)</span> 在第 <span class="math inline">\(j\)</span> 个被召唤，则贡献是 <span class="math inline">\(a_i+b_i (j-1)\)</span>。</p><p>在第二步中，仆从 <span class="math inline">\(i\)</span> 被召唤的贡献固定为 <span class="math inline">\(b_i(k-1)\)</span>。</p><p>在第三步中，仆从 <span class="math inline">\(i\)</span> 被召唤的贡献为 <span class="math inline">\(a_i+b_i(k-1)\)</span>，可以和第一步的贡献合并。</p><p>建立二分图，左部点代表仆从，右部点代表被召唤时的顺序，问题转化为一个满二分图的最大权匹配，跑最大费用最大流即可。</p><p>时间复杂度 <span class="math inline">\(O(T\cdot \text{MinCostMaxFlow}(n, n^2))\)</span>。</p><p>另一种方法是注意到在第一步中，选定的 <span class="math inline">\(k\)</span> 个仆从（与第三步合并了，所以是 <span class="math inline">\(k\)</span> 个）一定按 <span class="math inline">\(b_i\)</span> 升序召唤。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <span class="math inline">\(i\)</span> 个仆从选出 <span class="math inline">\(j\)</span> 个放在第一步的最大答案。 <span class="math display">\[dp[i][j] = \max(dp[i-1][j]+b_i(k-1),dp[i-1][j-1]+a_i+b_i(j-1))\]</span> 回溯以记录方案。</p><p>时间复杂度 <span class="math inline">\(O(Tnk)\)</span>。</p><h2 id="cf555e.-case-of-computer-network"><a href="https://codeforces.com/problemset/problem/555/E">CF555E. Case of Computer Network</a></h2><p>*2800 <a href="https://codeforces.com/contest/555/submission/317567976">Code</a></p><p>位于同一个边双连通分量中的点总是可以互相到达。（指总是存在一种可行的定向方案）</p><p>边双缩点，对于一组 <span class="math inline">\((s_i, d_i)\)</span>，若 <span class="math inline">\(s_i\)</span> 和 <span class="math inline">\(d_i\)</span> 在同一个边双内，则可以忽略。</p><p>否则，<span class="math inline">\(s_i\to d_i\)</span> 上的边的方向就被固定了。（此处的 <span class="math inline">\(s_i,d_i\)</span> 指的都是其所在边双的编号，下同）</p><p>固定一个根，对每个点维护两个标记 <span class="math inline">\(up\)</span> 和 <span class="math inline">\(down\)</span> 分别表示上下两个方向。</p><p>对于一组询问，<span class="math inline">\(s_i\to \text{LCA}(s_i,d_i)\)</span> 上的点的 <span class="math inline">\(up\)</span> 标记 <span class="math inline">\(+1\)</span>，<span class="math inline">\(\text{LCA}(s_i,d_i)\to d_i\)</span> 上的点的 <span class="math inline">\(down\)</span> 标记 <span class="math inline">\(+1\)</span>，这个操作可以用树上差分简单实现。</p><p>最后，若有一个点同时有非零的 <span class="math inline">\(up\)</span> 和 <span class="math inline">\(down\)</span> 标记，就是 <code>No</code>。</p><p>此题有若干细节：</p><ul><li>图不连通，缩点后是一个森林，处理 LCA 时要小心。</li><li>若询问中的两个点不在一个连通分量内，直接就是 <code>No</code>。</li><li>有重边。若两个点之间有重边，则它们属于同一个边双。</li></ul><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p><h2 id="abc399f.-range-power-sum"><a href="https://atcoder.jp/contests/abc399/tasks/abc399_f">abc399f. Range Power Sum</a></h2><p><a href="https://atcoder.jp/contests/abc399/submissions/65320388">Code</a></p><p>令 <span class="math inline">\(s_i=\sum\limits_{j=1}^{i} s_j\)</span>，则： <span class="math display">\[\begin{align}\sum_{1\le l\le r\le N}\left(\sum_{l\le i\le r}a_i\right)^k&amp;= \sum_{l=1}^{n}\sum_{r=l}^{n}\left(s_r-s_{l-1}\right)^k \\&amp;= \sum_{l=1}^{n}\sum_{r=l}^{n}\sum_{i=0}^{k}(-1)^{k-i}\binom{k}{i}s_r^{i}s_{l-1}^{k-i} \\&amp;= \sum_{i=0}^{k}(-1)^{k-i}\binom{k}{i}\sum_{l=1}^{n}\sum_{r=l}^{n}s_r^{i}s_{l-1}^{k-i} \\&amp;= \sum_{i=0}^{k}(-1)^{k-i}\binom{k}{i}\sum_{r=1}^{n}\sum_{l=1}^{r}s_r^{i}s_{l-1}^{k-i} \\&amp;= \sum_{i=0}^{k}(-1)^{k-i}\binom{k}{i}\sum_{r=1}^{n}s_r^{i}\sum_{l=1}^{r}s_{l-1}^{k-i} \\\end{align}\]</span> 枚举 <span class="math inline">\(i,r\)</span>，而 <span class="math inline">\(\sum\limits_{l=1}^{r}s_{l-1}^{k-i}\)</span> 可以预处理前缀和 <span class="math inline">\(O(1)\)</span> 求。</p><p>时间复杂度 <span class="math inline">\(O(nk)\)</span>。</p><h2 id="cf2104g.-modulo-3"><a href="https://codeforces.com/contest/2104/problem/G">CF2104G. Modulo 3</a></h2><p><a href="https://codeforces.com/contest/2104/submission/317693007">Code</a></p><p>每个点至多有一条出边，意味着这个图由若干环和链组成。并且，这种特殊的结构使得同一个环上的点的颜色一定相同，而链上的每个点都能取 <span class="math inline">\(k\)</span> 种颜色中的任意一种。</p><p>具体的，设图中环的数量为 <span class="math inline">\(c\)</span>，第 <span class="math inline">\(i\)</span> 个环的长度为 <span class="math inline">\(l_i\)</span>，对于一个给定的 <span class="math inline">\(k\)</span>，答案是： <span class="math display">\[k^c\cdot k^{(n-\sum\limits_{i=1}^{c}l_i)}=k^{n+c-\sum\limits_{i=1}^{c}l_i}\]</span> 根据欧拉定理，对于任意互质的 <span class="math inline">\(a,p\)</span>，有 <span class="math inline">\(a^{\varphi(p)}\equiv 1\pmod{p}\)</span>，进一步对于任意 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(a^x\equiv a^{x\bmod \varphi(p)}\pmod {p}\)</span>。于是： <span class="math display">\[k^{n+c-\sum\limits_{i=1}^{c}l_i}\equiv k^{(n+c-\sum\limits_{i=1}^{c}l_i)\bmod 2}=k^{n\bmod 2+c\bmod 2+\sum\limits_{i=1}^{c}l_i\bmod 2}\pmod{3}\]</span> 注：当 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(3\)</span> 不互质时，<span class="math inline">\(k\)</span> 为 <span class="math inline">\(3\)</span> 的倍数，答案一定是 <span class="math inline">\(0\)</span>，可以特判掉。</p><p>令 <span class="math inline">\(M = c\bmod 2+\sum\limits_{i=1}^{c}l_i\bmod 2\)</span>，注意到奇环对 <span class="math inline">\(M\)</span> 是没有任何贡献的，于是 <span class="math inline">\(M\)</span> 等价于 "偶环个数<span class="math inline">\(\bmod 2\)</span>"。</p><p>有向图偶环是不好维护的，但这题中只要有偶环就一定连通（指存在一个点，环上的所有点都能从该点到达），故实际上我们可以当作无向图偶环来处理，用一个并查集维护。</p><p>因为是动态图，所以还要套一个线段树分治。</p><p>时间复杂度 <span class="math inline">\(O(q\log^2 q)\)</span>。</p><h2 id="qoj7653.-balloon-darts"><a href="https://qoj.ac/contest/1402/problem/7653">qoj7653. Balloon Darts</a></h2><p><a href="https://qoj.ac/submission/1007001">Code</a></p><p>枚举一条直线都会用掉 <span class="math inline">\(O(n^2)\)</span> 的复杂度，启发我们并不需要枚举所有 <span class="math inline">\(n\)</span> 个点。</p><p>依据抽屉原理，<span class="math inline">\(k\)</span> 条直线（这里 <span class="math inline">\(k=3\)</span>）上任取 <span class="math inline">\(k+1\)</span> 个点，必然有两点满足确定的直线是 <span class="math inline">\(k\)</span> 条中的一条。</p><p>或者反证法，如果选出的 <span class="math inline">\(k+1\)</span> 个点不存在两点组成目标直线中的一条，则这 <span class="math inline">\(k+1\)</span> 个点需要 <span class="math inline">\(k+1\)</span> 条直线才能消除。</p><p>于是我们的做法是：</p><ul><li>对于当前 <span class="math inline">\(k\)</span>，从前 <span class="math inline">\(k+1\)</span> 个点里选两点构成一条直线，遍历所有剩下的点，消除在这条直线上的点。</li><li>将问题递归到 <span class="math inline">\(k-1\)</span>。边界条件是点数 <span class="math inline">\(\le 2k\)</span> 返回 <code>true</code>。</li></ul><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1437e.-make-it-increasing"><a href="https://codeforces.com/contest/1437/problem/E">CF1437E. Make It Increasing</a></h2><p>*2200 <a href="https://codeforces.com/contest/1437/submission/317756029">Code</a></p><p>trick：令 <span class="math inline">\(a_i\leftarrow a_i-i\)</span>，则最长上升子序列 <span class="math inline">\(\to\)</span> 最长不下降子序列。</p><p>令 <span class="math inline">\(a_0=-\infty,a_{n+1}=+\infty\)</span> 并将 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(n+1\)</span> 加进 <span class="math inline">\(\{b\}\)</span> 中，则整个数列被划分为若干可以修改的段。</p><p>每个段分开考虑，设当前段为 <span class="math inline">\([l,r]\)</span>，则需要修改的位置数量是 <span class="math inline">\((r-l+1)-cnt\)</span>，其中 <span class="math inline">\(cnt\)</span> 是 <span class="math inline">\([l,r]\)</span> 中值在 <span class="math inline">\([a_{l-1},a_{r+1}]\)</span> 里的最长不下降子序列长度。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1440d.-graph-subset-problem"><a href="https://codeforces.com/contest/1440/problem/D">CF1440D. Graph Subset Problem</a></h2><p>*2600 <a href="https://codeforces.com/contest/1440/submission/317876586">Code</a></p><p>将一个 <span class="math inline">\(k\)</span> 个点的 clique 称作 <span class="math inline">\(k\)</span>-clique，满足题意的子集称作 good-subset。</p><p>注意到一个点如果度数 <span class="math inline">\(&lt;k-1\)</span>，那么它既不可能组成 <span class="math inline">\(k\)</span>-clique，也不可能组成 good-subset，我们可以把这个点删掉。</p><p>当一个点被删掉时，它的邻居的度数就会 <span class="math inline">\(-1\)</span>，进而可能出现新的度数 <span class="math inline">\(&lt;k-1\)</span> 的点，所以我们是按照类似拓扑序的方式删点（当一个点度数 <span class="math inline">\(&lt;k-1\)</span> 时被加进队列）。</p><p>最终，图上所有点的度数都至少是 <span class="math inline">\(k-1\)</span>（如果至少是 <span class="math inline">\(k\)</span>，那么所有点一定组成 good-subset，直接输出）。此时，要满足 <span class="math inline">\(\frac{n(k-1)}{2}\le m\)</span>，剩余点数 <span class="math inline">\(n\)</span> 满足 <span class="math inline">\(n\le \frac{2m}{k-1}\)</span>。</p><p>我们可以枚举每个度数为 <span class="math inline">\(k-1\)</span> 的点作为 <span class="math inline">\(k\)</span>-clique 的一部分，标记它和它的 <span class="math inline">\(k-1\)</span> 个邻居，<span class="math inline">\(O(k^2\log k)\)</span> 验证这个 <span class="math inline">\(k\)</span>-clique 是否合法。（<span class="math inline">\(\log\)</span> 是在邻接表中二分查找的复杂度，如果使用 <code>unordered_map</code> 或其它哈希方法则可以省去）</p><p>最多验证 <span class="math inline">\(n\)</span> 个点，故复杂度 <span class="math inline">\(\le \frac{2m}{k-1}\cdot k^2\log k\approx O(mk\log k)\)</span>。又由 <span class="math inline">\(\frac{k(k-1)}{2}\le m\)</span>，故 <span class="math inline">\(k\le \sqrt{2m}\)</span>，也就是 <span class="math inline">\(O(m\sqrt{m}\log m)\)</span>，可以接受。</p><p>若找到了一个 <span class="math inline">\(k\)</span>-clique，就可以退出。否则，将这个点删掉。最终如果没有删光，仍旧得到一个点度数至少为 <span class="math inline">\(k\)</span> 的图，一定是 good-subset。</p><p>注意到找 <span class="math inline">\(k\)</span>-clique 的过程和一开始一样需要删点，删点后要跑拓扑，那么不如将一个点加进队列条件调整为度数 <span class="math inline">\(&lt;k\)</span>，一遍拓扑一边验证当前点是否可能组成 <span class="math inline">\(k\)</span>-clique。</p><p>写代码之前务必想清楚实现的细节，本题容易枚举不当导致复杂度退化。</p><p>时间复杂度 <span class="math inline">\(O(m\sqrt{m}\log m)\)</span>。</p><h2 id="cf1440e.-greedy-shopping"><a href="https://codeforces.com/contest/1440/problem/E">CF1440E. Greedy Shopping</a></h2><p>*2600 <a href="https://codeforces.com/contest/1440/submission/317776762">Code</a></p><p>操作一不会破坏序列的单调性，<span class="math inline">\(\{a\}\)</span> 始终单调递减。</p><p>对于操作 <code>1 x y</code>，我们可以二分出第一个 <span class="math inline">\(a_i&lt; y\)</span> 的下标 <span class="math inline">\(i\)</span>，转换为将区间 <span class="math inline">\([i,x]\)</span> 修改为 <span class="math inline">\(y\)</span>。</p><p>对于操作 <code>2 x y</code>，一个直观的想法二分出 <span class="math inline">\(x\)</span> 右侧第一个满足 <span class="math inline">\(\sum\limits_{i=x}^{p} a_i&gt;y\)</span> 的 <span class="math inline">\(p\)</span>，然后贡献就是区间 <span class="math inline">\([x,p-1]\)</span> 的长度。但注意到并不是只有这一段区间有贡献，实际可以是 <span class="math inline">\(x\)</span> 右侧的若干段区间。</p><p>可以证明，区间个数至多是 <span class="math inline">\(O(\log y)\)</span> 级别的。我们用 <span class="math inline">\(1\)</span> 表示选中的区间，<span class="math inline">\(0\)</span> 表示未选中的区间，那么 <span class="math inline">\(x\)</span> 右侧形如 <span class="math inline">\(101010\ldots\)</span>，左数第一个 <span class="math inline">\(0\)</span> 的 <span class="math inline">\(\sum a_i\)</span>（设为 <span class="math inline">\(A\)</span>）比左数第一个 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(\sum a_i\)</span>（设为 <span class="math inline">\(B\)</span>）要小，那么这一组 <span class="math inline">\(10\)</span> 存在就说明 <span class="math inline">\(y-A &lt; B &lt; A\to y&lt;2A\to A&gt;\frac{y}{2}\)</span>，即每次 <span class="math inline">\(y\)</span> 都至少消费掉自身的一半，得证。</p><p>回到证明之前，当找到 <span class="math inline">\(p\)</span> 后，累加贡献，<span class="math inline">\(y\)</span> 减去区间 <span class="math inline">\([x,p - 1]\)</span> 的和，就可以继续在 <span class="math inline">\(p\)</span> 右侧二分出第一个 <span class="math inline">\(a_j\le y\)</span> 的 <span class="math inline">\(j\)</span>，再在 <span class="math inline">\(j\)</span> 右侧二分出第一个满足 <span class="math inline">\(\sum\limits_{i=j}^{p_2}a_i&gt; y\)</span> 的 <span class="math inline">\(p_2\)</span>，得到区间 <span class="math inline">\([j,p_2-1]\)</span>，以此类推...</p><p>操作一用线段树区间赋值，操作二在线段树上二分，可以少一个 <span class="math inline">\(\log\)</span>，共二分 <span class="math inline">\(O(\log y)\)</span> 次。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n +q\log n\log w)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Atcoder</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】2025 UESTCPC 初赛</title>
    <link href="/posts/94193aa7.html"/>
    <url>/posts/94193aa7.html</url>
    
    <content type="html"><![CDATA[<p>据说题比去年初赛要简单，但我去年抱上了 lyc 大腿，所以完全不记得去年难度怎么样了。</p><p>今年来验题，但水平有限（集训队垫底水平），只验了一些简单题。</p><p>其中 A 题是经出题人提醒做出来的，D 偷看了 Tag，H 和 L 则完全不会，等有出题人题解了我再补上来。代码都写的很唐，也不一定是最优解，不要笑话我QAQ。</p><hr /><p>主观难度分布（H、L 未做出）：</p><ul><li>签到：F，G，J，N。</li><li>Easy：B，C，I，O，P。</li><li>Easy_Mid：K，M。</li><li>Mid：D，E，Q。</li><li>Mid_Hard：<span class="math inline">\(\varnothing\)</span>。</li><li>Hard：A。</li></ul><p>写下这段话的时候还有三天才初赛，大胆猜测决赛线是 <span class="math inline">\(4\)</span> 题（签到即送）。</p><p>（upd on 04.01）大一队伍 4 题，非大一队伍 5 题，外校未知。</p><hr /><p>（upd on 赛后）按榜来看 H 是 Easy/Easy_Mid，L 是 Mid_Hard/Hard。</p><hr /><p>（upd on 03.31）来点链接。</p><p>补题链接：<a href="https://cdoj.site/d/lutece/p?q=category%3ALutece%2C校赛%2C初赛%2C2025">Cdoj</a>。</p><p>题面：<a href="https://kisuraop.github.io/oth/2025UESTCPC/statement.pdf">Statement</a>。</p><p>官方题解：<a href="https://kisuraop.github.io/oth/2025UESTCPC/solution.pdf">Solution</a>。</p><p>查重前榜单：<a href="https://kisuraop.github.io/oth/2025UESTCPC/scoreboard.mhtml">Scoreboard</a>。</p><hr /><p>（upd on 赛后）来点 Statistics。</p><p>本场比赛共有 405 支队伍报名，其中正式队 278 支，打星队 127 支。</p><p>有效参赛队伍（至少通过 <span class="math inline">\(1\)</span> 题）总计 309 支，其中正式队 212 支，打星队 97 支。</p><p>最终 3 支队伍 AK，过题数情况如下。</p><table><thead><tr class="header"><th>组别 | 过题数</th><th>17</th><th>16</th><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th></tr></thead><tbody><tr class="odd"><td>正式队</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>2</td><td>4</td></tr><tr class="even"><td>打星队</td><td>2</td><td>0</td><td>1</td><td>2</td><td>2</td><td>8</td><td>8</td><td>6</td></tr></tbody></table><table><thead><tr class="header"><th>组别 | 过题数</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th></tr></thead><tbody><tr class="odd"><td>正式队</td><td>9</td><td>14</td><td>8</td><td>14</td><td>23</td><td>14</td><td>56</td><td>35</td><td>31</td></tr><tr class="even"><td>打星队</td><td>6</td><td>3</td><td>8</td><td>10</td><td>9</td><td>5</td><td>17</td><td>6</td><td>4</td></tr></tbody></table><p>接收到 8978 份有效 submissions，1698 份答案正确。</p><hr /><p>（upd on 初赛日）来点赛时趣事：</p><p>08:58 哎我草怎么是我发题面，赶紧登上 dj 下了个发到群里。</p><p>09:20 卧槽了，C 怎么被暴力过了，还碾压 std。验题的时候不交暴力导致的。</p><p>09:43 大哥给 C 加了一组数据，好很多了。</p><p>10:03 哎哎，I 的精度被浮点数硬抗过去了，精度大师。</p><p>10:47 Queue 莫名其妙 5min 了，有点爆了。</p><p>10:55 Queue 越来越长了，爆爆爆，准备多搞几台服务器加 judgehost。</p><p>11:20 加了一台 8c16g 开了 8 个 judgehost，把原来的关掉了，只跑 web。</p><p>11:27 貌似有点好转（？）</p><p>11:31 好起来了。终于有时间看榜，发现 M 竟然还没人过啊，低估了。</p><p>Fun Fact：在 pool 里 M 的难度是 *1300，有点幽默。</p><p>11:41 DeepSleep 这么厉害啊，队里两个 2000+ 就是不一样。</p><p>11:52 网页 502 了？？？？</p><p>11:55 k4c 很快就发现 <code>/etc/php/8.2/fpm/pool.d/domjudge.conf</code> 里 <code>request_slowlog_timeout</code> 的值写成了 <code>10si</code>，多了个 <code>i</code>。改完马上又好了。</p><p>12:01 L 被开出来了啊。你知道的，我一直是 DeepSleep 的粉丝。</p><p>下午就比较清闲了，大概就是时不时把 judgehost 的 internal error 给 resolved 一下。</p><p>本来想润去打洛谷的蓝桥杯模拟赛，斟酌了一下还是算了。</p><p>这期间 QQ 收到了若干人机大学生发来的<del>弱智</del>让人啼笑皆非的私信。</p><p>15:37 sooke 拿到了 first AK!</p><p>16:58 第一发交 clar 的代码出现了。</p><p>不知道会不会有往 clar 里交奶龙的，很期待啊！</p><p>19:08 DeepSleep 也 AK 了，仿佛看到了泥电的下一支 wf 队。</p><p>20:10 爆爆爆，O 被乱搞搞过去了。更有戏剧性的是我看出题人的题解，突然发现我验题的时候写了个错解（下面改正了），太难绷了。</p><p>在这里给大伙磕头了。</p><hr /><h3 id="a.-炼金术士">A. 炼金术士</h3><p>拉姆齐定理指出，<span class="math inline">\(6\)</span> 个点的完全图（<span class="math inline">\(K_6\)</span>）用两种颜色任意着色（每条边都必须着色），必然存在至少一个单色三角形。</p><p>这意味着我们选出的 "黑化边" 与 "白化边" 并集的边导出子图一定不含 <span class="math inline">\(K_6\)</span>。</p><p>发扬人类智慧，考虑这么一种构造：将 <span class="math inline">\(n\)</span> 个点划分成尽可能平均的 <span class="math inline">\(5\)</span> 个集合，每个集合内部互不连边，不同集合间全部连边。</p><p>根据抽屉原理，从中任意选出 <span class="math inline">\(6\)</span> 个点，至少有 <span class="math inline">\(2\)</span> 个来自同一集合，没有连边，故不含 <span class="math inline">\(K_6\)</span>。在此基础上，容易说明这样的构造具有最大连边数。</p><p>接着，我们要将这些边划分成两个集合，每个集合不含三元环，且其中一个集合能塞得下给定的长度为 <span class="math inline">\(k\)</span> 的无环链。</p><p>再度发扬人类智慧，给上述 <span class="math inline">\(5\)</span> 个点集编号 <span class="math inline">\(0\sim 4\)</span>，进行如下构造：</p><ul><li>"黑化边"：点集 <span class="math inline">\(i\)</span> 中的所有点向点集 <span class="math inline">\((i+1)\bmod 5\)</span> 中的所有点连出的边。</li><li>"白化边"：剩下的所有边。</li></ul><p>因为一个三元环肯定有一条边的两个端点不来自相邻的点集，故 "黑化边" 不含三元环。</p><p>而 "白化边" 要满足 "任意一条边都不来自相邻点集"，则至少需要 <span class="math inline">\(6\)</span> 个点集，不满足。</p><p>此外，在这 <span class="math inline">\(5\)</span> 个点集上绕圈圈，一定能构造出一条包含所有 <span class="math inline">\(n\)</span> 个顶点的链，将给定的链随便插进一个位置即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><p><img src="/image/academic/UESTCPC1.png" /></p><p>上图是 <span class="math inline">\(n=7\)</span> 的图例，<span class="math inline">\(5\)</span> 个集合的大小分别为 <span class="math inline">\(2, 2, 1, 1, 1\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(<span class="hljs-number">5</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bel</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;b[cur].<span class="hljs-built_in">push_back</span>(x);bel[x] = cur;cur = (cur + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>;vis[x] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;b[cur].<span class="hljs-built_in">push_back</span>(i);bel[i] = cur;cur = (cur + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>;&#125;&#125;&#125;<span class="hljs-function">vector <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<span class="hljs-type">int</span> j = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b[i]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : b[j]) &#123;vis[x][y] = vis[y][x] = <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<span class="hljs-keyword">if</span> (bel[i] != bel[j] &amp;&amp; vis[i][j] == <span class="hljs-number">0</span>) &#123;vis[i][j] = vis[j][i] = <span class="hljs-number">2</span>;&#125;&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;ans += (vis[i][j] &gt; <span class="hljs-number">0</span>);&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<span class="hljs-keyword">if</span> (vis[i][j] == <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&#x27;+&#x27;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[i][j] == <span class="hljs-number">2</span>) &#123;cout &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&#x27;0&#x27;</span>;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="b.-简单可满足性问题">B. 简单可满足性问题</h3><p>假定已经将所有变量赋过了值，可以分出以下三类子句。</p><ol type="1"><li>该子句所有变量均为 <span class="math inline">\(1\)</span>，此时子句的值为 <span class="math inline">\(1\)</span>。</li><li>该子句所有变量均为 <span class="math inline">\(0\)</span>，此时子句的值为 <span class="math inline">\(0\)</span>。</li><li>该子句部分变量为 <span class="math inline">\(1\)</span>，此时子句的值为 <span class="math inline">\(1\)</span>。</li></ol><p>注意到当我们给所有变量取反时，第一和第二类子句个数互换，第三类子句个数不变。</p><p>而 "第一 + 第三" 类子句的个数和 "第二 + 第三" 类子句的个数总有一个 <span class="math inline">\(\ge \lceil\frac{m}{2}\rceil\)</span>。</p><p>给所有变量任意赋值，验证不满足后就全部取反，总有一个满足条件。</p><p>时间复杂度 <span class="math inline">\(O(m)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> num;cin &gt;&gt; num;<span class="hljs-type">int</span> ok = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;ok |= y;&#125;<span class="hljs-keyword">if</span> (ok) &#123;res++;&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (res * <span class="hljs-number">2</span> &lt; m) &#123;ans = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="c.-箭串">C. 箭串</h3><p>将询问离线。暴力做就是倒序遍历每个区间，如果是 <code>*</code>，就覆盖；否则不操作。</p><p>用 <code>std::set</code> 维护当前还存活的 <code>*</code> 的位置。对于一个询问 <span class="math inline">\([l,r]\)</span>，二分出 <code>std::set</code> 中第一个 <span class="math inline">\(\ge l\)</span> 的位置，迭代器一直向右，修改沿途位置即可。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;string s = <span class="hljs-built_in">string</span>(n + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;*&#x27;</span>);vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; op;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;op.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);&#125;<span class="hljs-built_in">reverse</span>(op.<span class="hljs-built_in">begin</span>(), op.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">R</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;set&lt;<span class="hljs-type">int</span>&gt; t;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;L[i] = i - <span class="hljs-number">1</span>;R[i] = i + <span class="hljs-number">1</span>;t.<span class="hljs-built_in">insert</span>(i);&#125;<span class="hljs-keyword">auto</span> del = [&amp;] (<span class="hljs-type">int</span> i) &#123;t.<span class="hljs-built_in">erase</span>(i);L[R[i]] = L[i];R[L[i]] = R[i];&#125;; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [p, l] : op) &#123;<span class="hljs-keyword">auto</span> it = t.<span class="hljs-built_in">lower_bound</span>(p);<span class="hljs-keyword">if</span> (it == t.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = *it; i &lt;= p + l - <span class="hljs-number">1</span>; i = R[i]) &#123;<span class="hljs-keyword">if</span> (i == p || i &gt;= p + l - <span class="hljs-number">3</span>) &#123;s[i] = <span class="hljs-string">&#x27;&gt;&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;s[i] = <span class="hljs-string">&#x27;-&#x27;</span>;&#125;<span class="hljs-built_in">del</span>(i);&#125;&#125;s = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="d.-阿罗祖斯坦的桥">D. 阿罗祖斯坦的桥</h3><p>令 <span class="math inline">\(f[l][r],g[l][r]\)</span> 分别表示在 <span class="math inline">\([l,r]\)</span> 里建桥的最大数量和最小总长度，然后就是一个裸的区间 dp。</p><p>发现 <span class="math inline">\(w(l,r)=d\cdot \text{arcsin}(\frac{\text{dis}(l,r)}{d})\)</span> 具有单调性（跨度大桥更长）和四边形不等式条件（交叉弱于包含），于是套一个四边形不等式优化的板子就过了。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-10</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, d;    cin &gt;&gt; n &gt;&gt; d;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        cin &gt;&gt; a[i];        pre[i + <span class="hljs-number">1</span>] = pre[i] + a[i];    &#125;    <span class="hljs-keyword">auto</span> cost = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> * d * <span class="hljs-built_in">asin</span>(<span class="hljs-number">1.0</span> * (pre[r] - pre[l]) / d);    &#125;;    <span class="hljs-keyword">auto</span> ok = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">bool</span> &#123;        <span class="hljs-keyword">return</span> pre[r] - pre[l] &lt;= d;    &#125;;    <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">2</span>))</span>, <span class="hljs-title">m</span><span class="hljs-params">(f)</span></span>;    <span class="hljs-function">vector <span class="hljs-title">g</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-type">double</span>&gt;(n + <span class="hljs-number">2</span>))</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;        m[i][i] = i;        <span class="hljs-keyword">if</span> (i &lt; n + <span class="hljs-number">1</span>) &#123;            m[i][i + <span class="hljs-number">1</span>] = i;        &#125;    &#125;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n + <span class="hljs-number">1</span>; len++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n + <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = m[i][j - <span class="hljs-number">1</span>]; k &lt;= m[i + <span class="hljs-number">1</span>][j]; k++) &#123;                <span class="hljs-keyword">if</span> (f[i][k] + f[k][j] &gt; f[i][j]) &#123;                    f[i][j] = f[i][k] + f[k][j];                    g[i][j] = g[i][k] + g[k][j];                    m[i][j] = k;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f[i][k] + f[k][j] == f[i][j]) &#123;                    <span class="hljs-keyword">if</span> (g[i][k] + g[k][j] &lt; g[i][j]) &#123;                        g[i][j] = g[i][k] + g[k][j];                        m[i][j] = k;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>(i, j)) &#123;                f[i][j]++;                g[i][j] += <span class="hljs-built_in">cost</span>(i, j);            &#125;        &#125;    &#125;    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">12</span>) &lt;&lt; g[<span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">solve</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="e.-猫猫城大选困难版">E. 猫猫城大选（困难版）</h3><p>把问题 format 一下：给定一个变量 <span class="math inline">\(x\)</span>，初始为 <span class="math inline">\(0\)</span>，四种操作如下，问最终 <span class="math inline">\(x\)</span> 的期望。</p><ol type="1"><li><span class="math inline">\(x\leftarrow x+1\)</span>；</li><li><span class="math inline">\(x\leftarrow x-1\)</span>；</li><li><span class="math inline">\(\begin{cases}x\leftarrow x+1 &amp;,x&gt;0\\ x\leftarrow x-1&amp;,x&lt;0\\ p_i \text{ 概率}+1,(1-p_i)\text{ 概率}-1 &amp;,x=0\end{cases}\)</span></li><li><span class="math inline">\(\begin{cases}x\leftarrow x-1 &amp;,x&gt;0\\ x\leftarrow x+1&amp;,x&lt;0\\ p_i \text{ 概率}+1,(1-p_i)\text{ 概率}-1 &amp;,x=0\end{cases}\)</span></li></ol><p>我们发现对于两个 <span class="math inline">\(x=0\)</span> 的位置，其间进行的操作是确定的。</p><p>具体的，假设当前时刻操作前 <span class="math inline">\(x=0\)</span> 且当前为第 <span class="math inline">\(3/4\)</span> 类操作：若选择了 <span class="math inline">\(+1\)</span>，则直到下一次 <span class="math inline">\(x=0\)</span> 之前 <span class="math inline">\(x\)</span> 的值都是正的；若选择了 <span class="math inline">\(-1\)</span>，则直到下一次 <span class="math inline">\(x=0\)</span> 之前 <span class="math inline">\(x\)</span> 的值都是负的。</p><p>令 <span class="math inline">\(dp[i]\)</span> 代表若第 <span class="math inline">\(i\)</span> 个时刻操作前 <span class="math inline">\(x=0\)</span>，最后 <span class="math inline">\(x\)</span> 的期望值。</p><p>从后向前转移，<span class="math inline">\(dp[i]=p[i]\cdot f(i)+(1-p[i])\cdot g(i)\)</span>。</p><p>其中 <span class="math inline">\(f(i)/g(i)\)</span> 代表第 <span class="math inline">\(i\)</span> 时刻选择了 <span class="math inline">\(+1/-1\)</span> 的情况下，之后的贡献。</p><p>以 <span class="math inline">\(f(i)\)</span> 为例，若之后不存在 <span class="math inline">\(x=0\)</span> 的时刻，<span class="math inline">\(f(i)=a_n-a_i+1\)</span>，其中 <span class="math inline">\(a_i\)</span> 表示假定 <span class="math inline">\(x\)</span> 一直 <span class="math inline">\(&gt;0\)</span>，按顺序执行完第 <span class="math inline">\(i\)</span> 次操作后的结果；否则设这 <span class="math inline">\(i\)</span> 之后第一个 <span class="math inline">\(x=0\)</span> 的时刻为 <span class="math inline">\(\text{nxt}\)</span>，有 <span class="math inline">\(f(i)=dp[\text{nxt+1}]\)</span>。</p><p>找 <span class="math inline">\(\text{nxt}\)</span> 的过程可以用线段树实现，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">power</span><span class="hljs-params">(T a, <span class="hljs-type">int</span> b)</span> </span>&#123;    T res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; b; b /= <span class="hljs-number">2</span>, a *= a)        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>) res *= a;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;    <span class="hljs-type">int</span> res = a * b % p;    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) res += p;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> P&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MInt</span> &#123;    <span class="hljs-type">int</span> x;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">()</span> : x&#123;</span>&#125; &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : x&#123;</span><span class="hljs-built_in">norm</span>(x % <span class="hljs-built_in">getMod</span>())&#125; &#123;&#125;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> Mod;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getMod</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> P &gt; <span class="hljs-number">0</span> ? P : Mod;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">setMod</span><span class="hljs-params">(<span class="hljs-type">int</span> Mod_)</span> </span>&#123; Mod = Mod_;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">norm</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += <span class="hljs-built_in">getMod</span>(); <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-built_in">getMod</span>()) x -= <span class="hljs-built_in">getMod</span>(); <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123; MInt res; res.x = <span class="hljs-built_in">norm</span>(<span class="hljs-built_in">getMod</span>() - x); <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> MInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">assert</span>(x != <span class="hljs-number">0</span>); <span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(*<span class="hljs-keyword">this</span>, <span class="hljs-built_in">getMod</span>() - <span class="hljs-number">2</span>);&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>*=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">mul</span>(x, rhs.x, <span class="hljs-built_in">getMod</span>()); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>+=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">norm</span>(x + rhs.x); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>-=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">norm</span>(x - rhs.x); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>/=(MInt rhs) &amp; &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> *= rhs.<span class="hljs-built_in">inv</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>*(MInt lhs, MInt rhs) &#123; MInt res = lhs; res *= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>+(MInt lhs, MInt rhs) &#123; MInt res = lhs; res += rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-(MInt lhs, MInt rhs) &#123; MInt res = lhs; res -= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>/(MInt lhs, MInt rhs) &#123; MInt res = lhs; res /= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, MInt &amp;a) &#123; <span class="hljs-type">int</span> v; is &gt;&gt; v; a = <span class="hljs-built_in">MInt</span>(v); <span class="hljs-keyword">return</span> is;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> MInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.<span class="hljs-built_in">val</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MInt lhs, MInt rhs) &#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() == rhs.<span class="hljs-built_in">val</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(MInt lhs, MInt rhs) &#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() != rhs.<span class="hljs-built_in">val</span>();&#125;&#125;;<span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-type">int</span> MInt&lt;<span class="hljs-number">0</span>&gt;::Mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> V, <span class="hljs-type">int</span> P&gt;<span class="hljs-keyword">constexpr</span> MInt&lt;P&gt; CInv = <span class="hljs-built_in">MInt</span>&lt;P&gt;(V).<span class="hljs-built_in">inv</span>();<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">using</span> Z = MInt&lt;modp&gt;;<span class="hljs-comment">// template&lt;int P&gt;</span><span class="hljs-comment">// int MInt&lt;P&gt;::Mod = P;</span><span class="hljs-comment">// using Z = MInt&lt;0&gt;;</span><span class="hljs-comment">// Z::setMod(mod);</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n;vector&lt;Info&gt; tr;<span class="hljs-built_in">SegmentTree</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a) &#123;<span class="hljs-function">vector&lt;Info&gt; <span class="hljs-title">b</span><span class="hljs-params">(a.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;b[i] = a[i];&#125;<span class="hljs-built_in">init</span>(b);&#125;<span class="hljs-built_in">SegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;<span class="hljs-built_in">init</span>(a);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(vector&lt;Info&gt; &amp;a)</span> </span>&#123;n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;tr.<span class="hljs-built_in">assign</span>((<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>, <span class="hljs-built_in">Info</span>());<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;tr[p] = a[l];<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(ls, l, m, a);<span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);<span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;tr[p] = tr[ls] + tr[rs];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;tr[p] = x;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (pos &lt;= m) &#123;<span class="hljs-built_in">modify</span>(ls, l, m, pos, x);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, pos, x);&#125;<span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, x);&#125;<span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();&#125;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> tr[p];&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);&#125;<span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-type">int</span> res = <span class="hljs-built_in">findFirst</span>(ls, l, m, ql, qr, pred);<span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;res = <span class="hljs-built_in">findFirst</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &gt; qr) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1LL</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">findFirst</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-type">int</span> res = <span class="hljs-built_in">findLast</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);<span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;res = <span class="hljs-built_in">findLast</span>(ls, l, m, ql, qr, pred);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &gt; qr) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1LL</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">findLast</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);&#125;<span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span><span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<span class="hljs-type">int</span> mx = -inf;<span class="hljs-type">int</span> mn = inf;<span class="hljs-built_in">Info</span>() &#123;&#125;<span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> x) &#123;mx = x;mn = x;&#125;&#125;;Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;Info c;c.mx = <span class="hljs-built_in">max</span>(a.mx, b.mx);c.mn = <span class="hljs-built_in">min</span>(a.mn, b.mn); <span class="hljs-keyword">return</span> c;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">op</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;Z&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; op[i] &gt;&gt; p[i];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">pb</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;pa[i] = pa[i - <span class="hljs-number">1</span>];pb[i] = pb[i - <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">1</span>) &#123;pa[i]++;pb[i]++;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">2</span>) &#123;pa[i]--;pb[i]--;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">3</span>) &#123;pa[i]++;pb[i]--;&#125; <span class="hljs-keyword">else</span> &#123;pa[i]--;pb[i]++;&#125;&#125;<span class="hljs-function">SegmentTree&lt;Info&gt; <span class="hljs-title">sa</span><span class="hljs-params">(pa)</span>, <span class="hljs-title">sb</span><span class="hljs-params">(pb)</span></span>;<span class="hljs-function">vector&lt;Z&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-keyword">auto</span> getP = [&amp;] () -&gt; Z &#123;<span class="hljs-type">int</span> pos = sa.<span class="hljs-built_in">findFirst</span>(i + <span class="hljs-number">1</span>, n, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.mn &lt;= pa[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> * (op[i] == <span class="hljs-number">4</span>);&#125;);<span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">return</span> pa[n] - pa[i] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> dp[pos + <span class="hljs-number">1</span>];&#125;;<span class="hljs-keyword">auto</span> getN = [&amp;] () -&gt; Z &#123;<span class="hljs-type">int</span> pos = sb.<span class="hljs-built_in">findFirst</span>(i + <span class="hljs-number">1</span>, n, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.mx &gt;= pb[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span> * (op[i] == <span class="hljs-number">4</span>);&#125;);<span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">return</span> pb[n] - pb[i] - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> dp[pos + <span class="hljs-number">1</span>];&#125;;dp[i] = p[i] * <span class="hljs-built_in">getP</span>() + (<span class="hljs-number">1</span> - p[i]) * <span class="hljs-built_in">getN</span>();&#125;cout &lt;&lt; dp[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="f.-我知道你姓啥">F. 我知道你姓啥！</h3><p>竖着看，相当于 <span class="math inline">\(m\)</span> 个长为 <span class="math inline">\(n\)</span> 的字符串。我们的目标是使这 <span class="math inline">\(m\)</span> 个字符串互不相同。</p><p>一次添加操作相当于给每个字符串末尾添上 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>。对于两个相同的字符串，在其末尾一个添 <span class="math inline">\(0\)</span>，一个添 <span class="math inline">\(1\)</span>，就能让它们不同。</p><p>用 <code>std::map</code> 统计出原来的 <span class="math inline">\(m\)</span> 个字符串中出现次数最多的串，设其出现次数为 <span class="math inline">\(c\)</span>。一次操作能让 <span class="math inline">\(c\leftarrow \lceil\frac{c}{2}\rceil\)</span>，暴力模拟即可。</p><p>时间复杂度 <span class="math inline">\(O(nm\log m)\)</span>。</p><p>Fun Fact：赛前出题人打算把 <code>std::unordered_map</code> 卡掉，但因为是签到，所以后来觉得没有必要就没卡。</p><p>Bonus：可以用 Trie 做到 <span class="math inline">\(O(nm)\)</span>。</p><p>Fun Fact2：你可能会因为看到我 F 和 P 的题解和官方题解一模一样，然后联想到我是出题人。这是错的，出题人只是不想写题解了就让我发一份上去。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; s[i];&#125;map&lt;string, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;string t;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;t += s[i][j];&#125;mp[t]++;&#125;<span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, x] : mp) &#123;mx = <span class="hljs-built_in">max</span>(mx, x);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (mx != <span class="hljs-number">1</span>) &#123;mx = (mx + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;ans++;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-猜数游戏">G. 猜数游戏</h3><p>可以找到 <span class="math inline">\(\ge l\)</span> 的最小的满足 <span class="math inline">\(x\bmod p=a\)</span> 的位置 <span class="math inline">\(i\)</span>，判断 <span class="math inline">\(i\)</span> 是否 <span class="math inline">\(\le r\)</span>。</p><p>令 <span class="math inline">\(i=kp+a\ge l\)</span>，得 <span class="math inline">\(k\ge \lceil\frac{l-a}{p} \rceil\)</span>，故 <span class="math inline">\(i=\lceil\frac{l-a}{p}\rceil p+a\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a, p, l, r;cin &gt;&gt; a &gt;&gt; p &gt;&gt; l &gt;&gt; r;<span class="hljs-type">int</span> x = (l - a + p - <span class="hljs-number">1</span>) / p * p + a;<span class="hljs-keyword">if</span> (x &lt;= r) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="h.-独立事件">H. 独立事件</h3><p>(upd on 03.31)</p><p>当 <span class="math inline">\(P(A)=0/1\)</span> 时，答案是 trivial 的。否则，存在以下推导： <span class="math display">\[\begin{align}&amp;P(A)P(B_I)=P(A\cap B_I)\\\rightarrow\  &amp;P(B_I\mid A)=P(B_I\mid  \overline{A}) \\\rightarrow\ &amp;\frac{P(AB_I)}{P(A)}=\frac{P(\overline{A}B_I)}{P(\overline{A})}\end{align}\]</span></p><p>记 <span class="math inline">\(f[i]\)</span> 表示在事件 <span class="math inline">\(A\)</span> 对应的集合中选出元素总和为 <span class="math inline">\(i\)</span> 的方案数。</p><p>记 <span class="math inline">\(g[i]\)</span> 表示在事件 <span class="math inline">\(\overline{A}\)</span> 对应的集合中选出元素总和为 <span class="math inline">\(i\)</span> 的方案数。</p><p>那么答案是：</p><p><span class="math display">\[\sum_{i=0}^{1000}\sum_{j=0}^{1000}f[i]\cdot g[j]\cdot [\frac{i}{P(A)}=\frac{j}{P(\overline{A})}]\]</span></p><p>其中，<span class="math inline">\(P(A)=\dfrac{\sum\limits_{i=1}^{k}a_i}{1000}\)</span>，<span class="math inline">\(P(\overline{A})=1-P(A)\)</span>。</p><p><span class="math inline">\(f[i]\)</span> 和 <span class="math inline">\(g[i]\)</span> 可以分别用 <span class="math inline">\(01\)</span> 背包求出。</p><p>时间复杂度 <span class="math inline">\(O(nw+w^2)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">power</span><span class="hljs-params">(T a, <span class="hljs-type">int</span> b)</span> </span>&#123;    T res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; b; b /= <span class="hljs-number">2</span>, a *= a)        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>) res *= a;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;    <span class="hljs-type">int</span> res = a * b % p;    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) res += p;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> P&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MInt</span> &#123;    <span class="hljs-type">int</span> x;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">()</span> : x&#123;</span>&#125; &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : x&#123;</span><span class="hljs-built_in">norm</span>(x % <span class="hljs-built_in">getMod</span>())&#125; &#123;&#125;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> Mod;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getMod</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> P &gt; <span class="hljs-number">0</span> ? P : Mod;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">setMod</span><span class="hljs-params">(<span class="hljs-type">int</span> Mod_)</span> </span>&#123; Mod = Mod_;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">norm</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += <span class="hljs-built_in">getMod</span>(); <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-built_in">getMod</span>()) x -= <span class="hljs-built_in">getMod</span>(); <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123; MInt res; res.x = <span class="hljs-built_in">norm</span>(<span class="hljs-built_in">getMod</span>() - x); <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> MInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">assert</span>(x != <span class="hljs-number">0</span>); <span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(*<span class="hljs-keyword">this</span>, <span class="hljs-built_in">getMod</span>() - <span class="hljs-number">2</span>);&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>*=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">mul</span>(x, rhs.x, <span class="hljs-built_in">getMod</span>()); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>+=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">norm</span>(x + rhs.x); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>-=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">norm</span>(x - rhs.x); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>/=(MInt rhs) &amp; &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> *= rhs.<span class="hljs-built_in">inv</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>*(MInt lhs, MInt rhs) &#123; MInt res = lhs; res *= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>+(MInt lhs, MInt rhs) &#123; MInt res = lhs; res += rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-(MInt lhs, MInt rhs) &#123; MInt res = lhs; res -= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>/(MInt lhs, MInt rhs) &#123; MInt res = lhs; res /= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, MInt &amp;a) &#123; <span class="hljs-type">int</span> v; is &gt;&gt; v; a = <span class="hljs-built_in">MInt</span>(v); <span class="hljs-keyword">return</span> is;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> MInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.<span class="hljs-built_in">val</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MInt lhs, MInt rhs) &#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() == rhs.<span class="hljs-built_in">val</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(MInt lhs, MInt rhs) &#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() != rhs.<span class="hljs-built_in">val</span>();&#125;&#125;;<span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-type">int</span> MInt&lt;<span class="hljs-number">0</span>&gt;::Mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> V, <span class="hljs-type">int</span> P&gt;<span class="hljs-keyword">constexpr</span> MInt&lt;P&gt; CInv = <span class="hljs-built_in">MInt</span>&lt;P&gt;(V).<span class="hljs-built_in">inv</span>();<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">using</span> Z = MInt&lt;modp&gt;;<span class="hljs-comment">// template&lt;int P&gt;</span><span class="hljs-comment">// int MInt&lt;P&gt;::Mod = P;</span><span class="hljs-comment">// using Z = MInt&lt;0&gt;;</span><span class="hljs-comment">// Z::setMod(mod);</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>, T = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (i &lt;= k) &#123;S += a[i];&#125; <span class="hljs-keyword">else</span> &#123;T += a[i];&#125;&#125;<span class="hljs-function">vector&lt;Z&gt; <span class="hljs-title">f</span><span class="hljs-params">(S + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">g</span><span class="hljs-params">(T + <span class="hljs-number">1</span>)</span></span>;f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = S; j &gt;= a[i]; j--) &#123;f[j] += f[j - a[i]];&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = T; j &gt;= a[i]; j--) &#123;g[j] += g[j - a[i]];&#125;&#125;Z ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= S; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= T; j++) &#123;<span class="hljs-keyword">if</span> (i * T == j * S) &#123;ans += f[i] * g[j];&#125;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="i.-圆与直线交点">I. 圆与直线交点</h3><p>因为不能出现浮点数，所以整个计算过程要保留分数形式。</p><p>python 的 fraction 是简单的，能帮你自动约分，四则运算也很方便。C++ 要么手写分数类，要么另谋出路。</p><ol type="1"><li>使用外心坐标公式求出三角形的外心坐标 <span class="math inline">\((X,Y)\)</span>。</li><li>任取三点之一，坐标公式计算其与外心的距离，得到半径的平方 <span class="math inline">\(R^2\)</span>。</li><li>由点到直线的距离公式，有：</li></ol><p><span class="math display">\[d=\frac{|(X-P_x)V_y-(Y-P_y)V_x|}{\sqrt{V_x^2+V_y^2}}\]</span></p><ol start="4" type="1"><li>移项，两边平方，得到相切的充要条件 <span class="math inline">\([(X-P_x)V_y-(Y-P_y)V_x]^2=R^2(V_x^2+V_y^2)\)</span>。</li><li>相交和相离改等号为不等号即可。</li></ol><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fractions <span class="hljs-keyword">import</span> *<span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():x1, y1 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())x2, y2 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())x3, y3 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())Px, Py = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())Vx, Vy = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())A1 = (x2 - x1) * <span class="hljs-number">2</span>B1 = (y2 - y1) * <span class="hljs-number">2</span>C1 = x2 * x2 + y2 * y2 - x1 * x1 - y1 * y1A2 = (x3 - x2) * <span class="hljs-number">2</span>B2 = (y3 - y2) * <span class="hljs-number">2</span>C2 = x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2X = Fraction(C1 * B2 - C2 * B1, A1 * B2 - A2 * B1)Y = Fraction(A1 * C2 - A2 * C1, A1 * B2 - A2 * B1)dx = Fraction(x1, <span class="hljs-number">1</span>) - Xdy = Fraction(y1, <span class="hljs-number">1</span>) - YR2 = dx * dx + dy * dyV_sq = Vx * Vx + Vy * Vygoal = R2 * V_sqt1 = (X - Fraction(Px, <span class="hljs-number">1</span>)) * Fraction(Vy, <span class="hljs-number">1</span>)t2 = (Y - Fraction(Py, <span class="hljs-number">1</span>)) * Fraction(Vx, <span class="hljs-number">1</span>)Z = t1 - t2Z = Z * Z;O = Z - goal<span class="hljs-keyword">if</span> O == Fraction(<span class="hljs-number">0</span>):<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Or&quot;</span>)<span class="hljs-keyword">elif</span> O &gt; Fraction(<span class="hljs-number">0</span>):<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<span class="hljs-keyword">else</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):solve() <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:main()</code></pre></div>    </div></div><hr /><h3 id="j.-创建用户">J. 创建用户</h3><p>按照题意模拟即可。</p><p>C++ 使用 <code>getline</code> 读入一整行。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    string tmp;    <span class="hljs-built_in">getline</span>(cin, tmp);<span class="hljs-type">int</span> n = <span class="hljs-built_in">stoll</span>(tmp);map&lt;string, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;<span class="hljs-built_in">getline</span>(cin, s);string t;<span class="hljs-type">int</span> lst = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<span class="hljs-keyword">if</span> (lst == <span class="hljs-number">-1</span>) &#123;t += s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j);&#125; <span class="hljs-keyword">else</span> &#123;t += s[lst + <span class="hljs-number">1</span>]; &#125;lst = j;&#125;&#125;t += s[lst + <span class="hljs-number">1</span>];<span class="hljs-type">int</span> tot = ++mp[t] - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (tot &gt; <span class="hljs-number">0</span>) &#123;t += <span class="hljs-built_in">to_string</span>(tot);&#125;cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-哲学之门">K. 哲学之门</h3><p>想好怎么枚举是重要的。</p><p><img src="/image/academic/UESTCPC2.png" /></p><p>我的做法是枚举三度点 <span class="math inline">\(i\)</span>，遍历 <span class="math inline">\(i\)</span> 的邻接点，让每个邻居都尝试作为 <span class="math inline">\(O\)</span>，这样 <span class="math inline">\(A,B\)</span> 就是另外两个邻居。</p><p>再枚举 <span class="math inline">\(A\)</span> 的邻居 <span class="math inline">\(C\)</span>，<span class="math inline">\(B\)</span> 的邻居 <span class="math inline">\(D\)</span>。将 <span class="math inline">\(C\)</span> 的邻居放进一个容器里，然后枚举 <span class="math inline">\(D\)</span> 的邻居，若和 <span class="math inline">\(C\)</span> 共有就是 <span class="math inline">\(x\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> get = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B, <span class="hljs-type">int</span> O) &#123;<span class="hljs-keyword">if</span> (adj[O].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[O]) &#123;<span class="hljs-keyword">if</span> (x == A || x == B) &#123;<span class="hljs-keyword">return</span> ;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; b &#123;O, A, B&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[O]) &#123;vis[x] = <span class="hljs-literal">true</span>;b.<span class="hljs-built_in">push_back</span>(x);&#125;vis[O] = <span class="hljs-literal">true</span>;vis[A] = <span class="hljs-literal">true</span>;vis[B] = <span class="hljs-literal">true</span>;set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> C : adj[A]) &#123;<span class="hljs-keyword">if</span> (vis[C]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[C] = <span class="hljs-literal">true</span>;set&lt;<span class="hljs-type">int</span>&gt; s;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[C]) &#123;s.<span class="hljs-built_in">insert</span>(x);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> D : adj[B]) &#123;<span class="hljs-keyword">if</span> (vis[D]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[D] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[D]) &#123;<span class="hljs-keyword">if</span> (vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(x)) &#123;ans++;&#125;&#125;vis[D] = <span class="hljs-literal">false</span>;&#125;vis[C] = <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;vis[x] = <span class="hljs-literal">false</span>;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (adj[i].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">get</span>(i, adj[i][<span class="hljs-number">0</span>], adj[i][<span class="hljs-number">1</span>], adj[i][<span class="hljs-number">2</span>]);<span class="hljs-built_in">get</span>(i, adj[i][<span class="hljs-number">1</span>], adj[i][<span class="hljs-number">2</span>], adj[i][<span class="hljs-number">0</span>]);<span class="hljs-built_in">get</span>(i, adj[i][<span class="hljs-number">0</span>], adj[i][<span class="hljs-number">2</span>], adj[i][<span class="hljs-number">1</span>]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="m.-前兜车一转后兜车一转">M. 前兜车一转后兜车一转</h3><p>选定的前缀和后缀可以是不交、恰交、相交，每种情况都讨论一下。</p><p>恰交是简单的。</p><p>不交的话预处理出 <span class="math inline">\(suf[i]\)</span> 代表翻转 <span class="math inline">\(i\sim n\)</span> 中的任一后缀的最大收益。接着枚举前缀，另一段的最大贡献就能查表了。</p><p>相交的话是类似的。枚举 <span class="math inline">\(i\)</span> 代表翻转前缀 <span class="math inline">\(1\sim i\)</span>，此时要选定一个 <span class="math inline">\(j\in [1,i]\)</span> 然后翻转后缀 <span class="math inline">\(j\sim n\)</span> 并让贡献最大。推一下式子，这等价于找到让 <span class="math inline">\(|a_j-a_n|-|a_j-a_{j-1}|\)</span> 最大的 <span class="math inline">\(j\)</span>，一样可以预处理出一个前缀和。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">auto</span> f = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a[i] - a[j]);&#125;;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;res += <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> ans = res;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;ans = <span class="hljs-built_in">max</span>(ans, res - <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, n));&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">suf</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">1</span>; i--) &#123;suf[i] = <span class="hljs-built_in">max</span>(suf[i + <span class="hljs-number">1</span>], -<span class="hljs-built_in">f</span>(i, i - <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(n, i - <span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">2</span>; i++) &#123;ans = <span class="hljs-built_in">max</span>(ans, res - <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>) + suf[i + <span class="hljs-number">2</span>]);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;pre[i] = <span class="hljs-built_in">max</span>(pre[i - <span class="hljs-number">1</span>], -<span class="hljs-built_in">f</span>(i - <span class="hljs-number">1</span>, i) + <span class="hljs-built_in">f</span>(i, n));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;ans = <span class="hljs-built_in">max</span>(ans, res - <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>) + pre[i]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="n.-幸运之环-ii">N. 幸运之环 II</h3><p>用 dfs 找出这棵基环树的环。</p><p>找到环上最小的点 <span class="math inline">\(x\)</span>，再看一下 <span class="math inline">\(x\)</span> 沿环上两个方向的邻居，哪个邻居小就往哪个方向输出。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;vector&lt;<span class="hljs-type">int</span>&gt; cir;&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">ins</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-literal">true</span>;ins[x] = <span class="hljs-literal">true</span>;f[x] = fa;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (ins[y] &amp;&amp; cir.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i != y; i = f[i]) &#123;cir.<span class="hljs-built_in">push_back</span>(i);&#125;cir.<span class="hljs-built_in">push_back</span>(y);&#125;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;ins[x] = <span class="hljs-literal">false</span>;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-type">int</span> len = cir.<span class="hljs-built_in">size</span>();cout &lt;&lt; len &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;cir.<span class="hljs-built_in">insert</span>(cir.<span class="hljs-built_in">end</span>(), cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> p = <span class="hljs-number">-1</span>, mn = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; cir.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">if</span> (cir[i] &lt; mn) &#123;mn = cir[i];p = i;&#125;&#125;cout &lt;&lt; cir[p] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">if</span> (cir[p - <span class="hljs-number">1</span>] &lt; cir[p + <span class="hljs-number">1</span>]) &#123;<span class="hljs-type">int</span> t = p, tot = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (tot &lt; len) &#123;t--;<span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) &#123;t = cir.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;cout &lt;&lt; cir[t] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;tot++;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> t = p, tot = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (tot &lt; len) &#123;t++;<span class="hljs-keyword">if</span> (t == cir.<span class="hljs-built_in">size</span>()) &#123;t = <span class="hljs-number">0</span>;&#125;cout &lt;&lt; cir[t] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;tot++;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="o.-不走回头路">O. 不走回头路</h3><p>在一个强连通分量内，所有的点都可以互相到达。即同一个 SCC 内的景点可以任意安排游览顺序。</p><p>缩点，得到一个 DAG。若要能遍历所有的点，这个 DAG 必然是一条链。</p><p>在 DAG 上 dp（令 <span class="math inline">\(f[x]\)</span> 代表以 <span class="math inline">\(x\)</span> 结尾的链的长度的最大值），判断是否存在一个点 <span class="math inline">\(f[x]=cnt\)</span> 即可（<span class="math inline">\(cnt\)</span> 是缩点后的图的顶点数）。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><p>FunFact：一个误区是只判断缩点后的图 "恰有一个入度为 <span class="math inline">\(0\)</span> 的点" 和 "恰有一个出度为 <span class="math inline">\(0\)</span>" 的点，这是错误的，反例是 <span class="math inline">\(1\to 2\to 3,1\to 4\to3\)</span>。赛时的数据有这个缺陷（包括其它一些没缩点乱搞度数的做法也过了），磕头 <span class="math inline">\(+1\)</span>。补题链接里的数据是更新过的。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">stk</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(n + <span class="hljs-number">1</span>);<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x] = low[x] = ++tim;vis[x] = <span class="hljs-literal">true</span>;stk[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span> &#123;now = stk[top--];vis[now] = <span class="hljs-literal">false</span>;c[now] = cnt;scc[cnt].<span class="hljs-built_in">push_back</span>(now);&#125; <span class="hljs-keyword">while</span>(x != now);&#125;&#125;;vector&lt;set&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">Adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> shrinkPoint = [&amp;]() &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (c[x] == c[y]) <span class="hljs-keyword">continue</span>;Adj[c[x]].<span class="hljs-built_in">insert</span>(c[y]);&#125;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!dfn[i]) &#123;<span class="hljs-built_in">tarjan</span>(i);&#125;&#125;<span class="hljs-built_in">shrinkPoint</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rd</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= cnt; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;rd[y]++;&#125;&#125;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<span class="hljs-keyword">if</span> (rd[i] == <span class="hljs-number">0</span>) &#123;q.<span class="hljs-built_in">push</span>(i);f[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;f[y] = <span class="hljs-built_in">max</span>(f[y], f[x] + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (--rd[y] == <span class="hljs-number">0</span>) &#123;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (*<span class="hljs-built_in">max_element</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>()) == cnt) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="p.-相同字符">P. 相同字符</h3><p>预处理 <span class="math inline">\(pre[i]\)</span> 代表从前向后在 <span class="math inline">\(a\)</span> 中匹配上 <span class="math inline">\(b\)</span> 中的字符的个数，即 <span class="math inline">\(a[0..i]\)</span> 能匹配上 <span class="math inline">\(b[0..(pre[i]-1)]\)</span>。</p><p>预处理 <span class="math inline">\(suf[i]\)</span> 代表从后向前在 <span class="math inline">\(a\)</span> 中匹配上 <span class="math inline">\(b\)</span> 中的字符的个数，即 <span class="math inline">\(a[i..n-1]\)</span> 能匹配上 <span class="math inline">\(b[(m-suf[i])..m-1]\)</span>。</p><p>上述的匹配不区分大小写。</p><p>若 <span class="math inline">\(a\)</span> 中无大写字母，判断 <span class="math inline">\(\max(suf[0],pre[n-1])=m\)</span> 是否成立即可。</p><p>否则枚举 <span class="math inline">\(b\)</span> 中每一个与大写字母相同的位置 <span class="math inline">\(i\)</span>，判断 <span class="math inline">\(pre[i-1] \ge i\)</span> 和 <span class="math inline">\(suf[i+1]\ge m-i-1\)</span> 是否成立。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string a, b;cin &gt;&gt; a &gt;&gt; b;<span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<span class="hljs-type">int</span> m = b.<span class="hljs-built_in">size</span>();<span class="hljs-type">int</span> pos = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isupper</span>(a[i])) &#123;pos = i;a[i] = <span class="hljs-built_in">tolower</span>(a[i]);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(n)</span></span>;pre[<span class="hljs-number">0</span>] = (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]);suf[n - <span class="hljs-number">1</span>] = (a.<span class="hljs-built_in">back</span>() == b.<span class="hljs-built_in">back</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;pre[i] = pre[i - <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (pre[i] &lt; m) &#123;pre[i] += (b[pre[i]] == a[i]);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;suf[i] = suf[i + <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (suf[i] &lt; m) &#123;suf[i] += (b[m - suf[i] - <span class="hljs-number">1</span>] == a[i]);&#125;&#125;<span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(suf[<span class="hljs-number">0</span>], pre[n - <span class="hljs-number">1</span>]) == m) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> L = (pos == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : pre[pos - <span class="hljs-number">1</span>]);<span class="hljs-type">int</span> R = (pos == n - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : suf[pos + <span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-keyword">if</span> (b[i] == a[pos]) &#123;<span class="hljs-keyword">if</span> (L &gt;= i &amp;&amp; R &gt;= m - i - <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="q.-校车">Q. 校车</h3><p>数据范围识状压。将给定的 <span class="math inline">\(w\)</span> 个路口称作关键点。</p><p>令 <span class="math inline">\(dp[S][i]\)</span> 代表从起点出发经过了状态 <span class="math inline">\(S\)</span> 中的点，最终到达关键点 <span class="math inline">\(i\)</span> 所需的路程。</p><ul><li>初态：<span class="math inline">\(dp[\{i\}][i]=\text{dis}(1,p_i)\)</span>。</li><li>转移：<span class="math inline">\(dp[S\cup \{j\}][j]=\min(dp[S\cup \{j\}][j],dp[S][i]+\text{dis}(p_i,p_j))\)</span>，其中 <span class="math inline">\(i\in S,j\not\in S\)</span>。</li></ul><p>那么经过 <span class="math inline">\(S\)</span> 中的点再返回起点的最短距离 <span class="math inline">\(f[S]=\min\limits_{i\in S}(dp[S][i]+\text{dis}(1,p_i))\)</span>。</p><p>二分答案，设二分出的答案是 <span class="math inline">\(mid\)</span>，问题转化为判断是否能用不超过 <span class="math inline">\(k\)</span> 条 <span class="math inline">\(f[S]\le mid\)</span> 的路径覆盖所有 <span class="math inline">\(w\)</span> 个关键点。</p><p>设 <span class="math inline">\(g[S]\)</span> 表示覆盖 <span class="math inline">\(S\)</span> 中的点需要的最小路径条数，判定就是 <span class="math inline">\(g[\{1,2,\ldots,w\}]\le k\)</span>。</p><ul><li>初态：<span class="math inline">\(g[\varnothing]=0\)</span>。</li><li>转移：<span class="math inline">\(g[S\cup T]=\min(g[S\cup T],g[S]+1)\)</span>，其中 <span class="math inline">\(f[T]\le mid\)</span>。</li></ul><p>注意：转移的时候不需要对每一个 <span class="math inline">\(S\)</span> 都枚举所有的 <span class="math inline">\(T\)</span>，那样是 <span class="math inline">\(O(4^w)\)</span>。只需要 <span class="math inline">\(O(3^w)\)</span> 枚举所有所有状态的子状态就行。</p><p>时间复杂度 <span class="math inline">\(O(wm\log m+w^22^w+20\cdot 3^{w})\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, m, w, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; w &gt;&gt; k;    vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-type">int</span> x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);        adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(w)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;        cin &gt;&gt; p[i];    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function">vector <span class="hljs-title">d</span><span class="hljs-params">(w, vector&lt;<span class="hljs-type">int</span>&gt;(w))</span></span>;    &#123;        <span class="hljs-keyword">auto</span> dijkstra = [&amp;] (<span class="hljs-type">int</span> S) &#123;            vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">dis</span>(n + <span class="hljs-number">1</span>, inf);            <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;                    <span class="hljs-meta">#<span class="hljs-keyword">define</span> P pair<span class="hljs-string">&lt;int, int&gt;</span></span>            priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; Q;            Q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);            dis[S] = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;                <span class="hljs-keyword">auto</span> [dist, x] = Q.<span class="hljs-built_in">top</span>();                Q.<span class="hljs-built_in">pop</span>();                <span class="hljs-keyword">if</span> (vis[x]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                vis[x] = <span class="hljs-literal">true</span>;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;                    <span class="hljs-keyword">if</span> (dis[y] &gt; dist + w) &#123;                        dis[y] = dist + w;                        Q.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);                    &#125;                &#125;            &#125;            <span class="hljs-keyword">return</span> dis;        &#125;;        dis = <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;            <span class="hljs-keyword">auto</span> A = <span class="hljs-built_in">dijkstra</span>(p[i]);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; w; j++) &#123;                d[i][j] = A[p[j]];            &#125;        &#125;    &#125;        <span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; w, vector&lt;<span class="hljs-type">int</span>&gt;(w, inf))</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;        dp[<span class="hljs-number">1</span> &lt;&lt; i][i] = dis[p[i]];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; w); S++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;            <span class="hljs-keyword">if</span> ((S &gt;&gt; i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> || dp[S][i] == inf) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; w; j++) &#123;                <span class="hljs-keyword">if</span> ((S &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-type">int</span> nS = S | (<span class="hljs-number">1</span> &lt;&lt; j);                    <span class="hljs-keyword">if</span> (d[i][j] &lt; <span class="hljs-number">1e10</span>) &#123;                        dp[nS][j] = <span class="hljs-built_in">min</span>(dp[nS][j], dp[S][i] + d[i][j]);                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; w, inf)</span></span>;    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; w); S++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;            <span class="hljs-keyword">if</span> ((S &gt;&gt; i &amp; <span class="hljs-number">1</span>) &amp;&amp; dp[S][i] != inf) &#123;                f[S] = <span class="hljs-built_in">min</span>(f[S], dp[S][i] + dis[p[i]]);            &#125;        &#125;        <span class="hljs-keyword">if</span> (f[S] &lt; <span class="hljs-number">1e10</span>) &#123;            mx = <span class="hljs-built_in">max</span>(mx, f[S]);        &#125;    &#125;    <span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> mid) &#123;        vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">g</span>(<span class="hljs-number">1</span> &lt;&lt; w, inf);        g[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; w); S++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> T = S; ; T = (T - <span class="hljs-number">1</span>) &amp; S) &#123;    <span class="hljs-keyword">if</span> (f[S ^ T] &lt;= mid) &#123;    g[S] = <span class="hljs-built_in">min</span>(g[S], g[T] + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span> (T == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">break</span>;    &#125;    &#125;    &#125;        <span class="hljs-keyword">return</span> g[(<span class="hljs-number">1</span> &lt;&lt; w) - <span class="hljs-number">1</span>] &lt;= k;    &#125;;    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = mx, ans = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;            ans = mid;            r = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            l = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">solve</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>UESTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】三月训练日记</title>
    <link href="/posts/5dc05f53.html"/>
    <url>/posts/5dc05f53.html</url>
    
    <content type="html"><![CDATA[<p>说是三月份，但实际上是从 2025.02.24 开始的，紧接着寒假。</p><p>表扬 <a href="https://cftracker.netlify.app/contests">CFTracker</a>，让我知道我去年原来有这么多题遗漏了没有补。</p><p>开学给自己定的节奏是每场 CF 必打，此外一周 vp 至少三场，补 *2500 以下，如果闲着就到 CFTracker 里解决历史遗留问题，周末晚上的 abc/arc 非急事不错过。</p><p>愿我获得算法之神的庇佑。</p><h2 id="abc394e.-palindromic-shortest-path"><a href="https://atcoder.jp/contests/abc394/tasks/abc394_e">abc394e. Palindromic Shortest Path</a></h2><p><a href="https://atcoder.jp/contests/abc394/submissions/63139453">Code</a></p><p>把从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的路径看成一个状态 <span class="math inline">\((S,T)\)</span>。初始只有两种状态是合法的：</p><ul><li><span class="math inline">\(\forall i\in [1,n]\)</span>，<span class="math inline">\((i,i)\)</span>。</li><li><span class="math inline">\(\forall i\in[1,n],j\in[1,n],s[i][j]\neq \text{“}-\text{”}\)</span>，<span class="math inline">\((i,j)\)</span>。</li></ul><p>以这些状态为起点进行 bfs。对于当前状态 <span class="math inline">\((x,y)\)</span>，二维枚举 <span class="math inline">\(i,j\)</span>，若 <span class="math inline">\(s[i][x]=s[y][j]\)</span>，说明可拓展，将状态 <span class="math inline">\((i,j)\)</span> 压入队列中。</p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="abc394f.-alkane"><a href="https://atcoder.jp/contests/abc394/tasks/abc394_f">abc394f. Alkane</a></h2><p><a href="https://atcoder.jp/contests/abc394/submissions/63140699">Code</a></p><p>令 <span class="math inline">\(dp[x]\)</span> 代表 <span class="math inline">\(x\)</span> 贡献了三个儿子的答案。</p><p>转移自然是 <span class="math inline">\(dp[x]\)</span> 取它儿子里面最大的三个 <span class="math inline">\(dp[y]\)</span> 求和。</p><p>对于当前节点 <span class="math inline">\(x\)</span>，有这么几种情况：</p><ul><li><span class="math inline">\(x\)</span> 的度数 <span class="math inline">\(\ge 1\)</span>，遍历所有儿子，取度数 <span class="math inline">\(\ge 4\)</span> 的儿子的 <span class="math inline">\(dp[y]\)</span> 加上 <span class="math inline">\(x\)</span> 自身一个计入答案。</li><li><span class="math inline">\(x\)</span> 的度数 <span class="math inline">\(\ge 4\)</span>，且有 <span class="math inline">\(\ge 4\)</span> 个儿子，取最大的四个 <span class="math inline">\(dp[y]\)</span> 的和加上 <span class="math inline">\(x\)</span> 自身一个计入答案。</li><li><span class="math inline">\(x\)</span> 的度数 <span class="math inline">\(\ge 4\)</span>，且有 <span class="math inline">\(\ge 3\)</span> 个儿子，则计算出 <span class="math inline">\(dp[x]\)</span> 传递上去。</li><li>除此之外 <span class="math inline">\(x\)</span> 只能作为一个叶子贡献给父亲。</li></ul><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1004e.-sonya-and-ice-cream"><a href="https://codeforces.com/contest/1004/problem/E">CF1004E. Sonya and Ice Cream</a></h2><p>*2400 <a href="https://codeforces.com/contest/1004/submission/307667954">Code</a></p><p>将 <span class="math inline">\(A,B\)</span> 两点间的距离简记为 <span class="math inline">\(d_{AB}\)</span>。</p><p>结论：最佳的路径一定被直径包含。</p><ul><li>首先，一个经典的结论是：对于树上任意一点，离它最远的点一定是直径的两个端点之一。对于直径外一点 <span class="math inline">\(x\)</span>，设离 <span class="math inline">\(x\)</span> 最近的直径上的点是点 <span class="math inline">\(y\)</span>，当 <span class="math inline">\(x\)</span> 向 <span class="math inline">\(y\)</span> 靠近时，离 <span class="math inline">\(x\)</span> 最远的点仍然是直径的两个端点，但最远距离减小，故取 <span class="math inline">\(y\)</span> 优于 <span class="math inline">\(x\)</span>。于是，我们选的第一个点肯定是在直径上。</li><li>设我们选的第一个点是 <span class="math inline">\(A\)</span>，接下来证明 <span class="math inline">\(A\)</span> 沿着直径扩展最佳。如下图，<span class="math inline">\(L,R\)</span> 是直径的两个端点，<span class="math inline">\(E,G\)</span> 分别是 <span class="math inline">\(D,F\)</span> 向下延伸出去最远的点。若从 <span class="math inline">\(A\)</span> 出发沿直径选了 <span class="math inline">\(B\)</span>，答案是 <span class="math inline">\(\max(d_{LA},d_{AE},d_{BG},d_{BR})\)</span>；若沿子树方向选了 <span class="math inline">\(D\)</span>，答案是 <span class="math inline">\(\max(d_{LA},d_{DE},d_{AR},d_{AG})\)</span>。依据直径的性质有 <span class="math inline">\(d_{BG} &lt; d_{BR}\)</span>，<span class="math inline">\(d_{AG}&lt;d_{AR}\)</span>，<span class="math inline">\(d_{AE} &lt; d_{LA}\)</span>，<span class="math inline">\(d_{DE} &lt; d_{LA}\)</span>，此时相当于比较 <span class="math inline">\(\max(d_{LA},d_{BR})\)</span> 与 <span class="math inline">\(\max(d_{LA},d_{AR})\)</span>，又 <span class="math inline">\(d_{AR} &gt; d_{BR}\)</span>，故选 <span class="math inline">\(B\)</span> 相比选 <span class="math inline">\(D\)</span> 更优。将 <span class="math inline">\(A,B\)</span> 看成一个整体，同理可证明选 <span class="math inline">\(C\)</span> 比选 <span class="math inline">\(F\)</span> 要更优，以此类推......因此路径肯定是沿着直径方向一直扩展。</li></ul><p><img src="/image/academic/CF1004.png" style="zoom:50%;" /></p><p>当 <span class="math inline">\(k\)</span> 大于等于直径长度时，就选完整个直径。否则在直径上搞一个长为 <span class="math inline">\(k\)</span> 的滑动窗口，窗口两侧延伸出去的最长距离可以预处理前缀后缀和计算，窗口内部子树的答案等同于区间最值。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>，若用单调队列求极值就是 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1969e.-unique-array"><a href="https://codeforces.com/contest/1969/problem/E">CF1969E. Unique Array</a></h2><p>*2400 <a href="https://codeforces.com/contest/1969/submission/307896648">Code</a></p><p>对于一个数 <span class="math inline">\(a_i\)</span>，设 <span class="math inline">\(a_i\)</span> 上一个出现的位置是 <span class="math inline">\(\text{lst}_{a_i}\)</span>，下一个出现的位置是 <span class="math inline">\(\text{nxt}_{a_i}\)</span>，那么 <span class="math inline">\(a_i\)</span> 在区间 <span class="math inline">\([l,r]\)</span> 中唯一的充要条件是 <span class="math inline">\(l\in(\text{lst}_{a_i},i]\)</span> 且 <span class="math inline">\(r\in [i,\text{nxt}_{a_i})\)</span>。</p><p>考虑从左到右枚举线段的右端点 <span class="math inline">\(r\)</span>，判断是否有不合法的左端点。</p><p>令 <span class="math inline">\(\text{llst}_{a_i}\)</span> 是 <span class="math inline">\(a_i\)</span> 的上一个的上一个的出现位置。当右端点移动到 <span class="math inline">\(i\)</span> 时，<span class="math inline">\((\text{llst}_{a_i},\text{lst}_{a_i}]\)</span> 这一段不能再作为合法的左端点了，我们将这个区间 <span class="math inline">\(-1\)</span>。而 <span class="math inline">\(l\in (\text{lst}_{a_i},i]\)</span> 是新增的合法左端点，我们将这个区间 <span class="math inline">\(+1\)</span>。</p><p>如此一来，对于当前右端点 <span class="math inline">\(i\)</span>，以 <span class="math inline">\(l\in[1,i]\)</span> 为左端点的区间全部 unique 就等价于区间 <span class="math inline">\([1,i]\)</span> 的最小值 <span class="math inline">\(&gt;0\)</span>。若不满足条件，我们就把 <span class="math inline">\(a_i\)</span> 替换掉，并且贪心的想肯定是替换成一个序列里从没出现过的数。替换后，左端点就能存在于 <span class="math inline">\([1,i]\)</span> 中的任何位置，于是我们将区间 <span class="math inline">\([1,i]+1\)</span>，同时把答案 <span class="math inline">\(+1\)</span>。</p><p>整个过程仅涉及区间加、区间极值，使用线段树维护。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2064f.-we-be-summing"><a href="https://codeforces.com/contest/2064/problem/F">CF2064F. We Be Summing</a></h2><p>*2600 <a href="https://codeforces.com/contest/2064/submission/307985033">Code</a></p><p>注意到随着 <span class="math inline">\(i\)</span> 增加，<span class="math inline">\(\min(b_1,\ldots,b_i)\)</span> 递减，<span class="math inline">\(\max(b_{i+1},\ldots,b_m)\)</span> 也递减。这两项加起来要是定值，说明对于任意 epic 的序列，满足相加等于 <span class="math inline">\(k\)</span> 的 <span class="math inline">\(\min(b_1,\ldots,b_i)\)</span> 唯一，<span class="math inline">\(\max(b_{i+1},\ldots,b_m)\)</span> 也唯一。我们把前缀 <span class="math inline">\(\min\)</span> 这一项的值记为 <span class="math inline">\(x\)</span>，后缀 <span class="math inline">\(\max\)</span> 这一项自然是 <span class="math inline">\(k-x\)</span>。对于满足该要求的序列，称之为 <span class="math inline">\(x\)</span>-epic 序列，并将 <span class="math inline">\(\min(b_1,\ldots,b_i)=x\)</span> 的 <span class="math inline">\(i\)</span> 称为分割点。不难发现分割点一定构成一段连续的区间。</p><p>记 <span class="math inline">\(lmn_i\)</span> 为 <span class="math inline">\(i\)</span> 左侧第一个 <span class="math inline">\(\le a_i\)</span> 的位置，<span class="math inline">\(lmx_i\)</span> 为 <span class="math inline">\(i\)</span> 左侧第一个 <span class="math inline">\(&gt;a_i\)</span> 的位置，<span class="math inline">\(rmx_i\)</span> 为 <span class="math inline">\(i\)</span> 右侧第一个 <span class="math inline">\(\ge a_i\)</span> 的位置，<span class="math inline">\(rmn_i\)</span> 为右侧第一个 <span class="math inline">\(&lt; a_i\)</span> 的位置。</p><p>依据第一段的分析，我们枚举 <span class="math inline">\(x\)</span>，对每个 <span class="math inline">\(x\)</span> 统计有多少 <span class="math inline">\(x\)</span>-epic 的子数组。对于当前 <span class="math inline">\(a_i=x\)</span>，若要 <span class="math inline">\(a_i\)</span> 成为前缀最小值（为了计数不重复，这里指第一个前缀最小值），左端点可以是 <span class="math inline">\((lmn_i+1,i]\)</span> 中的任意一个。再枚举满足 <span class="math inline">\(j &gt;i\)</span> 且 <span class="math inline">\(a_j=k-x\)</span> 的 <span class="math inline">\(j\)</span>，若要 <span class="math inline">\(a_j\)</span> 成为后缀最大值（同理这里指最后一个后缀最大值），右端点可以是 <span class="math inline">\([j,rmx_i)\)</span>。</p><p>不难发现，<span class="math inline">\(a_i,a_j\)</span> 要分别作为最小前缀和最大后缀贡献答案，当且仅当区间 <span class="math inline">\((lmn_i,rmn_i)\)</span> 和 <span class="math inline">\((lmx_j,rmx_j)\)</span> 相交，此时 <span class="math inline">\([lmx_j,rmn_i]\)</span> 内的任意一点均为分割点。若满足此条件，包含 <span class="math inline">\([i,j]\)</span> 的任一子数组均 <span class="math inline">\(a_i\)</span>-epic，贡献是 <span class="math inline">\((rmx_j-j)\times(i-lmn_i)\)</span>。</p><p>可以使用树状数组或线段树快速统计贡献。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2072g.-ive-been-flipping-numbers-for-300-years-and-calculated-the-sum"><a href="https://codeforces.com/contest/2072/problem/G">CF2072G. I've Been Flipping Numbers for 300 Years and Calculated the Sum</a></h2><p>*2200 <a href="https://codeforces.com/contest/2072/submission/308019731">Code</a></p><p>阈值分治。</p><ul><li><p>当 <span class="math inline">\(p \le \sqrt{n}\)</span> 时，暴力计算 <span class="math inline">\(\text{rev}(n,p)\)</span>。时间复杂度 <span class="math inline">\(O(\sqrt{n})\)</span>。</p></li><li><p>当 <span class="math inline">\(p&gt;n\)</span> 时，<span class="math inline">\(\text{rev}(n,p)=n\)</span>。时间复杂度 <span class="math inline">\(O(1)\)</span>。</p></li></ul><p>只用考虑 <span class="math inline">\(\sqrt{n}&lt;p\le n\)</span> 时如何快速计算。</p><p>注意到 <span class="math inline">\(n\)</span> 在 <span class="math inline">\(p\)</span> 进制下最多只有两位，翻转后式子写出来是： <span class="math display">\[\begin{align}&amp;\quad\ (n\bmod p)\cdot p+\left\lfloor\frac{n}{p}\right\rfloor\\&amp;=(n-\left\lfloor\frac{n}{p}\right\rfloor \cdot p)\cdot p+\left\lfloor\frac{n}{p}\right\rfloor\\&amp;=-\left\lfloor\frac{n}{p}\right\rfloor\cdot p^2+np+\left\lfloor\frac{n}{p}\right\rfloor\end{align}\]</span> 数论分块枚举 <span class="math inline">\(\left\lfloor\dfrac{n}{p}\right\rfloor\)</span> 的值，一段区间内 <span class="math inline">\(p^2\)</span> 的和以及 <span class="math inline">\(p\)</span> 的和可以用公式快速计算。</p><p>时间复杂度 <span class="math inline">\(O(t\sqrt{n})\)</span>，<span class="math inline">\(t\)</span> 是数据组数。</p><h2 id="cf1839d.-ball-sorting"><a href="https://codeforces.com/contest/1839/problem/D">CF1839D. Ball Sorting</a></h2><p>*2100 <a href="https://codeforces.com/contest/1839/submission/308219457">Code</a></p><p>考虑这么一种操作策略：选择原序列的任意一个上升子序列，称这个子序列里的元素为选定点。我们钦定选定点都不动，那么所需要 <span class="math inline">\(0\)</span> 的最小个数就是极长非选定点连续段的个数。</p><p>容易发现枚举所有的上升子序列可以涵盖所有可能的最优策略。</p><p>另一个观察是对于非选定点，可以只通过 <span class="math inline">\(1\)</span> 次移动就能移动到正确的位置上。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 表示若 <span class="math inline">\(i\)</span> 是一个选定点，<span class="math inline">\([1,i]\)</span> 中有至多 <span class="math inline">\(j\)</span> 个极长非选定点连续段，将 <span class="math inline">\([1,i]\)</span> 排好序的最小代价。</p><p>枚举上升子序列的上一个元素（即上一个选定点），做出以下转移： <span class="math display">\[dp[i][j]=\min\begin{cases}dp[i][j - 1]\\dp[i-1][j] &amp;,\text{if }c[i-1]&lt;c[i]\\dp[k][j-1]+(i-k-1)&amp;,\forall k\in[0,i-1),c[k]&lt;c[i]\end{cases}\]</span></p><ul><li><p>初态：<span class="math inline">\(dp[i][0]=\begin{cases}0&amp;,\text{if }\{c\}\textbf{ 在 }[1,i] \textbf{ 单调增}\\ \text{inf}&amp;,\text{otherwise}\end{cases}\)</span></p></li><li><p>答案：<span class="math inline">\(\min\begin{cases}dp[n][k]\\ dp[i][k-1]+(n-i)&amp;,\forall i\in[1,n)\end{cases}\)</span></p></li></ul><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="cf1839e.-decreasing-game"><a href="https://codeforces.com/contest/1839/problem/E">CF1839E. Decreasing Game</a></h2><p>*2400 <a href="https://codeforces.com/contest/1839/submission/308401912">Code</a></p><p>结论：后手必胜当且仅当 <span class="math inline">\(\{a\}\)</span> 能被划分为元素和相等的两部分。</p><ul><li><p>充分性：设划分成的两部分为 <span class="math inline">\(A,B\)</span>，后手必胜的策略如下。若先手选择了 <span class="math inline">\(A\)</span> 中的元素，后手就选择 <span class="math inline">\(B\)</span> 中的元素；否则后手选择 <span class="math inline">\(A\)</span> 中的元素。如此操作后 <span class="math inline">\(A,B\)</span> 两部分的元素和都减少了 <span class="math inline">\(d\)</span>，因此任何时刻 <span class="math inline">\(A,B\)</span> 两部分元素和相等。于是若先手还能继续游戏（即选择了一个 <span class="math inline">\(a_i&gt;0\)</span> 的 <span class="math inline">\(i\)</span>），后手也一定能从另一部分里找到一个 <span class="math inline">\(j\neq i\)</span> 使得 <span class="math inline">\(a_j&gt;0\)</span>。</p></li><li><p>必要性：若初始 <span class="math inline">\(\{a\}\)</span> 不能划分为元素和相等的两部分，则能够证明后续每一轮操作后 <span class="math inline">\(\{a\}\)</span> 仍旧不能划分为元素和相等的两部分。</p><ul><li>设某一轮中两人选择了 <span class="math inline">\(a_i,a_j\)</span>，不妨令 <span class="math inline">\(a_i\le a_j\)</span>。假设操作前 <span class="math inline">\(\{a\}\)</span> 不能被划分为了总和相等的两部分而操作结束后可以，令操作结束后 <span class="math inline">\(a_j-a_i\)</span> 所在的那部分其它数的和为 <span class="math inline">\(s_1\)</span>，另一部分总和为 <span class="math inline">\(s_2\)</span>，则 <span class="math inline">\(s_1+(a_j-a_i)=s_2\)</span>。移项得 <span class="math inline">\(s_1+a_j=s_2+a_i\)</span>，矛盾。</li></ul><p>于是，先手无论怎么抉择最后的局面都一定是只剩一个非零数或两个不同的非零数，必胜。</p></li></ul><p>最后的问题是如何找出这个划分，这等价于找一个和为 <span class="math inline">\(\dfrac{\sum a_i}{2}\)</span> 的子序列，是一个经典的背包问题。</p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="abc394g.-dense-buildings"><a href="https://atcoder.jp/contests/abc394/tasks/abc394_g">abc394g. Dense Buildings</a></h2><p><a href="https://atcoder.jp/contests/abc394/submissions/63238482">Code</a></p><p>对于一组询问 <span class="math inline">\((x_1,y_1,z_1,x_2,y_2,z_2)\)</span>，如果我们找到一条路径连通 <span class="math inline">\((x_1,y_1)\)</span> 与 <span class="math inline">\((x_2,y_2)\)</span> 且路径上最低的楼房高 <span class="math inline">\(h\)</span>。那么：</p><ul><li>若 <span class="math inline">\(h&lt; \min(z_1,z_2)\)</span>，则垂直方向上我们要 <span class="math inline">\(z_1\to h\)</span> 再 <span class="math inline">\(h\to z_2\)</span>，写成式子是 <span class="math inline">\(z_1+z_2-2h\)</span>。</li><li>若 <span class="math inline">\(h \ge \min(z_1,z_2)\)</span>，答案是 <span class="math inline">\(|z_1-z_2|\)</span>。</li></ul><p>为了让答案最小，我们肯定是找最大的 <span class="math inline">\(h\)</span>。</p><p>对于相邻的楼房，连边，边权是较低的楼房的高度。</p><p>问题转化为有若干组询问，每次询问两个点，需要找出两点间的一条简单路径，让路径上所有边的边权最小值最大（最大瓶颈路）。</p><p>这是个经典的问题（NOIP 货车运输），做法是 kruskal 重构树或者在最大生成树上倍增。</p><h2 id="cf1982d.-beauty-of-the-mountains"><a href="https://codeforces.com/contest/1982/problem/D">CF1982D. Beauty of the mountains</a></h2><p>*1700 <a href="https://codeforces.com/contest/1982/submission/308516339">Code</a></p><p>把有雪的格子称为 <span class="math inline">\(0\)</span> 格子，没雪的格子称为 <span class="math inline">\(1\)</span> 格子。</p><p>先计算出初始 <span class="math inline">\(1\)</span> 格子的高度和与 <span class="math inline">\(0\)</span> 格子的高度和的差值，记作 <span class="math inline">\(s\)</span>。</p><p>对于每一个 <span class="math inline">\(k\times k\)</span> 的矩形，我们可以用二维前缀和快速计算出对这个矩形整体 <span class="math inline">\(+1\)</span> 对 "<span class="math inline">\(1\)</span> 格子的高度和与 <span class="math inline">\(0\)</span> 格子的高度和的差值" 的贡献，把这个贡献记作 <span class="math inline">\(c_i\)</span>。</p><p>问题转化为给定序列 <span class="math inline">\(\{c\}\)</span>，求以下不定方程是否有解。 <span class="math display">\[c_1x_1+c_2x_2+\ldots+c_mx_m=s\]</span> 根据裴蜀定理，有解当且仅当 <span class="math inline">\(\gcd(c_1,c_2,\ldots,c_m)\mid s\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(nm\log k)\)</span>。</p><h2 id="cf1848c.-vika-and-price-tags"><a href="https://codeforces.com/contest/1848/problem/C">CF1848C. Vika and Price Tags</a></h2><p>*1800 <a href="https://codeforces.com/contest/1848/submission/308637343">Code</a></p><p><span class="math inline">\(\tiny{不是哥们，我怎么又卡 \text{ div2C }了，呜哇呜哇呜}\)</span></p><p>考虑单独一组 <span class="math inline">\((a_i,b_i)\)</span>，设终态是 <span class="math inline">\((0,x)\)</span>，那么有循环： <span class="math display">\[(0,x)\to (x,x)\to (x,0)\to(0,x)\]</span> 因此设当前 <span class="math inline">\((a_i,b_i)\)</span> 最少需要 <span class="math inline">\(d_i\)</span> 次操作达成 <span class="math inline">\(a_i=0\)</span>，那么 <code>Yes</code> 当且仅当 <span class="math inline">\(\forall i,j\in [1,n]\)</span>，<span class="math inline">\(d_i\equiv d_j\pmod {3}\)</span>。</p><p>接下来的任务是对每一组 <span class="math inline">\((a,b)\)</span> 求出相应的 <span class="math inline">\(d\)</span>。</p><p>考虑辗转相除的过程，当 <span class="math inline">\(a&lt;b\)</span> 时，令 <span class="math inline">\(b=ka+p\)</span>， <span class="math inline">\(p\in[0,a)\)</span>，状态变化如下：</p><p><span class="math display">\[(a,ka+p)\to(ka+p, (k-1)a+p)\to((k-1)a+p,a)\to(a,(k-2)a+p)\]</span></p><p>发现在三轮操作后，<span class="math inline">\(k\)</span> 减少了 <span class="math inline">\(2\)</span>。又因为我们只关心 <span class="math inline">\(d\bmod 3\)</span> 后的结果，于是 <span class="math inline">\((a,ka+p)\)</span> 和 <span class="math inline">\((a,(k-2)a+p)\)</span> 是等价的。进一步，奇偶性相同的 <span class="math inline">\(k\)</span> 都可以看作等价。我们仅取 <span class="math inline">\(k=0/1\)</span> 讨论即可。</p><ul><li><span class="math inline">\(k=1\)</span> 时，有 <span class="math inline">\((a,a+p)\to(a+p,p)\to(p,a)\)</span>。</li><li><span class="math inline">\(k=0\)</span> 时，就是 <span class="math inline">\((a,p)\)</span>。</li></ul><p>故以下递归成立： <span class="math display">\[d(a,ka+p)\to \begin{cases}2+d(p,a)&amp;,k \textbf{ 为奇数}\\ d(a,p) &amp;, k\textbf{ 为偶数}\end{cases}\]</span> 当 <span class="math inline">\(a\ge b\)</span> 时，同理取 <span class="math inline">\(a=kb+p\)</span>，<span class="math inline">\(p\in[0,b)\)</span>，则：</p><p><span class="math display">\[(kb+p,b)\to (b, (k-1)b+p)\to ((k-1)b+p, (k-2)b+p)\to ((k-2)b+p,b)\]</span></p><ul><li><span class="math inline">\(k=1\)</span> 时，有 <span class="math inline">\((b+p,b)\to(b,p)\)</span>。</li><li><span class="math inline">\(k=0\)</span> 时，就是 <span class="math inline">\((p,b)\)</span>。</li></ul><p>故以下递归成立： <span class="math display">\[d(kb+p,b)\to \begin{cases}1+d(b,p)&amp;,k \textbf{ 为奇数}\\ d(p,b) &amp;, k\textbf{ 为偶数}\end{cases}\]</span> 边界情况：<span class="math inline">\(d(0,*)=0\)</span>，<span class="math inline">\(d(*,0)=1\)</span>。</p><p>递归层数同辗转相除。时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p><h2 id="cf1848d.-vika-and-bonuses"><a href="https://codeforces.com/contest/1848/problem/D">CF1848D. Vika and Bonuses</a></h2><p>*2200 <a href="https://codeforces.com/contest/1848/submission/308650958">Code</a></p><p>按 <span class="math inline">\(t=s\bmod 10\)</span> 分类讨论。</p><ul><li>若 <span class="math inline">\(t=0\)</span>，操作二没有作用，答案是 <span class="math inline">\(sk\)</span>。</li><li>若 <span class="math inline">\(t=5\)</span>，最多进行一次操作二，答案是 <span class="math inline">\(\max(sk,(s+5)(k-1))\)</span>。</li><li>若 <span class="math inline">\(t=2,4,6,8\)</span>，注意到末尾有循环 <span class="math inline">\(2\to4\to 8\to6\to2\)</span>。每一轮循环 <span class="math inline">\(s\)</span> 增加 <span class="math inline">\(20\)</span>，枚举循环完整进行的次数 <span class="math inline">\(x\)</span>，贡献为 <span class="math inline">\((s+20x)(k-4x)\)</span>，这是一个二次函数，可以 <span class="math inline">\(O(1)\)</span> 求最大值。于是我们枚举最终 <span class="math inline">\(s\)</span> 末尾是 <span class="math inline">\(2,4,6,8\)</span> 的情况，对每种情况分别求答案再取 <span class="math inline">\(\max\)</span>。</li><li>若 <span class="math inline">\(t=1,3,7,9\)</span>，执行一次操作后就和上一种情况等同了。</li></ul><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><h2 id="cf1848f.-vika-and-wiki"><a href="https://codeforces.com/contest/1848/problem/F">CF1848F. Vika and Wiki</a></h2><p>*2400 <a href="https://codeforces.com/contest/1848/submission/308661424">Code</a></p><p>令 <span class="math inline">\(f_{i,j}\)</span> 表示进行 <span class="math inline">\(i\)</span> 次操作后 <span class="math inline">\(a_j\)</span> 的值。</p><p><span class="math display">\[\begin{align}&amp;f_0=\{a\} \\&amp;f_{1,i}=f_{0,i}\oplus f_{0,i+1}\\&amp;f_{2,i}=f_{1,i}\oplus f_{1,i+1}=(f_{0,i}\oplus f_{0,i+1})\oplus(f_{0,i+1}\oplus f_{0,i+2})=f_{0,i}\oplus f_{0,i+2}\\&amp;f_{3,i}=f_{2,i}\oplus f_{2,i+1}=(f_{0,i}\oplus f_{0,i+2})\oplus (f_{0,i+1}\oplus f_{0,i+3})\\&amp;f_{4,i}=f_{3,i}\oplus f_{3,i+1}=(f_{0,i}\oplus f_{0,i+1}\oplus f_{0,i+2}\oplus f_{0,i+3})\oplus (f_{0,i+1}\oplus f_{0,i+2}\oplus f_{0,i+3}\oplus f_{0,i+4})=f_{0,i}\oplus f_{0,i+4}\\\end{align}\]</span></p><p>非常 amazing 啊经过大力找规律，得到的结论是进行 <span class="math inline">\(2^k,k\in N^+\)</span> 次操作后，<span class="math inline">\(f_{2^k,i}=f_{0,i}\oplus f_{0,(i+2^k)\bmod n}\)</span>。</p><p>题目又保证 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(2\)</span> 的幂，故 <span class="math inline">\(n\)</span> 次操作后 <span class="math inline">\(\{a\}\)</span> 一定全 <span class="math inline">\(0\)</span>，没有无解的情况。</p><p>接着，又观察到若 <span class="math inline">\(\{a\}\)</span> 已经全 <span class="math inline">\(0\)</span>，再操作肯定也是全 <span class="math inline">\(0\)</span>，换句话说答案可以二分。</p><p>设二分出的答案是 <span class="math inline">\(x\)</span>，预处理对于 <span class="math inline">\(k\in[0,\log n]\)</span>，操作 <span class="math inline">\(2^k\)</span> 次后的数组，枚举 <span class="math inline">\(x\)</span> 的每一位大力操作即可。</p><p>更聪明的做法是倍增，令 <span class="math inline">\(i=\frac{n}{2},\frac{n}{4},\frac{n}{8},\ldots\)</span> ，对每个 <span class="math inline">\(i\)</span> 先令 <span class="math inline">\(\{b\}=\{a\}\)</span>，在 <span class="math inline">\(\{b\}\)</span> 上操作 <span class="math inline">\(i\)</span> 次，若操作后 <span class="math inline">\(\{b\}\)</span> 不全为 <span class="math inline">\(0\)</span>，说明答案比 <span class="math inline">\(i\)</span> 大，此时将答案累加上 <span class="math inline">\(i\)</span> 并把 <span class="math inline">\(\{b\}\)</span> 赋值给 <span class="math inline">\(\{a\}\)</span>。</p><p>时间复杂度前者 <span class="math inline">\(O(n\log^2 n)\)</span>，后者 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2070e.-game-with-binary-string"><a href="https://codeforces.com/contest/2070/problem/E">CF2070E. Game with Binary String</a></h2><p>*2200 <a href="https://codeforces.com/contest/2070/submission/308694558">Code</a></p><p>后手为了让 <span class="math inline">\(0\)</span> 尽可能少，一定是拿取相邻的一个 <span class="math inline">\(1\)</span> 和一个 <span class="math inline">\(0\)</span>。又因为序列是循环的，故若序列中存在至少一个 <span class="math inline">\(1\)</span> 和一个 <span class="math inline">\(0\)</span>，就肯定有相邻的 <span class="math inline">\(10\)</span> 或者 <span class="math inline">\(01\)</span>。</p><p>我们将这个游戏做一个转化：先手不必拿取相邻的两个 <span class="math inline">\(0\)</span>，而是序列中的任意两个 <span class="math inline">\(0\)</span>；同时后手也不必拿取相邻的 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(0\)</span>，而是序列中的任何一个 <span class="math inline">\(1\)</span> 以及任何一个 <span class="math inline">\(0\)</span>（若没有 <span class="math inline">\(0\)</span> 就是任意两个 <span class="math inline">\(1\)</span>）。</p><p>此时，在一个完整回合中，总计三个 <span class="math inline">\(0\)</span> 和一个 <span class="math inline">\(1\)</span> 被取走，我们不难想到按序列长度<span class="math inline">\(\bmod 4\)</span> 进行分类。记我们研究的序列长为 <span class="math inline">\(m\)</span>，用 <span class="math inline">\(c_{0/1}\)</span> 代表序列中 <span class="math inline">\(0/1\)</span> 的数量，手玩后得到如下结论。</p><ul><li>若 <span class="math inline">\(m\bmod 4=0\)</span>，先手赢得游戏当且仅当 <span class="math inline">\(c_0\ge 3c_1+1\)</span>。</li><li>若 <span class="math inline">\(m\bmod 4=1\)</span>，先手赢得游戏当且仅当 <span class="math inline">\(c_0\ge 3c_1+2\)</span>。</li><li>若 <span class="math inline">\(m\bmod 4=2\)</span>，先手赢得游戏当且仅当 <span class="math inline">\(c_0\ge 3c_1+2\)</span>。</li><li>若 <span class="math inline">\(m\bmod 4=3\)</span>，先手赢得游戏当且仅当 <span class="math inline">\(c_0\ge 3c_1-1\)</span>。</li></ul><p>其中 <span class="math inline">\(c_0\ge 3c_1+k_i\)</span> 这个 <span class="math inline">\(k_i\)</span> 并不唯一，如果你推出来其它的数值，也是对的。</p><p>接下来，可以断言：这个必胜条件对于原游戏仍然成立。</p><p>这看起来很违反直觉，因为后手虽然在原游戏中仍然能找到 <span class="math inline">\(0,1\)</span> 相邻，但先手不一定能找到两个相邻的 <span class="math inline">\(0\)</span>。</p><p>我们将这个 Claim 做一个等价转化：如果原问题（移除相邻字符）与转化后的游戏（移除任意位置字符）的胜负结果一致，那么当原问题中先手无法操作时，转化后的游戏中先手也一定会输。</p><p>而先手无法操作时，序列一定形如 <span class="math inline">\(0101\cdots0101\)</span>，即 <span class="math inline">\(c_1\ge c_0\)</span>，这个条件和上述四个先手必胜条件都相悖，因此先手必败。证毕。</p><p>原问题转化为求满足上述四个条件之一的子串有多少个。我们将序列中的 <span class="math inline">\(1\)</span> 看作 <span class="math inline">\(-3\)</span>，<span class="math inline">\(0\)</span> 看作 <span class="math inline">\(1\)</span> 求前缀和，条件 <span class="math inline">\(c_0\ge 3c_1+k_i\)</span> 便等价于区间和 <span class="math inline">\(\ge k_i\)</span>。</p><p>对<span class="math inline">\(\bmod 4\)</span> 相同的下标维护一个树状数组，每次到这四个树状数组里统计贡献。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1895c.-torn-lucky-ticket"><a href="https://codeforces.com/contest/1895/problem/C">CF1895C. Torn Lucky Ticket</a></h2><p>*1400 <a href="https://codeforces.com/contest/1895/submission/308826631">Code</a></p><p>上手直接蟒就容易写成一坨的题。（至少我是这样QAQ</p><p>这里给出一种优雅的解法。以下默认 0-index。</p><p>把数字看成字符串，记 <span class="math inline">\(f(i,j)\)</span> 代表第 <span class="math inline">\(i\)</span> 位到第 <span class="math inline">\(j\)</span> 位之间数位的和。</p><p>遍历每个串，设当前串长为 <span class="math inline">\(m\)</span>，<span class="math inline">\(\forall i\in[0,m)\)</span>，将二元组 <span class="math inline">\(\{f(0,i)-f(i+1,m-1),(i+1)-(m-i-1)\}\)</span> 记录进一个 <code>std::map</code> 中。</p><p>枚举每个串作为拼接左侧，能与它拼起来构成 pair 的字符串数等价于二元组 <span class="math inline">\(\{f(0,m-1),m\}\)</span> 和 <span class="math inline">\(\{-f(0,m-1),-m\}\)</span> 的数目和。</p><p>容易发现一个字符串既能做左侧合法拼接又能做右侧合法拼接的情况被规避掉了，计数不重不漏。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1895d.-xor-construction"><a href="https://codeforces.com/contest/1895/problem/D">CF1895D. XOR Construction</a></h2><p>*1900 <a href="https://codeforces.com/contest/1895/submission/308831646">Code</a></p><p>设 <span class="math inline">\(s_i=a_1\oplus a_2\oplus \cdots \oplus a_i\)</span>。</p><p>则 <span class="math inline">\(\forall i&gt;1\)</span>，<span class="math inline">\(b_i=b_{i-1}\oplus a_{i-1}=b_{i-2}\oplus a_{i-2}\oplus a_{i-1}=\cdots=b_1\oplus s_{i-1}\)</span>。</p><p>要让 <span class="math inline">\(b_i&lt;n\)</span>，就是让 <span class="math inline">\(\max\limits_{i\in[1,n]}(b_1\oplus s_{i-1})&lt;n\)</span>。</p><p>枚举 <span class="math inline">\(b_1\)</span>，用 trie 找到这个异或最大值，看它是否 <span class="math inline">\(&lt;n\)</span>。</p><p>因为单次判断是 <span class="math inline">\(\log\)</span> 级别的，从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(n-1\)</span> 暴力枚举就好。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><h2 id="cf1894d.-neutral-tonality"><a href="https://codeforces.com/contest/1894/problem/D">CF1894D. Neutral Tonality</a></h2><p>*1700 <a href="https://codeforces.com/contest/1894/submission/308865251">Code</a></p><p>依据 Dilworth 定理，<span class="math inline">\(\{b\}\)</span> 一定是排成降序最优，此时插进 <span class="math inline">\(\{a\}\)</span> 中最多让 LIS 长度 <span class="math inline">\(+1\)</span>。</p><p>我们只需尝试构造一种插入方式使得 LIS 长度尽可能不变。</p><p>贪心地想，对于当前 <span class="math inline">\(a_i\)</span>，可以将最小值 <span class="math inline">\(\ge a_i\)</span> 的一段下降序列插入到 <span class="math inline">\(a_i\)</span> 的前面，此时 LIS 长度一定不会增加。</p><p>维护一个双指针即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1894e.-freedom-of-choice"><a href="https://codeforces.com/contest/1894/problem/E">CF1894E. Freedom of Choice</a></h2><p>*2000 <a href="https://codeforces.com/contest/1894/submission/308868532">Code</a></p><p>设 <span class="math inline">\(L=\sum\limits_{i=1}^{m} l_i\)</span>，<span class="math inline">\(R =\sum\limits_{i=1}^{m} r_i\)</span>，<span class="math inline">\(N=\sum\limits_{i=1}^{m}n_i\)</span>。</p><p>断言：当 <span class="math inline">\(R-L+1&gt;N\)</span> 时，答案为 <span class="math inline">\(0\)</span>。</p><ul><li>根据 anti-beauty 的定义，一个 <span class="math inline">\(|X|\)</span> 对应一个 <span class="math inline">\(a_i\)</span>，而 <span class="math inline">\(a_i\)</span> 一共有 <span class="math inline">\(N\le 10^5\)</span> 种取值。当 <span class="math inline">\(|X|\)</span> 有 <span class="math inline">\(R-L+1&gt;N\)</span> 种取值时，由抽屉原理，一定存在一个 <span class="math inline">\(|X|\)</span> 没有 <span class="math inline">\(a_i\)</span> 与之对应，此时答案为 <span class="math inline">\(0\)</span>。</li></ul><p>否则我们可以 <span class="math inline">\(O(N)\)</span> 枚举 <span class="math inline">\(|X|\in [L,R]\)</span>，对于每一个 multiset，策略一定是 "若能不拿 <span class="math inline">\(|X|\)</span> 就不拿"。</p><p>具体地，初始化计数器 <span class="math inline">\(cnt=0\)</span>。对于当前 multiset，除了 <span class="math inline">\(|X|\)</span> 之外所有 <span class="math inline">\(a_i\)</span> 的 <span class="math inline">\(c_i\)</span> 之和为 <span class="math inline">\(s\)</span>，若 <span class="math inline">\(s&lt;l_i\)</span>，则有 <span class="math inline">\(l_i-s\)</span> 个 <span class="math inline">\(|X|\)</span> 是必须要拿的，令 <span class="math inline">\(cnt\leftarrow cnt+l_i-s\)</span> 且 <span class="math inline">\(s\leftarrow l_i\)</span>；否则 <span class="math inline">\(s=\min(s,r_i)\)</span>。将每个 multiset 的 <span class="math inline">\(s\)</span> 求和，设为 <span class="math inline">\(S\)</span>。</p><p>若 <span class="math inline">\(S\ge |X|\)</span>，说明我们只需支付必要的 <span class="math inline">\(cnt\)</span> 个 <span class="math inline">\(|X|\)</span> 就能满足要求，当前 <span class="math inline">\(|X|\)</span> 的答案就是 <span class="math inline">\(cnt\)</span>；否则，我们还需在 <span class="math inline">\(cnt\)</span> 的基础上支付额外的 <span class="math inline">\(|X|-S\)</span>。</p><p>当然，我们不能对每个 <span class="math inline">\(|X|\in[L,R]\)</span> 都枚举所有 <span class="math inline">\(m\)</span> 个 multisets。我们用一个 <code>std::map&lt;int, set&lt;int&gt;&gt;</code> 预处理出 <span class="math inline">\(|X|\)</span> 存在于哪些 multiset 中。此外还需要记录在每个 multiset 中 <span class="math inline">\(|X|\)</span> 的 <span class="math inline">\(c_i\)</span> 是多少。</p><p>时间复杂度 <span class="math inline">\(O(N\log N)\)</span>。</p><h2 id="cf2028d.-alices-adventures-in-cards"><a href="https://codeforces.com/contest/2028/problem/D">CF2028D. Alice's Adventures in Cards</a></h2><p>*2000 <a href="https://codeforces.com/contest/2028/submission/308902705">Code</a></p><p>Alice 能从第 <span class="math inline">\(i\)</span> 列移动到第 <span class="math inline">\(j\ (j&gt;i)\)</span> 列当且仅当 <span class="math inline">\(\exists k\in\{0,1,2\}\)</span>，<span class="math inline">\(a[k][j]&lt;a[k][i]\)</span>。</p><p>考虑从后向前枚举 <span class="math inline">\(i\)</span>，维护 <span class="math inline">\(dp[i]\)</span> 表示 Alice 能否从第 <span class="math inline">\(i\)</span> 列经过一系列移动到达第 <span class="math inline">\(n\)</span> 列。</p><p>为方便转移，令 <span class="math inline">\(\text{minp}[k]\)</span> 代表第 <span class="math inline">\(k\)</span> 行的当前后缀中 <span class="math inline">\(dp=1\)</span> 且值最小的元素的下标，那么 <span class="math inline">\(dp[i]=1\)</span> 当且仅当 <span class="math inline">\(\exists k\in \{0,1,2\}\)</span>，<span class="math inline">\(a[k][\text{minp}[k]]&lt;a[k][i]\)</span>。</p><p>同时若 <span class="math inline">\(dp[i]=1\)</span>，就 check 一下每一行的 <span class="math inline">\(\text{minp}\)</span> 能不能更新。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2028e.-alices-adventures-in-the-rabbit-hole"><a href="https://codeforces.com/contest/2028/problem/E">CF2028E. Alice's Adventures in the Rabbit Hole</a></h2><p>*2300 <a href="https://codeforces.com/contest/2028/submission/308910581">Code</a></p><p>令 <span class="math inline">\(f_x\)</span> 表示点 <span class="math inline">\(x\)</span> 的答案，由题 <span class="math inline">\(f_{1}=1\)</span>，<span class="math inline">\(f_{leaf}=0\)</span>。</p><p>每次轮到 Alice 操作肯定是向根节点走，轮到皇后操作肯定是前往距当前节点最近的叶子。</p><p>设当前研究的点为 <span class="math inline">\(x\)</span>，点 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 的儿子且在 <span class="math inline">\(x\)</span> 的所有儿子中离叶子最近，则： <span class="math display">\[f_x=\frac{1}{2}(f_{fa}+f_y)\]</span> 尝试待定系数，设 <span class="math inline">\(f_x=k_xf_{fa}+b_x\)</span>，代入。</p><p><span class="math display">\[\begin{align}f_x={\color{Red}k_x}f_{fa}+\color{Green}{b_x}&amp;=\frac{1}{2}(f_{fa}+f_y)\\&amp;=\dfrac{1}{2}(f_{fa}+k_yf_x+b_y)\\&amp;=\frac{1}{2}(f_{fa}+k_y(k_xf_{fa}+b_x)+b_y)\\&amp;=\frac{1}{2}((k_xk_y+1)f_{fa}+k_yb_x+b_y)\\&amp;={\color{Red}\frac{1}{2}(k_xk_y+1)}f_{fa}+{\color{Green}\frac{1}{2}(k_yb_x+b_y)}\end{align}\]</span></p><p>标红的两项对应相等，标绿的两项对应相等，解得： <span class="math display">\[k_x=\frac{1}{2-k_y}\qquad b_x=\frac{b_y}{2-k_y}\]</span> 又因叶子节点有 <span class="math inline">\(k_{leaf}=b_{leaf}=0\)</span>，根据 <span class="math inline">\(b_x\)</span> 递推式易知对于任意节点 <span class="math inline">\(b_x\)</span> 均为 <span class="math inline">\(0\)</span>。</p><p>用一遍 dfs 至下而上求出每个节点的 <span class="math inline">\(k_x\)</span>，再 dfs 一遍即可求出 <span class="math inline">\(f_x\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1820e.-the-fox-and-the-complete-tree-traversal"><a href="https://codeforces.com/contest/1820/problem/E">CF1820E. The Fox and the Complete Tree Traversal</a></h2><p>*2400 <a href="https://codeforces.com/contest/1820/submission/309151081">Code</a></p><p>萌萌性质题。手玩之后做出如下 Claim。</p><ul><li>能找到一个符合要求的回路当且仅当整棵树是一个毛毛虫（由一条主链和长度不超过 <span class="math inline">\(1\)</span> 的支链组成的结构）。而整棵树是毛毛虫时，直径显然可以充当主链。</li></ul><p>换句话说，<code>Yes</code> 当且仅当这棵树由直径和接在直径上的若干单点组成。</p><p>令 <span class="math inline">\(dp[x]\)</span> 代表 <span class="math inline">\(x\)</span> 的子树中以 <span class="math inline">\(x\)</span> 为毛毛虫的头的最大毛毛虫大小。转移是朴素的，最后只需判断这棵树的最大毛毛虫大小是否等于 <span class="math inline">\(n\)</span>。如果你不熟悉可以看一下 <span class="math inline">\(\to\)</span> <a href="https://www.luogu.com.cn/problem/P3174">Link</a>。</p><p>最后是构造方案。如下图构造即可（<span class="math inline">\(x,y\)</span> 是直径端点），其实就是看这个点在直径序列上下标的奇偶性。</p><p><img src="/image/academic/CF1820E.png" /></p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1982e.-number-of-k-good-subarrays"><a href="https://codeforces.com/contest/1982/problem/E">CF1982E. Number of k-good subarrays</a></h2><p>*2300 <a href="https://codeforces.com/contest/1982/submission/309161811">Code</a></p><p>设 <span class="math inline">\(f(x,y)\)</span> 代表 <span class="math inline">\(n=x,k=y\)</span> 时的答案，考虑分治： <span class="math display">\[f(n,k)\to f(m,k),f(n-m,k-1)\]</span> 其中 <span class="math inline">\(m=\text{bit}\underline{}\text{floor}(n)\)</span>。后一部分相当于把最 <span class="math inline">\(n\)</span> 最高位的 <span class="math inline">\(1\)</span> 拿掉，所以是 <span class="math inline">\(k-1\)</span>。</p><p>分治的时候对当前 <span class="math inline">\((n,k)\)</span> 返回一个三元组 <span class="math inline">\((l,r,ans)\)</span>，分别代表最大的 <span class="math inline">\(l\)</span> 满足 <span class="math inline">\([0,l)\)</span> 是 k-good 的，最小的 <span class="math inline">\(r\)</span> 满足 <span class="math inline">\([n-r,n)\)</span> 是 k-good 的，以及当前状态的答案。</p><p>合并的时候类似线段树维护前后缀，分情况讨论即可。</p><p>时间复杂度 <span class="math inline">\(O(t\log^2 n)\)</span>，其中一个 <span class="math inline">\(\log\)</span> 来自 <code>std::map</code> 的记忆化。</p><h2 id="cf1797e.-li-hua-and-array"><a href="https://codeforces.com/contest/1797/problem/E">CF1797E. Li Hua and Array</a></h2><p>*2300 <a href="https://codeforces.com/contest/1797/submission/309307708">Code</a></p><p>将值域内的所有 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(\varphi(x)\)</span> 连边（<span class="math inline">\(\varphi(x)\)</span> 是 <span class="math inline">\(x\)</span> 的父亲），构成一棵深度为 <span class="math inline">\(O(\log w)\)</span> 的树，根是 <span class="math inline">\(1\)</span>。</p><p>操作 <span class="math inline">\(1\)</span> 相当于让一段区间内的点同时跳向父亲，操作 <span class="math inline">\(2\)</span> 相当于求一段区间内的点的深度和，以及一段区间内所有点的 LCA 的深度。</p><p>对于操作 <span class="math inline">\(1\)</span>，因为树高是 <span class="math inline">\(\log\)</span> 级别，所以可以暴跳。若一个点跳到了 <span class="math inline">\(1\)</span>，它后面就不再跳了，故用双向链表维护非 <span class="math inline">\(1\)</span> 的节点。这样所有的操作 <span class="math inline">\(1\)</span> 复杂度之和不超过 <span class="math inline">\(O(n\log w)\)</span>。</p><p>对于操作 <span class="math inline">\(2\)</span>，因为我们采取暴跳，所以深度和是好维护的，每跳一步就用线段树对深度进行单点修改。最多修改 <span class="math inline">\(O(n\log w)\)</span> 次，故复杂度为 <span class="math inline">\(O(n\log n\log w)\)</span>。</p><p>最后一个问题就是如何快速求若干点的 LCA，有结论：</p><ul><li>一堆点的 LCA 等同于 "dfs 序最小点" 和 "dfs 序最大点" 的 LCA。</li></ul><p>还是用线段树维护一段区间里最小 dfn 和最大 dfn，这样就是单 <span class="math inline">\(\log\)</span> 的。</p><p>编码时要注意并不需要倍增求 LCA，暴跳求 LCA 就行了，因为空间限制不允许你倍增。</p><p>时间复杂度 <span class="math inline">\(O(w+n\log n\log w+m\log n)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><h2 id="cf1974g.-money-buys-less-happiness-now"><a href="https://codeforces.com/contest/1974/problem/G">CF1974G. Money Buys Less Happiness Now</a></h2><p>*2000 <a href="https://codeforces.com/contest/1974/submission/309608229">Code</a></p><p>非常经典的反悔贪心。契机是每次换取的幸福值是一样的，你只关心得到了多少，而不关心来自哪次交易。</p><p>用一个大根堆存储已经进行完交易的 <span class="math inline">\(c_i\)</span>，每次没钱时就把堆顶弹出来。</p><p>时间复杂度 <span class="math inline">\(O(m\log m)\)</span>。</p><h2 id="cf1797f.-li-hua-and-path"><a href="https://codeforces.com/contest/1797/problem/F">CF1797F. Li Hua and Path</a></h2><p>*3000 <a href="https://codeforces.com/contest/1797/submission/309616026">Code</a></p><p>这篇题解将会用到 Kruskal 点权多叉重构树。推荐前往 <a href="https://www.cnblogs.com/alex-wei/p/Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree.html">Link</a> 了解，如果你未曾接触过。</p><p>我们将树上的一对 pair <span class="math inline">\((u,v)\)</span> 分成三类，<span class="math inline">\(A\)</span> 类满足 <span class="math inline">\(u\)</span> 是 <span class="math inline">\(u\to v\)</span> 上的最小点，<span class="math inline">\(B\)</span> 类满足 <span class="math inline">\(v\)</span> 是 <span class="math inline">\(u\to v\)</span> 上的最大点，<span class="math inline">\(C\)</span> 类则同时满足 <span class="math inline">\(u\)</span> 是最小点且 <span class="math inline">\(v\)</span> 是最大点。简单容斥，答案是 <span class="math inline">\(|A|+|B|-2|C|\)</span>。</p><p>先考虑 <span class="math inline">\(A\)</span> 类路径的个数怎么求。求 <span class="math inline">\(A\)</span> 类本质上是对每一个点 <span class="math inline">\(i\)</span>，找从 <span class="math inline">\(i\)</span> 出发只经过编号大于等于 <span class="math inline">\(i\)</span> 的点能到达的点集大小。我们按点权从大到小的顺序建出原树的 Kruskal 点权多叉重构树（后文称为 <span class="math inline">\(A\)</span> 树），此时这棵树满足小根堆的性质，对于其上任意一点 <span class="math inline">\(x\)</span>，从 <span class="math inline">\(x\)</span> 出发能到达的点全在 <span class="math inline">\(x\)</span> 的子树中。因此 <span class="math inline">\(|A|=\sum\limits_{i=1}^{n}(sz_i-1)\)</span>。<span class="math inline">\(sz_i\)</span> 代表重构树上点 <span class="math inline">\(i\)</span> 的子树大小。</p><p>同理 <span class="math inline">\(B\)</span> 类路径就是按点权从小到大建树（称为 <span class="math inline">\(B\)</span> 树），这棵树满足大根堆的性质。</p><p>接着考虑 <span class="math inline">\(C\)</span> 类路径。一个 pair <span class="math inline">\((u,v)\)</span> 满足 <span class="math inline">\(C\)</span> 类当且仅当 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(A\)</span> 树上是 <span class="math inline">\(v\)</span> 的祖先，且 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(B\)</span> 树上是 <span class="math inline">\(v\)</span> 的子孙。容易将这个问题转化为子树加，利用树状数组维护。</p><p>最后考虑那 <span class="math inline">\(m\)</span> 次操作。注意到我们加的点的编号递增，这能引申出一系列良好的性质。</p><p>设新加的点编号为 <span class="math inline">\(x\)</span>，则 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(A\)</span> 树上一定是叶子，在 <span class="math inline">\(B\)</span> 树上一定是根。进一步，<span class="math inline">\(x\)</span> 对 <span class="math inline">\(A\)</span> 类的贡献就是它的深度（对每个祖先贡献 <span class="math inline">\(1\)</span> 的子树大小），对 <span class="math inline">\(B\)</span> 类的贡献就是加进去的时候整个 <span class="math inline">\(B\)</span> 树的大小（即 <span class="math inline">\(x-1\)</span>）。对于 <span class="math inline">\(C\)</span> 类，因为 <span class="math inline">\(x\)</span> 编号最大，只能作为 pair 的第二维，<span class="math inline">\((u,x)\)</span> 是 <span class="math inline">\(C\)</span> 类当且仅当 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(A\)</span> 树上是 <span class="math inline">\(x\)</span> 的祖先，且在 <span class="math inline">\(B\)</span> 树上是 <span class="math inline">\(x\)</span> 的子孙。换句话说 <span class="math inline">\(C\)</span> 类贡献与 <span class="math inline">\(A\)</span> 类相同，是 <span class="math inline">\(x\)</span> 的深度。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="abc396g.-flip-row-or-col"><a href="https://atcoder.jp/contests/abc396/tasks/abc396_g">abc396g. Flip Row or Col</a></h2><p><a href="https://atcoder.jp/contests/abc396/submissions/63615012">Code</a></p><p>对于一行来说，如果这一行有 <span class="math inline">\(c\)</span> 个 <span class="math inline">\(1\)</span>，我们肯定是调整至 <span class="math inline">\(\min(c,W-c)\)</span> 个 <span class="math inline">\(1\)</span>。</p><p>记 <span class="math inline">\(B_i\)</span> 代表第 <span class="math inline">\(i\)</span> 行对应的十进制数，枚举每一列是否翻转，答案是： <span class="math display">\[\min_{X=0}^{2^W-1}\sum_{i=0}^{H-1}\min(\text{popcount}(B_i\oplus X),W-\text{popcount}(B_i\oplus X))\]</span> 对于枚举的每一种列状态，时间复杂度不允许我们再枚举每一行，我们考虑对把 <span class="math inline">\(\text{popcount}(B_i\oplus X)\)</span> 相同的 <span class="math inline">\(i\)</span> 一起统计。</p><p>令 <span class="math inline">\(dp[X][c]\)</span> 代表满足 <span class="math inline">\(\text{popcount}(B_i\oplus X)=c\)</span> 的 <span class="math inline">\(i\)</span> 的数量，枚举 <span class="math inline">\(X,c\)</span> 以及 <span class="math inline">\(j\in[0,W)\to\)</span> 从状态 <span class="math inline">\(X\oplus 2^j\)</span> 转移过来。</p><p>答案是 <span class="math inline">\(\min\limits_{X=0}^{2^W-1}\sum\limits_{c=0}^{W}dp[X][c]\cdot\min(c,W-c)\)</span>。时间复杂度 <span class="math inline">\(O(W^22^W)\)</span>。</p><h2 id="cf2029e.-common-generator"><a href="https://codeforces.com/contest/2029/problem/E">CF2029E. Common Generator</a></h2><p>*2100 <a href="https://codeforces.com/contest/2029/submission/309724863">Code</a></p><p><strong>Claim 1.</strong> <span class="math inline">\(2\)</span> 能生成所有的合数。</p><ul><li>首先，<span class="math inline">\(2\)</span> 的倍数显然可以合成。否则假设当前合数为 <span class="math inline">\(x\)</span>，<span class="math inline">\(x\)</span> 一定可以表示成 <span class="math inline">\(x=pq\)</span>，其中 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(x\)</span> 的最小质因数且 <span class="math inline">\(p\ge 3,q&gt;1\)</span>。又 <span class="math inline">\(pq\)</span> 可以由 <span class="math inline">\((p-1)q\)</span> 合成，而 <span class="math inline">\(p-1\)</span> 是偶数，偶数可以由 <span class="math inline">\(2\)</span> 生成，故 <span class="math inline">\(x=pq\)</span> 可以由 <span class="math inline">\(2\)</span> 生成。</li></ul><p><strong>Claim 2. </strong> 质数只能由它自己生成。（显然，不证了）</p><p>至此我们扫一遍 <span class="math inline">\(\{a\}\)</span>，若没有质数，答案是 <span class="math inline">\(2\)</span>；若有不同的质数，无解。</p><p>否则设唯一质数为 <span class="math inline">\(p\)</span>，我们只用考虑 <span class="math inline">\(p\)</span> 能否生成 <span class="math inline">\(\{a\}\)</span> 中剩下的所有数。</p><p><strong>Claim 3. </strong> <span class="math inline">\(p\)</span> 能生成偶数 <span class="math inline">\(x\)</span> 当且仅当 <span class="math inline">\(x\ge 2p\)</span>。</p><ul><li>因为 <span class="math inline">\(p\)</span> 第一步只能变成 <span class="math inline">\(2p\)</span>，<span class="math inline">\(2p\)</span> 又是偶数。之后一直 <span class="math inline">\(+2\)</span> 得到所有 <span class="math inline">\(\ge 2p\)</span> 的偶数。</li></ul><p><strong>Claim4. </strong> <span class="math inline">\(p\)</span> 能生成奇合数 <span class="math inline">\(x\)</span> 当且仅当 <span class="math inline">\(x-\text{minp}_x\ge 2p\)</span>，其中 <span class="math inline">\(\text{minp}_x\)</span> 是 <span class="math inline">\(x\)</span> 的最小质因数。</p><ul><li><span class="math inline">\(x-\text{minp}_x\)</span> 是最大的 <span class="math inline">\(&lt; x\)</span> 的偶数。若 <span class="math inline">\(x-\text{minp}_x &lt; 2p\)</span>，即最大的能生成 <span class="math inline">\(x\)</span> 的偶数都无法生成，自然无解。</li></ul><p>素数和最小质因数都能线性筛，这样每组数据就是线性的。</p><p>时间复杂度 <span class="math inline">\(O(w+n)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><h2 id="arc194c.-cost-to-flip"><a href="https://atcoder.jp/contests/arc194/tasks/arc194_c">arc194c. Cost to Flip</a></h2><p><a href="https://atcoder.jp/contests/arc194/submissions/63650748">Code</a></p><p>用二元组 <span class="math inline">\((x,y)\)</span> 代表状态 <span class="math inline">\(A_i=x,B_i=y\)</span>。首先 <span class="math inline">\((0,1)\)</span> 和 <span class="math inline">\((1, 0)\)</span> 是无可避免的，<span class="math inline">\((0,0)\)</span> 不用动，<span class="math inline">\((1,1)\)</span> 既可以选择不动也可以选择 <span class="math inline">\(1\to 0\)</span> 再 <span class="math inline">\(0\to 1\)</span>。</p><p>依据贪心原则，满足状态 <span class="math inline">\((1, 0)\)</span> 的列肯定是按 <span class="math inline">\(c_i\)</span> 从大到小进行操作，满足状态 <span class="math inline">\((0,1)\)</span> 的列肯定是按 <span class="math inline">\(c_i\)</span> 从小到大进行操作。此外，对于状态 <span class="math inline">\((1, 1)\)</span>，也一定存在一个阈值 <span class="math inline">\(W\)</span>，使得 <span class="math inline">\(C_i\le W\)</span> 的列选择不动，<span class="math inline">\(C_i&gt;W\)</span> 的列选择 <span class="math inline">\(1\to 0\)</span> 再 <span class="math inline">\(0\to 1\)</span>。</p><p>我们考虑从小到大枚举这个阈值，列出式子并观察增量有何变化。</p><p>所有 <span class="math inline">\((1,1)\)</span> 选择不动时，有： <span class="math display">\[ans=\sum_{p=1}^{X}(p-1)C_{ip}+\sum_{p=1}^{Y}pC_{jp}+(X+Y)\sum_{p=1}^{Z}C_{kp}\]</span> 其中 <span class="math inline">\(C_{i1}\ge C_{i2}\ge C_{i3}\ge \ldots\ge C_{iX}\)</span> 代表满足状态 <span class="math inline">\((1,0)\)</span> 的 <span class="math inline">\(C\)</span>，<span class="math inline">\(C_{j1}\ge C_{j2}\ge C_{j3}\ge \ldots\ge C_{jY}\)</span> 代表满足状态 <span class="math inline">\((0, 1)\)</span> 的 <span class="math inline">\(C\)</span>，<span class="math inline">\(C_{k1},C_{k2},\ldots,C_{kZ}\)</span> 则代表满足状态 <span class="math inline">\((1, 1)\)</span> 的 <span class="math inline">\(C\)</span>。</p><p>选中一个状态 <span class="math inline">\((1,1)\)</span> 进行操作时，设对应的 <span class="math inline">\(C\)</span> 为 <span class="math inline">\(C_x\)</span>，最后一项会变成 <span class="math inline">\((X+Y+2)\left(\sum C_{kp}-C_x\right)\)</span>。</p><p>对于前面两项，拿第一项举例。操作前： <span class="math display">\[0\cdot C_{i1}+1\cdot C_{i2}+2\cdot C_{i3}+3\cdot C_{i4}+ 4\cdot C_{i5}+5\cdot C_{i6}\]</span> 将 <span class="math inline">\(C_x\)</span> 插入后： <span class="math display">\[0\cdot C_{i1}+1\cdot C_{i2}+2\cdot C_{i3}+{\color{Green}3\cdot C_{x}}+{\color{Red}4}\cdot C_{i4}+ {\color{Red}5}\cdot C_{i5}+{\color{Red}6}\cdot C_{i6}\]</span> 插入的位置可以二分出来，增量则是一段后缀。</p><p>但这并不意味着需要动态维护后缀和，因为我们插入的 <span class="math inline">\(C_x\)</span> 递减，每次插入的位置一定在之前的 <span class="math inline">\(C_x\)</span> 之后。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="arc194d.-reverse-brackets"><a href="https://atcoder.jp/contests/arc194/tasks/arc194_d">arc194d. Reverse Brackets</a></h2><p><a href="https://atcoder.jp/contests/arc194/submissions/63655541">Code</a></p><p>建出括号树（包括虚根），一次操作相当于选定一个点 <span class="math inline">\(x\)</span>（设 <span class="math inline">\(x\)</span> 的儿子按原序列顺序依次是 <span class="math inline">\(y_1,y_2,y_3,\ldots\)</span>），接着选定一个区间 <span class="math inline">\([l,r]\)</span>，将 <span class="math inline">\(y_l,y_{l+1},\ldots,y_r\)</span> 连带它们的子树翻转。</p><p>不难发现如此操作能任意排列一个点的儿子。</p><p>接着就是数树的形态了。我们把同构的两棵子树用相同的数字表示，对于一个点来说，将以它所有儿子为根的子树代表的数字排成序列，方案数相当于重排这个序列能得到的本质不同的序列数量。</p><p>使用树哈希容易做到 <span class="math inline">\(O(n\log n)\)</span> 或 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2071f.-towering-arrays"><a href="https://codeforces.com/contest/2071/problem/F">CF2071F. Towering Arrays</a></h2><p>*2700 <a href="https://codeforces.com/contest/2071/submission/310224979">Code</a></p><p>题外话：时限 6s，拼尽全力卡常喜提 5999ms。上面代码放的是没有刻意卡常的版本，clone 下来跑了 7s。</p><p>二分答案，设二分出的答案是 <span class="math inline">\(p\)</span>，我们就要找到最长的 <span class="math inline">\(p-towering\)</span> 序列的长度 <span class="math inline">\(m\)</span>，判断是否 <span class="math inline">\(n-m\le k\)</span>。</p><p>考虑遍历序列上的每一个位置 <span class="math inline">\(i\)</span>，check <span class="math inline">\(a_i\)</span> 是否能作为 <span class="math inline">\(p-towering\)</span> 序列的最高点。此时 <span class="math inline">\(a_i\)</span> 两侧延伸出去的长度独立，我们可以只考虑一边，然后把序列 reverse 做另一边。</p><p>现在的问题是对于每一个 <span class="math inline">\(i\)</span>，求序列 <span class="math inline">\(a_1\sim a_i\)</span> 中以 <span class="math inline">\(a_i\)</span> 结尾的最长的子序列 <span class="math inline">\(\{s\}\)</span>，满足 <span class="math inline">\(s\)</span> 最后一个元素 <span class="math inline">\(\ge p\)</span>，倒数第二个元素 <span class="math inline">\(\ge p-1\)</span>，倒数第三个元素 <span class="math inline">\(\ge p-2\)</span>，<span class="math inline">\(\ldots\)</span></p><p>结论：若 <span class="math inline">\(a_{i}\ge p\)</span>，对于任意满足 <span class="math inline">\(j&lt;i\)</span> 且 <span class="math inline">\(a_j\ge p\)</span> 的 <span class="math inline">\(j\)</span>，序列 <span class="math inline">\(a_1\sim a_i\)</span> 构造出的 <span class="math inline">\(\{s\}\)</span> 一定完全包含序列 <span class="math inline">\(a_1\sim a_{j}\)</span> 构造出的 <span class="math inline">\(\{s\}\)</span> 中的元素。换句话说随着 <span class="math inline">\(i\)</span> 增加，我们一定只是在 <span class="math inline">\(\{s\}\)</span> 的末尾添加元素。</p><ul><li>当我们把 <span class="math inline">\(a_i\)</span> 加进 <span class="math inline">\(\{s\}\)</span> 后，<span class="math inline">\(\{s\}\)</span> 中倒数第 <span class="math inline">\(i\)</span> 个元素要求 <span class="math inline">\(\ge p-i+1\)</span>，而在原来的 <span class="math inline">\(\{s\}\)</span> 中倒数第 <span class="math inline">\(i-1\)</span> 个元素满足 <span class="math inline">\(\ge p-i+2\)</span>。故得证。</li></ul><p>一个使用线段树维护 <span class="math inline">\(\{s\}\)</span> 最长长度的流程是：</p><ol type="1"><li>按顺序扫描序列，对于当前 <span class="math inline">\(i\)</span>，给线段树上第 <span class="math inline">\(i\)</span> 个位置赋值 <span class="math inline">\(p-a_i\)</span>。</li><li>找到 <span class="math inline">\(1\sim i\)</span> 中最后一个值 <span class="math inline">\(\le0\)</span> 的位置，设下标为 <span class="math inline">\(t\)</span>。将 <span class="math inline">\(a_t\)</span> 加进 <span class="math inline">\(\{s\}\)</span> 中，并给线段树上 <span class="math inline">\(1\sim t\)</span> 这段前缀 <span class="math inline">\(-1\)</span>。（多一个元素自然前面的元素限制 <span class="math inline">\(-1\)</span>）</li><li>将位置 <span class="math inline">\(t\)</span> 设为 <span class="math inline">\(+\infty\)</span>。（保证已经选中的之后不再选中）</li><li>重复步骤 <span class="math inline">\(2,3\)</span> 直到找不到值 <span class="math inline">\(\le 0\)</span> 的位置。此时 <span class="math inline">\(\{s\}\)</span> 中元素个数即为当前 <span class="math inline">\(i\)</span> 的答案。</li></ol><p>时间复杂度 <span class="math inline">\(O(n\log n\log w)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><h2 id="cf2074g.-game-with-triangles-season-2"><a href="https://codeforces.com/contest/2074/problem/G">CF2074G. Game With Triangles: Season 2</a></h2><p>*2100 <a href="https://codeforces.com/contest/2074/submission/310276404">Code</a></p><p>区间 dp。拆环成链，记 <span class="math inline">\(dp[L][R]\)</span> 为区间 <span class="math inline">\([L,R]\)</span> 的答案。</p><p>从小到大枚举长度，对于当前 <span class="math inline">\([L,R]\)</span>，枚举 <span class="math inline">\(k\in[L+1,R-1]\)</span> 让 <span class="math inline">\(L,k,R\)</span> 成为三角形的三个顶点。 <span class="math display">\[dp[L][R]=\max_{k\in(L,R)}(dp[L+1][k-1]+dp[k+1][R-1]+a_L\cdot a_k\cdot a_R)\]</span> 别忘了还有区间 dp 的定义式： <span class="math display">\[dp[L][R]=\max_{k\in[L,R)}(dp[L][k]+dp[k+1][R])\]</span> 时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="cf1994d.-funny-game"><a href="https://codeforces.com/contest/1994/problem/D">CF1994D. Funny Game</a></h2><p>*1900 <a href="https://codeforces.com/contest/1994/submission/310362959">Code</a></p><p>我们只关心连哪些边，而不关心连边的顺序。</p><p>按 <span class="math inline">\(x\)</span> 从大到小考虑，我们每次将选出的两个点用并查集连起来，这样每次操作后连通块个数 <span class="math inline">\(-1\)</span>。</p><p>第一次操作，要找到两个点 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\(|a_u-a_v|=n-1\)</span>，换个写法就是 <span class="math inline">\(a_u\equiv a_v\pmod{n-1}\)</span>。此时图上有 <span class="math inline">\(n\)</span> 个连通块，从每个连通块里任选一个点，就是 <span class="math inline">\(n\)</span> 个点。根据鸽笼原理，这 <span class="math inline">\(n\)</span> 个点里一定存在一对 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\(a_u\equiv a_v\pmod{n-1}\)</span>。</p><p>第二次操作，要找到两个点 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\(a_u\equiv a_v\pmod{n-2}\)</span>。此时图上有 <span class="math inline">\(n-1\)</span> 个连通块，从每个连通块里任选一个点，就是 <span class="math inline">\(n-1\)</span> 个点。根据鸽笼原理，这 <span class="math inline">\(n-1\)</span> 个点里也一定存在一对 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\(a_u\equiv a_v\pmod{n-2}\)</span>。</p><p>第三次操作，<span class="math inline">\(\ldots\)</span></p><p>综上，本题一定有解，按照上述流程构造一个即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="cf1994f.-stardew-valley"><a href="https://codeforces.com/contest/1994/problem/F">CF1994F. Stardew Valley</a></h2><p>*2500 <a href="https://codeforces.com/contest/1994/submission/310403549">Code</a></p><p>把有 NPC 的边称为 <span class="math inline">\(1\)</span> 边，否则称为 <span class="math inline">\(0\)</span> 边。</p><p>我们要找到一条经过每条 <span class="math inline">\(1\)</span> 边恰好一次的回路。可以将该问题转化为选择一些 <span class="math inline">\(0\)</span> 边删掉，使得图中所有点的度均为偶数，这样我们只用跑一遍欧拉回路就行。</p><p>当我们删除一条边时，如果两个端点原来都是奇度点，那么图中奇度点个数 <span class="math inline">\(-2\)</span>；如果两个端点原来度数一奇一偶，那么图中奇度点个数不变。</p><p>于是，建出一个只有 <span class="math inline">\(0\)</span> 边的图，<code>YES</code> 的充要条件就是对于图中每个连通分量，奇度点个数均为偶数。</p><p>一个较好的实现是：对每个连通分量 dfs，在 dfs 生成树上至下而上贪心地删边，若删到根后根是奇度点，就是 <code>NO</code>。这样删哪条边也顺便记录了。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2049f.-mex-or-mania"><a href="https://codeforces.com/contest/2049/problem/F">CF2049F. MEX OR Mania</a></h2><p>*2700 <a href="https://codeforces.com/contest/2049/submission/310513955">Code</a></p><p>由 <span class="math inline">\(\text{mex} \le \text{max}+1\le \text{or}+1\)</span>，题目条件成立当且仅当这两个不等号同时取等。</p><p><span class="math inline">\(\text{mex}=\max +1\)</span> 当且仅当序列包含了 <span class="math inline">\(0\sim \max\)</span> 中的所有数，<span class="math inline">\(\text{or}=\max\)</span> 当且仅当序列中的数在二进制下是 <span class="math inline">\(\max\)</span> 的子集。同时取等意味着这个序列包含了 <span class="math inline">\(0\sim 2^k-1\)</span> 中的所有数，<span class="math inline">\(k\in N\)</span>。</p><p>我们不妨枚举每个 <span class="math inline">\(k\)</span>，判断是否存在一段区间包含了 <span class="math inline">\(0\sim 2^k-1\)</span> 中的所有数，且不包含 <span class="math inline">\(\ge 2^k\)</span> 的数。</p><p>在不考虑修改的情况下，我们可以把 <span class="math inline">\(&lt;2^k\)</span> 的数用并查集连在一起，然后用一个 <code>unordered_map</code> 维护这个连通块不同的数的个数。若不同的数的个数恰好是 <span class="math inline">\(2^k\)</span>，就说明这个连通块是符合条件的。</p><p>接下来我们面临 <span class="math inline">\(q\)</span> 次单点加，当区间里的一个数超出了 <span class="math inline">\(2^k-1\)</span>，这个区间就会分成两个子区间，这是不好处理的。</p><p>于是考虑离线，倒着操作序列，变成单点减。我们依旧是对每个 <span class="math inline">\(k\)</span> 维护一个并查集，将 <span class="math inline">\(&lt; 2^k\)</span> 的数连在一起，这样每次只用考虑是否可以将被操作的位置的两端合并成一个大区间。若可以，就启发式合并，将小的那一段区间 <code>unordered_map</code> 记录的信息合并到大的那一段区间来。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="cf2078g.-another-folding-strip"><a href="https://codeforces.com/contest/2078/problem/G">CF2078G. Another Folding Strip</a></h2><p>*2700 <a href="https://codeforces.com/contest/2078/submission/310973326">Code</a></p><p>两个格子通过折叠能一上一下挨着当且仅当这两个格子的下标之差为奇数。</p><p>换句话说，一次操作相当于选择一组下标序列 <span class="math inline">\(i_1,i_2,i_3,\ldots\)</span>，其中 <span class="math inline">\(\forall k &gt; 0\)</span>，<span class="math inline">\(i_{k}\)</span> 与 <span class="math inline">\(i_{k+1}\)</span> 奇偶性不同，然后使这些位置上的值 <span class="math inline">\(+1\)</span>。</p><p>倒着考虑，每次让一组下标序列对应位置上的值 <span class="math inline">\(-1\)</span>，问将 <span class="math inline">\(\{a\}\)</span> 变成全 <span class="math inline">\(0\)</span> 序列的最小操作次数。</p><p>对序列进行黑白染色：<span class="math inline">\(\forall i\in[1,n]\)</span>，令 <span class="math inline">\(b_i=(-1)^ia_i\)</span>。</p><p>令一次操作后的 <span class="math inline">\(\{b\}\)</span> 为 <span class="math inline">\(\{b&#39;\}\)</span>，一个很强的性质是对于 <span class="math inline">\(1\sim n\)</span> 上任意一个区间 <span class="math inline">\([l,r]\)</span>，有 <span class="math inline">\(\left|\sum\limits_{i=l}^{r}b&#39;_i-\sum\limits_{i=l}^{r}b_i\right| \le 1\)</span>。</p><p>这意味着若 <span class="math inline">\(\{b\}\)</span> 上存在一个和为 <span class="math inline">\(k\)</span> 的子段，那么这个子段至少要进行 <span class="math inline">\(|k|\)</span> 次操作才能变为全 <span class="math inline">\(0\)</span>。</p><p>故 <span class="math inline">\(f(a_1a_2\ldots a_n)\)</span> 的下界是 <span class="math inline">\(\max\limits_{1\le l\le r\le n}\left|\sum\limits_{i=l}^{r}b_i\right|\)</span>。事实上能够证明该下界可达，具体见官方题解。（毕竟下标序列的选择条件是相当宽松的，退一步写一个 <span class="math inline">\(O(n^2)\)</span> 检验样例也很容易，这里就不证了）</p><p>令 <span class="math inline">\(pre_i=\sum\limits_{j=1}^{i}b_j\)</span>，式子变成 <span class="math inline">\(\max\limits_{1\le l\le r\le n}\left|pre_r-pre_{l-1}\right|\)</span>，即 <span class="math inline">\(\{pre\}\)</span> 的极差。</p><p>原问题转化为求 <span class="math inline">\(\{b\}\)</span> 所有连续子序列的极差之和。枚举一个数作为极大值/极小值占领的区间，单调栈或线段树均可做。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span> 或 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2082f.-mst-in-modulo-graph"><a href="https://codeforces.com/contest/2082/problem/F">CF2082F. MST in Modulo Graph</a></h2><p>*2600 <a href="https://codeforces.com/contest/2082/submission/311029035">Code</a></p><p>对每一个 <span class="math inline">\(p_i\)</span>，枚举 <span class="math inline">\(k=p_i,2p_i,3p_i,\ldots\)</span>，再二分出第一个 <span class="math inline">\(\ge k\)</span> 的 <span class="math inline">\(p_j\)</span>。将这对 <span class="math inline">\((i,j)\)</span> 放进候选表里。</p><p>此时对于 <span class="math inline">\(p_i\)</span> 来说，<span class="math inline">\(p_j\bmod p_i\)</span> 最小的 <span class="math inline">\(p_j\)</span> 一定在候选表中。</p><p>最终我们会有 <span class="math inline">\(O(n\log n)\)</span> 条候选边（调和级数效应）。用这些边跑最小生成树即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="cf2075d.-equalization"><a href="https://codeforces.com/contest/2075/problem/D">CF2075D. Equalization</a></h2><p>*2000 <a href="https://codeforces.com/contest/2075/submission/311292632">Code</a></p><p>每次操作相当于将二进制下的 <span class="math inline">\(x\)</span> 或 <span class="math inline">\(y\)</span> 右移一定位数。</p><p>假若我们确定了最优答案中 <span class="math inline">\(x\)</span> 右移了 <span class="math inline">\(k_1\)</span> 位，<span class="math inline">\(y\)</span> 右移了 <span class="math inline">\(k_2\)</span> 位，该如何计算最小操作次数？</p><p>将一次花费 <span class="math inline">\(2^k\)</span> 的操作看作一个物品，这个物品的体积是 <span class="math inline">\(k\)</span>，价值是 <span class="math inline">\(2^k\)</span>，且每个物品至多被选一次。</p><p>也就是说这是一个 <span class="math inline">\(01\)</span> 背包问题，而且是两个背包，容量分别为 <span class="math inline">\(k_1\)</span> 与 <span class="math inline">\(k_2\)</span>。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 为两个背包分别塞了 <span class="math inline">\(i\)</span> 体积和 <span class="math inline">\(j\)</span> 体积东西时的选取物品的最小价值。</p><ul><li>初态：<span class="math inline">\(dp[i][j]=\begin{cases}0&amp;,i=0\cap j=0\\ \infty &amp;,\text{otherwise}\end{cases}\)</span></li><li>转移：<span class="math inline">\(dp[i][j]=\min\limits_{1\le k\le 60}\begin{cases}dp[i-k][j]+2^k &amp;,k\le i\\ dp[i][j-k]+2^k &amp;,k\le j\end{cases}\)</span></li><li>答案：<span class="math inline">\(dp[k_1][k_2]\)</span>。</li></ul><p>但事实上 <span class="math inline">\(k_1\)</span> 和 <span class="math inline">\(k_2\)</span> 并不能贪心地确定。</p><p>正确的做法是枚举所有 "<span class="math inline">\(x\)</span> 右移 <span class="math inline">\(k_1\)</span> 位 <span class="math inline">\(=\)</span> <span class="math inline">\(y\)</span> 右移 <span class="math inline">\(k_2\)</span> 位" 的 <span class="math inline">\(k_1\)</span> 与 <span class="math inline">\(k_2\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(\log^3w)-O(\log^2 w)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p><h2 id="cf1808d.-petya-petya-petr-and-palindromes"><a href="https://codeforces.com/contest/1808/problem/D">CF1808D. Petya, Petya, Petr, and Palindromes</a></h2><p>*2100 <a href="https://codeforces.com/contest/1808/submission/311347398">Code</a></p><p>正难则反，用总和减去相等数对造成的贡献得到答案。</p><p>所有长为 <span class="math inline">\(k\)</span> 的子串的 palindromicity 之和为 <span class="math inline">\(\lfloor\frac{k}{2}\rfloor(n-k+1)\)</span>。</p><p>考虑满足 <span class="math inline">\(a_i=a_j\)</span> 的一对 <span class="math inline">\((i,j)(i&lt;j)\)</span>，这对 <span class="math inline">\((i,j)\)</span> 能造成 <span class="math inline">\(1\)</span> 的贡献当且仅当：</p><ul><li><p><span class="math inline">\(i\bmod 2=j\bmod 2\)</span>；</p></li><li><p><span class="math inline">\(j-i+1\le k\)</span>；</p></li><li><p><span class="math inline">\(i-\frac{k-(j-i+1)}{2}\ge 1\)</span>；</p></li><li><p><span class="math inline">\(j+\frac{k-(j-i+1)}{2}\le n\)</span>。</p></li></ul><p>解得 <span class="math inline">\(j\in [\max(i+1,k+1-i),\min(n,i+k-1,2n-k-i+1)]\)</span>。</p><p>将 <span class="math inline">\(\{a\}\)</span> 按照下标奇偶分成两个数组。对每个数组 <span class="math inline">\(\{b\}\)</span>，枚举 <span class="math inline">\(i\)</span>，二分出上述区间里有多少个 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(b_i=b_j\)</span>，计入贡献。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1808e1e2.-minibuses-on-venus"><a href="https://codeforces.com/contest/1808/problem/E1">CF1808E1/E2. Minibuses on Venus</a></h2><p>*2200 <a href="https://codeforces.com/contest/1808/submission/311374162">Code</a>（E1）</p><p>*2500 <a href="https://codeforces.com/contest/1808/submission/311387002">Code</a>（E2）</p><p>将 <span class="math inline">\(n\)</span> 个数位看成一个长为 <span class="math inline">\(n\)</span> 的数列 <span class="math inline">\(\{a\}\)</span>，每个元素的取值是 <span class="math inline">\([0,k)\)</span>。</p><p>一个数列满足条件当且仅当 <span class="math inline">\(\exists i\in[1,n]\)</span>，<span class="math inline">\(a_i\equiv a_1+a_2+\ldots+a_{i-1}+a_{i+1}+\ldots a_n\pmod{k}\)</span>。</p><p>令 <span class="math inline">\(S=\sum\limits_{i=1}^{n}a_i\)</span>，则改写为 <span class="math inline">\(a_i\equiv S-a_i\pmod {k}\)</span>，也就是 <span class="math inline">\(2a_i\equiv S\pmod {k}\)</span>。</p><p>容斥，用总方案数 <span class="math inline">\(k^n\)</span> 减去 <span class="math inline">\(\forall i\in[1,n]\)</span>，<span class="math inline">\(2a_i\not\equiv S\pmod {k}\)</span> 的 <span class="math inline">\(\{a\}\)</span> 的数量。</p><p>当我们每次往 <span class="math inline">\(\{a\}\)</span> 里添一个数时，<span class="math inline">\(S\)</span> 会动态变化。但<span class="math inline">\(\bmod k\)</span> 下 <span class="math inline">\(S\)</span> 只有 <span class="math inline">\(k\)</span> 种取值，所以我们可以枚举 <span class="math inline">\(S\)</span>。</p><p>对于一个固定的 <span class="math inline">\(S\)</span>，满足条件的序列数量可以用动态规划求解。</p><p>令 <span class="math inline">\(dp_{i,j}\)</span> 表示已经填了前 <span class="math inline">\(i\)</span> 个数，这 <span class="math inline">\(i\)</span> 个数和为 <span class="math inline">\(j\)</span> 的方案数。</p><ul><li><p>初态：<span class="math inline">\(dp_{0,0}=1\)</span>；</p></li><li><p>转移：<span class="math inline">\(\forall x\in [0,k),\forall j\in[0,k),2x\not\equiv S\pmod {k}\)</span>，<span class="math inline">\(dp_{i,(j+x)\bmod k}=dp_{i,(j+x)\bmod{k}}+dp_{i-1,j}\)</span>；</p></li><li><p>答案：<span class="math inline">\(dp_{n,S}\)</span>。</p></li></ul><p>时间复杂度 <span class="math inline">\(O(nk^3)\)</span>，可以通过 E1。</p><p>这个转移看起来就很矩阵，于是令矩阵 <span class="math inline">\(A_{i,(i+j)\bmod k}=[2j\not\equiv S\pmod{k}]\)</span>，则： <span class="math display">\[[dp_{i,0},dp_{i,1},\cdots,dp_{i,k-1}]\times A=[dp_{i+1,0},dp_{i+1, 1},\cdots,dp_{i+1,k-1}]\]</span></p><ul><li>初态：<span class="math inline">\(dp_0=[1,0,0,\cdots,0]\)</span>；</li><li>答案：<span class="math inline">\(dp_{0}\times A^{n}\)</span> 的第 <span class="math inline">\(S\)</span> 项。</li></ul><p>矩阵快速幂是 <span class="math inline">\(O(k^3\log n)\)</span>，加上枚举 <span class="math inline">\(S\)</span>，就是 <span class="math inline">\(O(k^4\log n)\)</span> ，并不能通过 E2。<a href="https://codeforces.com/contest/1808/submission/311376877">Code</a></p><p>但注意到 <span class="math inline">\(A\)</span> 是一个循环矩阵（每一行都是上一行的循环右移），这意味着我们可以把 <span class="math inline">\(dp_{i,0}\sim dp_{i,k-1}\)</span> 看成多项式的系数，用循环卷积去优化它。</p><p>具体地，定义多项式 <span class="math inline">\(f_i(x) = dp_{i,0}\cdot x^0+dp_{i,1}\cdot x^1+\cdots+dp_{i,k-1}\cdot x^{k-1}\)</span>。</p><p>转移多项式 <span class="math inline">\(G(x)\)</span> 取 <span class="math inline">\(A\)</span> 的第一行，也就是 <span class="math inline">\([x^i]G(x)=[2i\not\equiv S\pmod{k}]\)</span>。</p><p>答案即 <span class="math inline">\([x^S](f_0\times G^n(x))\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(k^3\log n)\)</span>，如果会 FFT 能做到 <span class="math inline">\(O(k^2\log n)\)</span>。能吗？反正我不会QAQ。</p><h2 id="abc397g.-maximize-distance"><a href="https://atcoder.jp/contests/abc397/tasks/abc397_g">abc397g. Maximize Distance</a></h2><p><a href="https://atcoder.jp/contests/abc397/submissions/63932043">Code</a></p><p>二分答案，设二分出的答案是 <span class="math inline">\(d\)</span>，那么需要判定让 <span class="math inline">\(1\to n\)</span> 的最短路为 <span class="math inline">\(d\)</span> 的最小操作次数是否 <span class="math inline">\(\le K\)</span>。</p><p>当 <span class="math inline">\(d=1\)</span> 时，问题等价于选定一个最小边集，使得任何一条从 <span class="math inline">\(1\to n\)</span> 的路径都无可避免地经过这个边集中的边。换句话说，边集中的边将原图分割成了两部分，即最小割。</p><p>当 <span class="math inline">\(d&gt;1\)</span> 时，我们能通过建模将问题转化为一个分层图的最小割。</p><p><img src="/image/academic/AT1.jpg" /></p><p>上图是 <span class="math inline">\(d=1\)</span> 的情况，标注出的数字代表流量。考虑同样的图，但 <span class="math inline">\(d=3\)</span>：</p><p><img src="/image/academic/AT3.jpg" /></p><p>这只是一个分层图的框架，当我们需要让 <span class="math inline">\(1\to n\)</span> 的最短路为 <span class="math inline">\(3\)</span> 时，会出现一些问题。</p><p><img src="/image/academic/AT6.jpg" /></p><p>左图是我们期望的：分层图的每一层都选定了一些边，且每一层选定的边都组成了原图的一个最小割。把它们割掉，原图不连通，这样一个 <span class="math inline">\(d\)</span> 层的分层图的最小割就是让 <span class="math inline">\(1\to n\)</span> 的最短路为 <span class="math inline">\(d\)</span> 的最小操作次数。但能这么做的前提是每一层选定的边集互不相同，右图中我们只选定了三条边就能让图不连通，显然不合法。</p><p><img src="/image/academic/final.jpg" /></p><p>解决方案是对于每一条存在于原图中的边 <span class="math inline">\((u,v)\)</span>，<span class="math inline">\(\forall i\in[1,d)\)</span>，从第 <span class="math inline">\(i\)</span> 层的 <span class="math inline">\(u\)</span> 向第 <span class="math inline">\(i+1\)</span> 层的 <span class="math inline">\(v\)</span> 连边。这样选中不同层的同一条边就没有了意义。</p><p>时间复杂度 <span class="math inline">\(O(\text{maxflow}(n^2,mn+n^2)\log n)\)</span>。</p><h2 id="cf2035e.-monster"><a href="https://codeforces.com/contest/2035/problem/E">CF2035E. Monster</a></h2><p>*2300 <a href="https://codeforces.com/contest/2035/submission/311492543">Code</a></p><p>假设我们总共使用了 <span class="math inline">\(a\)</span> 次操作 <span class="math inline">\(1\)</span>，<span class="math inline">\(b\)</span> 次操作 <span class="math inline">\(2\)</span>。</p><p>贪心地想，最优策略一定是 "提升 <span class="math inline">\(k\)</span> 次攻击力，打一次"，"提升 <span class="math inline">\(k\)</span> 次攻击力，打一次"，<span class="math inline">\(\ldots\)</span>，如此反复 <span class="math inline">\(c=\min(\left\lfloor\frac{a}{k}\right\rfloor,b)\)</span> 次，再将剩下的 <span class="math inline">\(a\bmod k\)</span> 次攻击力提升用完，打 <span class="math inline">\(b-c\)</span> 次怪物。</p><p>等差数列求和，造成的总伤害 <span class="math inline">\(\text{damage}(a,b)=\frac{c(c+1)}{2}k+a(b-c)\)</span>，总代价 <span class="math inline">\(\text{cost}(a,b)=ax+by\)</span>。</p><p>发现当 <span class="math inline">\(a\)</span> 固定时，<span class="math inline">\(\text{damage}(a,b)\)</span> 随着 <span class="math inline">\(b\)</span> 增加单调不降；当 <span class="math inline">\(b\)</span> 固定时，<span class="math inline">\(\text{damage}(a,b)\)</span> 随着 <span class="math inline">\(a\)</span> 增加单调不降。</p><p>于是可以枚举 <span class="math inline">\(a\)</span>，二分出使得 <span class="math inline">\(\text{damage}(a,b)\ge z\)</span> 的最小 <span class="math inline">\(b\)</span>；或者枚举 <span class="math inline">\(b\)</span>，二分出使得 <span class="math inline">\(\text{damage}(a,b)\ge z\)</span> 的最小 <span class="math inline">\(a\)</span>。</p><p>但 <span class="math inline">\(a,b\)</span> 太大不能枚举，根据你对算法竞赛的了解这时候肯定从哪里推导出一个神秘的不等式然后把 <span class="math inline">\(a\)</span> 或 <span class="math inline">\(b\)</span> 的上界缩小。恭喜你猜对了。（实际上你可以根据时限和数据组数试一个刚好不会超时的上界）</p><p>证明：<span class="math inline">\(\min(a,b)\le \sqrt{2z}\)</span>。</p><ul><li>当 <span class="math inline">\(k=1\)</span> 时，攻击间隔最短，最低效。此时 <span class="math inline">\(c=\min(\left\lfloor\frac{a}{k}\right\rfloor)=\min(a,b)\)</span>，而当你提升一次攻击力就打一次的时候，最后一次操作不是攻击肯定没有意义，所以 <span class="math inline">\(a\le b\)</span>，故 <span class="math inline">\(c=a\)</span>。</li><li>此时 <span class="math inline">\(\text{damage}(a,b)\ge \frac{a(a+1)}{2}+a(b-a)=\frac{a(2b-a+1)}{2}\ge \frac{a(2b-b+1)}{2}&gt;\frac{ab}{2}\)</span>。</li><li>当 <span class="math inline">\(\text{damage}(a,b)\)</span> 取到 <span class="math inline">\(z\)</span> 时，有 <span class="math inline">\(z&gt;\frac{ab}{2}\)</span>，即 <span class="math inline">\(ab&lt;2z\)</span>，<span class="math inline">\(\min(a,b)\le \sqrt{2z}\)</span>，得证。</li></ul><p>时间复杂度 <span class="math inline">\(O(\sqrt{z}\log z)\)</span>。</p><h2 id="cf2085c.-serval-and-the-formula"><a href="https://codeforces.com/contest/2085/problem/C">CF2085C. Serval and The Formula</a></h2><p>*1600 <a href="https://codeforces.com/contest/2085/submission/312151000">Code</a></p><p><span class="math inline">\((x + k)+(y+k)=(x+k)\oplus(y+k)\)</span> 等价于 <span class="math inline">\((x+k)\&amp; (y+k)=0\)</span>。</p><p>注意到 <span class="math inline">\(2^p\)</span> 和任何 <span class="math inline">\(&lt;2^p\)</span> 的数按位与的结果都是 <span class="math inline">\(0\)</span>。</p><p>故考虑把 <span class="math inline">\(x+k\)</span> 和 <span class="math inline">\(y+k\)</span> 中较大的那个构造成 <span class="math inline">\(2^p\)</span> 的形式。</p><p>若 <span class="math inline">\(x=y\)</span>，无解；否则不妨取 <span class="math inline">\(p=59\)</span>，答案是 <span class="math inline">\(2^{59}-\max(x,y)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><h2 id="cf2085d.-serval-and-kaitenzushi-buffet"><a href="https://codeforces.com/contest/2085/problem/D">CF2085D. Serval and Kaitenzushi Buffet</a></h2><p>*2000 <a href="https://codeforces.com/contest/2085/submission/312157113">Code</a></p><p>你选的第 <span class="math inline">\(i\)</span> 个数的下标 <span class="math inline">\(p_i\)</span> 一定满足 <span class="math inline">\(p_i\le n-i(k+1)+1\)</span>。</p><p>按顺序遍历，每到一个这样的节点就从前缀里选一个还没被选的最大的数计入答案。</p><p>优先队列或线段树均可，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2085e.-serval-and-modulo"><a href="https://codeforces.com/contest/2085/problem/E">CF2085E. Serval and Modulo</a></h2><p>*2200 <a href="https://codeforces.com/contest/2085/submission/312161892">Code</a></p><p>最为关键的观察：<span class="math inline">\(\sum a-\sum b\)</span> 是 <span class="math inline">\(k\)</span> 的倍数。（因为 <span class="math inline">\(\forall i\in[1,n]\)</span>， <span class="math inline">\(b_i\)</span> 都由 <span class="math inline">\(a_i\)</span> 减去若干个 <span class="math inline">\(k\)</span> 得到）</p><p>枚举 <span class="math inline">\(\sum a-\sum b\)</span> 的所有因数暴力 check，复杂度是可以接受的。</p><p>时间复杂度 <span class="math inline">\(O(n\cdot \sigma(\sum a_i)+\sqrt{\sum a_i})\)</span>。</p><h2 id="cf2090d.-simple-permutation"><a href="https://codeforces.com/contest/2090/problem/D">CF2090D. Simple Permutation</a></h2><p>*1700 <a href="https://codeforces.com/contest/2090/submission/312039158">Code</a></p><p><span class="math inline">\(1\sim n\)</span> 内的素数都没有 <span class="math inline">\(\left\lfloor\frac{n}{3}\right\rfloor-1\)</span> 这么多，所以一个素数肯定被用了不只一次。</p><p>考虑形如 <span class="math inline">\(p,p-1,p+1,p-2,p+2,\cdots\)</span> 的结构，此时前缀和出现了 <span class="math inline">\(p,3p,5p,\cdots\)</span>，它们除以 <span class="math inline">\(i\)</span> 恰好都是 <span class="math inline">\(p\)</span>。</p><p>为了让这个结构尽可能长，取 <span class="math inline">\(p\)</span> 为最靠近 <span class="math inline">\(\frac{n}{2}\)</span> 的素数即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1654e.-arithmetic-operations"><a href="https://codeforces.com/contest/1654/problem/E">CF1654E. Arithmetic Operations</a></h2><p>*2300 <a href="https://codeforces.com/contest/1654/submission/312269153">Code</a></p><p>考虑求出最多不需要修改的位置个数 <span class="math inline">\(cnt\)</span>，答案就是 <span class="math inline">\(n-cnt\)</span>。</p><p>设 <span class="math inline">\(\forall i\in [1,n]\)</span>，<span class="math inline">\(b_i=a_i-i\cdot d\)</span>。当公差 <span class="math inline">\(d\)</span> 确定时，<span class="math inline">\(\{b\}\)</span> 中众数的出现次数就是对应的 <span class="math inline">\(cnt\)</span>。</p><p>阈值分治，设 <span class="math inline">\(B\)</span> 为阈值。当 <span class="math inline">\(-B \le d \le B\)</span> 时，直接枚举 <span class="math inline">\(d\)</span>，扫一遍求众数，这部分是 <span class="math inline">\(O(nB)\)</span>。</p><p>当 <span class="math inline">\(d&lt; -B\)</span> 或 <span class="math inline">\(d&gt;B\)</span> 时，若存在两个位置 <span class="math inline">\(i,j\)</span> 不会被修改，那么 <span class="math inline">\(|i-j|\le \frac{W}{B}\)</span>。</p><p>枚举左端点 <span class="math inline">\(i\)</span>，右端点扫描 <span class="math inline">\([i+1,i+\frac{W}{B}]\)</span>，若 <span class="math inline">\(j-i\mid a_j-a_i\)</span>，那么 <span class="math inline">\(\dfrac{a_j-a_i}{j-i}\)</span> 就是一个可能的公差。</p><p>把所有可能的公差都 <span class="math inline">\(O(n)\)</span> check 一遍，是不能够接受的。</p><p>合理的做法是用一个桶对当前左端点 <span class="math inline">\(i\)</span> 统计公差 <span class="math inline">\(\dfrac{a_j-a_i}{j-i}\)</span> 的众数的出现次数，设为 <span class="math inline">\(tot\)</span>，那么 <span class="math inline">\(cnt=tot+1\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n(B+\frac{W}{B}))\)</span>，显然 <span class="math inline">\(B\)</span> 取 <span class="math inline">\(\sqrt{W}\)</span> 最优。</p><h2 id="cf1809f.-traveling-in-berland"><a href="https://codeforces.com/contest/1809/problem/F">CF1809F. Traveling in Berland</a></h2><p>*2500 <a href="https://codeforces.com/contest/1809/submission/312731463">Code</a></p><p><span class="math inline">\(b_i=1\)</span> 的点是特殊的，因为总是可以假定我们在到达一个 <span class="math inline">\(b_i=1\)</span> 的点时油量恰好为 <span class="math inline">\(0\)</span>。（否则不如把剩余的油换到这个加油站来加）</p><p>定义 <span class="math inline">\(c(i,j)\)</span> 代表从点 <span class="math inline">\(i\)</span> 行驶到点 <span class="math inline">\(j\)</span> 的最小代价，满足 <span class="math inline">\(b_i=1/2\)</span> 但 <span class="math inline">\(b_j=1\)</span>，且 <span class="math inline">\(b_{i+1}\sim b_{j-1}=2\)</span>。（换句话说 <span class="math inline">\(b_j\)</span> 是 <span class="math inline">\(i\to j\)</span> 方向上最近的油价为 <span class="math inline">\(1\)</span> 的点）</p><p>令 <span class="math inline">\(d=dis(i,j)\)</span>，则： <span class="math display">\[c(i,j)=\begin{cases}2d&amp;,b_i=2\\d&amp;,b_i=1\cap d\le k\\2d-k&amp;,b_i=1\cap d&gt;k\end{cases}\]</span> 这意味着从一个 <span class="math inline">\(b_i=1/2\)</span> 的点到下一个 <span class="math inline">\(b_i=1\)</span> 的点的代价是可以快速计算的。</p><p>破环成链。令 <span class="math inline">\(\text{nxt}[i][j]\)</span> 代表点 <span class="math inline">\(i\)</span> 的下 <span class="math inline">\(2^j\)</span> 个油价为 <span class="math inline">\(1\)</span> 点的编号，<span class="math inline">\(f[i][j]\)</span> 代表点 <span class="math inline">\(i\)</span> 到下 <span class="math inline">\(2^j\)</span> 个油价为 <span class="math inline">\(1\)</span> 的点的代价，倍增。</p><p>最后还要加上 "终点背后最近的 <span class="math inline">\(b_i=1\)</span> 的点到终点的距离"。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1700c.-helping-the-nature"><a href="https://codeforces.com/contest/1700/problem/C">CF1700C. Helping the Nature</a></h2><p>*1700 <a href="https://codeforces.com/contest/1700/submission/312820855">Code</a></p><p>设差分数组 <span class="math inline">\(b_i=a_i-a_{i-1}\)</span>。三种操作分别对应：</p><ol type="1"><li><span class="math inline">\(b_1\leftarrow b_1-1\)</span> ，<span class="math inline">\(b_{i+1}\leftarrow b_{i+1}+1\)</span> 。</li><li><span class="math inline">\(b_{i}\leftarrow b_i-1\)</span>。</li><li><span class="math inline">\(b_1\leftarrow b_1+1\)</span>。</li></ol><p>题目转化为求最小的操作次数使得 <span class="math inline">\(\forall i\in [1,n]\)</span>，<span class="math inline">\(b_i=0\)</span>。</p><p>先考虑将 <span class="math inline">\(b_2\sim b_n\)</span> 变成 <span class="math inline">\(0\)</span>。涉及到 <span class="math inline">\(b_i,i\in [2,n]\)</span> 的操作只有前两条，操作一能让一个 <span class="math inline">\(b_i\)</span> 加一，操作二能让一个 <span class="math inline">\(b_i\)</span> 减一。于是这部分的代价是 <span class="math inline">\(\sum\limits_{i=2}^{n}b_i\)</span>。</p><p>再考虑将 <span class="math inline">\(b_1\)</span> 变成 <span class="math inline">\(0\)</span>。注意到操作二 <span class="math inline">\(i\)</span> 取 <span class="math inline">\(1\)</span> 时就是 "<span class="math inline">\(b_1\leftarrow b_1-1\)</span>"，配合操作三，这部分的代价就是 <span class="math inline">\(|b_1|\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1981c.-turtle-and-an-incomplete-sequence"><a href="https://codeforces.com/contest/1981/problem/C">CF1981C. Turtle and an Incomplete Sequence</a></h2><p>*1800 <a href="https://codeforces.com/contest/1981/submission/313255211">Code</a></p><p>特判：初态不满足要求或全是 <span class="math inline">\(-1\)</span>。</p><p>设左数/右数第一个不为 <span class="math inline">\(-1\)</span> 的位置分别为 <span class="math inline">\(i,j\)</span>，则 <span class="math inline">\(a_1\sim a_i\)</span> 和 <span class="math inline">\(a_j\sim a_n\)</span> 是好填的，反复 <span class="math inline">\(\times 2,\div 2\)</span> 即可。</p><p>接下来问题转化为：给定长为 <span class="math inline">\(m\)</span> 的数组 <span class="math inline">\(\{b\}\)</span>，其中 <span class="math inline">\(b_1 \neq -1\)</span>，<span class="math inline">\(b_m\neq -1\)</span>，<span class="math inline">\(\forall i\in(1,m)\)</span>，<span class="math inline">\(b_i=-1\)</span>，求一个合法的填数。</p><p>不难发现固定了 <span class="math inline">\(b_i\)</span>，那么 <span class="math inline">\(b_{i+1}\)</span> 只有 <span class="math inline">\(\div 2\)</span> 下取整，<span class="math inline">\(\times2\)</span> 和 <span class="math inline">\(\times 2+1\)</span> 三种选择，这相当于在标号满二叉树上向父亲/左儿子/右儿子走一步。于是问题变成了在满二叉树上找一条从 <span class="math inline">\(b_1\)</span> 到 <span class="math inline">\(b_m\)</span> 且长 <span class="math inline">\(m-1\)</span> 的路径。</p><p>求出 <span class="math inline">\(b_1\)</span> 和 <span class="math inline">\(b_m\)</span> 在满二叉树上的 LCA，计算出 <span class="math inline">\(b_1,b_m\)</span> 之间的简单路径长度 <span class="math inline">\(len\)</span>（这里 <span class="math inline">\(len\)</span> 是路径上除了 <span class="math inline">\(b_1,b_m\)</span> 外点的数目）。那么若 <span class="math inline">\((m-2)&lt;len\)</span> 或 <span class="math inline">\(m-2 \not\equiv len\pmod{2}\)</span>，就无解。</p><p>否则构造方式就是从两边分别跳父亲，中间的一段反复 <span class="math inline">\(\times 2,\div 2\)</span> 补齐。</p><p>求 LCA 可以暴跳，时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Atcoder</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】2025 UESTC 寒假集训</title>
    <link href="/posts/1e7fc2bd.html"/>
    <url>/posts/1e7fc2bd.html</url>
    
    <content type="html"><![CDATA[<p>奇怪，怎么来训的人这么少。</p><p>这期间晚上打的 CF 包含在这里面了 <span class="math inline">\(\to\)</span> <a href="https://kisuraop.github.io/posts/abc8fb81.html">Link</a>。虽然大概率还没来得及补。</p><p>训了一个寒假还是希望自己能有一点长进的，虽然现在还看不到...甚至写下这段话的时候 CF 还掉了大分。</p><h2 id="day-1">【2.15】Day 1</h2><p><a href="https://vjudge.net/contest/693557">Virtual Judge Link</a></p><p>尽力了，E、F 我评估了一下已经远超我目前的 dp 水平。那就没题可补了。</p><p>菜猫你怎么这么坏。</p><h2 id="day-2">【2.16】Day 2</h2><p><a href="https://vjudge.net/contest/693898">Virtual Judge Link</a></p><p>dp 还在追着我跑QAQ。</p><div class="note note-info">            <p><a href="https://atcoder.jp/contests/arc160/tasks/arc160_c?lang=en">E. Power Up</a></p><p>题意：给定 <span class="math inline">\(n\)</span> 个元素的可重集，你可以选择出现次数 <span class="math inline">\(\ge 2\)</span> 的 <span class="math inline">\(x\)</span>，删除两个 <span class="math inline">\(x\)</span> 然后插入一个 <span class="math inline">\(x+1\)</span>。你可以执行任意多次，问能得到多少种不同的集合。对 998244353 取模。</p><p><span class="math inline">\(1 \le n,a_i \le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>考虑从小到大合并，</p><p>设 <span class="math inline">\(dp[i][j]\)</span> 表示已经将 <span class="math inline">\(&lt; i\)</span> 的数合并，合并后有 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(i\)</span> 的方案数。</p><p>设 <span class="math inline">\(cnt[i]\)</span> 表示集合中原始 <span class="math inline">\(i\)</span> 的个数，则有转移： <span class="math display">\[dp[i][j +cnt[i]]=\sum_{k=j\times2}^{\inf}dp[i-1][k]\]</span> 对于相同的 <span class="math inline">\(j\)</span>，可以用一个后缀和 <span class="math inline">\(O(1)\)</span> 转移，并用 <code>std::map</code> 只保留有用的状态。此时状态数就是枚举的 <span class="math inline">\(j\)</span> 的总和，由于每次合并都能将出现次数减半，可以预见 <span class="math inline">\(j\)</span> 的总和不会很大。实际能证明状态数接近线性。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> W = <span class="hljs-number">2e5</span> + <span class="hljs-number">100</span>;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(W + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];cnt[a[i]]++;&#125;map&lt;<span class="hljs-type">int</span>, vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; dp;dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= W; i++) &#123;<span class="hljs-type">int</span> num = (*dp[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">rbegin</span>())[<span class="hljs-number">0</span>];<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(num + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : dp[i - <span class="hljs-number">1</span>]) &#123;f[x] = y;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = num - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;f[j] += f[j + <span class="hljs-number">1</span>];f[j] %= mod;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= num / <span class="hljs-number">2</span>; j++) &#123;dp[i].<span class="hljs-built_in">push_back</span>(&#123;j + cnt[i], f[j * <span class="hljs-number">2</span>]&#125;);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : dp[W]) &#123;ans = (ans + y) % mod;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://atcoder.jp/contests/abc288/tasks/abc288_e?lang=en">F. Wish List</a></p><p>题意：有 <span class="math inline">\(N\)</span> 件商品，第 <span class="math inline">\(i\)</span> 件价格 <span class="math inline">\(A_i\)</span>，你需要其中的 <span class="math inline">\(M\)</span> 件，编号分别为 <span class="math inline">\(X_1,X_2,\cdots,X_M\)</span>。每次购买某个商品 <span class="math inline">\(i\)</span> 时，若其在所有未买商品中编号第 <span class="math inline">\(j\)</span> 小，就要付 <span class="math inline">\(A_i+C_j\)</span> 的钱。求买到这 <span class="math inline">\(M\)</span> 件物品最少需要多少钱。（可以买不想要的商品）</p><p><span class="math inline">\(1 \le M \le N\le 5000\)</span>，<span class="math inline">\(1 \le A_i,C_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <span class="math inline">\(i\)</span> 件商品中买了 <span class="math inline">\(j\)</span> 件所需的最少钱数。</p><ul><li>若不买第 <span class="math inline">\(i\)</span> 件商品，则 <span class="math inline">\(dp[i][j]=dp[i-1][j]\)</span>。</li><li>若买第 <span class="math inline">\(i\)</span> 件商品，考虑到此时第 <span class="math inline">\(i\)</span> 件在所有未买商品中的顺序最小是第 <span class="math inline">\(i-j+1\)</span> 件，最大是第 <span class="math inline">\(i\)</span> 件，并且可以通过调整购买顺序使得该商品位次恰好对应 <span class="math inline">\(C[i-j+1\sim i]\)</span> 中的最小值时买下。故有 <span class="math inline">\(dp[i][j]=dp[i-1][j-1]+\min\limits_{k=i-j+1}^{i}C[k]+A[i]\)</span>。</li></ul><p>当然若第 <span class="math inline">\(i\)</span> 件商品在必须要买的 <span class="math inline">\(M\)</span> 件之中，就不考虑第一种情况。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SparseTable</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ST;<span class="hljs-built_in">SparseTable</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr) &#123;<span class="hljs-keyword">this</span>-&gt;n = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;ST.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span> ,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(__lg(n) + <span class="hljs-number">1</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ST[i][<span class="hljs-number">0</span>] = arr[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= __lg(n); j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1LL</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++) &#123;ST[i][j] = <span class="hljs-built_in">min</span>(ST[i][j - <span class="hljs-number">1</span>], ST[i + (<span class="hljs-number">1LL</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> len = __lg(r - l + <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ST[l][len], ST[r - (<span class="hljs-number">1LL</span> &lt;&lt; len) + <span class="hljs-number">1</span>][len]);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; c[i];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">need</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;need[x] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">SparseTable <span class="hljs-title">st</span><span class="hljs-params">(c)</span></span>;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, inf))</span></span>;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span>) &#123;dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + st.<span class="hljs-built_in">query</span>(i - j + <span class="hljs-number">1</span>, i) + a[i];&#125;<span class="hljs-keyword">if</span> (need[i] == <span class="hljs-number">0</span>) &#123;dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j]);&#125;&#125;&#125;<span class="hljs-type">int</span> ans = *<span class="hljs-built_in">min_element</span>(dp[n].<span class="hljs-built_in">begin</span>(), dp[n].<span class="hljs-built_in">end</span>());cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://atcoder.jp/contests/abc288/tasks/abc288_f">G. Integer Division</a></p><p>题意：给定一个 <span class="math inline">\(N\)</span> 位数 <span class="math inline">\(X\)</span>，可以把 <span class="math inline">\(X\)</span> 分成若干段（或不分割），得分为将每一段数值的乘积。求所有分割方法的得分之和，对 998244353 取模。</p><p><span class="math inline">\(2 \le N \le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>令 <span class="math inline">\(dp[i]\)</span> 表示只考虑前 <span class="math inline">\(i\)</span> 位时答案，<span class="math inline">\(s(l, r)\)</span> 表示区间 <span class="math inline">\([l, r]\)</span> 构成的十进制整数数值，则： <span class="math display">\[\begin{align}dp[i] &amp;= \sum_{j=0}^{i-1}dp[j]\cdot s(j+1,i)\\&amp;=\sum_{j=0}^{i-1}dp[j]\cdot(10\cdot s(j+1,i-1)+X[i])\\&amp;=10 \sum_{j=0}^{i-2}dp[j]\cdot s(j+1,i-1)+\sum_{j=0}^{i-1}dp[j]\cdot X[i]\\&amp;=10\cdot dp[i-1]+\sum_{j=0}^{i-1}dp[j]\cdot X[i]\end{align}\]</span> 中间求和上标替换成 <span class="math inline">\(i-2\)</span> 是因为 <span class="math inline">\(s(i,i-1)\)</span> 没有意义。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;string s;cin &gt;&gt; s;s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;dp[<span class="hljs-number">1</span>] = s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-type">int</span> sum = dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;dp[i] = (<span class="hljs-number">10</span> * dp[i - <span class="hljs-number">1</span>] + sum * (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)) % mod;sum = (sum + dp[i]) % mod;&#125;cout &lt;&lt; dp[n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://atcoder.jp/contests/arc160/tasks/arc160_d?lang=en">H. Mahjong</a></p><p>题意：称一个序列 <span class="math inline">\(\{b\}\)</span> 是好的当且仅当 <span class="math inline">\(\sum b_i=m\)</span> 且可以通过任意次以下两种操作使得 <span class="math inline">\(\{b\}\)</span> 全为 <span class="math inline">\(0\)</span>。</p><ul><li>选一个元素减 <span class="math inline">\(k\)</span>。</li><li>选一个长为 <span class="math inline">\(k\)</span> 的连续段每个元素减 <span class="math inline">\(1\)</span>。</li></ul><p>问有多少个长为 <span class="math inline">\(n\)</span> 的非负整数序列 <span class="math inline">\(\{a\}\)</span> 是好的，对 998244353 取模。</p><p><span class="math inline">\(1 \le k\le n\le 2000\)</span>，<span class="math inline">\(1\le m\le 10^{18}\)</span>。</p>          </div><div class="note note-success">            <p>计数 <span class="math inline">\(\{a\}\)</span> 即考虑初始一个全为 <span class="math inline">\(0\)</span> 的序列，通过那两种操作能变成哪些。</p><p>首先两种操作每次对总和的贡献都是 <span class="math inline">\(k\)</span>，若 <span class="math inline">\(k\nmid m\)</span>，一定无解。否则两种操作的次数加起来一定是 <span class="math inline">\(\frac{m}{k}\)</span>。</p><p>注意到选同一个长为 <span class="math inline">\(k\)</span> 的段进行操作 <span class="math inline">\(2\)</span>，反复进行 <span class="math inline">\(k\)</span> 次，等同于对每个位置都进行一次操作 <span class="math inline">\(1\)</span>。为了计数不重复，钦定对于同一个段，操作 <span class="math inline">\(2\)</span> 最多进行 <span class="math inline">\(k-1\)</span> 次。</p><p>用一个长为 <span class="math inline">\(2n-k+1\)</span> 的序列 <span class="math inline">\(\{c\}\)</span> 来表示一种操作序列：</p><ul><li><span class="math inline">\(c_1\sim c_{n-k+1}\)</span> 这 <span class="math inline">\(n-k+1\)</span> 个数代表了那 <span class="math inline">\(n-k+1\)</span> 个长为 <span class="math inline">\(k\)</span> 的连续段分别进行了多少次操作 <span class="math inline">\(2\)</span>。</li><li><span class="math inline">\(c_{n-k+2}\sim c_{2n-k+1}\)</span> 这 <span class="math inline">\(n\)</span> 个数代表了每个位置分别进行了多少次操作 <span class="math inline">\(1\)</span>。</li></ul><p>此时，原问题等价为有多少个长为 <span class="math inline">\(2n-k+1\)</span> 的非负整数序列 <span class="math inline">\(\{c\}\)</span> 满足：</p><ul><li><span class="math inline">\(\forall i\in [1,n-k+1]\)</span>，<span class="math inline">\(c_i&lt;k\)</span>。</li><li><span class="math inline">\(\sum\limits_{i=1}^{2n-k+1}c_i=\dfrac{m}{k}\)</span>。</li></ul><p>运用容斥和插板法，答案是： <span class="math display">\[\sum_{t=0}^{n-k+1}(-1)^{t}\binom{n-k+1}{t}\binom{\frac{m}{k}-tk+2n-k}{2n-k}\]</span> 文末有详细的推导。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<span class="hljs-keyword">if</span> (m % k) &#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;mint s = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt;= n - k + <span class="hljs-number">1</span>; t++) &#123;s += (t &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * <span class="hljs-built_in">C</span>(n - k + <span class="hljs-number">1</span>, t) * <span class="hljs-built_in">bfC</span>(m / k - t * k + <span class="hljs-number">2</span> * n - k, <span class="hljs-number">2</span> * n - k);&#125;cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;</code></pre></div>    </div></div><div class="note note-primary">            <p>给定 <span class="math inline">\(n,m,k,s\)</span>，有多少个长为 <span class="math inline">\(n\)</span> 的数列 <span class="math inline">\(\{a\}\)</span> 满足以下要求？</p><ul><li><span class="math inline">\(\forall i\in [1,n]\)</span>，<span class="math inline">\(a_i \ge 0\)</span>。</li><li><span class="math inline">\(\forall i\in[1,m]\)</span>，<span class="math inline">\(a_i \le k\)</span>。</li><li><span class="math inline">\(\sum\limits_{i=1}^{n} a_i=s\)</span>。</li></ul><p>若不考虑条件 <span class="math inline">\(2\)</span>，解的数目可以通过经典的隔板法得到： <span class="math display">\[\binom{s+n-1}{n-1}\]</span> 即将总和为 <span class="math inline">\(s\)</span> 看成 <span class="math inline">\(s\)</span> 个 <span class="math inline">\(1\)</span>，在这 <span class="math inline">\(s\)</span> 个 <span class="math inline">\(1\)</span> 中间插 <span class="math inline">\(n-1\)</span> 个板，分成的 <span class="math inline">\(n\)</span> 个部分每个部分的和对应一个非负整数。</p><p>考虑条件 <span class="math inline">\(2\)</span>，对每个 <span class="math inline">\(i\in[1,m]\)</span> 的 <span class="math inline">\(a_i\)</span>，定义事件 <span class="math inline">\(P_i\)</span>："<span class="math inline">\(a_i&gt;k\)</span>"。</p><p>那么，根据容斥原理： <span class="math display">\[\begin{align}\textbf{不违反任何 } P_i \textbf{ 的解数}&amp;= \textbf{总情况数}\\&amp;-\sum \textbf{违反至少一个 } P_i \textbf{ 的情况数} \\&amp;+\sum \textbf{违反至少两个 } P_i \textbf{ 的情况数} \\&amp;- \cdots\end{align}\]</span> 我们枚举 <span class="math inline">\(t\)</span>，代表违反的约束的个数，那么答案是： <span class="math display">\[\sum_{t=0}^{m}(-1)^{t}\binom{m}{t}\cdot[\textbf{违反了至少 }t\textbf{ 个 }P_i \textbf{ 的情况数}]\]</span> 其中 <span class="math inline">\(\binom{m}{t}\)</span> 代表从前 <span class="math inline">\(m\)</span> 个位置中选 <span class="math inline">\(t\)</span> 个位置，钦定这 <span class="math inline">\(t\)</span> 个位置上的数<strong>一定</strong> <span class="math inline">\(&gt;k\)</span>。</p><p>也就是说，这 <span class="math inline">\(t\)</span> 个位置上的数的合法取值变成了 <span class="math inline">\([k+1,*]\)</span>，而其它位置上的数的合法取值为 <span class="math inline">\([0,*]\)</span>，这等价于将总和 <span class="math inline">\(s\)</span> 替换成 <span class="math inline">\(s&#39;=s-t(k+1)\)</span>。</p><p>于是，问题转化为有多少个长为 <span class="math inline">\(n\)</span> 的非负整数序列和为 <span class="math inline">\(s-t(k+1)\)</span>，根据前文提到的隔板法，答案是： <span class="math display">\[\binom{s-t(k+1)+n-1}{n-1}\]</span> 代回容斥后的式子，即得： <span class="math display">\[ans=\sum_{t=0}^{m}(-1)^{t}\binom{m}{t}\binom{s-t(k+1)+n-1}{n-1}\]</span></p>          </div><hr /><div class="note note-info">            <p><a href="https://atcoder.jp/contests/arc160/tasks/arc160_e?lang=en">J. Make Biconnected</a></p><p>题意：给定一棵 <span class="math inline">\(n\)</span> 个点的树，点有点权 <span class="math inline">\(w_i\)</span>，且每个点度数至多为 <span class="math inline">\(3\)</span>。你可以在树上加边，加一条连接 <span class="math inline">\(i,j\)</span> 的边耗费 <span class="math inline">\(w_i+w_j\)</span>。求将这棵树变成点双连通图的最小花费。</p><p><span class="math inline">\(3 \le n \le 2\cdot 10^5\)</span>，<span class="math inline">\(1 \le w_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>首先优先连叶子肯定不劣。假设我们给这个树选定了一个根，两个叶子能连起来当且仅当它们在这个根的不同的子树中。令这棵树有 <span class="math inline">\(k\)</span> 个叶子：</p><ul><li>若 <span class="math inline">\(k\)</span> 为偶数，可以证明一定存在一个根使得这这 <span class="math inline">\(k\)</span> 个叶子能够用 <span class="math inline">\(\frac{k}{2}\)</span> 条边两两连接。这个根只需满足叶子最多的子树的叶子个数不超过 <span class="math inline">\(\frac{k}{2}\)</span>，可以用反证法证明。</li></ul><p>当然我们并不用真的求出这个根：既然一定存在，设这 <span class="math inline">\(k\)</span> 个叶子 dfs 序跑出来的编号为 <span class="math inline">\(d_1,d_2,\cdots d_k\)</span>，那么 <span class="math inline">\(d_i\)</span> 连 <span class="math inline">\(d_{(i+\frac{k}{2}) \bmod k\ +1}\)</span> 就是最优的。</p><ul><li>若 <span class="math inline">\(k\)</span> 为奇数，考虑枚举多出来的那个叶子 <span class="math inline">\(x\)</span>，然后剩下的按偶数的方法两两连接。 设 <span class="math inline">\(x\)</span> 往上跳到的第一个三度点是 <span class="math inline">\(y\)</span>，那么断言 <span class="math inline">\(x\)</span> 可以和除了 <span class="math inline">\(x\to y\)</span> 路径上的点之外的所有点连边，我们只用挑权值最小的连即可。</li></ul><p>tip：dfs 时可以选择一个三度点为根，这样 <span class="math inline">\(x\)</span> 向根的方向一定能跳到一个三度点。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; w[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">is3</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> rt = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (adj[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;is3[i] = <span class="hljs-literal">true</span>;rt = i;&#125;&#125;<span class="hljs-keyword">if</span> (rt == <span class="hljs-number">-1</span>) &#123;vector&lt;<span class="hljs-type">int</span>&gt; ex;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (adj[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;ex.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;1\n&quot;</span> &lt;&lt; ex[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ex[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;vector&lt;<span class="hljs-type">int</span>&gt; leaf;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;f[x] = fa;<span class="hljs-keyword">if</span> (adj[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;leaf.<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;; <span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> cnt = leaf.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; cnt / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + cnt / <span class="hljs-number">2</span> &lt; cnt; i++) &#123;cout &lt;&lt; leaf[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; leaf[i + cnt / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-keyword">return</span> ;&#125;set&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; s;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;s.<span class="hljs-built_in">insert</span>(&#123;w[i], i&#125;);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; res;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<span class="hljs-type">int</span> x = leaf[i];vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; tmp;<span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;s.<span class="hljs-built_in">extract</span>(&#123;w[x], x&#125;);tmp.<span class="hljs-built_in">push_back</span>(&#123;w[x], x&#125;);<span class="hljs-keyword">if</span> (is3[x]) &#123;<span class="hljs-keyword">break</span>;&#125;x = f[x];&#125;<span class="hljs-keyword">auto</span> [val, anoid] = *s.<span class="hljs-built_in">begin</span>();res.<span class="hljs-built_in">push_back</span>(&#123;val, anoid, i&#125;);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : tmp) &#123;s.<span class="hljs-built_in">insert</span>(x);&#125;&#125;<span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">auto</span> [_, anoid, mnid] = res[<span class="hljs-number">0</span>];vector&lt;<span class="hljs-type">int</span>&gt; fir, sec;array&lt;<span class="hljs-type">int</span>, 2&gt; spe;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<span class="hljs-keyword">if</span> (i == mnid) &#123;spe = &#123;leaf[i], anoid&#125;;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (fir.<span class="hljs-built_in">size</span>() &lt; cnt / <span class="hljs-number">2</span>) &#123;fir.<span class="hljs-built_in">push_back</span>(leaf[i]);&#125; <span class="hljs-keyword">else</span> &#123;sec.<span class="hljs-built_in">push_back</span>(leaf[i]);&#125;&#125;&#125;cout &lt;&lt; cnt / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fir.<span class="hljs-built_in">size</span>(); i++) &#123;cout &lt;&lt; fir[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; sec[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;cout &lt;&lt; spe[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; spe[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="day-3">【2.17】 Day 3</h2><p><a href="https://vjudge.net/contest/694161">Virtual Judge Link</a></p><p>红了，D 一直 wa，拍完才发现没想清楚。</p><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1866C">D. Completely Searching for Inversions</a></p><p>题意：给一个 <span class="math inline">\(n\)</span> 个点的有向无环图，边权为 <span class="math inline">\(0/1\)</span>，且从 <span class="math inline">\(1\)</span> 可以到达任意点。从 <span class="math inline">\(1\)</span> 开始跑一个不带 <code>vis</code> 的 dfs，并将沿途边权记录下来，形成一个二进制串。求这个串的逆序对个数，对 998244353 取模。</p><p><span class="math inline">\(2 \le n \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>将边权为 <span class="math inline">\(0/1\)</span> 的边称为 <span class="math inline">\(0/1\)</span> 边。</p><p>先跑一遍正常的 dfs，回溯时统计答案。当我们从终点向前加一个点时，形成的新贡献是从 <span class="math inline">\(1\)</span> 开始 dfs 到这个点的路上经过的 <span class="math inline">\(1\)</span> 边数量乘上这个点后面 <span class="math inline">\(0\)</span> 边的数量。至于这个点后面的 <span class="math inline">\(1\)</span> 边对后面的 <span class="math inline">\(0\)</span> 边造成的贡献，已经包含在后面的答案里了。</p><p>令 <span class="math inline">\(pre1[x]\)</span> 表示从 <span class="math inline">\(1\)</span> 开始 dfs 到 <span class="math inline">\(x\)</span> 经过的 <span class="math inline">\(1\)</span> 边的数量，<span class="math inline">\(suf0[x]\)</span> 表示从 <span class="math inline">\(x\)</span> 到 dfs 末尾这一段经过的 <span class="math inline">\(0\)</span> 边的数量，<span class="math inline">\(f[x]\)</span> 表示 <span class="math inline">\(x\)</span> 向后形成的闭合子图的答案，则： <span class="math display">\[f[x]=\sum_{x\to y} (f[y]+pre1[x]\cdot suf0[y])\]</span> 时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> num;cin &gt;&gt; num;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<span class="hljs-type">int</span> y, w;cin &gt;&gt; y &gt;&gt; w;adj[i].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre1</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">suf0</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span>) &#123;suf0[x]++;f[x] += pre1[x]; f[x] %= mod;&#125; <span class="hljs-keyword">else</span> &#123;pre1[x]++;&#125;<span class="hljs-keyword">if</span> (!vis[y]) &#123;<span class="hljs-built_in">self</span>(self, y);&#125;f[x] += f[y];f[x] %= mod;f[x] += pre1[x] * suf0[y] % mod;f[x] %= mod;pre1[x] += pre1[y];pre1[x] %= mod;suf0[x] += suf0[y];suf0[x] %= mod;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);cout &lt;&lt; f[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1762D">G. GCD Queries</a></p><p>题意：交互题，给定一个 <span class="math inline">\(0\sim n-1\)</span> 的排列，你需要通过不超过 <span class="math inline">\(2n\)</span> 次询问找到两个下标 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 满足 <span class="math inline">\(p_x=0\)</span> 或 <span class="math inline">\(p_y=0\)</span>。每次询问你可以问两个下标 <span class="math inline">\(i,j\)</span>，交互器返回 <span class="math inline">\(\gcd(p_i,p_j)\)</span>。</p><p><span class="math inline">\(2 \le n \le 2 \cdot 10^4\)</span>。</p>          </div><div class="note note-success">            <p>题目的要求暗示了 <span class="math inline">\(0\)</span> 的位置是不能确定的，只能是排除到只剩两个位置。考虑三个不同的位置 <span class="math inline">\(i,j,k\)</span>，令 <span class="math inline">\(A=\text{query}(i,k)=\gcd(i,k)\)</span>，<span class="math inline">\(B=\text{query(j,k)}=\gcd(j,k)\)</span>。<span class="math inline">\(A,B\)</span> 间只能是以下三种关系：</p><ul><li><span class="math inline">\(A=B\)</span>。此时能断言 <span class="math inline">\(p_k\neq0\)</span>，因为 <span class="math inline">\(p_i\neq p_j\)</span>。</li><li><span class="math inline">\(A&lt;B\)</span>。此时能断言 <span class="math inline">\(p_i\neq 0\)</span>，因为 <span class="math inline">\(\gcd(p_k,0)=p_k&gt;\gcd(p_k,x),x&gt;0\)</span>。</li><li><span class="math inline">\(A&gt;B\)</span>。此时能断言 <span class="math inline">\(p_j\neq 0\)</span>，原因同上。</li></ul><p>如此一来，我们每次选三个还不确定是不是 <span class="math inline">\(0\)</span> 的下标问两次就能排除一个，排除 <span class="math inline">\(n-2\)</span> 次即可。总共用了 <span class="math inline">\(2(n-2)=2n-4\)</span> 次询问。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;<span class="hljs-type">int</span> x;cin &gt;&gt; x;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;set&lt;<span class="hljs-type">int</span>&gt; s;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;s.<span class="hljs-built_in">insert</span>(i);&#125;<span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<span class="hljs-type">int</span> x = *s.<span class="hljs-built_in">begin</span>();s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<span class="hljs-type">int</span> y = *s.<span class="hljs-built_in">begin</span>();s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<span class="hljs-type">int</span> z = *s.<span class="hljs-built_in">begin</span>();s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<span class="hljs-type">int</span> res1 = <span class="hljs-built_in">query</span>(x, z);<span class="hljs-type">int</span> res2 = <span class="hljs-built_in">query</span>(y, z);<span class="hljs-keyword">if</span> (res1 == res2) &#123;s.<span class="hljs-built_in">insert</span>(x);s.<span class="hljs-built_in">insert</span>(y);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res1 &lt; res2) &#123;s.<span class="hljs-built_in">insert</span>(y);s.<span class="hljs-built_in">insert</span>(z);&#125; <span class="hljs-keyword">else</span> &#123;s.<span class="hljs-built_in">insert</span>(x);s.<span class="hljs-built_in">insert</span>(z);&#125;&#125;<span class="hljs-type">int</span> x = *s.<span class="hljs-built_in">begin</span>();s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<span class="hljs-type">int</span> y = *s.<span class="hljs-built_in">begin</span>();cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;<span class="hljs-type">int</span> z;cin &gt;&gt; z;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1534E">H. Lost Array</a></p><p>题意：交互题，给定 <span class="math inline">\(n,k\)</span>，有一个长为 <span class="math inline">\(n\)</span> 的未知序列 <span class="math inline">\(\{a\}\)</span>，你需要通过最少次数的询问找出 <span class="math inline">\(\oplus_{i=1}^{n}a_i\)</span>。每次你可以询问一个长为 <span class="math inline">\(k\)</span> 的子序列的异或和。</p><p><span class="math inline">\(1\le k\le n\le 500\)</span>，<span class="math inline">\(1\le a_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>如果一个下标被选中了两次，那么相当于没问过这个下标。也就是说每个位置都只有被问过和没被问过两种状态。</p><p>令 <span class="math inline">\(f_i\)</span> 表示 "知道了 <span class="math inline">\(i\)</span> 个位置的异或和" 这个状态，则连边：</p><ul><li><span class="math inline">\(\forall i\in[0,n-k]\)</span>，<span class="math inline">\(f_i\to f_{i+k}\)</span>。</li><li><span class="math inline">\(\forall i\in [1,n]\)</span>，<span class="math inline">\(\forall j\in[k-(n-i),\min(i,k)]\)</span>，<span class="math inline">\(f_i\to f_{i+k-2j}\)</span>。</li></ul><p>第一种连边好理解：如果还有 <span class="math inline">\(k\)</span> 个位置没问，那就问。</p><p>第二种连边枚举了需要把 <span class="math inline">\(j\)</span> 个已经问过的下标更新为 "没问过"，不仅失去了 <span class="math inline">\(j\)</span> 个已知的点，也只剩 <span class="math inline">\(k-j\)</span> 次去问其它未知点，故为 <span class="math inline">\(f_{i+k-2j}\)</span>。</p><p>题目要求询问次数最少，跑 <span class="math inline">\(f_0\)</span> 到 <span class="math inline">\(f_n\)</span> 的最短路（或 bfs）即可。若到达不了 <span class="math inline">\(f_n\)</span> 就是 <span class="math inline">\(-1\)</span>，否则记下途径的点用于构造方案。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-type">int</span> x;cin &gt;&gt; x;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + k &lt;= n; i++) &#123;adj[i].<span class="hljs-built_in">push_back</span>(i + k);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>, k - (n - i)); j &lt;= <span class="hljs-built_in">min</span>(i, k); j++) &#123;<span class="hljs-type">int</span> x = i + k - <span class="hljs-number">2</span> * j;<span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= n) &#123;adj[i].<span class="hljs-built_in">push_back</span>(x);&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);vis[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span> (x == n) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!vis[y]) &#123;vis[y] = <span class="hljs-number">1</span>;pre[y] = x;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i != <span class="hljs-number">0</span>; i = pre[i]) &#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span>) &#123;cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<span class="hljs-keyword">return</span> ;&#125;path.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : path) &#123;<span class="hljs-type">int</span> back_cover = (cur + k - x) / <span class="hljs-number">2</span>;<span class="hljs-type">int</span> cover = k - back_cover;vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, A = <span class="hljs-number">0</span>, B = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; A &lt; cover) &#123;vis[i] = <span class="hljs-number">1</span>;a.<span class="hljs-built_in">push_back</span>(i);A++;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[i] &amp;&amp; B &lt; back_cover) &#123;vis[i] = <span class="hljs-number">0</span>;a.<span class="hljs-built_in">push_back</span>(i);B++;&#125;&#125;<span class="hljs-built_in">assert</span>(a.<span class="hljs-built_in">size</span>() == k);ans ^= <span class="hljs-built_in">query</span>(a);cur = x;&#125;cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-980F">J. Cactus to Tree</a></p><p>题意：给定一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的连通无向图。对每个 <span class="math inline">\(i\in[1,n]\)</span>，求若以最佳方式断边使得图变成树，<span class="math inline">\(\max\limits_{u\in leaf} dis(i,u)\)</span> 最小是多少。</p><p><span class="math inline">\(1 \le n \le 5\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>考虑一个点 <span class="math inline">\(x\)</span>，以 <span class="math inline">\(x\)</span> 为根建出 bfs 生成树，生成树上的边就是要保留的边。换句话说，题意等同于对每个点 <span class="math inline">\(i\)</span>，求 <span class="math inline">\(i\)</span> 到其它所有点最短距离的最大值。</p><p>我们任选一个环，钦定他为整个图的 "根"。同样约定 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(y\)</span> 的子树中当且仅当 <span class="math inline">\(y\)</span> 在从根到 <span class="math inline">\(x\)</span> 的路径上。</p><p>定义 <span class="math inline">\(F[x]=\max\limits_{y}dis(x,y)\)</span>，其中 <span class="math inline">\(y\)</span> 在 <span class="math inline">\(x\)</span> 的子树内。对于根来说，我们从根的每个点出发向子树内 bfs，可以 <span class="math inline">\(O(n)\)</span> 得到根上每个点的 <span class="math inline">\(F[x]\)</span>。</p><p>令 <span class="math inline">\(Cir[x]\)</span> 代表 <span class="math inline">\(x\)</span> 所在的环，特别地，单点看作一个环。定义 <span class="math inline">\(G[x]\)</span> 代表从 <span class="math inline">\(x\)</span> 出发向 <span class="math inline">\(Cir[x]\)</span> 方向延伸出的最长距离，那么： <span class="math display">\[G[u]=\max_{v\in Cir[u]}(dis(u,v)+F[v])\]</span> 这是一个典型的使用单调队列解决的式子。具体地，拆环成链，单调队列维护最大的 <span class="math inline">\(F[i]-i\)</span>，窗口大小不超过 <span class="math inline">\(\frac{1}{2}\)</span> 环长，顺时针逆时针扫两遍。</p><p>现在，在知道一个环所有 <span class="math inline">\(F[x]\)</span> 的情况下，可以线性求出 <span class="math inline">\(G[x]\)</span>。而对于每个点 <span class="math inline">\(x\)</span>，答案就是 <span class="math inline">\(\max(F[x],G[x])\)</span>。于是问题转化为如何把 <span class="math inline">\(F\)</span> 从根转移到图上的其它点。</p><p>这依然是典型的换根问题，每次转移时的 <span class="math inline">\(\text{UpValue}\)</span> 选择非该当前子树的最大深度，并与当前点的 <span class="math inline">\(G\)</span> 取 <span class="math inline">\(\max\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。实现时有若干细节等待你的探索（</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_combine</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123;    seed ^= <span class="hljs-built_in">hash</span>&lt;T&gt;()(val) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123;    <span class="hljs-built_in">hash_combine</span>(seed, val);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val, <span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;    <span class="hljs-built_in">hash_combine</span>(seed, val);    <span class="hljs-built_in">hash_val</span>(seed, args...);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;    <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;    <span class="hljs-built_in">hash_val</span>(seed, args...);    <span class="hljs-keyword">return</span> seed;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">custom_hash</span> &#123;    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(p.first, p.second);    &#125;&#125;;unordered_set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, custom_hash&gt; E;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">EBCC</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; dfn, low, stk, c;<span class="hljs-type">int</span> tim, top, cnt;<span class="hljs-built_in">EBCC</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; Adj) : <span class="hljs-built_in">n</span>(Adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>), <span class="hljs-built_in">adj</span>(Adj), <span class="hljs-built_in">dfn</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">low</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">stk</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">c</span>(n + <span class="hljs-number">1</span>) &#123;tim = top = cnt = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> par)</span> </span>&#123;dfn[x] = low[x] = ++tim;stk[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == par) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y, x);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);<span class="hljs-keyword">if</span> (low[y] &gt; dfn[x]) &#123;E.<span class="hljs-built_in">insert</span>(&#123;x, y&#125;);E.<span class="hljs-built_in">insert</span>(&#123;y, x&#125;);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!c[y] &amp;&amp; dfn[y] &lt; dfn[x]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; cnt++;<span class="hljs-keyword">do</span> &#123;now = stk[top--];c[now] = cnt;&#125; <span class="hljs-keyword">while</span> (x != now);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<span class="hljs-built_in">tarjan</span>(rt, <span class="hljs-number">0</span>);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">EBCC <span class="hljs-title">T</span><span class="hljs-params">(adj)</span></span>;T.<span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>);vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; cirs;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cirID</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; cir;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;cir.<span class="hljs-built_in">push_back</span>(x);vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y] || E.<span class="hljs-built_in">count</span>(&#123;x, y&#125;)) &#123;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-built_in">self</span>(self, y);&#125;&#125;; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;cir.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">dfs</span>(dfs, i);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;cirID[x] = cirs.<span class="hljs-built_in">size</span>();&#125;cirs.<span class="hljs-built_in">push_back</span>(cir);&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">F</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">bfsDep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bfsFa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; bfsOrder;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);vis[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();bfsOrder.<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!vis[y]) &#123;vis[y] = <span class="hljs-literal">true</span>;bfsFa[y] = x;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-built_in">reverse</span>(bfsOrder.<span class="hljs-built_in">begin</span>(), bfsOrder.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : bfsOrder) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (bfsFa[y] == x) &#123;bfsDep[x] = <span class="hljs-built_in">max</span>(bfsDep[x], bfsDep[y] + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (E.<span class="hljs-built_in">count</span>(&#123;x, y&#125;)) &#123;F[x] = <span class="hljs-built_in">max</span>(F[x], bfsDep[y] + <span class="hljs-number">1</span>);&#125;&#125;&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">G</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> scanCircle = [&amp;] (<span class="hljs-type">int</span> id) &#123;vector&lt;<span class="hljs-type">int</span>&gt; cir = cirs[id];vector&lt;<span class="hljs-type">int</span>&gt; f;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;f.<span class="hljs-built_in">push_back</span>(F[x]);&#125;<span class="hljs-type">int</span> len = cir.<span class="hljs-built_in">size</span>();cir.<span class="hljs-built_in">insert</span>(cir.<span class="hljs-built_in">end</span>(), cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());f.<span class="hljs-built_in">insert</span>(f.<span class="hljs-built_in">end</span>(), f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>());deque&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * len; i++) &#123;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() &gt; len / <span class="hljs-number">2</span>) &#123;q.<span class="hljs-built_in">pop_front</span>();&#125;<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;G[cir[i]] = <span class="hljs-built_in">max</span>(G[cir[i]], f[q.<span class="hljs-built_in">front</span>()] + i - q.<span class="hljs-built_in">front</span>());&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; f[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt;= f[i] - i) &#123;q.<span class="hljs-built_in">pop_back</span>();&#125;q.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">reverse</span>(cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>());q.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * len; i++) &#123;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() &gt; len / <span class="hljs-number">2</span>) &#123;q.<span class="hljs-built_in">pop_front</span>();&#125;<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;G[cir[i]] = <span class="hljs-built_in">max</span>(G[cir[i]], f[q.<span class="hljs-built_in">front</span>()] + i - q.<span class="hljs-built_in">front</span>());&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; f[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt;= f[i] - i) &#123;q.<span class="hljs-built_in">pop_back</span>();&#125;q.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> up) -&gt; <span class="hljs-type">void</span> &#123;F[x] = <span class="hljs-built_in">max</span>(F[x], up);<span class="hljs-built_in">scanCircle</span>(cirID[x]);vector&lt;<span class="hljs-type">int</span>&gt; cir = cirs[cirID[x]];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;<span class="hljs-type">int</span> firMx = <span class="hljs-number">0</span>, secMx = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa || E.<span class="hljs-built_in">count</span>(&#123;x, y&#125;) == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (bfsDep[y] + <span class="hljs-number">1</span> &gt; firMx) &#123;secMx = firMx;firMx = bfsDep[y] + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bfsDep[y] + <span class="hljs-number">1</span> &gt; secMx) &#123;secMx = bfsDep[y] + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa || E.<span class="hljs-built_in">count</span>(&#123;x, y&#125;) == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> nup = <span class="hljs-built_in">max</span>(up, G[x]);<span class="hljs-keyword">if</span> (bfsDep[y] + <span class="hljs-number">1</span> == firMx) &#123;nup = <span class="hljs-built_in">max</span>(nup, secMx);&#125; <span class="hljs-keyword">else</span> &#123;nup = <span class="hljs-built_in">max</span>(nup, firMx);&#125;<span class="hljs-built_in">self</span>(self, y, x, nup + <span class="hljs-number">1</span>);&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; <span class="hljs-built_in">max</span>(F[i], G[i]) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="day-4">【2.18】 Day 4</h2><p><a href="https://vjudge.net/contest/694446">Virtual Judge Link</a></p><p>前面都是一些很无聊的题...</p><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-534F">H. Simplified Nonogram</a></p><p>题意：完成一个 <span class="math inline">\(5\times 20\)</span> 的简易版数织。简易即你只知道每行/列有多少段黑色，而不知道每一段黑色具体长多少。</p>          </div><div class="note note-success">            <p>我们把同一行连续的一段黑色称为一个连通块。</p><p>令 <span class="math inline">\(dp[col][lst][p_1][p_2][p_3][p_4][p_5]=0/1\)</span> 表示是否能到达 "已经填了 <span class="math inline">\(col\)</span> 列，上一列填了 <span class="math inline">\(lst\)</span>，第 <span class="math inline">\(i\)</span> 行已经有 <span class="math inline">\(p_i\)</span> 个连通块" 这个状态。</p><p>其中 <span class="math inline">\(lst\)</span> 是一个长为 <span class="math inline">\(n\)</span> 的二进制串，第 <span class="math inline">\(i\)</span> 位为 <span class="math inline">\(0/1\)</span> 代表上一列第 <span class="math inline">\(i\)</span> 行是否涂黑。</p><p>由每一行连通块个数 <span class="math inline">\(p_i&lt;\lceil\frac{m}{2}\rceil\)</span>，此时的状态数有 <span class="math inline">\(m\cdot 2^n\cdot (\lceil\frac{m}{2}\rceil)^n=6.4\cdot 10^7\)</span>，开成 bool 类型的数组为 <span class="math inline">\(61\)</span>mB，爆不了。</p><p>考虑转移，我们枚举当前列的 <span class="math inline">\(2^n\)</span> 种状态，遍历一遍看该状态是否满足纵向限制。若满足，再枚举每一行看是否 "当前第 <span class="math inline">\(i\)</span> 行为 <span class="math inline">\(1\)</span> 且 <span class="math inline">\(lst\)</span> 第 <span class="math inline">\(i\)</span> 位为 <span class="math inline">\(0\)</span>"，若是，则对应行的连通块个数 <span class="math inline">\(+1\)</span>；否则不变。</p><p>于是对于当前列的每一种状态，纵向和横向的限制都能在 <span class="math inline">\(O(n)\)</span> 内 check out。</p><p>使用记忆化搜索转移，时间复杂度的上界是状态数乘上 <span class="math inline">\(n\)</span>。</p><p>实测仅使用最简单的剪枝就能跑进 150ms。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-type">bool</span> f[<span class="hljs-number">21</span>][<span class="hljs-number">32</span>][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;cin &gt;&gt; b[i];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-keyword">if</span> ((i &gt;&gt; j &amp; <span class="hljs-number">1</span>) &amp;&amp; (j == <span class="hljs-number">0</span> || (i &gt;&gt; (j - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)) &#123;cnt[i]++;&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> lst, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; p) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (p[i] &gt; a[i] || p[i] + (m - col) &lt; a[i]) &#123; <span class="hljs-keyword">return</span> ;&#125;&#125;<span class="hljs-keyword">if</span> (col == m) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cout &lt;&lt; (ans[j] &gt;&gt; i &amp; <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;*&quot;</span> : <span class="hljs-string">&quot;.&quot;</span>); &#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">if</span> (f[col][lst][p[<span class="hljs-number">0</span>]][p[<span class="hljs-number">1</span>]][p[<span class="hljs-number">2</span>]][p[<span class="hljs-number">3</span>]][p[<span class="hljs-number">4</span>]]) &#123;<span class="hljs-keyword">return</span> ;&#125;f[col][lst][p[<span class="hljs-number">0</span>]][p[<span class="hljs-number">1</span>]][p[<span class="hljs-number">2</span>]][p[<span class="hljs-number">3</span>]][p[<span class="hljs-number">4</span>]] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<span class="hljs-keyword">if</span> (cnt[i] != b[col]) &#123;<span class="hljs-keyword">continue</span>;&#125;array&lt;<span class="hljs-type">int</span>, 5&gt; cur = p;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-keyword">if</span> ((i &gt;&gt; j &amp; <span class="hljs-number">1</span>) &amp;&amp; (lst &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;cur[j]++;&#125;&#125;ans[col] = i;<span class="hljs-built_in">self</span>(self, col + <span class="hljs-number">1</span>, i, cur);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-538F">I. A Heap of Heaps</a></p><p>题意：一棵 <span class="math inline">\(n\)</span> 个节点的堆，点有点权，节点编号为 bfs 序。对 <span class="math inline">\(k\in[1,n-1]\)</span> 求当这个堆是 <span class="math inline">\(k\)</span> 叉堆时有多少个节点的权值比父亲小。</p><p><span class="math inline">\(2 \le n \le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>易知对于 <span class="math inline">\(k\)</span> 叉堆，节点 <span class="math inline">\(x\)</span> 的父亲编号为 <span class="math inline">\(\left\lfloor\dfrac{x-2}{k}\right\rfloor+1\)</span>。</p><p>可以发现对于许多 <span class="math inline">\(k\)</span>，节点 <span class="math inline">\(x\)</span> 的父亲都是相同的。</p><p>用数论分块对每一个节点 <span class="math inline">\(i\)</span> 求出满足权值比父亲小的 <span class="math inline">\(k\)</span> 的范围，差分一下即可。</p><p>时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>; l &lt;= i - <span class="hljs-number">2</span>; l = r + <span class="hljs-number">1</span>) &#123;r = <span class="hljs-built_in">min</span>(i - <span class="hljs-number">2</span>, (i - <span class="hljs-number">2</span>) / ((i - <span class="hljs-number">2</span>) / l));<span class="hljs-keyword">if</span> (a[i] &lt; a[(i - <span class="hljs-number">2</span>) / l + <span class="hljs-number">1</span>]) &#123;d[l]++;d[r + <span class="hljs-number">1</span>]--;&#125;&#125;<span class="hljs-keyword">if</span> (a[i] &lt; a[<span class="hljs-number">1</span>]) &#123;d[i - <span class="hljs-number">1</span>]++;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;d[i] += d[i - <span class="hljs-number">1</span>];cout &lt;&lt; d[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="day-5">【2.19】 Day 5</h2><p><a href="https://vjudge.net/contest/694757">Virtual Judge Link</a></p><p>脑子经常不够用，代码经常调不出。</p><p>昨晚打 CF 的时候明显脑子转不动啊，有点怀疑是不是最近写题太多了。感觉以后打比赛之前真的要放空一下自己。</p><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1023F">I. Mobile Phone Network</a></p><p>题意：给定 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的图，边有边权。另给定 <span class="math inline">\(k\)</span> 条没有权值的边，你需要给每条边赋边权使得将这 <span class="math inline">\(k\)</span> 条边加进图中后，这个图至少有一个最小生成树完全覆盖这 <span class="math inline">\(k\)</span> 条边。输出这 <span class="math inline">\(k\)</span> 条边边权和最大是多少。</p><p><span class="math inline">\(1 \le n,k,m\le 5\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>先将给定的 <span class="math inline">\(k\)</span> 条边加进生成树里，再从 <span class="math inline">\(m\)</span> 条边中选权值最小的几条连成一棵完整的生成树。</p><p>此时，对于一条非树边 <span class="math inline">\((x,y,w)\)</span>，相当于一个限制 "生成树上 <span class="math inline">\(x\leftrightarrow y\)</span> 这条路径上的边的权值不能超过 <span class="math inline">\(w\)</span>"。因为超过了就可以把那条边断掉换成这条非树边。</p><p>相当于对于每条非树边，在生成树上将一段路径上的边权取 <span class="math inline">\(\min\)</span>。</p><p>按边权从小到大枚举非树边，此时每条树边只用访问一次，用并查集维护即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) &#123;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k, m;cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);map&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;, <span class="hljs-type">int</span>&gt; my;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;my[&#123;x, y&#125;] = my[&#123;y, x&#125;] = <span class="hljs-number">1</span>;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);dsu.<span class="hljs-built_in">merge</span>(x, y);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 4&gt;&gt; E;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;E.<span class="hljs-built_in">push_back</span>(&#123;w, x, y, i&#125;);<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">merge</span>(x, y)) &#123;f[i] = <span class="hljs-literal">true</span>;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, inf)</span>, <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (my.<span class="hljs-built_in">count</span>(&#123;x, fath&#125;) == <span class="hljs-number">0</span>) &#123;val[x] = <span class="hljs-number">0</span>;&#125; dep[x] = dep[fath] + <span class="hljs-number">1</span>;fa[x] = fath;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);dsu = <span class="hljs-built_in">DSU</span>(n);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y, i] : E) &#123;<span class="hljs-keyword">if</span> (f[i]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">while</span> (x != y) &#123;x = dsu.<span class="hljs-built_in">find</span>(x);y = dsu.<span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;val[x] = <span class="hljs-built_in">min</span>(val[x], w);dsu.<span class="hljs-built_in">merge</span>(fa[x], x);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (val[i] == inf) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;ans += val[i];&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="day-6">【2.20】 Day 6</h2><p><a href="https://vjudge.net/contest/695051">Virtual Judge Link</a></p><p>A 题输出浮点数因为没设置精度一直 wa，lyc 指导之后才知道直接输出来会是科学计数法，十分难绷。</p><div class="note note-info">            <p><a href="https://vjudge.net/problem/AtCoder-abc155_f">F - Perils in Parallel</a></p><p>题意：有 <span class="math inline">\(n\)</span> 个灯，给定每个灯的坐标 <span class="math inline">\(A_i\)</span> 和初始状态 <span class="math inline">\(B_i\)</span>（亮或灭）。另有 <span class="math inline">\(m\)</span> 个操作，形如 "将坐标在 <span class="math inline">\(L_i\)</span> 和 <span class="math inline">\(R_i\)</span> 之间的灯的状态取反"，问是否能让所有灯全灭。若能，给出操作方案。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<span class="math inline">\(1\le m \le 2\cdot10^5\)</span>，<span class="math inline">\(1 \le A_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>离散化是必要的，我们按坐标从小到大给灯标号，然后预处理出每种操作对应灯的标号范围。</p><p>取反等价于异或 <span class="math inline">\(1\)</span>。设按坐标排序后的状态序列为 <span class="math inline">\(\{s\}\)</span>，求出其异或差分数组 <span class="math inline">\(\{t\}\)</span>（即 <span class="math inline">\(t[i]=s[i]\oplus s_[i-1]\)</span>）。那么操作 <span class="math inline">\((L_i,R_i)\)</span> 相当于将 <span class="math inline">\(t[L_i]\)</span> 和 <span class="math inline">\(t[R_i+1]\)</span> 取反，最终目标也转化为使 <span class="math inline">\(\{t\}\)</span> 全为 <span class="math inline">\(0\)</span>（<span class="math inline">\(t[n+1]\)</span> 除外）。</p><p>对每种操作连边 <span class="math inline">\(L_i \leftrightarrow R_{i}+1\)</span>，那么每次肯定是将一条边的两个端点同时取反。</p><p>对于每一个连通分量：从任意一个点（设为 <span class="math inline">\(A\)</span>）开始 dfs，回溯时可以贪心的将当前点与其 dfs 树上的儿子进行操作，使得儿子全为 <span class="math inline">\(0\)</span>。这么做可以使除了 <span class="math inline">\(A\)</span> 之外的所有点为 <span class="math inline">\(0\)</span>。</p><p>接着，能够断言：无解当且仅当 <span class="math inline">\(A\)</span> 的值为 <span class="math inline">\(1\)</span> 且 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(n+1\)</span> 不在一个连通分量。</p><p>因为若在一个连通分量内，可以直接沿着 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(n+1\)</span> 之间的路径一直操作，将 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(1\)</span> 转移给 <span class="math inline">\(n+1\)</span>。</p><p>方案可以在 dfs 时顺便记录。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) &#123;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;a[i] = &#123;x, y&#125;;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;b[i] = a[i][<span class="hljs-number">1</span>] ^ a[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];c[i] = a[i][<span class="hljs-number">0</span>];&#125;map&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;, <span class="hljs-type">int</span>&gt; mp;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">2</span>);<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">auto</span> itL = <span class="hljs-built_in">lower_bound</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">auto</span> itR = <span class="hljs-built_in">upper_bound</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), r);<span class="hljs-keyword">if</span> (itL == c.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> L = itL - c.<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> R = itR == c.<span class="hljs-built_in">end</span>() ? n : itR - c.<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>; <span class="hljs-keyword">if</span> (L &gt; R || mp[&#123;L, R + <span class="hljs-number">1</span>&#125;]) &#123;<span class="hljs-keyword">continue</span>;&#125;dsu.<span class="hljs-built_in">merge</span>(L, R + <span class="hljs-number">1</span>);mp[&#123;L, R + <span class="hljs-number">1</span>&#125;] = mp[&#123;R + <span class="hljs-number">1</span>, L&#125;] = i + <span class="hljs-number">1</span>;adj[L].<span class="hljs-built_in">push_back</span>(R + <span class="hljs-number">1</span>);adj[R + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(L);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;set&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> have_T = <span class="hljs-number">0</span>;vector&lt;<span class="hljs-type">int</span>&gt; son;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;pre[y] = x;<span class="hljs-built_in">self</span>(self, y);<span class="hljs-keyword">if</span> (y == n + <span class="hljs-number">1</span>) &#123;have_T = <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;son.<span class="hljs-built_in">push_back</span>(y);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : son) &#123;<span class="hljs-keyword">if</span> (b[y]) &#123;ans.<span class="hljs-built_in">insert</span>(mp[&#123;x, y&#125;]);b[y] = <span class="hljs-number">0</span>;b[x] ^= <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span> (b[x] &amp;&amp; have_T) &#123;ans.<span class="hljs-built_in">insert</span>(mp[&#123;x, n + <span class="hljs-number">1</span>&#125;]);b[x] = <span class="hljs-number">0</span>;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;<span class="hljs-built_in">dfs</span>(dfs, i);<span class="hljs-keyword">if</span> (b[i]) &#123;<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">same</span>(i, n + <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n + <span class="hljs-number">1</span>; j != i; j = pre[j]) &#123;<span class="hljs-type">int</span> id = mp[&#123;j, pre[j]&#125;];<span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">count</span>(id)) &#123;ans.<span class="hljs-built_in">erase</span>(id);&#125; <span class="hljs-keyword">else</span> &#123;ans.<span class="hljs-built_in">insert</span>(id);&#125;&#125;&#125;&#125;&#125;cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1332F">G - Independent Set</a></p><p>题意：给定一棵 <span class="math inline">\(n\)</span> 个点的树，求它的 <span class="math inline">\(2^{n-1}-1\)</span> 种非空边导出子图的点独立集个数之和。</p><p><span class="math inline">\(2 \le n \le 3 \cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>任意选择一个根节点。</p><p>令 <span class="math inline">\(dp[x][0/1][0/1]\)</span> 表示 "以 <span class="math inline">\(x\)</span> 为根的子树内，是否选 <span class="math inline">\(x\)</span> 上面的边（<span class="math inline">\(x\leftrightarrow fa[x]\)</span>）作为边导出子图的一部分，是否选 <span class="math inline">\(x\)</span> 作为点独立集中的一个元素" 的答案。</p><p>转移如下： <span class="math display">\[\begin{align}&amp;dp[x][0][0]=\prod_{y\in son[x]}dp[y][0][0]+dp[y][0][1]+dp[y][1][0]+dp[y][1][1]\\&amp;dp[x][1][0]=\prod_{y\in son[x]}dp[y][0][0]+dp[y][0][1]+dp[y][1][0]+dp[y][1][1]\\&amp;dp[x][1][1]=\prod_{y\in son[x]}dp[y][0][0]+dp[y][0][1]+dp[y][1][0]\\&amp;dp[x][0][1]=\left(\prod_{y\in son[x]}dp[y][0][0]+dp[y][0][1]+dp[y][1][0]\right)-\left(\prod_{y\in son[x]}dp[y][0][0]+dp[y][0][1]\right)\end{align}\]</span> 前三条根据独立集的定义好理解，最后一条 <span class="math inline">\(dp[x][0][1]\)</span> 代表 <span class="math inline">\(x\)</span> 与其父亲不相连而自己又在独立集中，此时必须保证 <span class="math inline">\(x\)</span> 至少有一个儿子 <span class="math inline">\(y\)</span> 和 <span class="math inline">\(x\)</span> 有边相连。容斥一下就是总方案数减去 "所有儿子都不与 <span class="math inline">\(x\)</span> 连边" 的方案数。</p><p>因为要求边导出子图非空，答案还需要 <span class="math inline">\(-1\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector(<span class="hljs-number">2</span>, vector&lt;mint&gt;(<span class="hljs-number">2</span>)))</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;mint c1 = <span class="hljs-number">1</span>, c2 = <span class="hljs-number">1</span>, c3 = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);c1 *= dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[y][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];c2 *= dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];c3 *= dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];&#125;dp[x][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = c1;dp[x][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = c1;dp[x][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = c2;dp[x][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = c2 - c3;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);cout &lt;&lt; dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1332G">H - No Monotone Triples</a></p><p>题意：给定长为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\{a\}\)</span>，定义三元组 <span class="math inline">\((i,j,k)\)</span> 单调当且仅当 <span class="math inline">\(i&lt;j&lt;k\)</span> 且 <span class="math inline">\(a_i\le a_j\le a_k\)</span> 或 <span class="math inline">\(a_i\ge a_j\ge a_k\)</span>。<span class="math inline">\(q\)</span> 次询问，每次询问 <span class="math inline">\(l,r\)</span>，你需要在 <span class="math inline">\(a[l,r]\)</span> 中找到一个长度至少为 <span class="math inline">\(3\)</span> 且不含单调三元组的子序列 <span class="math inline">\(\{b\}\)</span>。</p><p><span class="math inline">\(3\le n \le 2\cdot 10^5\)</span>，<span class="math inline">\(1 \le q\le 2\cdot 10^5\)</span>，<span class="math inline">\(1 \le a_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>对于长度 <span class="math inline">\(\ge 5\)</span> 的任意数列，若元素互不相同，由 Erdős–Szekeres 定理（详见文末）可知至少存在长为 <span class="math inline">\(3\)</span> 的单调子序列；若有相同元素，单调条件更容易满足。故我们要找的 <span class="math inline">\(\{b\}\)</span> 长度只能是 <span class="math inline">\(3\)</span> 或者 <span class="math inline">\(4\)</span>。</p><p>先说如何找长为 <span class="math inline">\(3\)</span> 的 <span class="math inline">\(\{b\}\)</span>。对于 <span class="math inline">\(\{a\}\)</span> 中每个极长的元素相同段 <span class="math inline">\([L,R]\)</span>，若 <span class="math inline">\((L-1,L,R+1)\)</span> 不是单调三元组，就将 <span class="math inline">\(L-1\)</span> 放入 <span class="math inline">\(\{c\}\)</span> 中。接着还需要预处理 <span class="math inline">\(\text{nxt}[i]\)</span> 代表 <span class="math inline">\(i\)</span> 右侧第一个 <span class="math inline">\(\neq a[i]\)</span> 的元素的下标。对于每个询问 <span class="math inline">\((l,r)\)</span>，二分出 <span class="math inline">\(\{c\}\)</span> 中第一个 <span class="math inline">\(\ge l\)</span> 的 <span class="math inline">\(L\)</span>，若 <span class="math inline">\(\text{nxt}[L+1] \le r\)</span>，则 <span class="math inline">\(\{b\}=\{L,L+1,\text{nxt}[L+1]\}\)</span> 就是一组合法的答案。</p><p>麻烦的是长为 <span class="math inline">\(4\)</span> 的 <span class="math inline">\(\{b\}\)</span>。此时序列的特征是：<span class="math inline">\(b_2,b_3\)</span> 是极值，<span class="math inline">\(b_1,b_4\)</span> 落在值域中间且不等于极值。</p><p>倒着扫描序列，维护两个单调栈 <span class="math inline">\(mn,mx\)</span> 分别存储当前位置往后的非严格前缀最小值和非严格前缀最大值。设当前位置就是 <span class="math inline">\(b_1\)</span>，那么显然 <span class="math inline">\(b_2,b_3\)</span> 一定分别在两个单调栈中，否则更劣。以及 <span class="math inline">\(b_4\)</span> 一定不在两个单调栈中，因为 <span class="math inline">\(b_4\)</span> 不是极值。</p><p>此时，我们有了一个能求出 "若当前位置 <span class="math inline">\(i\)</span> 作为 <span class="math inline">\(p_1\)</span>，<span class="math inline">\(p_4\)</span> 的最小合法取值（记为 <span class="math inline">\(res[i]\)</span>）" 的方法：</p><ul><li>维护一个 <code>std::set</code> 存储不在任何一个单调栈中的元素的下标。</li><li>从两个单调栈中分别找出第一个 <span class="math inline">\(\neq a[i]\)</span> 的元素的下标 <span class="math inline">\(p_2,p_3\)</span>，这可以通过在单调栈上二分实现。</li><li>从 <code>std::set</code> 里二分出第一个 <span class="math inline">\(&gt;\max(p_2,p_3)\)</span> 的下标即为所求最小的 <span class="math inline">\(p_4\)</span>（<span class="math inline">\(res[i]=p_4\)</span>）。</li></ul><p>我们把 <span class="math inline">\(res\)</span> 数组放到线段树上。对于每个询问 <span class="math inline">\([l,r]\)</span>，在线段树上二分找到区间里第一个 <span class="math inline">\(L\)</span> 满足 <span class="math inline">\(res[L]\le r\)</span>，再找到 <span class="math inline">\([L,res[L]]\)</span> 里最大最小值对于的下标 <span class="math inline">\(p_2,p_3(p_2&lt;p_3)\)</span>，则 <span class="math inline">\(\{b\}=\{L,p_2,p_3,res[L]\}\)</span> 就是一组合法的答案。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;    <span class="hljs-type">int</span> n;    vector&lt;Info&gt; tr;    <span class="hljs-built_in">SegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;        n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;        tr.<span class="hljs-built_in">assign</span>((<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>, <span class="hljs-built_in">Info</span>());        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);    &#125;    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = a[l];            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(ls, l, m, a);        <span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        tr[p] = tr[ls] + tr[rs];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = x;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (pos &lt;= m) &#123;            <span class="hljs-built_in">modify</span>(ls, l, m, pos, x);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, pos, x);        &#125;        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, x);    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-keyword">return</span> tr[p];        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findFirst</span>(ls, l, m, ql, qr, pred);        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;            res = <span class="hljs-built_in">findFirst</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFirst</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findLast</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;            res = <span class="hljs-built_in">findLast</span>(ls, l, m, ql, qr, pred);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findLast</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);    &#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<span class="hljs-type">int</span> mn = inf;<span class="hljs-type">int</span> mx = -inf;<span class="hljs-type">int</span> res = inf;    <span class="hljs-built_in">Info</span>() &#123;&#125;    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;    mn = mx = x;    res = y;    &#125;&#125;;Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;    Info c;    c.mn = <span class="hljs-built_in">min</span>(a.mn, b.mn);    c.mx = <span class="hljs-built_in">max</span>(a.mx, b.mx);    c.res = <span class="hljs-built_in">min</span>(a.res, b.res);    <span class="hljs-keyword">return</span> c;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;<span class="hljs-type">int</span>&gt; s, f;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (a[i] != a[i - <span class="hljs-number">1</span>]) &#123;s.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">3</span>) &#123;<span class="hljs-type">int</span> lst = s.<span class="hljs-built_in">back</span>();<span class="hljs-type">int</span> mid = s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>];<span class="hljs-type">int</span> pre = s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>];<span class="hljs-keyword">if</span> (a[mid] &gt; a[lst] &amp;&amp; a[mid] &gt; a[pre]) &#123;f.<span class="hljs-built_in">push_back</span>(pre);&#125;<span class="hljs-keyword">if</span> (a[mid] &lt; a[lst] &amp;&amp; a[mid] &lt; a[pre]) &#123;f.<span class="hljs-built_in">push_back</span>(pre);&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;s.<span class="hljs-built_in">pop_back</span>();s.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-keyword">if</span> (a[i] == a[i + <span class="hljs-number">1</span>]) &#123;nxt[i] = nxt[i + <span class="hljs-number">1</span>];&#125; <span class="hljs-keyword">else</span> &#123;nxt[i] = i + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">auto</span> get3 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">if</span> (it == f.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-type">int</span> L = *it;<span class="hljs-keyword">if</span> (nxt[L + <span class="hljs-number">1</span>] &gt; r) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;3\n&quot;</span>;cout &lt;&lt; L &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; L + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; nxt[L + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;set&lt;<span class="hljs-type">int</span>&gt; outside;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;outside.<span class="hljs-built_in">insert</span>(i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, inf)</span>, <span class="hljs-title">tot</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; mn, mx;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-keyword">while</span> (!mn.<span class="hljs-built_in">empty</span>() &amp;&amp; a[mn.<span class="hljs-built_in">back</span>()] &gt; a[i]) &#123;<span class="hljs-keyword">if</span> (--tot[mn.<span class="hljs-built_in">back</span>()] == <span class="hljs-number">0</span>) &#123;outside.<span class="hljs-built_in">insert</span>(mn.<span class="hljs-built_in">back</span>());&#125;mn.<span class="hljs-built_in">pop_back</span>();&#125;<span class="hljs-keyword">while</span> (!mx.<span class="hljs-built_in">empty</span>() &amp;&amp; a[mx.<span class="hljs-built_in">back</span>()] &lt; a[i]) &#123;<span class="hljs-keyword">if</span> (--tot[mx.<span class="hljs-built_in">back</span>()] == <span class="hljs-number">0</span>) &#123;outside.<span class="hljs-built_in">insert</span>(mx.<span class="hljs-built_in">back</span>());&#125;mx.<span class="hljs-built_in">pop_back</span>();&#125;mn.<span class="hljs-built_in">push_back</span>(i);mx.<span class="hljs-built_in">push_back</span>(i);outside.<span class="hljs-built_in">erase</span>(i);tot[i] += <span class="hljs-number">2</span>;<span class="hljs-type">int</span> resmn = <span class="hljs-number">-1</span>, resmx = <span class="hljs-number">-1</span>;<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = mn.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (a[i] != a[mn[mid]]) &#123;resmn = mn[mid];l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;r = mid - <span class="hljs-number">1</span>;&#125;&#125; l = <span class="hljs-number">0</span>, r = mx.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (a[i] != a[mx[mid]]) &#123;resmx = mx[mid];l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;r = mid - <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span> (resmn == <span class="hljs-number">-1</span> || resmx == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">auto</span> it = outside.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">max</span>(resmn, resmx));<span class="hljs-keyword">if</span> (it == outside.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;res[i] = *it;&#125;<span class="hljs-function">vector&lt;Info&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;tmp[i] = <span class="hljs-built_in">Info</span>(a[i], res[i]);&#125;<span class="hljs-function">SegmentTree&lt;Info&gt; <span class="hljs-title">seg</span><span class="hljs-params">(tmp)</span></span>;<span class="hljs-keyword">auto</span> get4 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<span class="hljs-type">int</span> p1 = seg.<span class="hljs-built_in">findFirst</span>(l, r, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.res &lt;= r;&#125;);<span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-type">int</span> p4 = res[p1];<span class="hljs-type">int</span> mn = seg.<span class="hljs-built_in">query</span>(p1, p4).mn;<span class="hljs-type">int</span> mx = seg.<span class="hljs-built_in">query</span>(p1, p4).mx;<span class="hljs-type">int</span> p2 = seg.<span class="hljs-built_in">findFirst</span>(p1, p4, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.mn &lt;= mn;&#125;);<span class="hljs-type">int</span> p3 = seg.<span class="hljs-built_in">findFirst</span>(p1, p4, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.mx &gt;= mx;&#125;);<span class="hljs-keyword">if</span> (p2 &gt; p3) &#123;<span class="hljs-built_in">swap</span>(p2, p3);&#125;cout &lt;&lt; <span class="hljs-string">&quot;4\n&quot;</span>;cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p4 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get4</span>(l, r) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">get3</span>(l, r) == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-primary">            <p><strong>Dilworth 定理</strong>：任意有限偏序集中，最长链的长度等于最小的反链划分的数量。</p><ul><li>将序列中的每个值看成一个元素，定义偏序关系：对于集合中的两个元素 <span class="math inline">\(a,b\)</span>，<span class="math inline">\(a≺b\)</span> 当且仅当 <span class="math inline">\(a&lt;b\)</span> 。Dilworth 定理在此基础上给出的结论就是：<strong>一个序列的最长上升子序列的长度（LIS）等于将该序列划分成不上升子序列的最小数量</strong>。</li></ul><p>通俗来说，若序列的 LIS 长度为 <span class="math inline">\(k\)</span>，则至少需要 <span class="math inline">\(k\)</span> 个不上升的子序列才能覆盖整个序列，且无法用更少的子序列完成覆盖。</p><ul><li>同样地，若定义偏序关系：对于集合中的两个元素 <span class="math inline">\(a,b\)</span>，<span class="math inline">\(a\preccurlyeq b\)</span> 当且仅当 <span class="math inline">\(a\le b\)</span>。则有：<strong>一个序列的最长不下降子序列的长度等于将该序列划分成严格下降子序列的最小数量</strong>。</li></ul><p><strong>Erdős–Szekeres 定理</strong>是 Dilworth 定理的一个简单推论，内容是：</p><ul><li>对于 <span class="math inline">\(mn+1\)</span> 个互不相同的实数组成的数列 <span class="math inline">\((m,n\in \text{N}^+)\)</span>，一定存在长为 <span class="math inline">\(m+1\)</span> 的递增子列或长为 <span class="math inline">\(n+1\)</span> 的递减子列。</li><li>二维欧式平面上任意 <span class="math inline">\(mn+1\)</span> 个点总能构造出 <span class="math inline">\(m+1\)</span> 条正斜率线段或 <span class="math inline">\(n+1\)</span> 条负斜率线段。（只要该坐标系下任意两点横纵坐标都不同）</li></ul><p>对于第一条，设这个序列的 LIS 长度为 <span class="math inline">\(k\)</span>，若 <span class="math inline">\(k\ge m+1\)</span>，成立；若 <span class="math inline">\(k&lt;m+1\)</span>，应用 Dilworth 定理，将该序列划分成下降子序列的最小数量是 <span class="math inline">\(k\)</span>。序列被划分成了 <span class="math inline">\(k\)</span> 段，这样划分出最长的下降序列的长度 <span class="math inline">\(l\)</span> 的最小值是 <span class="math inline">\(\lceil\frac{mn+1}{k}\rceil\)</span>（因为均分最优），又 <span class="math inline">\(k&lt;m+1\)</span>，不难得出 <span class="math inline">\(l\ge n+1\)</span>，得证。</p>          </div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>UESTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】寒假训练日记</title>
    <link href="/posts/abc8fb81.html"/>
    <url>/posts/abc8fb81.html</url>
    
    <content type="html"><![CDATA[<p>寒假给自己定的要求是 vp 后补 *2500 以下的题，有些 &gt; 2500 但我感兴趣的题也会补。</p><h2 id="cf2048f.-kevin-and-math-class"><a href="https://codeforces.com/contest/2048/problem/F">CF2048F. Kevin and Math Class</a></h2><p>*2500 <a href="https://codeforces.com/contest/2048/submission/300486188">Code</a></p><p>对于 <span class="math inline">\(b_x\)</span>，找到 <span class="math inline">\(b_x\)</span> 左侧第一个 <span class="math inline">\(l\)</span> 使得 <span class="math inline">\(b_l &lt; b_x\)</span>，右侧第一个 <span class="math inline">\(r\)</span> 使得 <span class="math inline">\(b_r &lt; b_x\)</span>。</p><p>那么要让 <span class="math inline">\(b_x\)</span> 当最小值，区间最大就是 <span class="math inline">\([l+1,r-1]\)</span>，又我们肯定是选尽可能大的区间，所以要除 <span class="math inline">\(b_x\)</span> 时肯定是对区间 <span class="math inline">\([l+1,r-1]\)</span> 操作。</p><p>于是建出 <span class="math inline">\((i,b_i)\)</span> 的小根笛卡尔树，我们一定是操作笛卡尔树上的区间。</p><p>又 <span class="math inline">\(b_i \ge 2\)</span>，所以每个区间操作不会超过 <span class="math inline">\(64\)</span> 次。</p><p>令 <span class="math inline">\(dp[x][i]\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树对应的区间，操作 <span class="math inline">\(i\)</span> 次后区间最大值最小是多少。 <span class="math display">\[\begin{align}dp[x][k] = \min_{k=i+j}(\max(dp[ls[x]][i],dp[rs[x]][j],a[x]))\\dp[x+1][k] = \min(dp[x+1][k],\left\lceil\frac{dp[x][k]}{b[x]}\right\rceil)\end{align}\]</span> 答案是使 <span class="math inline">\(dp[rt][i]=1\)</span> 的最小的 <span class="math inline">\(i\)</span>。<span class="math inline">\(rt\)</span> 是笛卡尔树的根。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2w)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><p>题解说可以用 <span class="math inline">\(\min-\max\)</span> 卷积优化到 <span class="math inline">\(O(n\log w)\)</span>，但我琢磨了一下不是很会。</p><p>实测双 <span class="math inline">\(\log\)</span> 跑了 1.1s &lt; 2s。</p><h2 id="cf1976d.-invertible-bracket-sequences"><a href="https://codeforces.com/contest/1976/problem/D">CF1976D. Invertible Bracket Sequences</a></h2><p>*2000 <a href="https://codeforces.com/contest/1976/submission/300528983">Code</a></p><p>把左括号看成 <span class="math inline">\(1\)</span>，右括号看成 <span class="math inline">\(-1\)</span>，求前缀和，可以作出折线图。</p><p>一段折线如果要翻转后也形成合法括号序列，需要满足两个条件：</p><ul><li>两端纵坐标相等。</li><li>翻转后最高点不能越过 <span class="math inline">\(x\)</span> 轴。</li></ul><p>第一个条件即 <span class="math inline">\(sum_l = sum_r\)</span>，第二个条件即 <span class="math inline">\(\max\limits_{l\le i\le r}sum_{i}\le2sum_l\)</span>。</p><p>最大值可以用 ST 表或线段树维护，然后沿 <span class="math inline">\(y\)</span> 轴做扫描线即可。注意对于同一 <span class="math inline">\(y\)</span> 坐标，若有三个点满足 <span class="math inline">\(sum_l=sum_m=sum_r\)</span>，且 <span class="math inline">\([l, m]\)</span> 和 <span class="math inline">\([m,r]\)</span> 满足要求，那么 <span class="math inline">\([l,r]\)</span> 也满足要求。使用一个计数器累加即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1976e.-splittable-permutations"><a href="https://codeforces.com/contest/1976/problem/E">CF1976E. Splittable Permutations</a></h2><p>*2500 <a href="https://codeforces.com/contest/1976/submission/300596121">Code</a></p><p>这题最关键的观察：出现在 <span class="math inline">\(l[i]\)</span>，<span class="math inline">\(r[i]\)</span> 中的所有数的相对位置是可以唯一确定的。</p><ul><li>首先对于一组 <span class="math inline">\((l, r)\)</span>，<span class="math inline">\(l\)</span> 肯定在 <span class="math inline">\(r\)</span> 的左边。倒着扫描序列，每次相当于一次合并。设 <span class="math inline">\(l\)</span> 目前所在的序列为 <span class="math inline">\(a\)</span>，<span class="math inline">\(r\)</span> 目前所在的序列为 <span class="math inline">\(b\)</span>，那么合并后新序列的相对顺序一定是 <span class="math inline">\(b\)</span> 中的元素按顺序拼接在 <span class="math inline">\(a\)</span> 的后面。这个性质可以手玩出来。</li></ul><p>并查集记录这个数属于哪个连通块，再用双向链表连接，就能求出这个相对顺序。</p><p>接着还有一些数没在 <span class="math inline">\(l[i]\)</span>，<span class="math inline">\(r[i]\)</span> 中出现过，我们考虑把它们插进去。</p><p>又一个观察：一个数 <span class="math inline">\(x\)</span> 能插进 <span class="math inline">\(A,B\)</span> 之间的必要条件是 <span class="math inline">\(x\le \max(A,B)\)</span>。</p><ul><li>比较显然。</li></ul><p>于是从大到小枚举要插的数，用一个计数器统计每次有多少空可以插，乘起来就是答案。</p><p>时间复杂度<span class="math inline">\(O(n\alpha)\)</span>。</p><h2 id="cf2055d.-scarecrow"><a href="https://codeforces.com/contest/2055/problem/D">CF2055D. Scarecrow</a></h2><p>*2000 <a href="https://codeforces.com/contest/2055/submission/301662039">Code</a></p><p>设当前使用的时间是 <span class="math inline">\(t\)</span>，乌鸦当前在 <span class="math inline">\(p\)</span>。</p><p>首先离 <span class="math inline">\(0\)</span> 最近的稻草人要移到 <span class="math inline">\(0\)</span>，那么令初值 <span class="math inline">\(t = a[0]\)</span>，<span class="math inline">\(p=k\)</span>。</p><p>一个观察是：你是被你左边最近的稻草人推着走的，与此同时右边最近的稻草人可以按情况选择左移，不动，或右移来减少你转移到它（也就是被它推着走）的时间。</p><p>那么从左到右扫描每个稻草人，做出如下分类讨论：</p><ul><li><span class="math inline">\(a[i]-t&gt;p\)</span>，即之前的时间都向左移都还在乌鸦的右边时，选择花时间继续向左，与此同时乌鸦也被它左边的稻草人推着向右，所以需要 <span class="math inline">\(t&#39;=(a[i]-t-p)/2\)</span>。那么 <span class="math inline">\(t=t+t&#39;\)</span>，乌鸦转移到 <span class="math inline">\(p=p+t&#39;+k\)</span>。</li><li><span class="math inline">\(a[i]-t\le p\)</span> 时，分两种情况。<ul><li><span class="math inline">\(a[i]+t\le p\)</span>，也就是之前的时间一直向右移也在乌鸦的左边，那就取个 <span class="math inline">\(\max\)</span>，即 <span class="math inline">\(p=\max(p,a[i]+t+k)\)</span>。</li><li><span class="math inline">\(a[i]+t&gt;p\)</span>，也就是之前的时间足够右移到乌鸦右边了，此时肯定是恰好停在 $ p$ 不用花额外的时间，所以 <span class="math inline">\(p = p+k\)</span>。</li></ul></li></ul><p>最后如果 <span class="math inline">\(p&lt;l\)</span>，就加上 <span class="math inline">\(l-p\)</span>，代表最后一个稻草人把它推向终点。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2057e1e2.-another-exercise-on-graphs"><a href="https://codeforces.com/contest/2057/problem/E2">CF2057E1/E2. Another Exercise on Graphs</a></h2><p>*2300 <a href="https://codeforces.com/contest/2057/submission/301679582">Code</a>（E1）</p><p>*2500 <a href="https://codeforces.com/contest/2057/submission/301730095">Code1</a> <a href="https://codeforces.com/contest/2057/submission/301732253">Code2</a>（E2）</p><p>先考虑这样一个事情：我们将原图 copy 一份，对于新图上的每条边，如果原图的边权 <span class="math inline">\(\le x\)</span>，则赋值为 <span class="math inline">\(0\)</span>，否则赋值为 <span class="math inline">\(1\)</span>。那么 <span class="math inline">\(a\to b\)</span> 在新图上的最短路为 <span class="math inline">\(w \Longleftrightarrow\)</span> <span class="math inline">\(x\)</span> 为原图中 <span class="math inline">\(a\to b\)</span> 路径上第 <span class="math inline">\(w+1\)</span> 大的边。</p><p>那么得到一个暴力做法：从小到大枚举所有的边权 <span class="math inline">\(x\)</span>，按上述规则赋值跑最短路，直到第一个 <span class="math inline">\(w\)</span> 满足 <span class="math inline">\(w+1\le k\)</span>，此时 <span class="math inline">\(x\)</span> 就是答案。</p><p>进一步地，<span class="math inline">\(x\)</span> 每次增大都相当于把一些边（即边权等于新 <span class="math inline">\(x\)</span> 的边）由 <span class="math inline">\(1\to 0\)</span>，我们利用 floyd 枚举这些边的两个端点为中转点就可以很快地更新答案。具体地，更新一次是 <span class="math inline">\(O(n^2)\)</span>，更新不超过 <span class="math inline">\(m\)</span> 次。</p><p>至于多组询问，用 <span class="math inline">\(dis[a][b][x]\)</span> 表示对 <span class="math inline">\(\le x\)</span> 的边赋值为 <span class="math inline">\(0\)</span>，否则赋值为 <span class="math inline">\(1\)</span> 后 <span class="math inline">\(a\to b\)</span> 的最短路，每次询问就对 <span class="math inline">\(dis[a][b][\cdot]\)</span> 二分出第一个 <span class="math inline">\(\le k-1\)</span> 的值对应的 <span class="math inline">\(x\)</span> 就是答案。</p><p>由于要枚举每个边权，时间复杂度 <span class="math inline">\(O(mn^2)\)</span>，能够通过 E1。</p><p>注意我们把一些边由 <span class="math inline">\(1\to0\)</span> 的过程，如果对于所有边权为 <span class="math inline">\(x\)</span> 的边 <span class="math inline">\((a,b)\)</span>，<span class="math inline">\(dis[a][b]\)</span> 都已经为 <span class="math inline">\(0\)</span>，那么此次更新就是不必要的，就能省下一个 <span class="math inline">\(O(n^2)\)</span>。</p><p>实际上，可以证明这样的更新最多进行 <span class="math inline">\(n\)</span> 次：如果当前边 <span class="math inline">\((a,b)\)</span> 有 <span class="math inline">\(dis[a][b]\neq0\)</span>，那么 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 中的至少一个需要来自之前没更新过的点，而一共就 <span class="math inline">\(n\)</span> 个点，故得证。</p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>，能够通过 E2。</p><p>事实上，回答询问的时候二分并不是必要的。一样是从小到大枚举边权 <span class="math inline">\(x\)</span> 并赋值，但你只需要在 floyd 更新的时候顺便记一下就行了，细节可以阅读 jiangly 的代码。</p><h2 id="cf2060e.-graph-composition"><a href="https://codeforces.com/contest/2060/problem/E">CF2060E. Graph Composition</a></h2><p>*1500 <a href="https://codeforces.com/contest/2060/submission/301963287">Code</a></p><p>很容易想的很复杂，实际上只需要两步：</p><ul><li>把 <span class="math inline">\(F\)</span> 的一些边断掉使得 <span class="math inline">\(F\)</span> 的任意同一连通分量中的点都在 <span class="math inline">\(G\)</span> 中连通。</li><li>把 <span class="math inline">\(F\)</span> 的一些连通分量组合得到 <span class="math inline">\(G\)</span>。</li></ul><p>第一步只用枚举 <span class="math inline">\(F\)</span> 的每条边 <span class="math inline">\(a\to b\)</span> 然后用并查集看在 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(a,b\)</span> 是否连通，不连通需要花费 <span class="math inline">\(1\)</span> 的代价割掉。</p><p>第二步花费的代价一定是 <span class="math inline">\(F\)</span> 的连通分量个数 <span class="math inline">\(-\)</span> <span class="math inline">\(G\)</span> 的连通分量个数。</p><p>时间复杂度 <span class="math inline">\(O(n\alpha)\)</span>。</p><h2 id="cf2061e.-kevin-and-and"><a href="https://codeforces.com/contest/2061/problem/E">CF2061E. Kevin and And</a></h2><p>*2000 <a href="https://codeforces.com/contest/2061/submission/302339557">Code</a></p><p>题目要让总和最小，一个容易想到的贪心是：每一步操作都让总和尽可能地变小，也就是每次都采取能让总和变化量最大的操作。在以下叙述中，把减少的量称为收益。</p><p>要说明这个贪心是对的，得先证明一个结论：对于一个固定的 <span class="math inline">\(a_i\)</span>，设 <span class="math inline">\(f(j)\)</span> 代表对 <span class="math inline">\(a_i\)</span> 使用 <span class="math inline">\(j\)</span> 次魔法能获得的最大的收益，那么 <span class="math inline">\(f(j)-f(j-1)\)</span> 递减（即 <span class="math inline">\(f(j)\)</span> 是凸的）。</p><ul><li>感性证明："使用两次魔法相对于使用一次魔法" 带来的收益不可能超过 "使用一次魔法相对于不使用魔法" 带来的收益。否则此时使用一次魔法带来的收益并非是最大的。</li></ul><p>基于这个结论，我们可以对于每个 <span class="math inline">\(i\in[1,n]\)</span>，把所有的 <span class="math inline">\(f(j)-f(j-1),j\in[1,m]\)</span> 记下来，排序之后选最大的 <span class="math inline">\(k\)</span> 个值相加即最大收益。</p><p>代码实现过程中，把 <span class="math inline">\(m\)</span> 个魔法是否使用压缩成一个状态，可以先 <span class="math inline">\(O(2^m\cdot m)\)</span> 求出每种状态的累加效果（即按位与后的结果），再 <span class="math inline">\(O(n\cdot 2^m)\)</span> 对每个 <span class="math inline">\(a_i\)</span> 求出 <span class="math inline">\(f(1\sim m)\)</span>。</p><p>时间复杂度：<span class="math inline">\(O(n2^m+nm\log nm)\)</span>。</p><p>如果使用 <code>std::nth_element</code> 可以省去最后的 <span class="math inline">\(\log\)</span>。</p><h2 id="cf2061f1.-kevin-and-binary-string-easy-version"><a href="https://codeforces.com/contest/2061/problem/F1">CF2061F1. Kevin and Binary String (Easy Version)</a></h2><p>*2100 <a href="https://codeforces.com/contest/2061/submission/302357467">Code</a></p><p>对于串 <span class="math inline">\(\cdots011001\cdots\)</span>，交换中间的 <span class="math inline">\(11\)</span> 和 <span class="math inline">\(00\)</span>，会让交换后的 <span class="math inline">\(00\)</span> 与左边的 <span class="math inline">\(0\)</span> 粘连，<span class="math inline">\(11\)</span> 与右边的 <span class="math inline">\(1\)</span> 粘连。而一旦粘连，只能一起移动，因此整块的 <span class="math inline">\(1\)</span> 是无法跨越另一个整块的 <span class="math inline">\(1\)</span> 的，整块的 <span class="math inline">\(0\)</span> 也无法跨越另一个整块的 <span class="math inline">\(0\)</span>。</p><p>这就说明了 <span class="math inline">\(s\)</span> 要想变成 <span class="math inline">\(t\)</span>，可以进行以下贪心：从左到右扫描，当 <span class="math inline">\(s[i]\neq t[i]\)</span> 时，就从 <span class="math inline">\(i\)</span> 后边找最近的整块的 <span class="math inline">\(t[i]\)</span> 修补。</p><p>例如，<span class="math inline">\(s=001\color{Red}0\)</span><span class="math inline">\(1\color{Red}00\)</span><span class="math inline">\(101\)</span>，<span class="math inline">\(t=00\color{Green}000\)</span><span class="math inline">\(1111\)</span>。当 <span class="math inline">\(i=3\)</span> 时，<span class="math inline">\(s[i]\neq t[i]\)</span>，且 <span class="math inline">\(t\)</span> 此时还有连续 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(0\)</span>，故要从 <span class="math inline">\(s[3]\)</span> 后边找 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(0\)</span>。找到第一个 <span class="math inline">\(0\)</span> 块有 <span class="math inline">\(1\)</span> 个 <span class="math inline">\(0\)</span>，还需要找 <span class="math inline">\(2\)</span> 个，再往后找到下一个 <span class="math inline">\(0\)</span> 块就恰好找到 <span class="math inline">\(2\)</span> 个。</p><p>而 <span class="math inline">\(s=001\color{Red}0\)</span><span class="math inline">\(1\color{Red}00\)</span><span class="math inline">\(011\)</span>，<span class="math inline">\(t=00\color{Green}000\)</span><span class="math inline">\(1111\)</span> 就无法匹配上，因为往后找只能找到 <span class="math inline">\(1\)</span> 个或 <span class="math inline">\(4\)</span> 个 <span class="math inline">\(0\)</span>，不能补上 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(0\)</span> 的缺口。</p><p>具体实现时可以用容器把 <span class="math inline">\(1,0\)</span> 的位置存起来以便快速向后查找，另有若干细节不再赘述。</p><p>时间复杂度：<span class="math inline">\(O(n)\)</span> 或 <span class="math inline">\(O(n\log n)\)</span>。（依据实现方式）</p><h2 id="cf2056d.-unique-median"><a href="https://codeforces.com/contest/2056/problem/D">CF2056D. Unique Median</a></h2><p>*2200 <a href="https://codeforces.com/contest/2056/submission/302570099">Code</a></p><p>容斥，用全集 <span class="math inline">\(\frac{n(n+1)}{2}\)</span> 减去中位数不等的子串个数。</p><p>注意到值域很小，故枚举两个中位数中较小的那个（记为 <span class="math inline">\(x\)</span>）。将数组中 <span class="math inline">\(\le x\)</span> 的置为 <span class="math inline">\(-1\)</span>，<span class="math inline">\(&gt;x\)</span> 的置为 <span class="math inline">\(1\)</span> 求出前缀和 <span class="math inline">\(pre\)</span>，那么子串 <span class="math inline">\((i,j)\)</span> 中位数不等 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(pre[i-1]=pre[j]\)</span>。</p><p>由于 <span class="math inline">\(pre[i-1]=pre[j]\)</span> 时对应的串长定为偶数，所以不用考虑奇数长度的判断。</p><p>故我们只需要计数有多少个二元组 <span class="math inline">\((l,r)\)</span> 满足 <span class="math inline">\(pre[l]=pre[r]\)</span> 且区间 <span class="math inline">\([l+1,r]\)</span> 中有 <span class="math inline">\(x\)</span>。</p><p>一种方法是枚举 <span class="math inline">\(i=1\cdots n\)</span>，以及一个指针 <span class="math inline">\(j\)</span>，初始 <span class="math inline">\(j=0\)</span>。当 <span class="math inline">\(a[i]=x\)</span> 时，<span class="math inline">\(j\)</span> 就跟上 <span class="math inline">\(i\)</span> 并把路上的 <span class="math inline">\(pre[j]\)</span> 都加进桶里，然后累加桶里 <span class="math inline">\(pre[i]\)</span> 的数目。正确性显然，即这样两个 <span class="math inline">\(x\)</span> 之间的 <span class="math inline">\(pre\)</span> 值无法造成贡献。</p><p>时间复杂度 <span class="math inline">\(O(wn\log n)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p><h2 id="cf2056e.-nested-segments"><a href="https://codeforces.com/contest/2056/problem/E">CF2056E. Nested Segments</a></h2><p>*2500 <a href="https://codeforces.com/contest/2056/submission/302750497">Code</a></p><p>观察 <span class="math inline">\(1\)</span>：当 <span class="math inline">\(m=0\)</span> 时最多能向 <span class="math inline">\([1,n]\)</span> 中填 <span class="math inline">\(2n-1\)</span> 条线段。</p><ul><li>草稿纸画几笔易得。</li></ul><p>观察 <span class="math inline">\(2\)</span>：当 <span class="math inline">\(m=0\)</span> 时向 <span class="math inline">\([1,n]\)</span> 中填 <span class="math inline">\(2n-1\)</span> 条线段的方案数是 <span class="math inline">\(C_{n-1}\)</span>，其中 <span class="math inline">\(C\)</span> 为卡特兰数。</p><ul><li>考虑这样一个事情：把 <span class="math inline">\([1,n]\)</span> 当作根节点，<span class="math inline">\([1, 1],[2, 2],\cdots,[n,n]\)</span> 当作叶节点，若 <span class="math inline">\([L,R]\)</span> 包含 <span class="math inline">\([l,r]\)</span> 且 <span class="math inline">\([L, R]\)</span> 极小，就连一条边，最终连成一棵树。同时，当填满 <span class="math inline">\(2n-1\)</span> 条线段时，这一定是一棵满位置二叉树（每个节点有 <span class="math inline">\(0\)</span> 个或 <span class="math inline">\(2\)</span> 个儿子），因为如果有 <span class="math inline">\(&gt;2\)</span> 个儿子，我们一定可以取出两个为其添加一个父亲。</li><li>接着套用结论：有 <span class="math inline">\(n\)</span> 个叶子的满位置二叉树数量为 <span class="math inline">\(C_{n-1}\)</span>。末尾的第二个参考链接附有示例。</li></ul><p>观察 <span class="math inline">\(3\)</span>：当 <span class="math inline">\(m\neq 0\)</span> 时，<span class="math inline">\([1,n]\)</span> 中仍然能填满 <span class="math inline">\(2n-1\)</span> 条线段。</p><ul><li>虽然题目预先给出了一些线段，但保证了已经给出的是好的。草稿纸再画几笔发现我们仍然能建出一个有 <span class="math inline">\(n\)</span> 个儿子的满位置二叉树。</li></ul><p>我们可以先把题给线段构成的树建出来（如果没有 <span class="math inline">\([1,n]\)</span> 的话就为它添加），这时的树有些节点（设为 <span class="math inline">\(x\)</span>）有 <span class="math inline">\(&gt;2\)</span> 个儿子，不妨将 <span class="math inline">\(x\)</span> 的儿子设为 <span class="math inline">\([l_1,r_1],[l_2,r_2],\cdots[l_k,r_k]\)</span>。对于 <span class="math inline">\(\forall i\in[1,k)\)</span>，若 <span class="math inline">\(r_i \neq l_{i+1}\)</span>，那么一定可以添加线段 <span class="math inline">\([r_i+1,r_i+1],[r_i+2,r_i+2],\cdots,[l_{i+1}-1,l_{i+1}-1]\)</span> 在中间。</p><p>再设如此填充线段后 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(p\)</span> 个儿子，我们的目标就是把这个以 <span class="math inline">\(x\)</span> 为根的子树建成一棵满位置二叉树，而这么做的方案数恰好等价于有 <span class="math inline">\(p\)</span> 个叶子的满位置二叉树数量，即 <span class="math inline">\(C_{p-1}\)</span>。</p><p>于是对于每一条线段，它的贡献都是一个卡特兰数，累乘起来就是最终的方案数。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><p>一些卡特兰数模型：<a href="https://zhuanlan.zhihu.com/p/31317307">Link1</a> <a href="https://zhuanlan.zhihu.com/p/31526354">Link2</a> <a href="https://zhuanlan.zhihu.com/p/609104268">Link3</a>。</p><p>记忆：<span class="math inline">\(C_{n}=\binom{2n}{n}-\binom{2n}{n-1}\)</span>。</p><h2 id="cf2063f1f2.-counting-is-not-fun"><a href="https://codeforces.com/contest/2063/problem/F2">CF2063F1/F2. Counting Is Not Fun</a></h2><p>*2400 <a href="https://codeforces.com/contest/2063/submission/302767057">Code</a>（F1）</p><p>*2700 <a href="https://codeforces.com/contest/2063/submission/302848292">Code</a>（F2）</p><p>我们将一组 good pair <span class="math inline">\((l,r)\)</span> 看成覆盖 <span class="math inline">\([l,r]\)</span> 的线段，显然任何时候的任意两条线段都要么不交要么完全包含。和这篇文章的上一题及其相似，我们把具有包含关系的线段连边（对于 <span class="math inline">\([l,r]\)</span>，若能找到极小的 <span class="math inline">\([L,R]\)</span> 使其包含 <span class="math inline">\([l,r]\)</span>，就在这两条线段间连一条边），会连成一棵森林。</p><p>令 <span class="math inline">\(f[i]\)</span> 表示第 <span class="math inline">\(i\)</span> 条线段去掉两个端点后没有被其儿子覆盖的长度。这个长度内我们可以自由填。</p><p>定理：用 <span class="math inline">\(n\)</span> 对括号填满 <span class="math inline">\(2n\)</span> 个位置构成平衡括号序列的方案数为 <span class="math inline">\(C_{n}\)</span>（卡特兰数的第 <span class="math inline">\(n\)</span> 项） 。</p><p>于是答案即为 <span class="math inline">\(\prod\limits_{i=1}^m C_{f[i]/2}\)</span>，<span class="math inline">\(m\)</span> 为当前添加的括号组数。</p><p>F1 中，我们可以每次添加括号后 <span class="math inline">\(O(n)\)</span> 地去扫这个序列，求出 <span class="math inline">\(f[i]\)</span>。</p><p>具体地，把非右括号装进栈，扫到右括号时计数弹出了多少元素。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><p>F2 需要动态地维护 <span class="math inline">\(f[i]\)</span>，题解给出了一种平衡树做法，但离线是简单的，这里只讲离线怎么做。</p><p>倒着操作，相当于每次拿走一组括号，此时只有这条线段本身和其父亲的贡献发生了变化。具体地，设当前为第 <span class="math inline">\(i\)</span> 条线段，父亲为第 <span class="math inline">\(fa_i\)</span> 条线段，那么答案只需要在之前答案的基础上加上 <span class="math inline">\(-C_{f[i]/2}-C_{f[fa_i]/2}+C_{(f[fa_i]+f[i]+2)/2}\)</span>。</p><p>快速定位到父亲是哪条线段可以用并查集，时间复杂度 <span class="math inline">\(O(n\log n + n\alpha)\)</span>。</p><h2 id="cf2063e.-triangle-tree"><a href="https://codeforces.com/contest/2063/problem/E">CF2063E. Triangle Tree</a></h2><p>*2300 <a href="https://codeforces.com/contest/2063/submission/302994147">Code</a></p><p>草稿纸画一画，易知： <span class="math display">\[\begin{align}f(x,y)&amp;= 2\min(\text{dis}(x,\text{lca}_{x,y}),\text{dis}(y,\text{lca}_{x,y}))-1 \\&amp;= 2\min(\text{dep}_x,\text{dep}_y)-2\text{dep}_{\text{lca}_{x,y}}-1\end{align}\]</span> 前提是 <span class="math inline">\(x,y\)</span> 没有祖先关系。</p><p>这样就把贡献拆成了三部分，可以分别计算：</p><ul><li><span class="math inline">\(\min(\text{dep}_x, \text{dep}_y)\)</span>：枚举 <span class="math inline">\(x\)</span>，则每个深度比 <span class="math inline">\(x\)</span> 大且不在 <span class="math inline">\(x\)</span> 子树中的 <span class="math inline">\(y\)</span> 有 <span class="math inline">\(\text{dep}_x\)</span> 的贡献。令 <span class="math inline">\(d_x\)</span> 表示深度 <span class="math inline">\(\ge x\)</span> 的节点数（可以通过一个后缀和实现），分为两种情况。<ul><li><span class="math inline">\(\text{dep}_x &lt; \text{dep}_y\)</span>：贡献为 <span class="math inline">\((d_{dep_x+1}-(sz_x-1))\times dep_x\)</span>。</li><li><span class="math inline">\(\text{dep}_x=\text{dep}_y\)</span>：贡献为 <span class="math inline">\((d_{dep_x}-d_{dep_x+1}-1)\times dep_x\)</span>，最后要除以 <span class="math inline">\(2\)</span> 使无序对 <span class="math inline">\(\to\)</span> 有序对。</li></ul></li><li><span class="math inline">\(\text{dep}_{\text{lca}_{x,y}}\)</span>：枚举 <span class="math inline">\(\text{lca}\)</span>，对于当前点 <span class="math inline">\(x\)</span>，贡献为 <span class="math inline">\(\sum_{y\in son[x]}sz_y\times (sz_x-1-sz_y)\times dep_x\)</span>。</li><li><span class="math inline">\(1\)</span>：即没有祖先关系的 <span class="math inline">\((x,y)\)</span> 组数。对于当前点 <span class="math inline">\(x\)</span>，贡献为 <span class="math inline">\(n-sz_x-dep_x+1\)</span>。</li></ul><p>第 <span class="math inline">\(2, 3\)</span> 部分最后也需要除以 <span class="math inline">\(2\)</span>，从而只计算有序对。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2060f.-multiplicative-arrays"><a href="https://codeforces.com/contest/2060/problem/F">CF2060F. Multiplicative Arrays</a></h2><p>*2200 <a href="https://codeforces.com/contest/2060/submission/303010975">Code</a></p><p>首先注意到构造出的 <span class="math inline">\(\{a\}\)</span> 中 <span class="math inline">\(&gt; 1\)</span> 的数不超过 <span class="math inline">\(16\)</span> 个（因为 <span class="math inline">\(2^{17}&gt;10^5\)</span>）。</p><p>于是这个计数分为两步：</p><ol type="1"><li><p>算 <span class="math inline">\(&gt;1\)</span> 的数构成 <span class="math inline">\(x\)</span> 有多少种可能。</p></li><li><p>算剩下的 <span class="math inline">\(1\)</span> 有多少种插空方法。</p></li></ol><p>令 <span class="math inline">\(dp[i][j]\)</span> 代表 <span class="math inline">\(i\)</span> 个 <span class="math inline">\(&gt;1\)</span> 的数构成 <span class="math inline">\(j\)</span> 的方案数。</p><ul><li>初态：<span class="math inline">\(\forall i\in[2,k]\)</span>，<span class="math inline">\(dp[1][i]=1\)</span>。</li><li>转移：<span class="math inline">\(dp[i][j] = \sum\limits_{k&gt;1} dp[i-1][\dfrac{j}{k}]\)</span>。</li></ul><p>令 <span class="math inline">\(ans[x]\)</span> 代表乘积为 <span class="math inline">\(x\)</span> 时的方案数，当 <span class="math inline">\(x=1\)</span> 时显然为 <span class="math inline">\(n\)</span>，当 <span class="math inline">\(x &gt; 1\)</span> 时： <span class="math display">\[ans[x]=\sum_{i=1}^{n}\sum_{j=1}^{16} dp[j][x]\binom{i}{j}\]</span> 其中 <span class="math inline">\(i\)</span> 为枚举的序列长度，<span class="math inline">\(\binom{i}{j}\)</span> 代表选出 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(&gt;1\)</span> 的数的位置，继续化简： <span class="math display">\[\begin{align}ans[x]&amp;=\sum_{j=1}^{16}\left(dp[j][x]\sum_{i=1}^{n}\binom{i}{j}\right)\\&amp;=\sum_{j=1}^{16}dp[j][x]\binom{n+1}{j+1}\end{align}\]</span> 这里运用了上指标求和公式：<span class="math inline">\(\sum\limits_{i=1}^{n}\binom{i}{j}=\binom{n+1}{j+1}\)</span>，可以借助杨辉三角记忆。</p><p>虽然 <span class="math inline">\(n\)</span> 比较大，但 <span class="math inline">\(\binom{n+1}{j+1}\)</span> 可以用定义 <span class="math inline">\(O(\log k)\)</span> 求得，故总时间复杂度 <span class="math inline">\(O(k\log^2k)\)</span>。</p><h2 id="cf2007e.-iris-and-the-tree"><a href="https://codeforces.com/contest/2007/problem/E">CF2007E. Iris and the Tree</a></h2><p>*1800 <a href="https://codeforces.com/contest/2007/submission/303238809">Code</a></p><p>编号是 dfs 序，说明任意一条边都恰好被两条 <span class="math inline">\(i\to i+1\)</span> 的路径经过（初次遍历时至上而下一条，回溯时至下而上一条）。</p><p>我们可以暴力地把每条 <span class="math inline">\(i\to i+1\)</span> 的路径经过的点记录下来，由于总长度是 <span class="math inline">\(2n\)</span>，所以是线性的。</p><p>当我们给一条边赋值后，我们找到这条边对应的两条路径，此时这两条路径的边权和有两种情况：</p><ul><li>这条路径上仍然有边权不确定的点。此时可以把剩余的权值全部分配给那条边权不确定的边。</li><li>这条路径上所有边都被赋值了。此时边权和是固定的。</li></ul><p>我们可以记录两个信息以快速计算贡献，分别是已经赋值过的权值和 <span class="math inline">\(add\)</span> 以及未被全部赋值的路径条数 <span class="math inline">\(cnt\)</span>。</p><p>此时第二种情况和第一种情况的已赋值部分等价于 <span class="math inline">\(2\cdot add\)</span>，第一种情况的未赋值部分等价于 <span class="math inline">\(cnt\cdot(w-add)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。带 <span class="math inline">\(\log\)</span> 是因为使用了 <code>std::set</code> 来辅助计算 <span class="math inline">\(cnt\)</span>。</p><h2 id="cf2007f.-eri-and-expanded-sets"><a href="https://codeforces.com/contest/2007/problem/F">CF2007F. Eri and Expanded Sets</a></h2><p>*2300 <a href="https://codeforces.com/contest/2007/submission/303324539">Code</a></p><p>连续意味着排序后相邻两项的差是 <span class="math inline">\(1\)</span>，这引导我们思考差分数组。</p><p>结论：对于一个有序序列 <span class="math inline">\(\{a\}\)</span>，它不能再进行 expand 当且仅当它的差分数组 <span class="math inline">\(\{b\}\)</span> 全为奇数且相同。换句话说，<span class="math inline">\(\{a\}\)</span> 是公差为奇数的等差数列。</p><ul><li>若 <span class="math inline">\(b_i=a_{i+1}-a_i\)</span> 为偶数，则一定有 <span class="math inline">\(c=\frac{a_i+a_{i+1}}{2}\in(a_i,a_{i+1})\)</span> 可以加进 set 里。</li><li>若存在相邻两项 <span class="math inline">\(b_i,b_{i+1}\)</span> 为奇数但不同，则 <span class="math inline">\(b_i+b_{i+1}=a_{i+2}-a_{i}\)</span> 为偶数，且 <span class="math inline">\(c=\frac{a_{i+2}+a_i}{2}\in(a_i,a_{i+1})\cup(a_{i+1},a_{i+2})\)</span> 不在序列里，可以再 expand。</li></ul><p>进一步地，假定 <span class="math inline">\(g=\gcd\limits_{i\in[1,n)}(|a_{i}-a_{i+1}|)\)</span>，<span class="math inline">\(\{a\}\)</span> 的公差为 <span class="math inline">\(d\)</span>，则 <span class="math inline">\(d\)</span> 一定是 <span class="math inline">\(g\)</span> 除以 <span class="math inline">\(2\)</span> 的若干次幂得到。具体地，<span class="math inline">\(d=\dfrac{g}{\text{lowbit}(g)}\)</span>。</p><ul><li>因为任意两项的差要是公差 <span class="math inline">\(d\)</span> 的倍数，故 <span class="math inline">\(d\)</span> 是相邻两项差的 <span class="math inline">\(\gcd\)</span> 的因数 。而 <span class="math inline">\(g\)</span> 能再分的前提是 <span class="math inline">\(g\)</span> 是偶数，故 <span class="math inline">\(g\)</span> 不断除以 <span class="math inline">\(2\)</span> 直到为奇数就得到 <span class="math inline">\(d\)</span>，写成公式就是上面那样。</li></ul><p>还需要注意的是这里引入了 <span class="math inline">\(\gcd\)</span>，根据其辗转相减的性质，结论对于无序数组依然成立。</p><p>回到题目的要求，连续即 <span class="math inline">\(d=1\)</span>，即：</p><p><span class="math display">\[d=\dfrac{g}{\text{lowbit}(g)}=1\Longrightarrow g=\text{lowbit}(g)\Longrightarrow g=0 \cup g=2^k,k\ge 0\]</span></p><p>转化为求 <span class="math inline">\(\{b\}\)</span> 有多少个子区间的 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(2\)</span> 的幂。</p><p>枚举左端点 <span class="math inline">\(L\)</span>，二分找到第一个右端点 <span class="math inline">\(R\)</span> 满足 <span class="math inline">\(\underline{\ }\text{builtin}\underline{}\text{popcount}\left(\gcd\limits_{i\in[L,R]}b_i\right)=1\)</span>。则区间 <span class="math inline">\([L,R], [L,R+1],[L,R+2],\cdots,[L,n]\)</span> 的 <span class="math inline">\(\gcd\)</span> 均为 <span class="math inline">\(2\)</span> 的幂次。这是因为 <span class="math inline">\(2\)</span> 的幂次只有因数 <span class="math inline">\(2\)</span>，与任何数做 <span class="math inline">\(\gcd\)</span> 也只能得到 <span class="math inline">\(2\)</span> 的幂次。</p><p>还是通过二分找到最后一个右端点 <span class="math inline">\(R\)</span> 满足 <span class="math inline">\(\gcd\limits_{i\in[L,R]}b_i=0\)</span>，则区间 <span class="math inline">\([L,L],[L,L+1],[L,L+2],\cdots,[L,R]\)</span> 的 <span class="math inline">\(\gcd\)</span> 均为 <span class="math inline">\(0\)</span>，原因显然。</p><p>区间 <span class="math inline">\(\gcd\)</span> 可以用 ST 表实现，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2062d.-balanced-tree"><a href="https://codeforces.com/contest/2062/problem/D">CF2062D. Balanced Tree</a></h2><p>*2200 <a href="https://codeforces.com/contest/2062/submission/303333922">Code</a></p><p>操作是：选定一个根，再让一个点的子树 <span class="math inline">\(+1\)</span>。</p><p>对于一条边，我们只会让它一侧的所有节点 <span class="math inline">\(+1\)</span>（因为两侧都加等价于整棵树加，是没有意义的）。</p><p>想象所有点都已经固定点权了，此时肯定是让点权小的一侧的所有点权 <span class="math inline">\(+1\)</span>。边的决策取决于两侧的节点，不妨先随意选定一个根，进行至下而上地贪心。</p><p>设 <span class="math inline">\(f[x]\)</span> 为节点 <span class="math inline">\(x\)</span> 的答案，并初始化一个 <span class="math inline">\(delta=0\)</span> 代表全局 tag。对于当前节点 <span class="math inline">\(x\)</span>，若为叶子，选 <span class="math inline">\(L[x]\)</span> 肯定不劣；否则有两种情况：</p><ul><li><span class="math inline">\(\forall y\in son[x]\)</span>，<span class="math inline">\(f[y]\le r[x]\)</span>。此时选 <span class="math inline">\(\max(l[x],\max\limits_{y\in son[x]} f[y])\)</span> 肯定最优。因为可以让某一个儿子所在的子树变大，儿子之间互不影响。</li><li><span class="math inline">\(\exists y\in son[x],f[y]&gt;r[x]\)</span>。此时节点 <span class="math inline">\(x\)</span> 只能选 <span class="math inline">\(r[x]\)</span>，为了让所有节点权值一样只能让 <span class="math inline">\(x\)</span> 沿着根方向的子树 <span class="math inline">\(+1\)</span>。并且对于每个儿子所在的子树，造成的贡献是累加的，即 <span class="math inline">\(delta \leftarrow delta + \sum\limits_{y\in son[x],f[y] &gt; r[x]} (f[y]-r[x])\)</span>。</li></ul><p>答案即 <span class="math inline">\(f[rt]+delta\)</span>，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2033g.-sakurako-and-chefir"><a href="https://codeforces.com/contest/2033/problem/G">CF2033G. Sakurako and Chefir</a></h2><p>*2200 <a href="https://codeforces.com/contest/2033/submission/303354940">Code</a></p><p>对于一组询问 <span class="math inline">\((v,k)\)</span>，我们直接跳到 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(k\)</span> 级祖先（设为 <span class="math inline">\(x\)</span>）一定不劣。</p><p>那么询问等价于找 <span class="math inline">\(x\)</span> 的子树中距 <span class="math inline">\(v\)</span> 最远的点。</p><p>这个最远的点一定是 <span class="math inline">\(x\)</span> 的子树的两个直径端点之一。</p><p>问题转化为对树上的每个点 <span class="math inline">\(x\)</span>，求其子树的直径的两个端点。</p><p>这仍然是一个套路化的问题，回顾一下做法：</p><ul><li>至下而上考虑，设当前考虑的节点为 <span class="math inline">\(x\)</span>。</li><li>若 <span class="math inline">\(x\)</span> 为叶子，两个直径端点都是它自身。</li><li>若 <span class="math inline">\(x\)</span> 恰有一个儿子 <span class="math inline">\(y\)</span>，考虑 <span class="math inline">\(x\)</span> 是否能与 <span class="math inline">\(y\)</span> 的两个端点之一来作为新的直径，不能就直接继承 <span class="math inline">\(y\)</span> 的答案。</li><li>若 <span class="math inline">\(x\)</span> 有两个儿子 <span class="math inline">\(y_1,y_2\)</span>，答案为两种情况取 <span class="math inline">\(\max\)</span>：<ul><li>继承自 <span class="math inline">\(y_1\)</span> 或 <span class="math inline">\(y_2\)</span>。</li><li>穿过 <span class="math inline">\(x\)</span> 将两段拼起来。此时新的直径端点肯定有一个来自 <span class="math inline">\(y_1\)</span> 的两个端点之一，另一个来自 <span class="math inline">\(y_2\)</span> 的两个端点之一。</li></ul></li><li>若 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(&gt; 2\)</span> 个儿子，按上一种情况每次合并两个子树，直到合并完为止。</li></ul><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1993d.-med-imize"><a href="https://codeforces.com/contest/1993/problem/D">CF1993D. Med-imize</a></h2><p>*2200 <a href="https://codeforces.com/contest/1993/submission/303478399">Code</a></p><p>答案具有二分性，设二分出的答案为 <span class="math inline">\(mid\)</span>。</p><p>中位数套路：<span class="math inline">\(\forall i\in[1,n]\)</span>，令 <span class="math inline">\(b[i]=\begin{cases}1&amp;,a[i]\ge mid \\ -1&amp;,a[i]&lt;mid\end{cases}\ \)</span>，则 <span class="math inline">\(\sum b[i]&gt;0 \Longleftrightarrow mid\le median(a)\)</span>。</p><p>题目转化为：给定 <span class="math inline">\(\{b\}\)</span>，每次任选一个长为 <span class="math inline">\(k\)</span> 的段删掉，直到不能删为止，剩下数的和是否 <span class="math inline">\(&gt;0\)</span>。</p><p>这里给出其中一种 dp 方案。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <span class="math inline">\(i\)</span> 个数选了 <span class="math inline">\(j\)</span> 个长为 <span class="math inline">\(k\)</span> 的段删去后，剩下数和的最大值。</p><p>则 <span class="math inline">\(dp[i][j] = \max(dp[i-1][j]+b[i],dp[i-k][j - 1])\)</span>，答案为 <span class="math inline">\(dp[n][\left\lfloor\frac{n-1}{k}\right\rfloor]\)</span>。</p><p>考虑到 <span class="math inline">\(0\le i-jk\le k \Longrightarrow j\in\left[\left\lfloor\dfrac{i-1}{k}\right\rfloor,\left\lfloor\dfrac{i}{k}\right\rfloor\right]\)</span>，即 <span class="math inline">\(j\)</span> 只有两种取值。</p><p>故不妨令 <span class="math inline">\(dp[i][j=0/1]\)</span> 表示前 <span class="math inline">\(i\)</span> 个数选了 <span class="math inline">\(\left\lfloor\dfrac{i-1}{k}\right\rfloor+j\)</span> 个长为 <span class="math inline">\(k\)</span> 的段删去后，剩下数和的最大值。</p><p>使用记忆化搜索转移，时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><p>官方题解里是另一种 dp，我花了半个小时仍未完全理解，希望有生之年能够参悟。</p><h2 id="cf1993f1f2.-dyn-scripted-robot"><a href="https://codeforces.com/contest/1993/problem/F2">CF1993F1/F2. Dyn-scripted Robot</a></h2><p>*2400 <a href="https://codeforces.com/contest/1993/submission/303822753">Code</a>（F1）</p><p>*2800 <a href="https://codeforces.com/contest/1993/submission/303832230">Code</a>（F2）</p><p>我们假定一个在没有墙的二维平面中移动的机器人称作 <span class="math inline">\(B\)</span>，题中的机器人称作 <span class="math inline">\(A\)</span>。由于 <span class="math inline">\(B\)</span> 相比 <span class="math inline">\(A\)</span> 取消了墙的限制，移动序列自然不会改变。</p><p>结论：<span class="math inline">\(A\)</span> 回到原点的次数 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(B\)</span> 经过点 <span class="math inline">\((x,y),\begin{cases}x\equiv 0\pmod{2w} \\ y\equiv 0 \pmod{2h} \end{cases}\)</span> 的次数。</p><ul><li>先考虑只存在沿 <span class="math inline">\(y\)</span> 轴方向的移动，当 <span class="math inline">\(A\)</span> 撞到 <span class="math inline">\(y=h\)</span> 后，<span class="math inline">\(A,B\)</span> 运动轨迹沿 <span class="math inline">\(y=h\)</span> 轴对称；而 <span class="math inline">\(A\)</span> 再撞到 <span class="math inline">\(y=0\)</span>（<span class="math inline">\(B\)</span> 撞到 <span class="math inline">\(y=2h\)</span>）后，二者运动方向恢复一致。<span class="math inline">\(x\)</span> 轴方向的运动同理，外推后不难得出该结论。</li></ul><p>故只需研究 <span class="math inline">\(B\)</span> 的运动即可。设 <span class="math inline">\(x_i\ (i\in[1,n])\)</span> 表示 <span class="math inline">\(B\)</span> 从 <span class="math inline">\((0,0)\)</span> 开始，经过 <span class="math inline">\(i\)</span> 次移动后的横坐标（在 <span class="math inline">\(\bmod 2w\)</span> 同余系下）; <span class="math inline">\(y_i\ (i\in[1,n])\)</span> 表示 <span class="math inline">\(B\)</span> 从 <span class="math inline">\((0, 0)\)</span> 开始，经过 <span class="math inline">\(i\)</span> 次移动后的纵坐标（在 <span class="math inline">\(\bmod 2h\)</span> 同余系下）。</p><p>假设 <span class="math inline">\(B\)</span> 已经执行了完整的移动序列 <span class="math inline">\(i\in[0,k)\)</span> 次，并额外移动了 <span class="math inline">\(j\in[1,n]\)</span> 次，那么坐标为 <span class="math inline">\((ix_n+x_j,iy_n+y_j)\)</span>。题目转化为求有序对 <span class="math inline">\((i,j)\)</span> 的数目，满足：</p><p><span class="math display">\[\begin{cases} x\equiv 0 \pmod{2w} \\y\equiv 0 \pmod{2h}\end{cases}\Longrightarrow\begin{cases}ix_n+x_j\equiv 0 \pmod{2w} \\iy_n+y_j\equiv 0 \pmod{2h}\end{cases}\]</span></p><p>对于 F1，将式子变形，得到：</p><p><span class="math display">\[\begin{cases}x_j\equiv -ix_n \pmod{2w} \\y_j\equiv -iy_n \pmod{2h}\end{cases}\]</span></p><p>我们可以把执行一次移动序列经过的点的坐标存到一个 <code>std::map</code> 里，然后枚举 <span class="math inline">\(i\in[0,k)\)</span>，查一下 <code>std::map</code> 中点 <span class="math inline">\((-ix_n,-iy_n)\)</span> 的值即可。时间复杂度 <span class="math inline">\(O(k\log n)\)</span>。</p><p>对于 F2，将式子变形，得到：</p><p><span class="math display">\[\begin{cases}ix_n\equiv -x_j \pmod{2w} \\iy_n\equiv -y_j \pmod{2h}\end{cases}\]</span></p><p>在这个方程组中，除了 <span class="math inline">\(i\)</span> 均为已知，于是可以枚举 <span class="math inline">\(x_j\)</span>，用中国剩余定理解 <span class="math inline">\(n\)</span> 遍即可。在此之前，还需要把方程转化为 <span class="math inline">\(x\equiv a\pmod{p}\)</span> 的标准形式。</p><p>由于 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(\bmod p\)</span> 下的逆元仅在 <span class="math inline">\(a,p\)</span> 互质时存在，故令 <span class="math inline">\(g=\gcd(2w,x_n)\)</span>，则：</p><p><span class="math display">\[\begin{align}ix_n&amp;\equiv -x_j \pmod{2w}\\i\cdot\frac{x_n}{g}&amp;\equiv -\frac{x_j}{g}\pmod{\frac{2w}{g}}\\i &amp;\equiv -\frac{x_j}{g}\left(\frac{x_n}{g}\right)^{-1}\pmod{\frac{2w}{g}}\end{align}\]</span></p><p>显然当 <span class="math inline">\(g \nmid x_j\)</span> 时方程无解。另一个方程组同理。</p><p>对于一组 <span class="math inline">\((x_j,y_j)\)</span>，用 CRT 解出最小的 <span class="math inline">\(i\)</span> 后，问题转化为 <span class="math inline">\(i,i+M,i+2M,\cdots\)</span> 中有几个在 <span class="math inline">\([0,k-1)\)</span> 范围内，答案是 <span class="math inline">\(\dfrac{k-1-i}{M}+1\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p><h2 id="cf1972d.-reverse-card-hard-version"><a href="https://codeforces.com/contest/1972/problem/D2">CF1972D. Reverse Card (Hard Version)</a></h2><p>*2200 <a href="https://codeforces.com/contest/1972/submission/303818473">Code</a></p><p>题目要求满足 <span class="math inline">\(a\in[1,n]\)</span>，<span class="math inline">\(b\in[1,m]\)</span>，<span class="math inline">\((a+b)\mid b\cdot\gcd(a,b)\)</span> 的有序对 <span class="math inline">\((a,b)\)</span> 的数量。</p><p>令 <span class="math inline">\(d=\gcd(a,b)\)</span>，<span class="math inline">\(a=pd\)</span>，<span class="math inline">\(b=qd\)</span>，则 <span class="math inline">\(\gcd(p,q)=1\)</span>。代入得： <span class="math display">\[\begin{align}a+b&amp;\mid b\cdot\gcd(a,b)\\ \to (p+q)d&amp;\mid qd^2 \\ \to \quad \ p+q&amp;\mid qd\\\to \quad\ p+q&amp;\mid d\end{align}\]</span> 最后一步是因为 <span class="math inline">\(\gcd(p,q)=1 \to \gcd(p+q,q)=1\)</span>。</p><p>又因为：</p><p><span class="math display">\[\begin{align}p+q\mid d \to p+q\le d\to p\le d=\dfrac{a}{p}\le \dfrac{n}{p}\end{align}\]</span></p><p>于是 <span class="math inline">\(p^2 \le n \to p\in[1,\sqrt{n}]\)</span>，同理 <span class="math inline">\(q\in[1,\sqrt{m}]\)</span>。</p><p><span class="math inline">\(O(\sqrt{nm})\)</span> 枚举 <span class="math inline">\(p,q\)</span>，当 <span class="math inline">\(\gcd(p,q)=1\)</span> 时，贡献等价于有多少 <span class="math inline">\(d\)</span> 满足 <span class="math inline">\(p+q\mid d\)</span> 且 <span class="math inline">\(d\le \min(\dfrac{n}{p},\dfrac{m}{q})\)</span>，即 <span class="math inline">\(\left\lfloor\dfrac{\min(\dfrac{n}{p},\dfrac{m}{q})}{p+q}\right\rfloor\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1824b2.-luotianyi-and-the-floating-islands-hard-version"><a href="https://codeforces.com/contest/1824/problem/B2">CF1824B2. LuoTianyi and the Floating Islands (Hard Version)</a></h2><p>*2300 <a href="https://codeforces.com/contest/1824/submission/304516792">Code</a></p><p>规定有人的点称为黑点，到所有黑点距离和最小的点称为目标点。</p><p>结论：目标点构成一个连通块。</p><ul><li>比较显然。</li></ul><p>结论：当 <span class="math inline">\(k\)</span> 为奇数时，答案为 <span class="math inline">\(1\)</span>。</p><ul><li>对于任意一个有奇数个黑点的局面，假定我们已经找到了一个目标点 <span class="math inline">\(x\)</span>。若存在 <span class="math inline">\(x\)</span> 的一个邻居 <span class="math inline">\(y\)</span> 也是目标点，那么 <span class="math inline">\(x\to y\)</span> 移动的过程中理应没有额外贡献，换句话说边 <span class="math inline">\((x,y)\)</span> 两侧黑点数目相同。此时黑点个数定为偶数，矛盾。故对于任意一个奇数个黑点的局面有且仅有一个目标点。</li></ul><p>接下来考虑将点的贡献放到边上，好处是目标点构成连通块，边的数量总是目标点数量 <span class="math inline">\(-1\)</span>，而且边的贡献容易计算。</p><p>当 <span class="math inline">\(k\)</span> 为偶数时，根据上述分析，一条边当且仅当两侧黑点数目相同时有贡献，故贡献为两侧各选 <span class="math inline">\(\dfrac{k}{2}\)</span> 个黑点的方案数。</p><p>任选根计算出 <span class="math inline">\(sz[x]\)</span> 为子树大小，那么答案即 <span class="math inline">\(\dfrac{\sum\limits_{x=1}^{n}\sum\limits_{y\in son[x]}\dbinom{sz[y]}{\dfrac{k}{2}}\dbinom{n-sz[y]}{\dfrac{k}{2}}}{\dbinom{n}{k}}+1\)</span> 。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1989d.-smithing-skill"><a href="https://codeforces.com/contest/1989/problem/D">CF1989D. Smithing Skill</a></h2><p>*1900 <a href="https://codeforces.com/contest/1989/submission/304548337">Code</a></p><p>首先，不同 <span class="math inline">\(c_j\)</span> 互不影响。其次，对于一个 <span class="math inline">\(c_j\)</span>，肯定是选满足 <span class="math inline">\(c_j\ge a_i\)</span> 的武器中 <span class="math inline">\(a_i-b_i\)</span> 最小的武器，并不断地合成再焚毁直到 <span class="math inline">\(c_j &lt; a_i\)</span> 为止。</p><p>考虑阈值分治，令 <span class="math inline">\(A=\max a_i\)</span>，可以先对每个 <span class="math inline">\(i\in[1,A]\)</span> 预处理出 <span class="math inline">\(res[i]\)</span> 表示 <span class="math inline">\(i\)</span> 个矿石能够获得的最大经验点数；而对于 <span class="math inline">\(c_j &gt; A\)</span> 的询问，用最小的 <span class="math inline">\(a_i-b_i\)</span> 处理直到 <span class="math inline">\(c_j \le A\)</span>，就能直接查表查到 <span class="math inline">\(res[c_j]\)</span>。</p><p>其中 <span class="math inline">\(res[i]\)</span> 的预处理仍然不简单，我们可以定义一个辅助数组 <span class="math inline">\(d[i]\)</span> 表示所有 <span class="math inline">\(a_i \le i\)</span> 的武器里面 <span class="math inline">\(a_i-b_i\)</span> 的最小值。在此基础上，有递推 <span class="math inline">\(res[i]=2+res[i-d[i]]\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n+w+m)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p><h2 id="cf1972e.-fenwick-tree"><a href="https://codeforces.com/contest/1972/problem/E">CF1972E. Fenwick Tree</a></h2><p>*2300 <a href="https://codeforces.com/contest/1972/submission/304751560">Code</a></p><p>首先要知道树状数组的结构是怎么样的，这里引用题解的一张图。</p><p><img src="/image/academic/fenwick.png" /></p><p>其中 <span class="math inline">\(c_1,c_2,\cdots c_{10}\)</span> 就是迭代一次后的数组，即 <span class="math inline">\(f^{1}(a)\)</span>。</p><p>故每次迭代相当于把上一次迭代后的数组作为叶子，再向上合并一遍。</p><p>我们考虑对每个 <span class="math inline">\(c_i\)</span>，把它的贡献从它的祖先中除去。</p><p>例如，当 <span class="math inline">\(k=1\)</span> 时，对于 <span class="math inline">\(c_1\)</span>，要把 <span class="math inline">\(c_1\)</span> 从 <span class="math inline">\(c_2,c_4,c_8\)</span> 中除去，此时系数显然都是 <span class="math inline">\(1\)</span>。（系数即 "减去几倍的 <span class="math inline">\(c_1\)</span>"）</p><p>当 <span class="math inline">\(k=2\)</span> 时，<span class="math inline">\(c_2\)</span> 在第一次迭代的基础上再累加了一遍 <span class="math inline">\(c_1\)</span>，系数是 <span class="math inline">\(1+1=2\)</span>；<span class="math inline">\(c_4\)</span> 累加了 <span class="math inline">\(c_2\)</span>，系数是 <span class="math inline">\(1+2=3\)</span>；<span class="math inline">\(c_8\)</span> 累加了 <span class="math inline">\(c_4\)</span>，系数是 <span class="math inline">\(1+3=4\)</span>。</p><p>当 <span class="math inline">\(k=3\)</span> 时，<span class="math inline">\(c_2\)</span> 再累加一遍 <span class="math inline">\(c_1\)</span>，系数是 <span class="math inline">\(2+1=3\)</span>；<span class="math inline">\(c_4\)</span> 累加 <span class="math inline">\(c_2\)</span>，系数是 <span class="math inline">\(3+3=6\)</span>；<span class="math inline">\(c_8\)</span> 累加 <span class="math inline">\(c_4\)</span>，系数是 <span class="math inline">\(4+6=10\)</span>。</p><p>可以发现，对于相同的 <span class="math inline">\(k\)</span>，系数只和向上爬升的层数有关，列成一个表。</p><p><span class="math inline">\(k=1\to 1,1,1,1,1,\cdots\)</span></p><p><span class="math inline">\(k=2\to 2,3,4,5,\cdots\)</span></p><p><span class="math inline">\(k=3\to 3,6,10,\cdots\)</span></p><p><span class="math inline">\(k=4\to 4,10,\cdots\)</span></p><p>将这个三角形摆正，可以发现就是杨辉三角。</p><p>其中，第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 项表示 <span class="math inline">\(k=i\)</span> 时向上爬升 <span class="math inline">\(j\)</span> 层需要减去的系数，组合数写出来就是 <span class="math inline">\(\dbinom{i+j-1}{j}\)</span>。</p><p>由于树状数组不超过 <span class="math inline">\(\log n\)</span> 层，故时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1996g.-penacony"><a href="https://codeforces.com/contest/1996/problem/G">CF1996G. Penacony</a></h2><p>*2200 <a href="https://codeforces.com/contest/1996/submission/304762843">Code1</a> <a href="https://codeforces.com/contest/1996/submission/304805042">Code2</a></p><p><strong>solution1</strong>：对于一对朋友 <span class="math inline">\((a,b)\)</span>，他们之间有且仅有两条路径，并且这两条路径构成一个环。因此最为关键的观察是 '"只要钦定某一条边是断开的，那么每一对朋友间的路径就是唯一的"。</p><p>建一棵 <span class="math inline">\(n\)</span> 个点的线段树，每个位置的值代表对应的道路被几对朋友占用了。一开始，先将所有 <span class="math inline">\([a,b)\)</span> 区间 <span class="math inline">\(+1\)</span>。从左到右枚举每条边并钦定为断开，如遇到左端点就将 <span class="math inline">\([1,a),[b,n]+1\)</span>，<span class="math inline">\([a,b)-1\)</span>；如遇右端点就将 <span class="math inline">\([1,a),[b,n]-1\)</span>，<span class="math inline">\([a,b)+1\)</span>。每次修改完查询 <span class="math inline">\([1,n]\)</span> 中 <span class="math inline">\(0\)</span> 出现的次数就是非必须保留的道路数目。</p><p>由于整个修改过程线段树保存的值非负，故 <span class="math inline">\(0\)</span> 出现的次数等价于最小值出现的次数。</p><p><strong>solution2</strong>：将这 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(n\)</span> 条边看成一个 <span class="math inline">\(n\)</span> 边形，对于一对朋友 <span class="math inline">\((a,b)\)</span>，在 <span class="math inline">\(a,b\)</span> 间连对角线。</p><p>断言：对于任意两条边，如果它们被相同的对角线集合覆盖，那么这两条边可以删去。</p><ul><li>你可以想象每条对角线都有正反面，正面对应多边形上的边和反面对应多边形上的边被认为是不同的。就一对朋友关系而言，你能且仅能选择两段其一。</li></ul><p>对于每条对角线，我们不妨把其任一侧的所有边异或上一个固定的值。</p><p>利用差分和前缀和，就能 <span class="math inline">\(O(n)\)</span> 求出每条边在 “染色” 后的权值。此时两条边权值相同就等价于被相同的对角线集合覆盖了。</p><p>最后，用一个 <code>std::map</code> 统计出现次数最多的权值即可。</p><p>两种方法时间复杂度均为 <span class="math inline">\(O(n\log n)\)</span>，后者常数小很多。</p><h2 id="cf1983e.-i-love-balls"><a href="https://codeforces.com/contest/1983/problem/E">CF1983E. I Love Balls</a></h2><p>*2300 <a href="https://codeforces.com/contest/1983/submission/305424717">Code</a></p><p>数学题。令 <span class="math inline">\(special=\dfrac{\sum_{i=1}^{k}v_i}{k}\)</span>，<span class="math inline">\(normal=\dfrac{\sum_{i=k+1}^{n}v_i}{n-k}\)</span>，分别表示特殊球和普通球的期望价值。</p><p>考虑将 <span class="math inline">\(k\)</span> 特殊球插进 <span class="math inline">\(n-k+1\)</span> 个普通球的 gap 里面，每个 gap 可以放多个特殊球，这么建立模型的好处是你选中一个 gap 就拿完这个 gap 里的所有球，符合特殊球的机制。</p><p>Alice 会选中 <span class="math inline">\(\left\lceil\dfrac{n-k+1}{2}\right\rceil\)</span> 个 gap，每个 gap 里特殊球期望有 <span class="math inline">\(\dfrac{k}{n-k+1}\)</span> 个，故 Alice 选中特殊球价值的期望总和是 <span class="math inline">\(\dfrac{\lceil\frac{n-k+1}{2}\rceil \cdot k}{n-k+1}\cdot special\)</span>。</p><p>而 Alice 作为先手会选中 <span class="math inline">\(\left\lceil\dfrac{n-k}{2}\right\rceil\)</span> 个普通球，故他选中普通球价值的期望总和是 <span class="math inline">\(\left\lceil\dfrac{n-k}{2}\right\rceil\cdot normal\)</span>。</p><p>根据期望的线性性， 上述两个式子相加就是 Alice 的答案。Bob 的答案即所有球的价值总和减去 Alice 的答案。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1983f.-array-value"><a href="https://codeforces.com/contest/1983/problem/F">CF1983F. array-value</a></h2><p>*2500 <a href="https://codeforces.com/contest/1983/submission/305454555">Code</a></p><p>二分答案，设二分出的答案是 <span class="math inline">\(mid\)</span>，若至少有 <span class="math inline">\(k\)</span> 个区间的 value <span class="math inline">\(\le mid\)</span>，就往小二分，否则往大二分。</p><p>问题转化为判断求有多少个区间的 value <span class="math inline">\(\le mid\)</span>。</p><p>不妨枚举右端点 <span class="math inline">\(r\)</span>，此时只需找到最大的 <span class="math inline">\(l\)</span> 满足 <span class="math inline">\(a_l \oplus a_r \le mid\)</span>，那么左端点位于 <span class="math inline">\([1,l]\)</span> 内构成的区间均满足条件。</p><p>这是个经典的问题，使用一个 trie 就能维护，步骤如下：</p><ul><li>对每个 trie 树上的节点 <span class="math inline">\(p\)</span> 维护一个 <span class="math inline">\(mx[p]\)</span> 存储经过这个点的值中下标最大值。</li><li>假设当前对 <span class="math inline">\(a_i\)</span> 进行查询，我们要返回一个最大的 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(a_j\oplus a_i \le mid\)</span>。从大到小枚举每一位，设 <span class="math inline">\(a_i\)</span> 当前位为 <span class="math inline">\(x\)</span>，<span class="math inline">\(mid\)</span> 当前位为 <span class="math inline">\(m\)</span>。<ul><li>若 <span class="math inline">\(m=0\)</span>，为了满足 <span class="math inline">\(\le mid\)</span> 的条件，<span class="math inline">\(a_j\)</span> 这一位应和 <span class="math inline">\(x\)</span> 相同，故只能向 <span class="math inline">\(x\)</span> 的方向走。</li><li>若 <span class="math inline">\(m=1\)</span>，那么两边都可以走：如果向 <span class="math inline">\(x\)</span> 一侧走，之后无论怎么走得到的 <span class="math inline">\(a_j\)</span> 都会满足 <span class="math inline">\(a_j \oplus a_i \le mid\)</span>，故直接累加 <span class="math inline">\(x\)</span> 一侧的 <span class="math inline">\(mx[p]\)</span>，并转而走向 <span class="math inline">\(x\)</span> 的对侧。</li></ul></li><li>最后走到底得到的 <span class="math inline">\(a_j\)</span> 一样满足条件，故答案还要和末尾节点的 <span class="math inline">\(mx[p]\)</span> 取 <span class="math inline">\(\max\)</span>。</li></ul><p>时间复杂度 <span class="math inline">\(O(n\log^2w)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p><h2 id="cf2004f.-make-a-palindrome"><a href="https://codeforces.com/contest/2004/problem/F">CF2004F. Make a Palindrome</a></h2><p>*2600 <a href="https://codeforces.com/contest/2004/submission/305497742">Code</a></p><p>结论：两种操作对最小操作次数的影响等价，即任选其中一种操作或两种操作都用得到的答案相同。</p><ul><li>考虑对于一个 <span class="math inline">\(\{b\}\)</span>，如何计算 <span class="math inline">\(f(b)\)</span>。设 <span class="math inline">\(\{b\}\)</span> 中第一个元素是 <span class="math inline">\(b_1\)</span>，最后一个是 <span class="math inline">\(b_n\)</span>。首先若 <span class="math inline">\(b_1=b_n\)</span>，可以将它们从序列中拿掉，直到 <span class="math inline">\(b_1 \neq b_n\)</span>。此时如果使用分裂操作肯定是选择将 <span class="math inline">\(b_1,b_n\)</span> 中较大的那个分解成较小的那个，不妨设 <span class="math inline">\(b_1 &lt; b_n\)</span>，则相当于耗费一次操作将 <span class="math inline">\(b_1,b_n\)</span> 去掉并在右侧添加一个 <span class="math inline">\(b_n-b_1\)</span>。此时若 <span class="math inline">\(b_n-b_1 \neq b_2\)</span>，那么此次分裂只是单纯把序列元素个数减少了一个，合并操作同样能做到。若 <span class="math inline">\(b_n-b_1=b_2\)</span>，说明此时可以额外将最左侧的 <span class="math inline">\(b_2\)</span> 和最右侧的 <span class="math inline">\(b_n-b_1\)</span> 去掉，一次操作相当于减少了两个元素；但移项可知 <span class="math inline">\(b_1+b_2=b_n\)</span>，说明最开始我们如果在左侧用一次合并生成 <span class="math inline">\(b_1+b_2\)</span> 再和右边的 <span class="math inline">\(b_n\)</span> 抵掉，也是减少了两个元素。于是分裂和合并操作是等价的。</li></ul><p>接下来我们只讨论合并操作。在最极端的情况下，将长为 <span class="math inline">\(n\)</span> 的序列变成回文需要 <span class="math inline">\(n-1\)</span> 次操作，考虑什么情况能减少操作次数。</p><p>结论：对于一个序列，如果其某一个非空前缀和某一个非空后缀的元素和相同，就能减少一次操作。</p><ul><li>设序列长为 <span class="math inline">\(n\)</span>，若 <span class="math inline">\([1,l]\)</span> 和 <span class="math inline">\([r,n]\)</span> 的元素和相同，说明从两端移去数的过程进行到只剩 <span class="math inline">\(\sum\limits_{i=1}^{l-1}a_i,a_l,a_{l+1},\cdots,a_{r-1},\sum\limits_{i=r}^{n}a_i\)</span> 或 <span class="math inline">\(\sum\limits_{i=1}^{l}a_i,a_{l+1},\cdots,a_{r-1},a_r,\sum\limits_{i=r+1}^{n}a_i\)</span> 时，头两个元素合并或后两个元素合并就能额外减少一个元素，换句话说少用了一次操作，并且操作后序列的结构和操作前一致，可以继续寻找最近的非空前缀和最近的非空后缀。</li></ul><p>特别地，找到的非空前缀和非空后缀可以相交，如何理解？若有 <span class="math inline">\([1,l]\)</span> 和 <span class="math inline">\([r,n]\)</span> 元素和相等但 <span class="math inline">\(l&gt;r\)</span>，说明一定有 <span class="math inline">\([1,r]\)</span> 和 <span class="math inline">\([l,n]\)</span> 元素和相等而中间 <span class="math inline">\([r,l]\)</span> 的部分共用，此时 <span class="math inline">\([r,l]\)</span> 一定构成回文串而不用删掉。</p><p>回到原本的问题上来，我们要计算 <span class="math inline">\(\{a\}\)</span> 所有非空子数组 <span class="math inline">\(\{b\}\)</span> 的 <span class="math inline">\(f(b)\)</span> 之和。假若我们在 <span class="math inline">\(\{a\}\)</span> 中发现了一组 <span class="math inline">\([l_1,r_1]\)</span>，<span class="math inline">\([l_2,r_2]\)</span> 元素和相等，那么这两段如果要作为前后缀只能是对 <span class="math inline">\([l_1,r_2]\)</span> 有 <span class="math inline">\(-1\)</span> 的贡献，对其它区间都没有贡献，故对整个序列的贡献就是 <span class="math inline">\(-1\)</span>。</p><p>故题目转化为求 <span class="math inline">\(\{a\}\)</span> 中有多少对非空子区间相等，枚举每个区间存到 <code>std::map</code> 里统计即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p><h2 id="cf1821d.-black-cells"><a href="https://codeforces.com/contest/1821/problem/D">CF1821D. Black Cells</a></h2><p>*1900 <a href="https://codeforces.com/contest/1821/submission/305852685">Code1</a> <a href="https://codeforces.com/contest/1821/submission/305851032">Code2</a></p><p><strong>solution1</strong>：通过观察能得出结论：选择长度 <span class="math inline">\(\ge 2\)</span> 的区间一定不劣。</p><ul><li>随便举个例子：假设 <span class="math inline">\(k=4\)</span>，对于 <span class="math inline">\([1,1]\)</span> 和 <span class="math inline">\([4,7]\)</span>，选择两个区间最少消耗 <span class="math inline">\(10\)</span> 次操作，如果只选 <span class="math inline">\([4,7]\)</span> 则最少只消耗 <span class="math inline">\(9\)</span> 次。但若是 <span class="math inline">\([1,2]\)</span> 和 <span class="math inline">\([4,7]\)</span>，无论选择两个区间还是只选 <span class="math inline">\([4,7]\)</span>，最少都是消耗 <span class="math inline">\(9\)</span> 次操作。</li></ul><p>于是我们记录 <span class="math inline">\(\text{one}\)</span> 和 <span class="math inline">\(\text{sum}\)</span> 分别代表长为 <span class="math inline">\(1\)</span> 的区间个数和长度 <span class="math inline">\(\ge 2\)</span> 的区间的长度和。从左到右扫，分 <span class="math inline">\(\text{sum}\ge k\)</span> 和 <span class="math inline">\(\text{sum}+\text{one}\ge k\)</span> 讨论即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><strong>solution2：</strong>显然选长度尽可能大的区间更优，故使用反悔贪心。</p><p>压入堆中的是已经选择的区间的长度。每当堆中元素和 <span class="math inline">\(\ge k\)</span>，就把最小的元素弹出来。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1821e.-rearrange-brackets"><a href="https://codeforces.com/contest/1821/problem/E">CF1821E. Rearrange Brackets</a></h2><p>*2100 <a href="https://codeforces.com/contest/1821/submission/305857599">Code</a></p><p>题意差评，一堆能让人误会的地方。</p><p>首先，对于给定的平衡括号序列，得到最小 cost 的方式是每次移除最右侧的相邻括号对。</p><p>对于两对括号 <span class="math inline">\(A,B\)</span>，如果 <span class="math inline">\(A\)</span> 包含 <span class="math inline">\(B\)</span>，就连一条 <span class="math inline">\(A\to B\)</span> 的边，建出括号森林。不妨设节点 <span class="math inline">\(1\)</span> 是虚根，这样得到一棵括号树。</p><p>那么移除节点 <span class="math inline">\(x\)</span> 的代价就是 <span class="math inline">\(x\)</span> 的非 <span class="math inline">\(1\)</span> 祖先数目。换句话说，对于任意一个点，它子树内的每个点都有 <span class="math inline">\(1\)</span> 的贡献，即这组括号序列的最小 cost 是 <span class="math inline">\(\sum\limits_{i=2} sz[i]-1\)</span>。</p><p>考虑移动一个括号，可行的移动方式是 <span class="math inline">\(A(B)C\to A()BC\)</span>，这等价于把一个点 <span class="math inline">\(x\)</span> 的儿子接到父亲上，再把 <span class="math inline">\(x\)</span> 删去。不难发现这个过程是无序的（即只要删除的点集是一样的得到的括号树就一样），你只要将 <span class="math inline">\(sz[i]-1\)</span> 排序后选最大的 <span class="math inline">\(k\)</span> 个删去就行。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。<span class="math inline">\(k\)</span> 的范围十分诈骗。</p><h2 id="cf2022e2.-billetes-mxhard-version"><a href="https://codeforces.com/contest/2022/problem/E2">CF2022E2. Billetes MX（Hard Version）</a></h2><p>*2600 <a href="https://codeforces.com/contest/2022/submission/305865364">Code</a></p><p>结论：对于一个 beautiful 的 <span class="math inline">\(n\times m\)</span> 网格，一定存在长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{X\}\)</span> 和长为 <span class="math inline">\(m\)</span> 的序列 <span class="math inline">\(\{Y\}\)</span> 满足 <span class="math inline">\(a[i][j]=X[i]\oplus Y[j]\)</span>。</p><ul><li>容易说明，对于一个 beautiful 的网格，我们将任意一行异或上任意一个数后得到的新网格仍然 beautiful。于是我们进行如下操作：将每一行都异或上那行的第一个数，每一列都异或上那列的第一个数。这样我们得到了一个第一行、第一列全为 <span class="math inline">\(0\)</span> 的网格，它仍然 beautiful。</li><li>此时 <span class="math inline">\(\forall i\in[2,n],j\in[2,m]\)</span>，有 <span class="math inline">\(a[i][j] \oplus a[1][j]\oplus a[i][1] \oplus a[1][1]=0\)</span>，由于后三项均为 <span class="math inline">\(0\)</span>，则 <span class="math inline">\(a[i][j]=0\)</span>。我们取第一列为序列 <span class="math inline">\(\{X\}\)</span>，第一行为序列 <span class="math inline">\(\{Y\}\)</span>，由 <span class="math inline">\(a[i][j]\)</span> 在异或完 <span class="math inline">\(X[i]\)</span> 和 <span class="math inline">\(Y[j]\)</span> 后为 <span class="math inline">\(0\)</span>，可知 <span class="math inline">\(a[i][j]=X[i]\oplus Y[j]\)</span>。</li></ul><p>那么，<span class="math inline">\(a[i][j]\)</span> 给定意味着 <span class="math inline">\(X[i] \oplus Y[j]\)</span> 给定，我们建立一个图论模型：一个 <span class="math inline">\(n+m\)</span> 个点的图，点 <span class="math inline">\(1\sim n\)</span> 代表对应的行，点 <span class="math inline">\(n+1\sim n+m\)</span> 代表对应的列，给定 <span class="math inline">\(a[i][j]\)</span> 就连一条 <span class="math inline">\(i \to n+j\)</span> 边权为 <span class="math inline">\(a[i][j]\)</span> 的边。</p><p>根据异或的性质，在这个图中所有的环都要满足 "环上的边权异或和为 <span class="math inline">\(0\)</span>"。若不满足，答案就是 <span class="math inline">\(0\)</span>。否则方案数是什么呢？考虑一个没填数的格子，不妨设它的坐标是 <span class="math inline">\((r, c)\)</span>，将它填上相当于将点 <span class="math inline">\(r\)</span> 和点 <span class="math inline">\(n+c\)</span> 连起来了，分两种情况：</p><ul><li>连之前 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(n+c\)</span> 就在一个连通块里了。此时新加进的这条边能构成一个新环，由于一个环上的边异或和要为 <span class="math inline">\(0\)</span>，这条新边权值自然是固定的，答案 <span class="math inline">\(\times 1\)</span>。</li><li>连之前 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(n+c\)</span> 不在一个连通块中。此时新加进的这条边不组成任何一个环，边权就能取任何一个 <span class="math inline">\([0,2^{30}-1]\)</span> 中的值，故答案 <span class="math inline">\(\times 2^{30}\)</span>。</li></ul><p>也就是说，对于当前的一个局面，有 <span class="math inline">\(cnt\)</span> 个连通块，且所有环都满足边权异或和为 <span class="math inline">\(0\)</span>，答案就是 <span class="math inline">\(2^{30\cdot cnt}\)</span>。</p><p>连通块数目用并查集容易维护，只用考虑如何每次修改后都 check 异或和为 <span class="math inline">\(0\)</span> 的条件。</p><p>实际上这个问题同样能用并查集维护：我们对图上每个点 <span class="math inline">\(x\)</span> 记录一个 <span class="math inline">\(g[x]\)</span> 表示 <span class="math inline">\(x\)</span> 到它所在连通块的根的距离（这个根也就是并查集里 find 得到的点）。那么并查集 merge 的时候如果发现 <span class="math inline">\(x,y\)</span> 在一个连通块中且 <span class="math inline">\(g[x]\oplus g[y] \neq w\)</span>，就说明我们发现了异或和 <span class="math inline">\(&gt;0\)</span> 的环。</p><p><span class="math inline">\(g[x]\)</span> 则通过以下操作维护：</p><ul><li>find 函数回溯时 <span class="math inline">\(g[x] =g[x]\oplus g[fa[x]]\)</span>。</li><li>merge 时假定 <span class="math inline">\(fa[rt_y]=rt_x\)</span>，则 <span class="math inline">\(g[rt_y]=(g[x] \oplus g[y]\oplus w)\)</span>。</li></ul><p>给一幅图帮助理解，不再赘述。</p><p><img src="/image/academic/dsu.png" /></p><p>时间复杂度 <span class="math inline">\(O((n+q)\alpha)\)</span>。</p><h2 id="cf1972f.-long-way-to-be-non-decreasing"><a href="https://codeforces.com/contest/1972/problem/F">CF1972F. Long Way to be Non-decreasing</a></h2><p>*2800 <a href="https://codeforces.com/contest/1972/submission/306070777">Code</a></p><p>建图：<span class="math inline">\(\forall i\in [1, m]\)</span>，<span class="math inline">\(i\to b_i\)</span>。</p><p>问题转化为：求最小的 <span class="math inline">\(k\)</span>，使得每个 <span class="math inline">\(a_i\)</span> 最多能在图上走 <span class="math inline">\(k\)</span> 步，得到的序列单调不降。</p><p>容易发现答案单调，于是二分答案，设二分出的答案是 <span class="math inline">\(mid\)</span>。</p><p>考虑一个贪心，对于第一个数而言，肯定是选 <span class="math inline">\(mid\)</span> 步内的权值最小点；第二个数肯定是选 <span class="math inline">\(mid\)</span> 步内权值大于等于第一个数的最小点，以此类推。我们从小到大枚举权值判定能否走到，若能走到，就跳到下一个数；否则继续往大了枚举。</p><p>具体地，我们用一个三元组 <span class="math inline">\((S,T,mid)\)</span> 表示一个判定：判定 <span class="math inline">\(S\)</span> 走不超过 <span class="math inline">\(mid\)</span> 步是否能走到 <span class="math inline">\(T\)</span>。 <span class="math inline">\(T\)</span> 显然单调不降，于是我们只需判定 <span class="math inline">\(O(m)\)</span> 次。</p><p>判定很简单，只是需要一些码力。首先 <span class="math inline">\(i\to b_i\)</span> 能得到一棵基环内向树，两点间的距离分为环上的一段和子树的一段，维护是朴素的。记录每个点属于哪个环对应的子树以及深度，就能 <span class="math inline">\(O(1)\)</span> 得到距离，再和 <span class="math inline">\(mid\)</span> 比较即可。无解情况是：</p><ol type="1"><li><span class="math inline">\(S, T\)</span> 不在同一棵子树内并且 <span class="math inline">\(T\)</span> 不在环上。</li><li><span class="math inline">\(S,T\)</span> 在同一棵子树内但 <span class="math inline">\(T\)</span> 深度大于 <span class="math inline">\(S\)</span> 或二者不是祖先关系。</li></ol><p>时间复杂度 <span class="math inline">\(O(n\log m)\)</span>。</p><h2 id="cf1969d.-shop-game"><a href="https://codeforces.com/contest/1969/problem/D">CF1969D. Shop Game</a></h2><p>*1900 <a href="https://codeforces.com/contest/1969/submission/306110742">Code</a></p><p>Bob 会从 Alice 选的物品里选 <span class="math inline">\(k\)</span> 个 for free，那他肯定会选 <span class="math inline">\(b[i]\)</span> 最大的 <span class="math inline">\(k\)</span> 个。</p><p>我们不妨将物品按 <span class="math inline">\(b[i]\)</span> 降序排序，这样相当于我们要选一个长至少为 <span class="math inline">\(k\)</span> 的子序列，然后把长为 <span class="math inline">\(k\)</span> 的前缀舍去。</p><p>这样的好处是要舍去的物品和剩下 Bob 要从 Alice 手里买来的物品有了分界线。我们枚举这个分界线，分界线前我们选 <span class="math inline">\(k\)</span> 个舍去，贪心来讲一定是选 <span class="math inline">\(a[i]\)</span> 最小的 <span class="math inline">\(k\)</span> 个；分界线后我们要获得最大的利润，一定是选所有 <span class="math inline">\(b[i]&gt;a[i]\)</span> 的物品。</p><p>分界线前用一个优先队列维护，分界线后预处理一个后缀和作为贡献。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2067e.-white-magic"><a href="https://codeforces.com/contest/2067/problem/E">CF2067E. White Magic</a></h2><p>*1900 <a href="https://codeforces.com/contest/2067/submission/306114621">Code</a></p><p>首先，答案序列中最多出现一个 <span class="math inline">\(0\)</span>。</p><ul><li>若出现两个 <span class="math inline">\(0\)</span>，设下标分别为 <span class="math inline">\(i,j\)</span>。则 <span class="math inline">\(\min(a_1,\cdots,a_i)=0&lt;1\le\text{mex}(a_{i+1},\cdots,a_j=0,\cdots,a_n)\)</span>，矛盾。</li></ul><p>并且，如果答案序列中有 <span class="math inline">\(0\)</span>，这个 <span class="math inline">\(0\)</span> 一定是左数第一个 <span class="math inline">\(0\)</span>。</p><ul><li>贪心的想，这样可以让尽可能长的后缀 <span class="math inline">\(\text{mex}\)</span> 为 <span class="math inline">\(0\)</span>，不劣。</li></ul><p>最后，所有非 <span class="math inline">\(0\)</span> 的数构成的序列一定 magical。</p><p>设有 <span class="math inline">\(cnt\)</span> 个 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(a_i&gt;0\)</span>，我们只需检查含有第一个 <span class="math inline">\(0\)</span> 和所有非 <span class="math inline">\(0\)</span> 数的序列。若其 magical，答案是 <span class="math inline">\(cnt+1\)</span>；否则答案是 <span class="math inline">\(cnt\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2067f.-bitwise-slides"><a href="https://codeforces.com/contest/2067/problem/F">CF2067F. Bitwise Slides</a></h2><p>*2300 <a href="https://codeforces.com/contest/2067/submission/306240933">Code</a></p><p>记 <span class="math inline">\(pre_i=\oplus_{j=1}^{i}a_j\)</span>。</p><p>首先，操作 <span class="math inline">\(i\)</span> 次后，有 <span class="math inline">\(P\oplus Q\oplus R=pre_i\)</span>。三个变量 not pairwise distinct 意味着至少有两个变量相等。然而无论有两个还是三个变量相等，都会有至少一个变量等于 <span class="math inline">\(pre_i\)</span>。</p><p>不妨设相等的两个变量为 <span class="math inline">\(x\)</span>，操作 <span class="math inline">\(i\)</span> 次后的状态只能是 <span class="math inline">\((pre_i,x,x),(x,pre_i,x),(x,x,pre_i)\)</span> 中的一种。</p><p>令 <span class="math inline">\(dp[i][x]\)</span> 表示操作 <span class="math inline">\(i\)</span> 次后达到上述三种状态的方案数。它可以从 <span class="math inline">\((pre_i\oplus a_i,x,x),(x\oplus a_i,pre_i,x),(x\oplus a_i,x,pre_i)\)</span> 转移而来，我们研究转移方程应该长什么样。</p><ul><li>上一个状态是 <span class="math inline">\((pre_i\oplus a_i,x,x)=(pre_{i-1},x,x)\)</span>。<ul><li>若 <span class="math inline">\(pre_{i-1} \neq x\)</span>，<span class="math inline">\(dp[i][x]=dp[i-1][x]\)</span>。</li><li>否则，<span class="math inline">\(dp[i][x]=3\cdot dp[i-1][x]\)</span>。</li></ul></li><li>上一个状态是 <span class="math inline">\((x\oplus a_i,pre_i,x)\)</span>。由其中两个元素相同得到 <span class="math inline">\(pre_i=x\)</span> 或 <span class="math inline">\(pre_i=x\oplus a_i\to pre_{i-1}=x\)</span>。<ul><li>若 <span class="math inline">\(pre_i=x\)</span>，<span class="math inline">\((x\oplus a_i,pre_i,x)=(pre_{i-1},x,x)\)</span>，故 <span class="math inline">\(dp[i][x]=dp[i-1][x]\)</span>。</li><li>若 <span class="math inline">\(pre_{i-1}=x\)</span>，<span class="math inline">\((x\oplus a_i,pre_i,x)=(pre_i,pre_i,pre_{i-1})\)</span>。故 <span class="math inline">\(dp[i][x]=dp[i-1][pre_i]\)</span>。</li></ul></li><li>上一个状态是 <span class="math inline">\((x\oplus a_i,x,pre_i)\)</span>，同上一种。</li></ul><p>综上，只有 <span class="math inline">\(pre_{i-1}=x\)</span> 时 <span class="math inline">\(dp[i][x]\)</span> 不从 <span class="math inline">\(dp[i-1][x]\)</span> 转移而来。</p><p>此时 <span class="math inline">\(dp[i][x]=3\cdot dp[i-1][x]+2\cdot dp[i-1][pre_i]\)</span>。</p><p>把第一维压掉，第二维 <span class="math inline">\(x\)</span> 换成 <span class="math inline">\(pre_{i-1}\)</span>，得到转移方程： <span class="math display">\[dp[pre_{i-1}]=3\cdot dp[pre_{i-1}]+2\cdot dp[pre_i]\]</span> 初始 <span class="math inline">\(dp[0]=1\)</span>，用 <code>std::map</code> 作容器，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2064e.-mycraft-sand-sort"><a href="https://codeforces.com/contest/2064/problem/E">CF2064E. Mycraft Sand Sort</a></h2><p>*2400 <a href="https://codeforces.com/contest/2064/submission/307300383">Code</a></p><p>首先注意到 <span class="math inline">\(\{c\}\)</span> 的顺序不能换，因为第一列是不会下落的，换了之后第一列肯定不同。</p><p>结论：对于一组 <span class="math inline">\(p_i,p_j\)</span>，它们能交换位置当且仅当 <span class="math inline">\(c_i=c_j\)</span> 且 <span class="math inline">\(\max\limits_{k\in (i,j),c_k \neq c_i}p_k &lt; \min(p_i,p_j)\)</span>。</p><ul><li>若 <span class="math inline">\(c_i \neq c_j\)</span>，交换会改变颜色的相对顺序，一定不合法。</li><li>若 <span class="math inline">\(\max\limits_{k\in (i,j),c_k \neq c_i}p_k &gt; \min(p_i,p_j)\)</span>，令 <span class="math inline">\(p_m=\max\limits_{k\in (i,j),c_k \neq c_i}p_k\)</span>，不难想象交换前后在 <span class="math inline">\(p_m\)</span> 上侧颜色 <span class="math inline">\(c_i\)</span> 的数目肯定不同。</li></ul><p>那么如何计数呢？考虑 <span class="math inline">\(1\sim n\)</span> 的一个排列，每次删去一个数相当于固定的 <span class="math inline">\(\{p\}\)</span> 的一位，删除序列和原排列构成双射，因此我们只用对删数的方式进行计数。</p><p>将 <span class="math inline">\(p_i\)</span> 从小到大枚举，统计完之后把 <span class="math inline">\(i\)</span> 这个位置删掉，两端用双向链表连接。这么做的好处是统计到 <span class="math inline">\(p_i\)</span> 时能与 <span class="math inline">\(p_i\)</span> 交换的行一定相邻（不相邻只能是中间夹着更短的，但更短的已经在这之前被删掉了），形成一个连通块。假设此时 <span class="math inline">\(p_i\)</span> 所在的连通块大小是 <span class="math inline">\(t_i\)</span>，依据乘法原理最终答案就是 <span class="math inline">\(\prod t_i\)</span>。</p><p>用并查集维护连通块大小。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2069e.-a-b-ab-and-ba"><a href="https://codeforces.com/contest/2069/problem/E">CF2069E. A, B, AB and BA</a></h2><p>*2300 <a href="https://codeforces.com/contest/2069/submission/307315231">Code</a></p><p>"AA" 和 "BB" 是不被允许的。我们在相邻的两个 "A"，相邻的两个 "B" 中间划一刀，这样整个序列被分割成若干子串，每个子串是下列四种之一：</p><ul><li>ABAB...AB;</li><li>BABA...BA;</li><li>ABAB...ABA;</li><li>BABA...BAB.</li></ul><p>对于长为 <span class="math inline">\(l\)</span> 的第三第四类子串，可以用 <span class="math inline">\(\frac{l-1}{2}\)</span> 个 AB 或 BA 填充，剩下的一定是一个 A（如果是第三类）或者一个 B（如果是第四类）。此时 AB 和 BA 的地位等价。</p><p>对于长为 <span class="math inline">\(l\)</span> 的第一类子串，可以用 <span class="math inline">\(\frac{l}{2}\)</span> 个 AB 完全填充，或 <span class="math inline">\(\frac{l}{2}-1\)</span> 个 BA 外加一个 A 和一个 B。此时 AB 的地位显然高于 BA。同理对于第二类子串，BA 的地位高于 AB。</p><p>对于第一第二类子串，只有用 AB（或 BA）完全填满才不会浪费，所以我们的决策顺序是：</p><ul><li>用 AB 填充长度最小的第一类串，直到 AB 不足或没有第一类串了。</li><li>用 BA 填充长度最小的第二类串，直到 BA 不足或没有第二类串了。</li><li>用 BA，A，B 填充第一类串的剩余部分。</li><li>用 AB，A，B 填充第二类串的剩余部分。</li><li>用剩下的 AB，BA，A，B 填充第三第四类串。</li></ul><p>若填充过程缺材料了，就是 NO。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2069f.-graph-inclusion"><a href="https://codeforces.com/contest/2069/problem/F">CF2069F. Graph Inclusion</a></h2><p>*2800 <a href="https://codeforces.com/contest/2069/submission/307327089">Code</a></p><p>断言：任何时刻，答案是 <span class="math inline">\(A\)</span> 的连通块数减去 <span class="math inline">\(A\cup B\)</span> 的连通块数。</p><ul><li>挺显然的。</li></ul><p>然后就是线段树分治板子了。</p><p>时间复杂度 <span class="math inline">\(O(q\log^2 q)\)</span>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 DOMjudge 从零搭建一场比赛</title>
    <link href="/posts/4cf2169a.html"/>
    <url>/posts/4cf2169a.html</url>
    
    <content type="html"><![CDATA[<p>本文使用的环境：全新 Ubuntu24.04 LTS。</p><p>Domjudge 版本：8.3.1。</p><p>本文主要参考了：</p><p><a href="https://vingying.github.io/2024/09/04/domjudge-icpctool/">Vingying | 关于搭建 domjudge 还有其他一些 ICPC Tool 之类的事</a></p><p><a href="https://zhuanlan.zhihu.com/p/258024151">HeRaNO | 计算机 · DOMjudge Docker 配置</a></p><p>文中的所有流程经过了从头验证，十分感谢 vy 和 hrdg 的耐心指导QAQ。</p><h3 id="安装-domjudge-和相关依赖">1. 安装 DOMjudge 和相关依赖</h3><div class="code-wrapper"><pre><code class="hljs bash">sudo apt-get updatesudo apt-get upgrade</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">sudo apt install acl zip unzip mariadb-server nginx \        php-fpm php-gd php-cli php-intl php-mbstring php-mysql \        php-curl php-json php-xml php-zip composer ntpsudo apt install make gcc g++ debootstrap libcgroup-dev lsof \        procps libcurl4-gnutls-dev libjsoncpp-dev libmagic-dev</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/sudo wget https://www.domjudge.org/releases/domjudge-8.3.1.tar.gzsudo tar -zxvf domjudge-8.3.1.tar.gz</code></pre></div><p>如果 <code>wget</code> 太慢可以点链接进去下再 <code>sudo mv ./domjudge-8.3.1.tar.gz /opt/</code>。</p><h3 id="编译-domjudge配置数据库和-web-服务器">2. 编译 DOMjudge，配置数据库和 web 服务器</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/domjudge-8.3.1sudo ./configure --prefix=/opt/domjudge --with-domjudge-user=root --with-baseurl=127.0.0.1</code></pre></div><p>这一步如果警告缺少 <code>pkg-config</code> 就 <code>sudo apt install pkg-config</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo make domserver</code></pre></div><p>这一步会弹出一个询问，直接 <code>yes</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo make install-domserver<span class="hljs-built_in">cd</span> /opt/domjudge/domserversudo bin/dj_setup_database -s installsudo <span class="hljs-built_in">ln</span> -s /opt/domjudge/domserver/etc/nginx-conf /etc/nginx/sites-enabled/domjudgesudo <span class="hljs-built_in">ln</span> -s /opt/domjudge/domserver/etc/domjudge-fpm.conf /etc/php/8.3/fpm/pool.d/domjudge.confsudo service php8.3-fpm reload</code></pre></div><p>最后两句 php 要换成对应的版本，我这里是 php8.3。</p><p>最后一句如果警告说要 <code>systemctl daemon-reload</code>，按它说的执行就行。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/nginx/sites-enabledsudo <span class="hljs-built_in">rm</span> defaultsudo service nginx reload<span class="hljs-built_in">cd</span> /opt/domjudge/domserversudo <span class="hljs-built_in">chown</span> www-data:www-data -R webapp/public/*</code></pre></div><p>接着访问 <code>127.0.0.1/domjudge</code> 就有 web 界面了（云服务器就换成公网地址）。</p><p><img src="/image/academic/d1.png" style="zoom:70%;" /></p><p>如果没按前两句把 <code>default</code> 删掉你就会收获 404 的好结果。</p><p>如果还没有 web 界面就看看服务器 80 端口有没有打开。</p><p>接着在网页里 login，账号填 admin，密码通过以下命令获取：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cat</span> /opt/domjudge/domserver/etc/initial_admin_password.secret</code></pre></div><h3 id="配置-php-和-mysql">3. 配置 php 和 mysql</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/php/8.3/fpm/pool.dsudo vim domjudge.conf</code></pre></div><p>如果提示没有 vim，就 <code>sudo apt install vim</code>。</p><p>打开配置文件后找到 <code>php_admin_value[memory_limit]</code> 一栏，改成：</p><div class="code-wrapper"><pre><code class="hljs bash">php_admin_value[memory_limit] = 1024M</code></pre></div><p>再找到 <code>php_admin_value[date.timezone]</code> 一栏，改成：</p><div class="code-wrapper"><pre><code class="hljs bash">php_admin_value[date.timezone] = Asia/Shanghai</code></pre></div><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo service php8.3-fpm reloadsudo vim /etc/mysql/conf.d/mysql.cnf</code></pre></div><p>你会看到一行 <code>[mysql]</code>，删掉。接着粘贴以下内容：</p><div class="code-wrapper"><pre><code class="hljs bash">[mysqld]max_connections = 1000max_allowed_packet = 512MBinnodb_log_file_size = 2560MB</code></pre></div><p>这只是示例，实际 <code>max_allowed_packet</code> 要改成两倍于题目测试数据文件的大小；<code>innodb_log_file_size</code> 要改成十倍于题目测试数据文件的大小。</p><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf</code></pre></div><p>找到 <code>max_allowed_packet = 1G</code>，取消这一行的注释。</p><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl restart mysql</code></pre></div><p>如果一切正常，刷新 DOMjudge 的 web 页面，点进 config checker，你会看到：</p><p><img src="/image/academic/d2.png" style="zoom:30%;" /></p><p><img src="/image/academic/d3.png" style="zoom:35%;" /></p><h3 id="配置-judgehost-docker">4. 配置 judgehost (docker)</h3><p>首先要下载 docker，如果是云服务器，可以找到对应的文档。</p><p>我则是查阅了一些博客和文章，以下命令可能有不妥之处。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span>sudo apt-get update</code></pre></div><p>这里可能会提示 <code>密钥存储在过时的 trusted.gpg 密钥环中</code>，我的解决方法是：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/aptsudo <span class="hljs-built_in">cp</span> trusted.gpg trusted.gpg.dsudo apt-get update</code></pre></div><p>然后就可以安装 docker 了。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo apt-get install docker-ce<span class="hljs-built_in">cd</span> /etc/dockersudo <span class="hljs-built_in">touch</span> daemon.jsonsudo vim daemon.json</code></pre></div><p>粘贴以下内容：</p><div class="code-wrapper"><pre><code class="hljs bash">&#123;    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.1ms.run&quot;</span>]&#125;</code></pre></div><p>其中国内镜像源是我从 <a href="https://cloud.tencent.com/developer/article/2454486">Link</a> 里面找的。</p><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo service docker restart</code></pre></div><p>接着设置 cgroups。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo vim /etc/default/grub</code></pre></div><p>找到 <code>GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"</code> 一行（引号里可能初始是空），改成：</p><div class="code-wrapper"><pre><code class="hljs bash">GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet cgroup_enable=memory swapaccount=1 systemd.unified_cgroup_hierarchy=0&quot;</span></code></pre></div><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo update-grubsudo reboot</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">sudo docker run -d -it --privileged -v /sys/fs/cgroup:/sys/fs/cgroup --name judgehost-new0 --hostname localhost --network=<span class="hljs-string">&quot;host&quot;</span> -e DAEMON_ID=0 -e CONTAINER_TIMEZONE=Asia/Shanghai -e JUDGEDAEMON_PASSWORD=&lt;domserver password&gt; -e DOMSERVER_BASEURL=http://localhost/domjudge/ domjudge/judgehost:8.3.1</code></pre></div><p>其中 <code>&lt;domserver password&gt;</code> 通过以下命令获取：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cat</span> /opt/domjudge/domserver/etc/restapi.secret</code></pre></div><p>如果一切正常，那么：</p><p><img src="/image/academic/d4.png" style="zoom:100%;" /></p><p><img src="/image/academic/d5.png" style="zoom:100%;" /></p><p>如果起多个 judgehost，需要修改 <code>--name</code> 参数和 <code>DAEMON_ID</code> 参数。后者是核编号，不能超过机子的核心数。</p><p>例如起第 2 个 judgehost 的话，命令得是：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo docker run -d -it --privileged -v /sys/fs/cgroup:/sys/fs/cgroup --name judgehost-new1 --hostname localhost --network=<span class="hljs-string">&quot;host&quot;</span> -e DAEMON_ID=1 -e CONTAINER_TIMEZONE=Asia/Shanghai -e JUDGEDAEMON_PASSWORD=&lt;domserver password&gt; -e DOMSERVER_BASEURL=http://localhost/domjudge/ domjudge/judgehost:8.3.1</code></pre></div><p>起第 3 个的话，得是：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo docker run -d -it --privileged -v /sys/fs/cgroup:/sys/fs/cgroup --name judgehost-new2 --hostname localhost --network=<span class="hljs-string">&quot;host&quot;</span> -e DAEMON_ID=2 -e CONTAINER_TIMEZONE=Asia/Shanghai -e JUDGEDAEMON_PASSWORD=&lt;domserver password&gt; -e DOMSERVER_BASEURL=http://localhost/domjudge/ domjudge/judgehost:8.3.1</code></pre></div><h3 id="配置比赛">5. 配置比赛</h3><p>从这里开始就看个人喜好了。</p><p>以下配置均以 UESTC 第十五届趣味程序设计竞赛为例。</p><p>Configuration settings <span class="math inline">\(\to\)</span> External systems <span class="math inline">\(\to\)</span> configuration data external。</p><p>Configuration settings <span class="math inline">\(\to\)</span> Scoring <span class="math inline">\(\to\)</span> Results remap: 将 <code>output-limit</code> 和 <code>no-output</code> 定向为 <code>wrong-answer</code>。</p><p>save 之后如果提示你 Recalculate caches now，就点进去，之后同理。</p><p>Configuration settings <span class="math inline">\(\to\)</span> Judging <span class="math inline">\(\to\)</span> Enable parallel judging 关闭。</p><p>Configuration settings <span class="math inline">\(\to\)</span> Display <span class="math inline">\(\to\)</span> Show flags 关闭。</p><p>Configuration settings <span class="math inline">\(\to\)</span> Display <span class="math inline">\(\to\)</span> Allow team submission download 开启。</p><p>Configuration settings <span class="math inline">\(\to\)</span> Display <span class="math inline">\(\to\)</span> Show language versions 开启。</p><p>回到主页，进 Team Categories。</p><p>把 visible 的三个组别的 external ID 改成 <code>beginner</code>，<code>advanced</code> 和 <code>observer</code>，代表零基础组，有基础组，和打星组。然后把这三个组的 SortOrder 改成同一个数字（这样榜单上才不会割裂显示）。</p><p>接着导入队伍，依据 <a href="https://www.domjudge.org/docs/manual/8.3/import.html#importing-team-affiliations">Link</a> 完成 accounts.yaml，teams.json 和 organizations.json。</p><ul><li>teams.json 中 display_name 虽然是 [option]，但如果不写这一项会默认设成空串，很神秘，所以还是加上。</li></ul><p>以下是我用到的脚本：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># gen_accounts.py</span><span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> string<span class="hljs-comment"># 生成账号的数量</span>account_number = <span class="hljs-number">452</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_team_data</span>():    data_list = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, account_number + <span class="hljs-number">1</span>):        team_id = <span class="hljs-string">f&quot;team<span class="hljs-subst">&#123;i:03d&#125;</span>&quot;</span>        <span class="hljs-built_in">id</span> = <span class="hljs-string">f&quot;account<span class="hljs-subst">&#123;i:03d&#125;</span>&quot;</span>        username = team_id        password = <span class="hljs-string">&#x27;&#x27;</span>.join(random.choices(string.ascii_letters + string.digits, k=<span class="hljs-number">10</span>))        data_list.append(<span class="hljs-string">f&quot;- id: <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>&#125;</span>\n  username: <span class="hljs-subst">&#123;username&#125;</span>\n  password: <span class="hljs-subst">&#123;password&#125;</span>\n  type: team\n  team_id: &#x27;<span class="hljs-subst">&#123;team_id&#125;</span>&#x27;\n\n&quot;</span>)    <span class="hljs-keyword">return</span> data_listteam_data = generate_team_data()<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;accounts.yaml&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:    file.writelines(team_data)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># gen_organizations.py</span><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> json<span class="hljs-comment"># 读取表格第 10 列的内容（学校名称）</span>df = pd.read_excel(<span class="hljs-string">&#x27;name.xlsx&#x27;</span>, usecols=[<span class="hljs-number">9</span>], skiprows=<span class="hljs-number">1</span>)<span class="hljs-comment"># 去重</span>universities = df.iloc[:, <span class="hljs-number">0</span>].dropna().unique()organizations = [&#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>), <span class="hljs-string">&quot;name&quot;</span>: university, <span class="hljs-string">&quot;formal_name&quot;</span>: university, <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;CHN&quot;</span>&#125; <span class="hljs-keyword">for</span> i, university <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(universities) <span class="hljs-keyword">if</span> university]<span class="hljs-comment"># 本校</span>organizations.append(&#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&#x27;电子科技大学&#x27;</span>, <span class="hljs-string">&quot;formal_name&quot;</span>: <span class="hljs-string">&#x27;电子科技大学&#x27;</span>, <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;CHN&quot;</span>&#125;)<span class="hljs-comment"># 没填学校名字的</span>organizations.append(&#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&#x27;未填写&#x27;</span>, <span class="hljs-string">&quot;formal_name&quot;</span>: <span class="hljs-string">&#x27;未填写&#x27;</span>, <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;CHN&quot;</span>&#125;)<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;organizations.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:    json.dump(organizations, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># gen_teams.py</span><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_data</span>():    excel_data = pd.read_excel(<span class="hljs-string">&quot;name.xlsx&quot;</span>, sheet_name=<span class="hljs-number">0</span>)    organizations = &#123;&#125;    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;organizations.json&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:        organizations = json.load(f)    result = []    id_counter = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> excel_data.iterrows():        <span class="hljs-keyword">if</span> pd.isna(row[<span class="hljs-number">1</span>]):            <span class="hljs-keyword">break</span>        <span class="hljs-comment"># row[2]: 是否为本校选手</span>        <span class="hljs-comment"># row[5]: 是否正式参赛</span>        <span class="hljs-comment"># row[6]: 年级</span>        <span class="hljs-comment"># row[8]: 是否有信息竞赛基础</span>        <span class="hljs-comment"># row[9]: 学校（外校）</span>        <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;否&quot;</span> <span class="hljs-keyword">or</span> row[<span class="hljs-number">5</span>] == <span class="hljs-string">&quot;否（不参与评奖）&quot;</span>:            X = <span class="hljs-string">&quot;observer&quot;</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> row[<span class="hljs-number">6</span>] == <span class="hljs-string">&quot;大一&quot;</span> <span class="hljs-keyword">and</span> row[<span class="hljs-number">8</span>] == <span class="hljs-string">&quot;否&quot;</span>:                X = <span class="hljs-string">&quot;beginner&quot;</span>            <span class="hljs-keyword">else</span>:                X = <span class="hljs-string">&quot;advanced&quot;</span>        <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;否&quot;</span>:            S = row[<span class="hljs-number">9</span>]            org_id = <span class="hljs-built_in">next</span>((org[<span class="hljs-string">&quot;id&quot;</span>] <span class="hljs-keyword">for</span> org <span class="hljs-keyword">in</span> organizations <span class="hljs-keyword">if</span> org[<span class="hljs-string">&quot;name&quot;</span>] == S), <span class="hljs-literal">None</span>)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> org_id:                org_id = <span class="hljs-number">101</span>                <span class="hljs-comment"># raise ValueError(f&quot;组织名称 &#x27;&#123;S&#125;&#x27; 未在 organizations.json 中找到！&quot;)</span>        <span class="hljs-keyword">else</span>:            org_id = <span class="hljs-number">100</span>        item = &#123;            <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">f&quot;team<span class="hljs-subst">&#123;id_counter:03d&#125;</span>&quot;</span>,            <span class="hljs-string">&quot;group_ids&quot;</span>: [<span class="hljs-built_in">str</span>(X)],            <span class="hljs-string">&quot;name&quot;</span>: row[<span class="hljs-number">1</span>],            <span class="hljs-string">&quot;display_name&quot;</span>: row[<span class="hljs-number">1</span>],            <span class="hljs-string">&quot;organization_id&quot;</span>: <span class="hljs-built_in">str</span>(org_id)        &#125;        result.append(item)        id_counter += <span class="hljs-number">1</span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;teams.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> outfile:        json.dump(result, outfile, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    generate_data()</code></pre></div><p>生成完毕后回到主页，点进 import / export，找到 Teams &amp; groups <span class="math inline">\(\to\)</span> Import JSON / YAML。</p><p>将上述三个文件按 organizations.json，teams.json，accounts.yaml 的顺序传上去（务必注意顺序，Type 也要随着改动）。</p><p>不同大学的校徽可以在 <a href="https://github.com/CSGrandeur/CCPCOJ/tree/master/ojweb/public/static/image/school_badge">Link</a> 或 <a href="https://www.urongda.com/logos">Link</a> 里下载，再到主页进 Team Affiliations 里编辑上传。</p><p>接着建立 Contests。回到主页点进 Contests，demo 删掉，Add new contest，External ID 随便填一个，剩下的选项都有注释，不再赘述。</p><ul><li>注意时间格式的 <code>timezone</code> 应该填 <code>Asia/Shanghai</code> 而不是 <code>UTC+8</code>。</li></ul><p>可以利用 Problemset document 选项上传题面，在 Polygon 导出 Chinese 题面 PDF 的方法：</p><ul><li>右边栏 Properties/File，找到 statements.ftl，Edit。</li><li>开头粘贴 <code>\usepackage &#123;CJK&#125;</code>，<code>\begin&#123;document&#125;</code> 之后粘贴 <code>\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125;</code>，结尾 <code>\end&#123;document&#125;</code> 前粘贴 <code>\end &#123;CJK&#125;</code>。</li></ul><p>接着上传题目。需要借助 <a href="https://github.com/cn-xcpc-tools/Polygon2DOMjudge/blob/master/README.cn.md">Link</a>。</p><p>Polygon 点进 Contest，右边栏找到 Build full packages (+verify)，点 (+verify)，之后点进每个题目的 Package 界面下载 Linux 版本的 package。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo apt install pipxpipx install p2dpipx ensurepath</code></pre></div><p>关掉这个终端，重新开一个。</p><p>对每一题执行以下命令：</p><div class="code-wrapper"><pre><code class="hljs bash">p2d --code A --color <span class="hljs-string">&quot;#FF0000&quot;</span> -o /path/to/domjudge-package.zip /path/to/polygon-package.zip</code></pre></div><p>其中 code 是题目的 short name，color 是题目在 DOMjudge 中的颜色，更多设置项可以点进链接里试。</p><ul><li><code>--external-id</code> 也建议设置成 ABCD。</li></ul><p>得到的 domjudge-package.zip 就可以在 Import and export <span class="math inline">\(\to\)</span> Problems 里上传了。</p><p>补一个邮件收集脚本：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> yaml<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_accounts_yaml</span>(<span class="hljs-params">file_path</span>):    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:        accounts = yaml.safe_load(file)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(accounts, <span class="hljs-built_in">list</span>):        accounts_dict = &#123;item[<span class="hljs-string">&#x27;username&#x27;</span>]: item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> accounts&#125;    <span class="hljs-keyword">else</span>:        accounts_dict = accounts    <span class="hljs-keyword">return</span> accounts_dict<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_mail_xlsx</span>(<span class="hljs-params">name_file, accounts_yaml</span>):    df = pd.read_excel(name_file)    accounts = load_accounts_yaml(accounts_yaml)    data = []    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> df.iterrows():        <span class="hljs-keyword">if</span> pd.isna(row[<span class="hljs-number">1</span>]):            <span class="hljs-keyword">break</span>        name = row[<span class="hljs-number">1</span>]        <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;是&#x27;</span>:            <span class="hljs-built_in">id</span> = <span class="hljs-built_in">int</span>(row[<span class="hljs-number">4</span>])            email = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>) + <span class="hljs-string">&quot;@std.uestc.edu.cn&quot;</span>            email2 = <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">else</span>:            email = <span class="hljs-built_in">str</span>(row[<span class="hljs-number">10</span>])            <span class="hljs-keyword">if</span> pd.isna(row[<span class="hljs-number">11</span>]):                email2 = <span class="hljs-string">&quot;&quot;</span>            <span class="hljs-keyword">else</span>:                email2 = <span class="hljs-built_in">str</span>(row[<span class="hljs-number">11</span>])        username = <span class="hljs-string">f&quot;team<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>:03d&#125;</span>&quot;</span>        password = accounts.get(username, &#123;&#125;).get(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;否&quot;</span> <span class="hljs-keyword">or</span> row[<span class="hljs-number">5</span>] == <span class="hljs-string">&quot;否（不参与评奖）&quot;</span>:            user_type = <span class="hljs-string">&quot;打星组&quot;</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> row[<span class="hljs-number">6</span>] == <span class="hljs-string">&quot;大一&quot;</span> <span class="hljs-keyword">and</span> row[<span class="hljs-number">8</span>] == <span class="hljs-string">&quot;否&quot;</span>:                user_type = <span class="hljs-string">&quot;初学组&quot;</span>            <span class="hljs-keyword">else</span>:                user_type = <span class="hljs-string">&quot;进阶组&quot;</span>        data.append([name, email, email2, username, password, user_type])    mail_df = pd.DataFrame(data, columns=[<span class="hljs-string">&quot;姓名&quot;</span>, <span class="hljs-string">&quot;邮箱1&quot;</span>, <span class="hljs-string">&quot;邮箱2&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;组别&quot;</span>])    mail_df.to_excel(<span class="hljs-string">&#x27;mail.xlsx&#x27;</span>, index=<span class="hljs-literal">False</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    create_mail_xlsx(<span class="hljs-string">&#x27;name.xlsx&#x27;</span>, <span class="hljs-string">&#x27;accounts.yaml&#x27;</span>)</code></pre></div><h3 id="比赛结束后">6. 比赛结束后</h3><p>结束的时候马上点进 Contest 界面把 Allow submit 选项关掉。</p><p>接着导出榜单和提交。</p><p>榜单直接在浏览器界面右键打印，选择打印到 PDF。如果预览出来是黑白的，就在更多设置里面找到 "背景图形" 打上勾。</p><p>导出提交需要用到 <a href="https://github.com/HeRaNO/ChickenRibs/blob/master/ICPCToy/DOMjudge/dj_download_submissions.py">Link</a>。命令如下：</p><div class="code-wrapper"><pre><code class="hljs bash">py dj_download_submissions.py http://localhost/domjudge/ &lt;contest-external-id&gt;</code></pre></div><p>其中 <code>&lt;contest-external-id&gt;</code> 是 contest 页面的 external ID。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>note</tag>
      
      <tag>DOMjudge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【游记】2024 CCPC 网络预选赛</title>
    <link href="/posts/a57ce1e5.html"/>
    <url>/posts/a57ce1e5.html</url>
    
    <content type="html"><![CDATA[<p>UESTC_EndlessEmbrace 第一场正式的比赛。</p><p>快到九点才起床，本来昨晚和同样晕车的 kkaaxxrrdxing4c 商量好了一起做地铁去，但起床一刷消息发现被鸽了，只好重新买上了九点半的车票，赶忙跑去东门把模板印了。</p><p>很困，昨晚临时补了一些板子，两点才睡。车上很颠，没睡着，意料之中。</p><p>12点整，PTA 准时开崩。以前只是有所耳闻，这下身临其境了。</p><p>队友和我上去打了点板子，期间刷新出了一道签 L，马上秒了（伏笔），继续敲板子。</p><p>大概 44min 终于能交题了，交，WA，我趣，字符串读的 0-index 写的 1-index，气晕了，47minL2A。</p><p>接着签 B，很快啊，WA。wbc 签 K，63minK1A，随后发现我少了个特判，加上过了，64minB2A。</p><p>队友开 D，我开其它的，两个队友都是 dp 糕手，讨论出了一个区间 dp，115minD1A。</p><p>PTA 发了延时通知，延了 1h，很难评价。</p><p>看榜 UESTC_PenaltyAutomaton 过了不到 10 个队过的 C，大为震撼。</p><p>于是看了 C，跟 wp 说了一个贪心，不知道对不对就上去写了，WA，换了一个贪心策略又 WA 了两发，耻辱换题。按榜看了 J，写了两发线性基，仍 WA，红温进行时。</p><p>这期间队友一直在攻 E，两个多小时终于找对了方向，283minE2A。</p><p>冷静了一下，改了一下线性基的逻辑，终于 287minJ3A。</p><p>时间不多了，大伙一起看 I，wp 很快就会 dp 了，就让他上去写，我和 wbc 研究 C。</p><p>我简单说了一下我的做法，他也觉得很对啊，我就打印了一下肉眼查错。</p><p>最后半小时 I 题狂 T，一起帮着 wp 卡常，可惜的是直到比赛结束也没卡过。同时也发现 C 其实假了。</p><p>6 题 Rank360/9 收尾，有点沮丧。赛后发现 C，G，I 都不应该丢，但马后炮也意义不大，只能希望下周 ICPC 打得好一点。</p><p>FunFact：赛后把 I 题 clone 下来开大了时限把赛时代码交了上去，1952msAccepted，赛时时限是 1s。</p><hr /><h3 id="a.-军训-i">A. 军训 I</h3><div class="note note-success">            <p>可以预见的是合法的状态数很少。</p><p>实际上可以证明 <span class="math inline">\(k &gt; 13\)</span> 时无解：把所有人移到一个角，这些人在这个角最多只有 <span class="math inline">\(2\)</span> 种方案，移到一个角之后向另外三个角移动一共 <span class="math inline">\(2\cdot 4=8\)</span> 种。四个方向单移动一次共 <span class="math inline">\(4\)</span> 种，再加上原状态 <span class="math inline">\(1\)</span> 种共 <span class="math inline">\(13\)</span> 种。</p><p>对 <span class="math inline">\(k\in [1,13]\)</span> 打表发现 <span class="math inline">\(k=8,10,12\)</span> 时无解，同时还能很快打出 <span class="math inline">\(\min(n,m)&lt;3\)</span> 的情况进行特判。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        打表程序    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">20</span>; k++) &#123;<span class="hljs-function">vector <span class="hljs-title">a</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(m))</span></span>;<span class="hljs-keyword">auto</span> do_L = [&amp;] () &#123;vector b = a;b.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cnt += a[i][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; j++) &#123;b[i][j] = <span class="hljs-number">1</span>;&#125;&#125;a = b;&#125;;<span class="hljs-keyword">auto</span> do_R = [&amp;] () &#123;vector b = a;b.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cnt += a[i][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= m - cnt; j--) &#123;b[i][j] = <span class="hljs-number">1</span>;&#125;&#125;a = b;&#125;;<span class="hljs-keyword">auto</span> do_U = [&amp;] () &#123;vector b = a;b.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cnt += a[i][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;b[i][j] = <span class="hljs-number">1</span>;&#125;&#125;a = b;&#125;;<span class="hljs-keyword">auto</span> do_D = [&amp;] () &#123;vector b = a;b.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cnt += a[i][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= n - cnt; i--) &#123;b[i][j] = <span class="hljs-number">1</span>;&#125;&#125;a = b;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; (n * m)); i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; m; l++) &#123;<span class="hljs-type">int</span> o = j * m + l;<span class="hljs-keyword">if</span> (i &gt;&gt; o &amp; <span class="hljs-number">1</span>) &#123;a[j][l] = <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;a[j][l] = <span class="hljs-number">0</span>;&#125;&#125;&#125;map&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> step) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (res &gt; k) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (!mp[a]) &#123;mp[a] = <span class="hljs-number">1</span>;res++;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (step &gt; <span class="hljs-number">100</span>) &#123;<span class="hljs-keyword">return</span> ;&#125;vector b = a;<span class="hljs-built_in">do_U</span>();<span class="hljs-built_in">self</span>(self, step + <span class="hljs-number">1</span>);a = b;<span class="hljs-built_in">do_D</span>();<span class="hljs-built_in">self</span>(self, step + <span class="hljs-number">1</span>);a = b;<span class="hljs-built_in">do_L</span>();<span class="hljs-built_in">self</span>(self, step + <span class="hljs-number">1</span>);a = b;<span class="hljs-built_in">do_R</span>();<span class="hljs-built_in">self</span>(self, step + <span class="hljs-number">1</span>);&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (res == k) &#123;cout &lt;&lt; <span class="hljs-string">&quot;k = &quot;</span> &lt;&lt; k &lt;&lt; <span class="hljs-string">&quot; is ok&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; m; l++) &#123;<span class="hljs-type">int</span> o = j * m + l;<span class="hljs-keyword">if</span> (i &gt;&gt; o &amp; <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;0&quot;</span>;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>当 <span class="math inline">\(n,m \ge 3\)</span> 时，分出以下情况，打表找规律（听着难，实际上打出字典序最小的一个就能看出来）：</p><ul><li><span class="math inline">\(k=1\)</span>，把所有格子填满。</li><li><span class="math inline">\(k=2\)</span>，把第一行填满。</li><li><span class="math inline">\(k=3\)</span>，把第二行填满。</li><li><span class="math inline">\(k=4\)</span>，填 <span class="math inline">\((1,1)\)</span>。</li><li><span class="math inline">\(k=5\)</span>，此时合法的局面需要满足移动一次后向任意方向移动都没意义。当 <span class="math inline">\(n=m\)</span> 时填满任意一条对角线是好想的。<span class="math inline">\(n \neq m\)</span> 时考虑把 <span class="math inline">\(n\times m\)</span> 分成若干个 <span class="math inline">\(x\times x\)</span> 的子矩阵，每个子矩阵填满一条对角线。此时可取 <span class="math inline">\(x = \gcd(n, m)\)</span>。</li><li><span class="math inline">\(k=6\)</span>， 填 <span class="math inline">\((1, 2)\)</span>。</li><li><span class="math inline">\(k=7\)</span>，填 <span class="math inline">\((2, 1)\land (1,x),x\in[2, m]\)</span>。</li><li><span class="math inline">\(k=9\)</span>，填 <span class="math inline">\((1, 2)\land (2, 1)\)</span>。</li><li><span class="math inline">\(k=11\)</span>，填 <span class="math inline">\((1, 3)\land (2, 1)\)</span>。</li><li><span class="math inline">\(k=13\)</span>，填 <span class="math inline">\((1, 3)\land (3, 1)\)</span>。</li></ul><p>代码写的比较 shit，如果把 <span class="math inline">\(n=2\)</span> 和 <span class="math inline">\(m=2\)</span> 单独列出来会直观很多，但我懒得改 shit 了。</p><p>时间复杂度 <span class="math inline">\(O(nm)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NO (void)(cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>)</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cout &lt;&lt; <span class="hljs-string">&#x27;*&#x27;</span>;&#125;&#125;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">auto</span> print = [&amp;] (vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;&gt; a) -&gt; <span class="hljs-type">void</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : a) &#123;<span class="hljs-keyword">if</span> (x == i + <span class="hljs-number">1</span> &amp;&amp; y == j + <span class="hljs-number">1</span>) &#123;ok = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;cout &lt;&lt; (ok ? <span class="hljs-string">&#x27;*&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>);&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> printl = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">void</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-keyword">if</span> ((x &amp;&amp; x == i + <span class="hljs-number">1</span>) || (y &amp;&amp; y == j + <span class="hljs-number">1</span>)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;&#125;&#125;&#125;&#125;;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> &amp;&amp; m == <span class="hljs-number">1</span>) &#123;NO;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(n, m) == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">max</span>(n, m) == <span class="hljs-number">2</span>) &#123;k == <span class="hljs-number">2</span> ? <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;) : NO;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(n, m) == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) &#123;n == <span class="hljs-number">1</span> ? <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;) : <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> &amp;&amp; m == <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">5</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> &amp;&amp; m == <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">6</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">7</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">9</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span> &amp;&amp; m == <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">6</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">7</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">9</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) &#123;n &gt; m ? <span class="hljs-built_in">printl</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) : <span class="hljs-built_in">printl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">5</span>) &#123;<span class="hljs-keyword">if</span> (__gcd(n, m) == <span class="hljs-number">1</span>) &#123;NO;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-type">int</span> g = __gcd(n, m);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> x = i % g;<span class="hljs-type">int</span> y = j % g;<span class="hljs-keyword">if</span> (x == y) &#123;cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;&#125;&#125;&#125;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">6</span>) &#123;n &lt; m ? <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;) : <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">7</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-keyword">if</span> ((i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">0</span>) || (i == <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;&#125;&#125;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">9</span>) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">11</span>) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">13</span>) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || m == <span class="hljs-number">2</span>) &#123;NO;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125;&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="b.-军训-ii">B. 军训 II</h3><div class="note note-success">            <p>感性地，排序后不整齐度最小。</p><p><span class="math inline">\(ans1\)</span> 可以单 <span class="math inline">\(\log\)</span> 求，但允许 <span class="math inline">\(O(n^2)\)</span> 就没必要自讨苦吃。</p><p>接着设每个连续段长 <span class="math inline">\(cnt_i\)</span>，那么 <span class="math inline">\(ans2=2\prod cnt_i\)</span>。系数来自升序排序和降序排序两种。</p><p>特判：所有数都相同时，升序和降序看作一种，<span class="math inline">\(ans2=\prod cnt_i\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fac</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;fac[i] = fac[i - <span class="hljs-number">1</span>] * i % modp;&#125; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> ans1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> mx = a[i], mn = a[i];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; j++) &#123;mx = <span class="hljs-built_in">max</span>(mx, a[j]);mn = <span class="hljs-built_in">min</span>(mn, a[j]);ans1 += mx - mn;&#125;&#125;<span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, ans2 = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (a[i] != a[i - <span class="hljs-number">1</span>]) &#123;ans2 *= fac[cnt];ans2 %= modp;cnt = <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;cnt++;&#125;&#125;ans2 *= fac[cnt];ans2 %= modp;vector b = a;<span class="hljs-built_in">reverse</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span> (a != b) &#123;ans2 *= <span class="hljs-number">2</span>;ans2 %= modp;&#125;cout &lt;&lt; ans1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="c.-种树">C. 种树</h3><div class="note note-success">            <p>将已经种了树的点称为黑点，否则白点。</p><p>两种<strong>错误</strong>的贪心举例：</p><ul><li>两个黑点间夹 <span class="math inline">\(k\)</span> 个白点，<span class="math inline">\(k\)</span> 为偶数时用 <span class="math inline">\(\dfrac{k}{2}\)</span> 次操作填满。</li><li>以两个或以上相连的黑点为界，每个连通块贡献为 <span class="math inline">\(\left\lceil \dfrac{白点个数}{2}\right\rceil\)</span>。</li></ul><p>反例对应如下。</p><p><img src="/image/academic/CCPC1.png" style="zoom:25%;" /></p><p><strong>正确</strong>的贪心：任选一黑点为根 dfs，自下而上贪心，每次填两个。对于一个黑点：</p><ul><li>若当前子树中白点数为偶数，填满。</li><li>否则考虑是否能把多余的一个涂色操作摊给当前黑点的父亲。</li></ul><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> rt = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[x] = <span class="hljs-literal">true</span>;rt = x;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;sz[x] = a[x] == <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);sz[x] += sz[y];&#125;<span class="hljs-keyword">if</span> (a[x]) &#123;ans += sz[x] / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (sz[x] % <span class="hljs-number">2</span>) &#123;ans++;<span class="hljs-keyword">if</span> (fath &amp;&amp; a[fath] == <span class="hljs-number">0</span>) &#123;a[fath] = <span class="hljs-number">1</span>;sz[fath]--;&#125;&#125;sz[x] = <span class="hljs-number">0</span>;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-疯狂星期六">G. 疯狂星期六</h3><div class="note note-success">            <p>yyq 需要尽可能花多的钱，而他花的最多的钱数是可以处理出来的，即 <span class="math inline">\(X=\min(\sum \text{能摊到 yyq 上的菜钱}+T_1,a_1)\)</span>。</p><p>令 <span class="math inline">\(mx_i\)</span> 为第 <span class="math inline">\(i\)</span> 个人能花在菜上的最多钱数，首先 <span class="math inline">\(mx_1=X-T_1\)</span>，那么 <span class="math inline">\(mx_i=\min(a_i,mx_1-1)\)</span>。</p><p>接着只需 check 是否存在一种满足上述条件的方案。</p><p>转化为网络流问题：</p><ul><li>源点向每个菜连容量为菜钱的边。</li><li>每个菜向付它钱的两个人连容量为菜钱的边。</li><li>每个人向汇点连容量为 <span class="math inline">\(mx_i\)</span> 的边。</li></ul><p>check 成功当且仅当最大流 <span class="math inline">\(=\)</span> 总菜钱。</p><p>时间复杂度 <span class="math inline">\(O(n\sqrt{m})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span> &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<span class="hljs-type">int</span> x, cap;<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cap) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">cap</span>(cap) &#123;&#125; &#125;;<span class="hljs-type">int</span> n;vector&lt;Edge&gt; e;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; dep, cur;<span class="hljs-built_in">Dinic</span>(<span class="hljs-type">int</span> size) &#123;<span class="hljs-keyword">this</span>-&gt;n = size;adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cap)</span> </span>&#123;adj[x].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;y, cap&#125;);adj[y].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>&#125;);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;dep.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(S);dep[S] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : adj[x]) &#123;<span class="hljs-keyword">auto</span> [y, cap] = e[i];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == <span class="hljs-number">-1</span>) &#123;dep[y] = dep[x] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (y == T) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> T, <span class="hljs-type">int</span> limit)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == T) &#123;<span class="hljs-keyword">return</span> limit;&#125;<span class="hljs-type">int</span> r = limit;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i = cur[x]; i &lt; adj[x].<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-type">const</span> <span class="hljs-type">int</span> j = adj[x][i];<span class="hljs-keyword">auto</span> [y, cap] = e[j];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == dep[x] + <span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> t = <span class="hljs-built_in">dfs</span>(y, T, <span class="hljs-built_in">min</span>(r, cap));e[j].cap -= t;e[j ^ <span class="hljs-number">1</span>].cap += t;r -= t;<span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> limit;&#125;&#125;&#125;<span class="hljs-keyword">return</span> limit - r;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(S, T)) &#123;cur.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);flow += <span class="hljs-built_in">dfs</span>(S, T, inf); &#125; <span class="hljs-keyword">return</span> flow;&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">Taxi</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i] &gt;&gt; Taxi[i];&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">dish</span>(m + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mxcost</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> all = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;dish[i] = &#123;x, y, w&#125;;all += w;<span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span> || y == <span class="hljs-number">1</span>) &#123;mxcost[<span class="hljs-number">1</span>] += w;&#125;&#125;mxcost[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(a[<span class="hljs-number">1</span>], mxcost[<span class="hljs-number">1</span>] + Taxi[<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;mxcost[i] = <span class="hljs-built_in">min</span>(a[i], mxcost[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) - Taxi[i];<span class="hljs-keyword">if</span> (mxcost[i] &lt; <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;mxcost[<span class="hljs-number">1</span>] -= Taxi[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> S = m + n + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> T = m + n + <span class="hljs-number">2</span>;<span class="hljs-function">Dinic <span class="hljs-title">G</span><span class="hljs-params">(T)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-keyword">auto</span> [x, y, w] = dish[i];G.<span class="hljs-built_in">add</span>(S, i, w);G.<span class="hljs-built_in">add</span>(i, m + x, w);G.<span class="hljs-built_in">add</span>(i, m + y, w);&#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;G.<span class="hljs-built_in">add</span>(m + i, T, mxcost[i]);&#125;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dinic</span>(S, T) == all) &#123;cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="j.-找最小">J. 找最小</h3><div class="note note-success">            <p>令 <span class="math inline">\(c_i=a_i\oplus b_i\)</span>，<span class="math inline">\(A=\oplus_{i=1}^{n} a_i\)</span>，<span class="math inline">\(B=\oplus_{i=1}^{n} b_i\)</span>。</p><p>根据异或运算的自反性，题目转化为需要选一些 <span class="math inline">\(c_i\)</span>（设选出的 <span class="math inline">\(c_i\)</span> 的异或和为 <span class="math inline">\(C\)</span>）使得 <span class="math inline">\(\max(A\oplus C,B\oplus C)\)</span> 最小。</p><p>联想到线性基，其能解决这样一类问题：从一堆数中选出若干个数，它们的异或和最大/最小。</p><p>插入操作不用修改，查询时不妨将 <span class="math inline">\(\max(A,B)\)</span> 作为初值，代表已经选出这么多。</p><p>随后从高位向低位贪心，判断到某位异或之后 <span class="math inline">\(\max\)</span> 变小就更新即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; p;<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">p</span>(_n + <span class="hljs-number">1</span>) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (!(x &gt;&gt; i)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (!p[i]) &#123;p[i] = x;<span class="hljs-keyword">break</span>;&#125;x ^= p[i];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> st1, <span class="hljs-type">int</span> st2)</span> </span>&#123;<span class="hljs-type">int</span> res = <span class="hljs-built_in">max</span>(st1, st2);<span class="hljs-type">int</span> X = st1, Y = st2;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(X ^ p[i], Y ^ p[i]) &lt; res) &#123;X ^= p[i];Y ^= p[i];res = <span class="hljs-built_in">max</span>(X, Y);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> val1 = <span class="hljs-number">0</span>, val2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];val1 ^= a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; b[i];val2 ^= b[i];&#125;<span class="hljs-function">Node <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;t.<span class="hljs-built_in">insert</span>(a[i] ^ b[i]);&#125;cout &lt;&lt; t.<span class="hljs-built_in">getans</span>(val1, val2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-取沙子游戏">K. 取沙子游戏</h3><div class="note note-success">            <p>当 <span class="math inline">\(n\)</span> 为奇数时，先手拿 <span class="math inline">\(1\)</span>，之后后手和先手都只能轮流拿 <span class="math inline">\(1\)</span>，先手必胜。</p><p>否则，先手只能拿偶数，一种策略是每次拿 $ $，之后后手无论拿什么，先手跟着拿就行。</p><p>故当 <span class="math inline">\(\text{lowbit(n)}\le k\)</span> 时，先手必胜。否则无论拿 <span class="math inline">\(1\sim k\)</span> 中的多少，<span class="math inline">\(\text{lowbit(n)}\)</span> 都会落到 <span class="math inline">\(k\)</span> 以内，让后手取得胜利。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;<span class="hljs-keyword">if</span> ((n &amp; -n) &lt;= k) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>CCPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>UESTC_EndlessEmbrace</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】2024 UESTC 暑假集训 第二轮</title>
    <link href="/posts/70be1dc7.html"/>
    <url>/posts/70be1dc7.html</url>
    
    <content type="html"><![CDATA[<p>收录了二轮集训的部分题解。</p><hr /><p>抛一点链接，方便日后跳转。</p><p>7.31 https://codeforces.com/gym/537696（2024 HDU 多校 6）</p><p>8.1 https://codeforces.com/gym/539789（SEERC 2020）</p><p>8.2 https://codeforces.com/gym/540037（2023 江苏省赛/ CCPC Hunan）</p><p>8.3 https://codeforces.com/gym/540187（2020 CCPC Weihai）</p><p>8.4 https://codeforces.com/gym/105173（2024 东北四省赛 / CCPC Northeast）</p><p>8.5 https://codeforces.com/gym/540735（2023 Nanjing Regional / Ucup 2-11）</p><p>8.6 https://codeforces.com/gym/541036（UKIEPC 2023）</p><p>8.7 https://codeforces.com/gym/541235（NEERC 2019-2020）</p><p>8.8 https://codeforces.com/gym/541365（2024 上海市赛）</p><p>8.9 https://codeforces.com/gym/541786（2024 陕西省赛）</p><p>8.10 https://codeforces.com/gym/541891（2024 吉林省赛 / CCPC Changchun）</p><p>8.11 https://codeforces.com/gym/104976（2023 Hangzhou Regional / Ucup 2-22）</p><p>8.12 https://codeforces.com/gym/542320（毒瘤 psk / 998244353）</p><p>8.13 https://codeforces.com/gym/541594（SEERC 2022）</p><p>8.14 https://codeforces.com/gym/542837（ECNA 2022）</p><p>8.15 https://codeforces.com/gym/543029（2022 CCPC Weihai）</p><p>8.16 https://codeforces.com/gym/543323（NWERC 2019）</p><p>8.17 https://codeforces.com/gym/543433（2020 CCPC Changchun）</p><p>8.18 被赶出清水河</p><p>8.22 https://codeforces.com/gym/105231（2024 江西省赛）</p><p>8.23 https://codeforces.com/gym/102822（2020 CCPC Mianyang）</p><p>8.24 https://codeforces.com/gym/102769（2020 CCPC Qinhuangdao）</p><p>8.25 https://codeforces.com/gym/104252（2022-2023 Latin American Regional）</p><p>8.26 https://codeforces.com/gym/103081（SWERC 2020）</p><p>8.28 https://codeforces.com/gym/104064（NWERC 2021）</p><p>8.29 https://codeforces.com/gym/104787（2023 CCPC Qinhuangdao / Ucup 2-9）</p><p>8.30 https://codeforces.com/gym/104945（SWERC 2023）</p><h2 id="hdu-多校-第6场">2024 HDU 多校 第6场</h2><h3 id="b.-造花困难版分类讨论">B. 造花（困难版）【分类讨论】</h3><div class="note note-info">            <p>给定一张无重边无自环不保证联通的无向图，若删去某个点后整个图被分为若干菊花图，则称这个点为混沌点。升序输出所有混沌点编号，或报告不存在。</p><p><span class="math inline">\(1 \le n, m \le 2\cdot 10^6\)</span>。</p>          </div><div class="note note-success">            <p>首先可以暴力 check（通过度数判断）这张图的每个连通分量是不是菊花图。若有两个及以上的连通分量不是菊花图，则无解；否则我们只考虑不是菊花图的那个连通分量。</p><p>分两种情况考虑：</p><ul><li>这个连通分量是一棵树。通过以下步骤可以 <span class="math inline">\(O(n)\)</span> check 每个点是不是混沌点：<ul><li>对于每个点 <span class="math inline">\(x\)</span>，新建变量 <code>sum = 0</code>，遍历 <span class="math inline">\(x\)</span> 的邻接点 <span class="math inline">\(y\)</span>。若 <span class="math inline">\(y\)</span> 的度数为 <span class="math inline">\(2\)</span>，则继续遍历 <span class="math inline">\(y\)</span> 的邻接点 <span class="math inline">\(z\)</span>（<span class="math inline">\(z \neq x\)</span>），<code>sum += deg[z] + 1</code>；否则 <code>sum += deg[y]</code>。若删去 <span class="math inline">\(x\)</span> 该树被分为两个菊花图，那么此时度数统计完全，应有 <code>sum == n - 1</code>。这里 <span class="math inline">\(n\)</span> 是连通分量的大小。</li></ul></li><li>这个联通分量不是树（有环）。此时有两个性质可以手玩出来：<ol type="1"><li>若存在混沌点，该连通分量所有环的大小最多是四元环。</li><li>若有多个环，混沌点只能是所有环的交集。</li></ol></li></ul><p>由结论 <span class="math inline">\(2\)</span>，我们只需要随便从这个连通分量中找一个环，此时所有可能的混沌点都在这个环上。又由结论 <span class="math inline">\(1\)</span>，可以暴力 check 这些可能的混沌点，最多 check 不超过 <span class="math inline">\(4\)</span> 次。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ori_rd</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);ori_rd[x]++;ori_rd[y]++;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cir</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; need_to_check;<span class="hljs-type">int</span> cnt_circle = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> find_circle = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;cir[x] = <span class="hljs-literal">true</span>;fa[x] = fath;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (cir[y]) &#123;fa[y] = x;<span class="hljs-keyword">if</span> (cnt_circle == <span class="hljs-number">0</span>) &#123;cnt_circle = <span class="hljs-number">1</span>;need_to_check.<span class="hljs-built_in">push_back</span>(y);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = fa[y]; i != y; i = fa[i]) &#123;cnt_circle++;need_to_check.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[y] = <span class="hljs-literal">true</span>;<span class="hljs-built_in">self</span>(self, y, x);&#125;cir[x] = <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">auto</span> ok = [&amp;] (<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> A = <span class="hljs-number">0</span>) &#123;vector&lt;<span class="hljs-type">int</span>&gt; rd = ori_rd;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">if</span> (A == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;rd[x]--;&#125;rd[rt] = <span class="hljs-number">0</span>;vis[rt] = <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> rdn;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-literal">true</span>;rdn += rd[x] &gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y);&#125;&#125;;<span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;<span class="hljs-keyword">if</span> (!vis[x]) &#123;rdn = <span class="hljs-number">0</span>;<span class="hljs-built_in">dfs</span>(dfs, x);<span class="hljs-keyword">if</span> (rdn &gt; <span class="hljs-number">1</span>) &#123;flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> flag;&#125;;<span class="hljs-type">int</span> block = <span class="hljs-number">0</span>, block_id = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>(i, <span class="hljs-number">1</span>)) &#123;block++;block_id = i;&#125;cnt_circle = <span class="hljs-number">0</span>;<span class="hljs-built_in">find_circle</span>(find_circle, i, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (cnt_circle &gt; <span class="hljs-number">4</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (block &gt;= <span class="hljs-number">2</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">if</span> (need_to_check.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> check_tree = [&amp;] (<span class="hljs-type">int</span> A) &#123;vector&lt;<span class="hljs-type">int</span>&gt; b;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;b.<span class="hljs-built_in">push_back</span>(x);vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, A, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (ori_rd[y] == <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> o : adj[y]) &#123;<span class="hljs-keyword">if</span> (o == x) &#123;<span class="hljs-keyword">continue</span>;&#125;res += ori_rd[o] + <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;res += ori_rd[y];&#125;&#125;<span class="hljs-keyword">if</span> (res == b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;ans.<span class="hljs-built_in">push_back</span>(x);&#125;&#125;&#125;;<span class="hljs-keyword">if</span> (block_id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;<span class="hljs-built_in">check_tree</span>(i);&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">check_tree</span>(block_id);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : need_to_check) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>(x)) &#123;ans.<span class="hljs-built_in">push_back</span>(x);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-树上-mex-问题dp">G. 树上 MEX 问题【dp】</h3><div class="note note-info">            <p>定义一张图的 MEX 为：图中所有点的点权构成的集合中，最小的没有出现过的非负整数。</p><p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，点有点权 <span class="math inline">\(a_i\)</span>，保证<strong>点权互不相同</strong>。求这棵树的所有联通导出子图的 MEX 之和，对 998244353 取模。</p><p><span class="math inline">\(1 \le n \le 10 ^6\)</span>，<span class="math inline">\(0 \le a_i &lt; n\)</span>。</p>          </div><div class="note note-success">            <p>设 <span class="math inline">\(T_i\)</span> 为由点权为 <span class="math inline">\(0\sim i\)</span> 的点构成的极小联通子图，<span class="math inline">\(cnt_i\)</span> 为包含 <span class="math inline">\(T_i\)</span> 的联通子图个数。</p><p>则有结论：<span class="math inline">\(ans = \sum_\limits{i = 0}^{n - 1}cnt_i\)</span>。</p><ul><li>证明：子图 <span class="math inline">\(T_i\)</span> 的 mex 为 <span class="math inline">\(i + 1\)</span>，且 <span class="math inline">\(T_i\)</span> 一定包含 <span class="math inline">\(T_0\sim T_{i - 1}\)</span>，故 mex 恰好为 <span class="math inline">\(i + 1\)</span> 的联通子图个数为 <span class="math inline">\(cnt_i - cnt_{i + 1}\)</span>，有： <span class="math display">\[\large \begin{align}ans &amp;=\sum_{i = 0}^{n - 1}(i + 1)(cnt_i-cnt_{i + 1})\\&amp;=(cnt_{0}-cnt_{1})+2(cnt_1 - cnt_2)+3(cnt_2-cnt_3)+\cdots \\&amp;=\sum_{i = 0}^{n - 1}cnt_i\end{align}\]</span></li></ul><p>于是仅需求出 <span class="math inline">\(cnt_i\)</span>。</p><p>接下来考虑如何对连通子图进行计数。</p><p>令 <span class="math inline">\(f_i\)</span> 代表节点 <span class="math inline">\(i\)</span> 可选可不选时以 <span class="math inline">\(i\)</span> 为根的子树中以 <span class="math inline">\(i\)</span> 为根的联通子图个数；</p><p>令 <span class="math inline">\(g_i\)</span> 代表限定节点 <span class="math inline">\(i\)</span> 必须选时以 <span class="math inline">\(i\)</span> 为根的子树中以 <span class="math inline">\(i\)</span> 为根的联通子图个数，则： <span class="math display">\[\large\begin{cases}g_x = \prod_{y\in son_x}f_y\\f_x = g_x + 1\end{cases}\]</span> 显然 <span class="math inline">\(cnt_0=g_0\)</span>。</p><p>再考虑如何从 <span class="math inline">\(cnt_{i - 1}\)</span> 转移到 <span class="math inline">\(cnt_i\)</span>。发现每次由 <span class="math inline">\(T_{i - 1}\)</span> 变为 <span class="math inline">\(T_i\)</span> 时，原来必选的点现在仍然必选，同时多出来了一些必选的点，称为目标点集。不难发现目标点集构成一条链，即点权为 <span class="math inline">\(0\sim {i}\)</span> 的路径上 <span class="math inline">\(T_{i - 1}\)</span> 中的非必选点。</p><p>我们用一个 <code>vis</code> 数组标记已经访问过的点，遍历到 <span class="math inline">\(i\)</span> 时，若 <code>!vis[i]</code>，就一直跳父亲（以点权为 <span class="math inline">\(0\)</span> 的点为根），直到 <code>vis</code> 为 <span class="math inline">\(1\)</span>。途径的点即目标点集。</p><p>每次新增一个必选点 <span class="math inline">\(x\)</span> 时，有 <span class="math inline">\(cnt \leftarrow cnt \times \dfrac{g_x}{f_x}\)</span>，对目标点集中的每个点更新即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log m)\)</span>，<span class="math inline">\(m\)</span> 为模数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];id[a[i]] = i;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;fa[x] = fath;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);dp[x] *= (<span class="hljs-number">1</span> + dp[y]);dp[x] %= modp;&#125;&#125;;<span class="hljs-type">int</span> rt = id[<span class="hljs-number">0</span>];<span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vis[rt] = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> ans = dp[rt], cur = ans;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> u = id[i];<span class="hljs-keyword">if</span> (!vis[u]) &#123;vector&lt;<span class="hljs-type">int</span>&gt; b; <span class="hljs-keyword">while</span> (!vis[u]) &#123;b.<span class="hljs-built_in">push_back</span>(u);u = fa[u];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;vis[x] = <span class="hljs-literal">true</span>;cur *= dp[x] * <span class="hljs-built_in">qpow</span>(<span class="hljs-number">1</span> + dp[x], modp - <span class="hljs-number">2</span>) % modp;cur %= modp;&#125;&#125;ans += cur;ans %= modp;&#125; cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-天天爱跑步基环树单调队列线段树">K. 天天爱跑步【基环树，单调队列，线段树】</h3><div class="note note-info">            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的基环树。对 <span class="math inline">\(i\in[1, n]\)</span> 求<strong>经过</strong>第 <span class="math inline">\(i\)</span> 个点的最长简单路径长度。</p><p><span class="math inline">\(1 \le n \le 5\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>基环树的结构可概括为：一个环，然后环上的每个点向下延伸出子树。</p><p>以下是一些约定：</p><p>令 <span class="math inline">\(h_i\)</span> 代表点 <span class="math inline">\(i\)</span> 属于环上哪个点的子树。</p><p>令 <span class="math inline">\(dep_i\)</span> 代表点 <span class="math inline">\(i\)</span> 在子树内的深度。（<span class="math inline">\(h_i\)</span> 深度为 <span class="math inline">\(1\)</span>）</p><p>令 <span class="math inline">\(a_i\)</span> 代表环上的点 <span class="math inline">\(i\)</span> 向下延伸出的最长链长度。</p><p>令 <span class="math inline">\(len_i\)</span> 代表经过点 <span class="math inline">\(i\)</span> 且仅在 <span class="math inline">\(h_i\)</span> 子树内的最长链长度。</p><p>令 <span class="math inline">\(f_{i, 0/1}\)</span> 代表点 <span class="math inline">\(i\)</span> 向子树内延伸出的最长链/次长链长度。</p><p>令 <span class="math inline">\(g_{i, 0/1}\)</span> 代表点 <span class="math inline">\(i\)</span> 向子树内延伸出的最长链/次长链对应的子节点。</p><p>令 <span class="math inline">\(\text{ano}\text{side}_i\)</span> 代表环上的点 <span class="math inline">\(i\)</span> 向该点子树外延伸出的最长链长度。（包括环上的一段以及环上另一点向其子树延伸出的最长链）</p><p>根据点 <span class="math inline">\(i\)</span> 在基环树中的位置可以分为两种情况：点 <span class="math inline">\(i\)</span> 在环上和点 <span class="math inline">\(i\)</span> 在子树中。</p><p>点 <span class="math inline">\(i\)</span> 在环上时，我们要找的是 <span class="math inline">\(\max(a_i+\text{anoside}_i)=\max(a_i+a_j+i-j)\)</span>。破环成链，则 <span class="math inline">\(i-j\)</span> 代表环上的一段满足 <span class="math inline">\(i-j&lt;m\)</span> 的 <span class="math inline">\([j, i]\)</span>。</p><p>首先，我们可以用单调队列求出这个最大值。具体地，按顺序遍历环，每次往双端队列中压入 <span class="math inline">\(i\)</span>，弹出队首不满足 <span class="math inline">\(i-j&lt; m\)</span> 的 <span class="math inline">\(j\)</span>，弹出队尾不满足 <span class="math inline">\(a_j-j\ge a_i-i\)</span> 的 <span class="math inline">\(j\)</span>。</p><p>求出最大值后，我们可以用线段树维护对应区间 <span class="math inline">\([j,i]\)</span> 上的答案，每次用最大值与这个区间的值取 <span class="math inline">\(\max\)</span>。</p><p>注意，对环上的两个方向都要分别跑单调队列，同样更新答案。</p><p>点 <span class="math inline">\(i\)</span> 在子树中时，答案为： <span class="math display">\[\large \max(len_i,f_{i, 0}+dep_i-1+\text{anoside}_{h_i})\]</span> 前者为不经过环上的点的答案，后者为经过环上的点的答案。</p><p>对于一个子树，<span class="math inline">\(f_{i,0/1}\)</span> 可以一次 dfs 求出，同时处理出 <span class="math inline">\(g_{i,0/1}\)</span> 用于换根，求出 <span class="math inline">\(len_i\)</span>。</p><p>具体地，换根时令 <span class="math inline">\(d_i\)</span> 代表 <span class="math inline">\(i\)</span> 所在的子树外不经过环的最长链，有： <span class="math display">\[\large{d_x=\max\begin{cases}d_{fa}+1\\f_{fa,0}+1 &amp;,g_{fa,0}\neq x\\f_{fa,1}+1 &amp;,g_{fa,0}=x\end{cases}}\]</span> <span class="math display">\[\large{len_x=f_{x,0}+\max(f_{x,1},d_x)}\]</span></p><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sgt</span>&#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; tr;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span><span class="hljs-built_in">Sgt</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;tr.<span class="hljs-built_in">assign</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;tr[p] = <span class="hljs-built_in">max</span>(tr[p], x);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;<span class="hljs-built_in">update</span>(ls, l, mid, ql, qr, x);&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;<span class="hljs-built_in">update</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr, x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;l++; r++;<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">return</span> tr[p];&#125;<span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p], <span class="hljs-built_in">query</span>(ls, l, mid, pos));&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p], <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, pos));&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;pos++;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);deg[x]++;deg[y]++;&#125;<span class="hljs-keyword">auto</span> find_cir = [&amp;] () &#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">1</span>) &#123;q.<span class="hljs-built_in">push</span>(i);&#125;&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (--deg[y] == <span class="hljs-number">1</span>) &#123;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; o;<span class="hljs-keyword">auto</span> get_cir = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> rt) -&gt; <span class="hljs-type">void</span> &#123;o.<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa || y == rt || deg[y] &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x, rt);<span class="hljs-keyword">return</span> ;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (deg[i] &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">get_cir</span>(get_cir, i, <span class="hljs-number">0</span>, i);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> o;&#125;;vector cir = <span class="hljs-built_in">find_cir</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">h</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>); <span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> rt) -&gt; <span class="hljs-type">void</span> &#123; h[x] = rt; dep[x] = dep[fa] + <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123; <span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">continue</span>; &#125; <span class="hljs-built_in">self</span>(self, y, x, rt); <span class="hljs-keyword">if</span> (f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &gt; f[x][<span class="hljs-number">0</span>]) &#123; f[x][<span class="hljs-number">0</span>] = f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>; g[x][<span class="hljs-number">0</span>] = y; &#125; &#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123; <span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span> || y == g[x][<span class="hljs-number">0</span>]) &#123; <span class="hljs-keyword">continue</span>; &#125; <span class="hljs-keyword">if</span> (f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &gt; f[x][<span class="hljs-number">1</span>]) &#123; f[x][<span class="hljs-number">1</span>] = f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>; g[x][<span class="hljs-number">1</span>] = y; &#125; &#125;&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">len</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (fa) &#123;d[x] = d[fa] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (g[fa][<span class="hljs-number">0</span>] != x) &#123;d[x] = <span class="hljs-built_in">max</span>(d[x], f[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;d[x] = <span class="hljs-built_in">max</span>(d[x], f[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);&#125;&#125;len[x] = <span class="hljs-built_in">max</span>(f[x][<span class="hljs-number">0</span>] + f[x][<span class="hljs-number">1</span>], f[x][<span class="hljs-number">0</span>] + d[x]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;<span class="hljs-built_in">dfs1</span>(dfs1, x, <span class="hljs-number">0</span>, x);<span class="hljs-built_in">dfs2</span>(dfs2, x, <span class="hljs-number">0</span>);&#125;<span class="hljs-type">int</span> m = cir.<span class="hljs-built_in">size</span>();cir.<span class="hljs-built_in">insert</span>(cir.<span class="hljs-built_in">end</span>(), cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;a[i] = f[cir[i]][<span class="hljs-number">0</span>];&#125;<span class="hljs-function">Sgt <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">2</span> * m)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ano_side</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;deque&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span> &gt; m) &#123;q.<span class="hljs-built_in">pop_front</span>();&#125;<span class="hljs-type">int</span> j = q.<span class="hljs-built_in">front</span>();seg.<span class="hljs-built_in">update</span>(j, i, a[i] + a[j] + i - j);ano_side[cir[i]] = <span class="hljs-built_in">max</span>(ano_side[cir[i]], a[j] + i - j);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt; a[i] - i) &#123;q.<span class="hljs-built_in">pop_back</span>();&#125;q.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;ans[cir[i]] = <span class="hljs-built_in">max</span>(ans[cir[i]], seg.<span class="hljs-built_in">query</span>(i));&#125;<span class="hljs-built_in">reverse</span>(cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());q.<span class="hljs-built_in">clear</span>();q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span> &gt; m) &#123;q.<span class="hljs-built_in">pop_front</span>();&#125;<span class="hljs-type">int</span> j = q.<span class="hljs-built_in">front</span>();seg.<span class="hljs-built_in">update</span>(<span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - i, <span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - j, a[i] + a[j] + i - j);ano_side[cir[i]] = <span class="hljs-built_in">max</span>(ano_side[cir[i]], a[j] + i - j);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt; a[i] - i) &#123;q.<span class="hljs-built_in">pop_back</span>();&#125;q.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;ans[cir[i]] = <span class="hljs-built_in">max</span>(ans[cir[i]], seg.<span class="hljs-built_in">query</span>(<span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - i));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ans[i] = <span class="hljs-built_in">max</span>(&#123;ans[i], len[i], f[i][<span class="hljs-number">0</span>] + dep[i] - <span class="hljs-number">1</span> + ano_side[h[i]]&#125;);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="seerc-2020">SEERC 2020</h2><h3 id="b.-reverse-game博弈逆序对">B. Reverse Game【博弈，逆序对】</h3><div class="note note-info">            <p>给定一个 <span class="math inline">\(01\)</span> 串 <span class="math inline">\(s\)</span>，<span class="math inline">\(\text{Alice}\)</span> 和 <span class="math inline">\(\text{Bob}\)</span> 进行回合制博弈。轮到一个人时，该名玩家可以从 <span class="math inline">\(s\)</span> 中任选一个恰为 <span class="math inline">\(10,110,100\)</span> 或 <span class="math inline">\(1010\)</span> 的子串，并将其翻转。无法进行操作的玩家输，问先手是否有必胜策略。</p><p><span class="math inline">\(1 \le |s| \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>很考验 Insight 的题。</p><p>注意到 <span class="math inline">\(s\)</span> 的最后形态必然为 <span class="math inline">\(0\cdots01\cdots1\)</span>（因为有 <span class="math inline">\(10\)</span> 就可以翻转），特点是逆序对为 <span class="math inline">\(0\)</span>。</p><p>而每次翻转操作可以将 <span class="math inline">\(s\)</span> 的逆序对数减少 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2\)</span>，并且手玩发现若 <span class="math inline">\(s\)</span> 的逆序对数 <span class="math inline">\(\ge 2\)</span>，则子串中一定有 <span class="math inline">\(110,100,1010\)</span> 中的一种。</p><p>根据必胜必败态定理，后手总存在策略使得一个轮次中 <span class="math inline">\(s\)</span> 的逆序对数减少 <span class="math inline">\(3\)</span>（即先手减 <span class="math inline">\(1\)</span> 后手减 <span class="math inline">\(2\)</span>，先手减 <span class="math inline">\(2\)</span> 后手减 <span class="math inline">\(1\)</span>）。</p><p>因此当 <span class="math inline">\(s\)</span> 的逆序对数 <span class="math inline">\(\bmod 3 = 0\)</span> 时，后手必胜；否则先手必胜。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s;cin &gt;&gt; s;<span class="hljs-type">int</span> tot0 = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;tot0++;&#125; <span class="hljs-keyword">else</span> &#123;res += tot0;&#125;&#125;<span class="hljs-keyword">if</span> (res % <span class="hljs-number">3</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="a.-archeologists反悔贪心">A. Archeologists【反悔贪心】</h3><div class="note note-info">            <p>你在玩一个寻宝类游戏，一共有 <span class="math inline">\(n\)</span> 个格子，编号为 <span class="math inline">\(1 \sim n\)</span>。你每在第 <span class="math inline">\(i\)</span> 号格子上下挖一层便会获得 <span class="math inline">\(a_i\)</span> 的价值，你需要保证每个格子与其相邻格子的下挖深度不超过 <span class="math inline">\(1\)</span>（注意此时 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n\)</span> 号点最多只能挖一层），求最大价值。</p><p><span class="math inline">\(1 \le n \le 2.5\cdot 10^5\)</span>，<span class="math inline">\(-10^6 \le a_i \le 10^6\)</span>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jalyemdz.png" /></p>          </div><div class="note note-success">            <p>有一类用反悔贪心解决的经典问题：有一样物品，第 <span class="math inline">\(i\)</span> 天价值为 <span class="math inline">\(v_i\)</span>，每一天你可以买入一件或卖出一件，问最大收益。</p><p>解决步骤是维护一个小根堆，然后遍历 <span class="math inline">\(v_i\)</span>，若 <span class="math inline">\(v_i\)</span> 比堆顶 <span class="math inline">\(v_u\)</span> 大，则收益加上 <span class="math inline">\(v_i - v_u\)</span>，弹出堆顶，并再向堆中塞入一个 <span class="math inline">\(v_i\)</span>。这样下次再卖出时（假设为第 <span class="math inline">\(j\)</span> 天），若定位到为第 <span class="math inline">\(i\)</span> 天买入，就赚了 <span class="math inline">\(v_j - v_i\)</span>，加上之前赚的 <span class="math inline">\(v_i-v_u\)</span>，一共赚了 <span class="math inline">\(v_j-v_u\)</span>，等价于在第 <span class="math inline">\(u\)</span> 天买入第 <span class="math inline">\(j\)</span> 天卖出。以此涵盖了在任意天买入和卖出的情况。</p><div class="code-wrapper"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">top</span>() &lt; a[i]) &#123;ans += a[i] - q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();q.<span class="hljs-built_in">push</span>(a[i]);&#125;q.<span class="hljs-built_in">push</span>(a[i]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</code></pre></div><p>对于本题，令 <span class="math inline">\(b_i\)</span> 为第 <span class="math inline">\(i\)</span> 个格子的下挖深度，由于相邻项相差不超过 <span class="math inline">\(1\)</span>，因此其差分数组的每一项只可能是 <span class="math inline">\(-1, 0, 1\)</span>。</p><p>将 <span class="math inline">\(1\)</span> 看成一次买入，<span class="math inline">\(-1\)</span> 看成一次卖出，就与经典题等价了。</p><p>将题给的 <span class="math inline">\(a_i\)</span> 求前缀和作为物品的价值，跑反悔贪心即可。</p><p>时间复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];&#125;priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">top</span>() &lt; sum[i]) &#123;ans += sum[i] - q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();q.<span class="hljs-built_in">push</span>(sum[i]);&#125;q.<span class="hljs-built_in">push</span>(sum[i]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="h.-and-or线段树位运算">H. AND = OR【线段树，位运算】</h3><div class="note note-info">            <p>对于一个序列 <span class="math inline">\(\{b\}\)</span>，若可以将 <span class="math inline">\(\{b\}\)</span> 划分为两个非空的子序列，满足其中一个子序列中所有元素的 <span class="math inline">\(\text{And}\)</span> 与另一个子序列中所有元素的 <span class="math inline">\(OR\)</span> 相等，则称 <span class="math inline">\(\{b\}\)</span> 是 good 的。</p><p>给定一个长为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(\{a\}\)</span>，以及 <span class="math inline">\(q\)</span> 次询问。每次询问 <span class="math inline">\(\{a\}\)</span> 的一个区间 <span class="math inline">\([l, r]\)</span> 是否 good。</p><p><span class="math inline">\(1 \le n,q \le 10^5\)</span>，<span class="math inline">\(0\le a_i &lt; 2^{30}\)</span>。</p>          </div><div class="note note-success">            <p>先考虑单个询问。设 <span class="math inline">\([l,r]\)</span> 中的数被划分成 <span class="math inline">\(A,B\)</span> 两个集合，<span class="math inline">\(A\)</span> 集合的 <span class="math inline">\(\text{OR}\)</span> 和 <span class="math inline">\(B\)</span> 集合的 <span class="math inline">\(\text{And}\)</span> 相等，均为 <span class="math inline">\(X\)</span>。</p><p>那么宏观上有：<span class="math inline">\(A\)</span> 中的所有数 <span class="math inline">\(\le X\)</span>，<span class="math inline">\(B\)</span> 中的所有数 <span class="math inline">\(\ge X\)</span>。因此把 <span class="math inline">\([l,r]\)</span> 内的所有数升序排序，<span class="math inline">\(A\)</span> 中的数一定是一段前缀，<span class="math inline">\(B\)</span> 中的数一定是一段后缀，枚举分段点即可。</p><p>还能按位来看：设 <span class="math inline">\(p(x)=\text{popcount}(x)\)</span>，<span class="math inline">\(p(X)=k\)</span>，那么 <span class="math inline">\(\forall x\in A,p(x)\le k\)</span>，<span class="math inline">\(\forall x \in B,p(x)\ge k\)</span>。</p><p>此时可以枚举分段点 <span class="math inline">\(g\)</span>，两种情况：</p><p><span class="math display">\[\Large\begin{cases}\text{And}_{x\in[l, r],p(x)\le g} = \text{Or}_{x\in[l,r],p(x)&gt;g} &amp;, g\in [0,30)\\\text{And}_{x\in[l, r],p(x)\le g}= \text{Or}_{x \in[l,r], p(x)\ge g} &amp;, g \in[0,30]\end{cases}\]</span></p><p>对于第二种情况，可以证明若能划分，那么满足 <span class="math inline">\(p(x)=g\)</span> 的所有 <span class="math inline">\(x\)</span> 必须相等。<span class="math inline">\((\alpha)\)</span></p><ul><li>证明：假设存在 <span class="math inline">\(a,b\)</span> 满足 <span class="math inline">\(p(a)=g,p(b)=g\)</span>，且 <span class="math inline">\(a\)</span> 被划分进 <span class="math inline">\(A\)</span>，<span class="math inline">\(b\)</span> 被划分进 <span class="math inline">\(B\)</span>。那么：</li></ul><p><span class="math display">\[\Large\begin{cases}a \text{ | }X=X \\ b \ \&amp; \  X = X\end{cases}\to a \ \&amp;\  b = b \xrightarrow{p(a)=p(b)} a= b\]</span></p><p>至此，我们可以用 <span class="math inline">\(30\)</span> 个线段树或 <span class="math inline">\(30\)</span> 个 st 表维护二进制下每一位 <span class="math inline">\(\{a\}\)</span> 的区间按位或和区间按位与。对于一个询问 <span class="math inline">\([l,r]\)</span>，查询这个区间每一位的 <span class="math inline">\(\text{Or}\)</span> 值（<span class="math inline">\(\text{Or}[g]\)</span>）和 <span class="math inline">\(\text{And}\)</span> 值（<span class="math inline">\(\text{And}[g]\)</span>），并对前者做前缀和，后者做后缀和（即 <span class="math inline">\(\text{SOr}[g]\)</span> 代表区间内满足 <span class="math inline">\(p(x)\in[0,g]\)</span> 的所有 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(\text{Or}\)</span> 值，<span class="math inline">\(\text{SAnd}[g]\)</span> 代表区间内满足 <span class="math inline">\(p(x)\in[g,30]\)</span> 的所有 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(\text{And}\)</span> 值），对上文两种情况分别 <span class="math inline">\(\text{check}\)</span> 即可。</p><p>此外还要注意 <span class="math inline">\(\text{check}\)</span> 两个集合必须非空，可以对每一位额外维护一个前缀和相同处理。</p><p>而 <span class="math inline">\((\alpha)\)</span> 条件等价于判断 <span class="math inline">\(\text{Or}[g]=\text{And}[g]\)</span>，不用额外处理。</p><p>最开始写的 st 表没卡过，换了线段树过的。时间复杂度 <span class="math inline">\(O(30n+30q\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; And, Or;<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size) &#123;n = size;And.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);Or.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;And[p] = And[ls] &amp; And[rs];Or[p] = Or[ls] | Or[rs];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">int</span>&gt; &amp;po, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">if</span> (po[l] == k) &#123;And[p] = Or[p] = nums[l];&#125; <span class="hljs-keyword">else</span> &#123;And[p] = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>; Or[p] = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">in_build</span>(ls, l, mid, nums, po, k);<span class="hljs-built_in">in_build</span>(rs, mid + <span class="hljs-number">1</span>, r, nums, po, k);<span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query_And</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> And[p];&#125;<span class="hljs-type">int</span> res = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;res &amp;= <span class="hljs-built_in">range_query_And</span>(ls, l, mid, ql, qr);&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;res &amp;= <span class="hljs-built_in">range_query_And</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query_Or</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> Or[p];&#125;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;res |= <span class="hljs-built_in">range_query_Or</span>(ls, l, mid, ql, qr);&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;res |= <span class="hljs-built_in">range_query_Or</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">int</span>&gt; &amp;po, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-built_in">in_build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, nums, po, k);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_And</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query_And</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_Or</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query_Or</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];p[i] = __builtin_popcount(a[i]);&#125;<span class="hljs-function">vector <span class="hljs-title">st_Sum</span><span class="hljs-params">(<span class="hljs-number">31</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">30</span>; k++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;st_Sum[k][i] = st_Sum[k][i - <span class="hljs-number">1</span>] + (p[i] == k ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);&#125;&#125;<span class="hljs-function">vector&lt;SegmentTree&gt; <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">31</span>, SegmentTree(n))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;seg[i].<span class="hljs-built_in">build</span>(a, p, i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span>, <span class="hljs-title">And</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span>, <span class="hljs-title">Or</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span></span>; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span>, <span class="hljs-title">preOr</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span>, <span class="hljs-title">sufAnd</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span>;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;Sum[i] = st_Sum[i][r] - st_Sum[i][l - <span class="hljs-number">1</span>];And[i] = seg[i].<span class="hljs-built_in">query_And</span>(l, r);Or[i] = seg[i].<span class="hljs-built_in">query_Or</span>(l, r);&#125;preSum[<span class="hljs-number">0</span>] = Sum[<span class="hljs-number">0</span>];preOr[<span class="hljs-number">0</span>] = Or[<span class="hljs-number">0</span>];sufAnd[<span class="hljs-number">31</span>] = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;preSum[i] = preSum[i - <span class="hljs-number">1</span>] + Sum[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;preOr[i] = preOr[i - <span class="hljs-number">1</span>] | Or[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;sufAnd[i] = sufAnd[i + <span class="hljs-number">1</span>] &amp; And[i];&#125;<span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<span class="hljs-keyword">if</span> (preOr[i] == sufAnd[i + <span class="hljs-number">1</span>] &amp;&amp; preSum[i] &amp;&amp; preSum[i] &lt; preSum[<span class="hljs-number">30</span>]) &#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (!flag) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<span class="hljs-keyword">if</span> (preOr[i] == sufAnd[i] &amp;&amp; Or[i] == And[i] &amp;&amp; Sum[i] &gt; <span class="hljs-number">1</span>) &#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES\n&quot;</span> : <span class="hljs-string">&quot;NO\n&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="江苏省赛-ccpc-hunan">2023 江苏省赛/ CCPC Hunan</h2><h3 id="b.-honkai-in-taikula拆点缩点全源最短路">B. Honkai in TAIKULA【拆点，缩点，全源最短路】</h3><div class="note note-info">            <p>给定一张 <span class="math inline">\(n\)</span> 个节点 <span class="math inline">\(m\)</span> 条边的有向带权图，对每个节点，报告是否存在经过该点的奇权圈（可经过重复顶点、重复边、若经过重复边，边权计多次）。若存在，输出最小奇权圈的权值（或报告为负无穷）。</p><p><span class="math inline">\(1\le n \le 1000\)</span>，<span class="math inline">\(1 \le m \le 10^4\)</span>，<span class="math inline">\(0\le x_i,y_i &lt; n\)</span>，<span class="math inline">\(|w_i| \le 10^7\)</span>。</p>          </div><div class="note note-success">            <p>处理带权图的边权奇偶性问题常用缩点：把一个点 <span class="math inline">\(x\)</span> 拆成一个奇点 <span class="math inline">\(\text{Odd}_x\)</span>、一个偶点 <span class="math inline">\(\text{Even}_x\)</span>。</p><ul><li>若存在 <span class="math inline">\(x\xrightarrow{w} y\)</span>，<span class="math inline">\(w\)</span> 为奇数。则连 <span class="math inline">\(\text{Odd}_x \to \text{Even}_y\)</span>，<span class="math inline">\(\text{Even}_x \to \text{Odd}_y\)</span>。</li><li>若存在 <span class="math inline">\(x \xrightarrow{w} y\)</span>，<span class="math inline">\(w\)</span> 为偶数。则连 <span class="math inline">\(\text{Odd}_x\to \text{Odd}_y\)</span>，<span class="math inline">\(\text{Even}_x\to \text{Even}_y\)</span>。</li></ul><p>若存在一个经过点 <span class="math inline">\(x\)</span> 的奇权圈，等价于存在一条 <span class="math inline">\(\text{Odd}_x \to \text{Even}_x\)</span> 的路径。（或 <span class="math inline">\(\text{Even}_x \to \text{Odd}_x\)</span>，钦定一种即可）</p><p>接着，由于环只存在于单个强连通分量内，所以考虑缩点得到一张有向无环图 <span class="math inline">\(G\)</span>。</p><p>注意到只要存在一条路径从 <span class="math inline">\(x\)</span> 出发，经过负环，再回到 <span class="math inline">\(x\)</span>。那么最小奇权圈的权值就是负无穷，因为可以再负环上无限绕再返回 <span class="math inline">\(x\)</span>。所以对 <span class="math inline">\(G\)</span> 中每个点代表的子图都跑 SPFA 算法判断负环。</p><p>设 <span class="math inline">\(\text{Odd}_x\)</span> 和 <span class="math inline">\(\text{Even}_x\)</span> 所在的 SCC 编号分别为 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>。利用 dfs 判断 <span class="math inline">\(G\)</span> 中是否存在 <span class="math inline">\(A\to B\)</span> 的路径，路径上又是否有标记为负环的点即可完成无解和负无穷解的判断。</p><p>接下来是有解的情况。在未缩点的原图上跑 Johnson 全源最短路即可，注意避开 “位于被标记负环的 SCC 中” 的所有点。</p><p>时间复杂度 <span class="math inline">\(O(nm\log m)\)</span>。</p>          </div><div class="note note-warning">            <p>Funfact：有人拓扑图上 dfs 不用标记数组标记走过的点，狂 T 两小时QAQ。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _node vector<span class="hljs-string">&lt;vector&lt;array&lt;int, 2&gt;</span>&gt;&gt;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Johnson</span> &#123;<span class="hljs-type">int</span> n;_node adj;vector&lt;<span class="hljs-type">int</span>&gt; h, dis, A;<span class="hljs-built_in">Johnson</span>(_node Adj, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B) &#123;adj = Adj;A = B;<span class="hljs-keyword">this</span>-&gt;n = Adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-built_in">init</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;h.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);dis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;adj[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;i, <span class="hljs-number">0</span>&#125;);&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">circle</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;h.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);queue&lt;<span class="hljs-type">int</span>&gt; q;vis[s] = <span class="hljs-literal">true</span>;h[s] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();vis[x] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (!A[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span>(h[y] &gt; h[x] + w) &#123;h[y] = h[x] + w;<span class="hljs-keyword">if</span>(!vis[y]) &#123;<span class="hljs-keyword">if</span>(++circle[y] &gt;= n + <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;vis[y] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;priority_queue&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; q;dis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;dis[s] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>()[<span class="hljs-number">1</span>];q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (!A[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span>(dis[y] &gt; dis[x] + w) &#123;dis[y] = dis[x] + w;q.<span class="hljs-built_in">push</span>(&#123;-dis[y], y&#125;);&#125;&#125;&#125;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">work</span>() &#123;<span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, -inf))</span></span>;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>)) &#123;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[y, w] : adj[x]) &#123;w += h[x] - h[y];&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-built_in">dijkstra</span>(i);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<span class="hljs-keyword">if</span> (dis[j] == inf) &#123;ans[i][j] = inf; &#125; <span class="hljs-keyword">else</span> &#123;ans[i][j] = dis[j] + (h[j] - h[i]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; E;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;x++; y++;<span class="hljs-keyword">if</span> (w % <span class="hljs-number">2</span>) &#123;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y + n, w&#125;);adj[x + n].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);E.<span class="hljs-built_in">push_back</span>(&#123;x, y + n, w&#125;);E.<span class="hljs-built_in">push_back</span>(&#123;x + n, y, w&#125;);&#125; <span class="hljs-keyword">else</span> &#123;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);adj[x + n].<span class="hljs-built_in">push_back</span>(&#123;y + n, w&#125;);E.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);E.<span class="hljs-built_in">push_back</span>(&#123;x + n, y + n, w&#125;);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">VIS</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x] = low[x] = ++tim;VIS[x] = <span class="hljs-literal">true</span>;stack_[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VIS[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span> &#123;now = stack_[top--];VIS[now] = <span class="hljs-literal">false</span>;c[now] = cnt;scc[cnt].<span class="hljs-built_in">push_back</span>(now);&#125; <span class="hljs-keyword">while</span>(x != now);&#125;&#125;;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">Adj</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> shrinkPoint = [&amp;]() &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">2</span> * n; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : adj[x]) &#123;<span class="hljs-keyword">if</span> (c[x] == c[y]) <span class="hljs-keyword">continue</span>;Adj[c[x]].<span class="hljs-built_in">push_back</span>(c[y]);&#125;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++)<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-built_in">shrinkPoint</span>();vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">G</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>; <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">auto</span> spfa = [&amp;](<span class="hljs-type">int</span> s) &#123;dis.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, inf);vis.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);num.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);dis[s] = <span class="hljs-number">0</span>;vis[s] = <span class="hljs-literal">true</span>;priority_queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(s);num[s]++;<span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();vis[x] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, z] : G[x]) &#123;<span class="hljs-keyword">if</span>(dis[y] &gt; dis[x] + z) &#123;dis[y] = dis[x] + z;<span class="hljs-keyword">if</span> (!vis[y]) &#123;vis[y] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span> (++num[y] &gt; scc[c[s]].<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">have_circle</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> rt : scc[i]) &#123;exist[rt] = <span class="hljs-number">1</span>;&#125;G.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : E) &#123;<span class="hljs-keyword">if</span> (exist[x] &amp;&amp; exist[y]) &#123;G[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);&#125;&#125;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(scc[i][<span class="hljs-number">0</span>])) &#123;have_circle[i] = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-type">int</span> T, success;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis2</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> flag) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">if</span> (have_circle[x]) &#123;flag = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (x == T) &#123;<span class="hljs-keyword">if</span>(flag) &#123;success = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;<span class="hljs-keyword">if</span> (vis2[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis2[y] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>(self, y, flag)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;T = c[i + n];success = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> res = <span class="hljs-built_in">dfs</span>(dfs, c[i], <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (!res) &#123;ans[i] = <span class="hljs-number">-1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (success) &#123;ans[i] = inf;&#125; &#125; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<span class="hljs-keyword">if</span> (!have_circle[i]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : scc[i]) &#123;A[x] = <span class="hljs-literal">true</span>;&#125;&#125;&#125;<span class="hljs-function">Johnson <span class="hljs-title">H</span><span class="hljs-params">(adj, A)</span></span>;vector diss = H.<span class="hljs-built_in">work</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (ans[i] == <span class="hljs-number">-1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Battle with the crazy Honkai\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans[i] == inf) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Haha, stupid Honkai\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; diss[i][i + n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="l.-architect思维扫描线">L. Architect【思维，扫描线】</h3><div class="note note-info">            <p>给定 <span class="math inline">\(n\)</span> 个长方体，询问其是否能拼接成一个 <span class="math inline">\(W\times H\times L\)</span> 的立方体，没有重叠和空隙，所有长方体都要用到。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(1\le W, H, L \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>一种绝世聪明的想法是 “只需判断 <span class="math inline">\(n\)</span> 个立方体的体积和是否 <span class="math inline">\(=\)</span> <span class="math inline">\(W\times H\times L\)</span>，且八个角的出现次数是否是偶数次即可”。</p><p>体积一样限定了这 <span class="math inline">\(n\)</span> 个立方体不能有重叠。</p><p>八个角出现了偶数次限定了这 <span class="math inline">\(n\)</span> 个立方体与大立方体间没有空隙。</p><p>注意 <span class="math inline">\(10^9\cdot 10^9\cdot 10^9=10^{27}\)</span>，需要开 <code>__int128</code>。</p><p>时间复杂度 <span class="math inline">\(O(8n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int __int128</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, __int128 &amp;n) &#123;    string s;    is &gt;&gt; s;    n = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;     n = n * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);    &#125;    <span class="hljs-keyword">return</span> is;&#125;ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, __int128 n) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-number">0</span>;&#125;string s;<span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123; s += <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;0&#x27;</span> + n % <span class="hljs-number">10</span>); n /= <span class="hljs-number">10</span>;&#125;<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">return</span> os &lt;&lt; s;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> W, H, L, n;cin &gt;&gt; W &gt;&gt; H &gt;&gt; L &gt;&gt; n;<span class="hljs-type">int</span> All = W * H * L, all = <span class="hljs-number">0</span>;map&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">auto</span> ins = [&amp;] (<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> z0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> z1) &#123;mp[&#123;x0, y0, z0&#125;]++;mp[&#123;x0, y0, z1&#125;]++;mp[&#123;x0, y1, z0&#125;]++;mp[&#123;x0, y1, z1&#125;]++;mp[&#123;x1, y0, z0&#125;]++;mp[&#123;x1, y0, z1&#125;]++;mp[&#123;x1, y1, z0&#125;]++;mp[&#123;x1, y1, z1&#125;]++;&#125;;<span class="hljs-built_in">ins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, L);<span class="hljs-keyword">while</span> (n--) &#123;<span class="hljs-type">int</span> x0, y0, z0, x1, y1, z1;cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; z0 &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1;all += (x1 - x0) * (y1 - y0) * (z1 - z0);<span class="hljs-built_in">ins</span>(x0, y0, z0, x1, y1, z1);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, x] : mp) &#123;<span class="hljs-keyword">if</span> (x &amp; <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;cout &lt;&lt; (all == All ? <span class="hljs-string">&quot;Yes\n&quot;</span> : <span class="hljs-string">&quot;No\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>另一种朴素但也颇具技巧性的方法是扫描线。</p><p>先将 <span class="math inline">\(n\)</span> 个小立方体的底面看作 <span class="math inline">\(1\)</span>，顶面看作 <span class="math inline">\(-1\)</span>；大立方体的底面看作 <span class="math inline">\(-1\)</span>，顶面看作 <span class="math inline">\(1\)</span>。</p><p>如果每个表面紧紧贴合，那么代数和为 <span class="math inline">\(0\)</span>。</p><p>接着不断降维，同样的思想能判断线是否紧密贴合，点是否紧密贴合。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check2</span><span class="hljs-params">(vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; a)</span> </span>&#123;map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x1, x2, flag] : a) &#123;mp[x1] += flag;mp[x2] += -flag;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;<span class="hljs-keyword">if</span> (v) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt;&gt; a)</span> </span>&#123;map&lt;<span class="hljs-type">int</span>, vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt;&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x1, y1, x2, y2, flag] : a) &#123;mp[y1].<span class="hljs-built_in">push_back</span>(&#123;x1, x2, flag&#125;);mp[y2].<span class="hljs-built_in">push_back</span>(&#123;x1, x2, -flag&#125;);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check2</span>(v)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> W, H, L;cin &gt;&gt; W &gt;&gt; H &gt;&gt; L;map&lt;<span class="hljs-type">int</span>, vector&lt;array&lt;<span class="hljs-type">int</span>, 5&gt;&gt;&gt; mp;mp[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, <span class="hljs-number">-1</span>&#125;);mp[L].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, <span class="hljs-number">1</span>&#125;);<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x1, y1, z1, x2, y2, z2;cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2;mp[z1].<span class="hljs-built_in">push_back</span>(&#123;x1, y1, x2, y2, <span class="hljs-number">1</span>&#125;);mp[z2].<span class="hljs-built_in">push_back</span>(&#123;x1, y1, x2, y2, <span class="hljs-number">-1</span>&#125;);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(v)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="ccpc-weihai">2020 CCPC Weihai</h2><h3 id="b.-labyrinthbfs">B. Labyrinth【bfs】</h3><div class="note note-info">            <p>给定一个 <span class="math inline">\(n\times m\)</span> 的网格图，有 <span class="math inline">\(k\)</span> 个格子有障碍不能通行。<span class="math inline">\(q\)</span> 次询问，每次询问两点间的最短路长度。</p><p><span class="math inline">\(1\le n,m\le2\cdot 10^5\)</span>，<span class="math inline">\(1\le n\cdot m\le 2\cdot 10^5\)</span>，<span class="math inline">\(0\le k \le 42\)</span>，<span class="math inline">\(1\le q\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>对于一组询问，假设询问的两个点是 <span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2, y_2)\)</span>。</p><p>那么当 <span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2,y_2)\)</span> 作为对角线的两个端点围成的矩形中没有一个障碍时，答案就是这两点间的曼哈顿距离；否则可以想象到最短路一定经过某个障碍周围四格中的某一格。</p><p>把所有障碍的四联通预处理出来并去重，以每个点为起点跑 bfs 求出其到所有格子的最短路。</p><p>询问时枚举一下这 <span class="math inline">\(O(4k)\)</span> 个点作为中转点的最短路，取 <span class="math inline">\(\min\)</span> 即可。</p><p>时间复杂度 <span class="math inline">\(O(knm)-O(k)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(<span class="hljs-string">&quot;Ofast&quot;</span>)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k, Q;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; Q;<span class="hljs-function">vector <span class="hljs-title">bomb</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;bomb[x][y] = <span class="hljs-number">1</span>;&#125;vector sum = bomb;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;sum[i][j] += sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">auto</span> query = [&amp;] (<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy) &#123;<span class="hljs-keyword">return</span> sum[fx][fy] - sum[sx - <span class="hljs-number">1</span>][fy] - sum[fx][sy - <span class="hljs-number">1</span>] + sum[sx - <span class="hljs-number">1</span>][sy - <span class="hljs-number">1</span>];&#125;;<span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; waiting;<span class="hljs-function">vector <span class="hljs-title">VIS</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">if</span> (bomb[i][j]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<span class="hljs-type">int</span> x = i + dx[k];<span class="hljs-type">int</span> y = j + dy[k];<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">1</span> || x &gt; n || y &gt; m || bomb[x][y] || VIS[x][y]) &#123;<span class="hljs-keyword">continue</span>;&#125;VIS[x][y] = <span class="hljs-literal">true</span>;waiting.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);&#125;&#125;&#125;&#125;<span class="hljs-type">int</span> all = waiting.<span class="hljs-built_in">size</span>();<span class="hljs-function">vector <span class="hljs-title">dis</span><span class="hljs-params">(all, vector(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, inf)))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>; id &lt; all; id++) &#123;<span class="hljs-keyword">auto</span> [sx, sy] = waiting[id];queue&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; q;q.<span class="hljs-built_in">push</span>(&#123;sx, sy, <span class="hljs-number">0</span>&#125;);<span class="hljs-function">vector <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;vis[sx][sy] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> [x, y, lst_dis] = q.<span class="hljs-built_in">front</span>();dis[id][x][y] = lst_dis;q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-type">int</span> xx = x + dx[i];<span class="hljs-type">int</span> yy = y + dy[i];<span class="hljs-keyword">if</span> (xx &lt; <span class="hljs-number">1</span> || yy &lt; <span class="hljs-number">1</span> || xx &gt; n || yy &gt; m || bomb[xx][yy] || vis[xx][yy]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[xx][yy] = <span class="hljs-literal">true</span>;<span class="hljs-type">int</span> cur_dis = lst_dis + <span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(&#123;xx, yy, cur_dis&#125;);&#125;&#125;&#125;<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy) &#123;&#125;;<span class="hljs-keyword">while</span> (Q--) &#123;<span class="hljs-type">int</span> sx, sy, fx, fy;cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;<span class="hljs-keyword">if</span> (bomb[sx][sy] || bomb[fx][fy]) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (sx == fx &amp;&amp; sy == fy) &#123;cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> lx = <span class="hljs-built_in">min</span>(sx, fx);<span class="hljs-type">int</span> ly = <span class="hljs-built_in">min</span>(sy, fy);<span class="hljs-type">int</span> rx = <span class="hljs-built_in">max</span>(sx, fx);<span class="hljs-type">int</span> ry = <span class="hljs-built_in">max</span>(sy, fy);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">query</span>(lx, ly, rx, ry)) &#123;cout &lt;&lt; <span class="hljs-built_in">abs</span>(sx - fx) + <span class="hljs-built_in">abs</span>(sy - fy) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; all; i++) &#123;<span class="hljs-keyword">if</span> (dis[i][sx][sy] == inf || dis[i][fx][fy] == inf) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = dis[i][sx][sy] + dis[i][fx][fy];ans = <span class="hljs-built_in">min</span>(ans, res);&#125;<span class="hljs-keyword">if</span> (ans == inf) &#123;ans = <span class="hljs-number">-1</span>;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="c.-rencontre结论期望">C. Rencontre【结论，期望】</h3><div class="note note-info">            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，边有边权 <span class="math inline">\(w_i\)</span>。给定三个点集，从三个点集中分别随机选出 <span class="math inline">\(u_1,u_2,u_3\)</span>，问以下式子的期望： <span class="math display">\[f(u_1,u_2,u_3)=\min_{i\in[1,n]}(dis(u_1,i)+dis(u_2,i)+dis(u_3,i))\]</span> 其中 <span class="math inline">\(dis(x,y)\)</span> 代表点 <span class="math inline">\(x,y\)</span> 间的树上距离。</p><p><span class="math inline">\(1\le n \le 2 \cdot 10^5\)</span>，<span class="math inline">\(1\le w \le 1000\)</span>。</p>          </div><div class="note note-success">            <p>结论题。所给式子等价于： <span class="math display">\[f(u_1,u_2,u_3)=\frac{1}{2}(dis(u_1,u_2)+dis(u_2,u_3)+dis(u_1,u_3))\]</span> 根据期望的线性性，只需分别求出这三项每一项的期望再相加。</p><p>以 <span class="math inline">\(dis(u_1,u_2)\)</span> 举例，考虑拆贡献：对于一条边 <span class="math inline">\(x\leftrightarrow y\)</span>，设 <span class="math inline">\(x\)</span> 一侧有 <span class="math inline">\(A_x\)</span> 个点属于点集一，<span class="math inline">\(B_x\)</span> 个点属于点集二；<span class="math inline">\(y\)</span> 一侧有 <span class="math inline">\(A_y\)</span> 个点属于点集一，<span class="math inline">\(B_y\)</span> 个点属于点集二。</p><p>那么该条边的贡献为 <span class="math inline">\(w\cdot \dfrac{A_x B_y+A_yB_x}{|A||B|}\)</span>，<span class="math inline">\(|A|\)</span> 和 <span class="math inline">\(|B|\)</span> 分别为点集一和点集二的大小。最终贡献就是所有边的贡献之和。</p><p>dfs 简单处理，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);&#125;vector&lt;<span class="hljs-type">int</span>&gt; A, B, C;<span class="hljs-type">int</span> An, Bn, Cn;cin &gt;&gt; An;<span class="hljs-keyword">while</span> (An--) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;A.<span class="hljs-built_in">push_back</span>(x);&#125;cin &gt;&gt; Bn;<span class="hljs-keyword">while</span> (Bn--) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;B.<span class="hljs-built_in">push_back</span>(x);&#125;cin &gt;&gt; Cn;<span class="hljs-keyword">while</span> (Cn--) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;C.<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">auto</span> calc = [&amp;] (vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">isa</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">isb</span>(n + <span class="hljs-number">1</span>);<span class="hljs-type">int</span> asz = <span class="hljs-number">0</span>, bsz = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;isa[x] = <span class="hljs-literal">true</span>;asz++;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;isb[x] = <span class="hljs-literal">true</span>;bsz++;&#125;vector f = isa, g = isb;<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);f[x] += f[y];g[x] += g[y];&#125;&#125;;<span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">double</span> t = <span class="hljs-number">1.0</span> * f[y] * (bsz - g[y]);t += <span class="hljs-number">1.0</span> * g[y] * (asz - f[y]);res += <span class="hljs-number">1.0</span> * w * t;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);res /= (asz * bsz);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;ans += <span class="hljs-built_in">calc</span>(A, B);ans += <span class="hljs-built_in">calc</span>(B, C);ans += <span class="hljs-built_in">calc</span>(A, C);ans /= <span class="hljs-number">2</span>;cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>) &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-caesar-cipher线段树维护哈希值">G. Caesar Cipher【线段树维护哈希值】</h3><div class="note note-info">            <p>维护一个序列 <span class="math inline">\(\{a\}\)</span>，支持两种操作：</p><ul><li><code>1 l r</code>：<span class="math inline">\(\forall i\in[l, r]\)</span>，<span class="math inline">\(a_i=(a_i+1)\bmod 65536\)</span>.</li><li><code>2 x y L</code>：询问区间 <span class="math inline">\([x,x+L-1]\)</span> 和区间 <span class="math inline">\([y,y+L-1]\)</span> 是否完全相同。</li></ul><p><span class="math inline">\(1\le n,q\le 5\cdot10^5\)</span>。</p>          </div><div class="note note-success">            <p>经典题，线段树维护哈希值。</p><p>预处理出 <code>pow[i]</code> 代表 <span class="math inline">\(\text{base}^i\)</span>，<code>pre[i]</code> 代表 <span class="math inline">\(\sum_{j=0}^{i}\text{base}^j\)</span>。</p><p>区间合并时，左区间的哈希值需要乘 <code>pow[r - mid]</code> 再加上右区间的哈希值。</p><p>区间修改时，相当于区间加 <code>pre[r - l]</code>。</p><p>区间查询时，合并答案需要左区间答案乘 <code>pow[max(0, min(r, qr) - mid)]</code> 再加上右区间答案。</p><p>这道题的创新点是操作一需要模一个数。</p><p>注意到值溢出（即 <span class="math inline">\(\ge 65536\)</span>）的次数不超过 <span class="math inline">\(\frac{nq}{65536}\approx 4\cdot10^6\)</span> 次，可以维护区间最大值，每次定位到那个溢出的点然后单点修改。</p><p>时间复杂度 <span class="math inline">\(O(\frac{nq\log n}{65536}+q\log n)\)</span>。时限给了 10s，实际上 1s 多一点就跑完了。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> base = <span class="hljs-number">65536</span>;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1145141</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sgt</span>&#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; h, mx, Add;vector&lt;<span class="hljs-type">int</span>&gt; pow, pre;<span class="hljs-built_in">Sgt</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">h</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), <span class="hljs-built_in">mx</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), <span class="hljs-built_in">Add</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), <span class="hljs-built_in">pow</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">pre</span>(n + <span class="hljs-number">1</span>) &#123;pow[<span class="hljs-number">0</span>] = pre[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;pow[i] = pow[i - <span class="hljs-number">1</span>] * base % mod;pre[i] = (pre[i - <span class="hljs-number">1</span>] + pow[i]) % mod;&#125;&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;h[p] = (h[ls] * pow[r - mid] % mod + h[rs]) % mod;mx[p] = <span class="hljs-built_in">max</span>(mx[ls], mx[rs]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (Add[p]) &#123;h[ls] = (h[ls] + Add[p] * pre[mid - l] % mod) % mod; h[rs] = (h[rs] + Add[p] * pre[r - mid - <span class="hljs-number">1</span>] % mod) % mod;mx[ls] += Add[p];mx[rs] += Add[p];Add[ls] += Add[p];Add[rs] += Add[p];Add[p] = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;h[p] = a[l];mx[p] = a[l];<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">build</span>(ls, l, mid, a);<span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r, a);<span class="hljs-built_in">pushup</span>(p, l, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;h[p] = (h[p] + pre[r - l]) % mod;Add[p]++;mx[p]++;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">pushdown</span>(p, l, r);<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;<span class="hljs-built_in">update</span>(ls, l, mid, ql, qr);&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;<span class="hljs-built_in">update</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);&#125;<span class="hljs-built_in">pushup</span>(p, l, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_mod</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (mx[p] &lt; base) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (l == r) &#123;h[p] -= base;mx[p] -= base;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">pushdown</span>(p, l, r);<span class="hljs-keyword">if</span> (mx[ls] &gt;= base) &#123;<span class="hljs-built_in">update_mod</span>(ls, l, mid);&#125;<span class="hljs-keyword">if</span> (mx[rs] &gt;= base) &#123;<span class="hljs-built_in">update_mod</span>(rs, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-built_in">pushup</span>(p, l, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_mod</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">update_mod</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> h[p];&#125;<span class="hljs-built_in">pushdown</span>(p, l, r);<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;<span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, <span class="hljs-built_in">min</span>(r, qr) - mid);res = (res + <span class="hljs-built_in">query</span>(ls, l, mid, ql, qr) * pow[len] % mod) % mod;&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;res = (res + <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr)) % mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-function">Sgt <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;seg.<span class="hljs-built_in">build</span>(a);<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> opt;cin &gt;&gt; opt;<span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;seg.<span class="hljs-built_in">update</span>(l, r);seg.<span class="hljs-built_in">update_mod</span>();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x, y, L;cin &gt;&gt; x &gt;&gt; y &gt;&gt; L;<span class="hljs-type">int</span> h1 = seg.<span class="hljs-built_in">query</span>(x, x + L - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> h2 = seg.<span class="hljs-built_in">query</span>(y, y + L - <span class="hljs-number">1</span>);cout &lt;&lt; (h1 == h2 ? <span class="hljs-string">&quot;yes\n&quot;</span> : <span class="hljs-string">&quot;no\n&quot;</span>);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="j.-steinsgame博弈sg函数线性基">J. Steins;Game【博弈，SG函数，线性基】</h3><div class="note note-info">            <p>现定义一种博弈游戏：有 <span class="math inline">\(n\)</span> 堆石子，每堆石子被涂成了黑色或白色。双方轮流从以下两种取石子方式中选择一种并操作：</p><ul><li>从石子数最少的黑色堆中取任意个石子。这里“最少”是与其它黑色堆比较。</li><li>从任意白色堆中取任意个石子。</li></ul><p>轮到某一方时无石子可取则败。</p><p>现在这 <span class="math inline">\(n\)</span> 堆石子每一堆的数量 <span class="math inline">\(a_i\)</span> 固定，但并未上色。</p><p>求有多少种上色方案，使得先手必败。方案数对 <span class="math inline">\(10^9+7\)</span> 取模。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(1 \le a_i \le 10^{18}\)</span>。</p>          </div><div class="note note-success">            <p>将白色堆和黑色堆分开来看，称为白色游戏和黑色游戏。</p><p>当白色游戏的 SG 值和黑色游戏的 SG 值异或为 <span class="math inline">\(0\)</span> 时，先手必败。</p><p>白色游戏即 nim 游戏——当所有白色堆石子数目的异或和为 <span class="math inline">\(0\)</span> 时，先手必败。</p><p>接着尝试求出黑色游戏的 SG 值，可以打表找规律。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        bruteforce    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> node priority_queue<span class="hljs-string">&lt;int, vector&lt;int&gt;</span>, greater<span class="hljs-string">&lt;int&gt;</span>&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n = <span class="hljs-number">7</span>, mx = <span class="hljs-number">8</span>;map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">auto</span> sg = [&amp;] (<span class="hljs-keyword">auto</span> self, node q) -&gt; <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;vector&lt;<span class="hljs-type">int</span>&gt; A;node o_q = q;<span class="hljs-keyword">while</span> (!o_q.<span class="hljs-built_in">empty</span>()) &#123;A.<span class="hljs-built_in">push_back</span>(o_q.<span class="hljs-built_in">top</span>());o_q.<span class="hljs-built_in">pop</span>();&#125;<span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(A)) &#123;<span class="hljs-keyword">return</span> mp[A];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();vis[<span class="hljs-built_in">self</span>(self, q)] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; x; i++) &#123;<span class="hljs-keyword">auto</span> tmp = q;tmp.<span class="hljs-built_in">push</span>(i);vis[<span class="hljs-built_in">self</span>(self, tmp)] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;<span class="hljs-keyword">return</span> mp[A] = i;&#125;&#125;&#125;;vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> lst) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (dep == n) &#123;node q;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;q.<span class="hljs-built_in">push</span>(x);cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot; sg = &quot;</span> &lt;&lt; <span class="hljs-built_in">sg</span>(sg, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lst; i &lt;= mx; i++) &#123;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;a.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">self</span>(self, dep + <span class="hljs-number">1</span>, i);<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;a.<span class="hljs-built_in">pop_back</span>();&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>结论是： <span class="math display">\[\text{SG}_{黑色游戏}=\text{最小堆石子数量}-(有多少堆石子数最少+[所有堆石子数相同])\bmod2\]</span> 然后是计数。将 <span class="math inline">\(a_i\)</span> 排序，预处理出前缀异或和 <span class="math inline">\(\text{pre}_i\)</span>，后缀异或和 <span class="math inline">\(\text{suf}_i\)</span>，有 <span class="math inline">\(\text{tot}_i\)</span> 堆石子数为 <span class="math inline">\(i\)</span>，以及第 <span class="math inline">\(i\sim n\)</span> 堆中有 <span class="math inline">\(\text{same}_i\)</span> 堆石子数为 <span class="math inline">\(a_i\)</span>。在以下过程中，相同石子数的堆可以先被当成无标号来做，最后再乘上组合数转为有标号。</p><p>从后向前扫 <span class="math inline">\(\{a\}\)</span>，设当前扫到第 <span class="math inline">\(i\)</span> 堆，钦定第 <span class="math inline">\(i\)</span> 堆为黑色且在黑色堆中石子数量最少。此时第 <span class="math inline">\(1\sim (i-1)\)</span> 堆只能是黑色，异或和为 <span class="math inline">\(X=\text{pre}_{i-1}\)</span>。然后分 "所有黑色堆石子数是否相同" 来讨论第 <span class="math inline">\((i + 1) \sim n\)</span> 堆。</p><p>若选出的黑色堆要满足石子数相同，则第 <span class="math inline">\(i\sim (i+\text{same}_i-1)\)</span> 堆为黑色（因为是从后往前扫，所以涵盖了该连续段所有后缀为黑色堆的情况），第 <span class="math inline">\((i+\text{same}_i)\sim n\)</span> 堆为白色。它们的 SG 值可以用上述公式以及后缀异或和快速求。</p><p>若选出的黑色堆不需要满足石子数相同，那么黑色游戏的 SG 为 <span class="math inline">\(Y=a_{i}-\text{same}_i \bmod 2\)</span>。此时需要从后面的堆中选出若干白色堆使得它们的异或和是 <span class="math inline">\(X\oplus Y\)</span>，方案数可以用线性基求出。</p><p>具体地，设线性基 <span class="math inline">\(S\)</span> 的大小为 <span class="math inline">\(|S|\)</span>，此前插入了 <span class="math inline">\(x\)</span> 个数。若 <span class="math inline">\(X\oplus Y\)</span> 能被线性基表示出来，则方案数为 <span class="math inline">\(2^{x-|S|}\)</span>。</p><p>最后，别忘了乘组合数 <span class="math inline">\(\dbinom{\text{tot}_i}{\text{same}_i}\)</span> 再累加到答案中。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> n, tot, all;vector&lt;<span class="hljs-type">int</span>&gt; p;<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tot</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">all</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">p</span>(_n + <span class="hljs-number">1</span>) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;all++;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (!(x &gt;&gt; i)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (!p[i]) &#123;p[i] = x;tot++;<span class="hljs-keyword">break</span>;&#125;x ^= p[i];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> ((res ^ p[i]) &gt; res) &#123;res ^= p[i];&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (x &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;x ^= p[i];&#125;&#125;<span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getways</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">count</span>(x)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, all - tot);&#125;&#125;;  vector&lt;<span class="hljs-type">int</span>&gt; frac, inv;  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  frac.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);  inv.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);    frac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  frac[i] = frac[i - <span class="hljs-number">1</span>] * i % modp;  &#125;  inv[n] = <span class="hljs-built_in">qpow</span>(frac[n], modp - <span class="hljs-number">2</span>);  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;  inv[i - <span class="hljs-number">1</span>] = inv[i] * i % modp;  &#125;&#125;  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n &lt; m || m &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;  <span class="hljs-keyword">return</span> frac[n] * inv[m] % modp * inv[n - m] % modp;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// SG = 最小堆的石子数 - (最小堆数量 + [所有堆石子数相同]) % 2</span><span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-built_in">init</span>(n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];mp[a[i]]++;&#125; <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">same</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;pre[i] = pre[i - <span class="hljs-number">1</span>] ^ a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;suf[i] = suf[i + <span class="hljs-number">1</span>] ^ a[i];same[i] = (a[i] == a[i + <span class="hljs-number">1</span>] ? same[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;<span class="hljs-function">Node <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">60</span>)</span></span>;<span class="hljs-type">int</span> ans = (pre[n] == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> X = pre[i - <span class="hljs-number">1</span>];<span class="hljs-type">int</span> Y = a[i] - (same[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<span class="hljs-type">int</span> Z = suf[i + same[i]];<span class="hljs-keyword">if</span> ((X ^ Y ^ Z) == <span class="hljs-number">0</span>) &#123;res++;res %= modp;&#125;Y = a[i] - same[i] % <span class="hljs-number">2</span>;<span class="hljs-type">int</span> need = X ^ Y;res += t.<span class="hljs-built_in">getways</span>(need);<span class="hljs-keyword">if</span> ((need ^ Z) == <span class="hljs-number">0</span>) &#123;res = (res - <span class="hljs-number">1</span> + modp) % modp;&#125;<span class="hljs-keyword">if</span> (same[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; same[i]; j++) &#123;t.<span class="hljs-built_in">insert</span>(a[i]);&#125;&#125;res *= <span class="hljs-built_in">C</span>(mp[a[i]], same[i]);res %= modp;ans += res;ans %= modp;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="东北四省赛-ccpc-northeast">2024 东北四省赛 / CCPC Northeast</h2><h3 id="h.-meet树上差分分类讨论">H. Meet【树上差分，分类讨论】</h3><div class="note note-info">            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，以及 <span class="math inline">\(m\)</span> 组点对构成的集合 <span class="math inline">\(S\)</span>。你需要选定一个点作为根节点，使得 <span class="math inline">\(\max_\limits{(x, y)\in S} \max(\text{dis}(x, \text{lca}_{x, y}), \text{dis}(y, \text{lca}_{x, y}))\)</span> 最小，输出这个最小值。</p><p><span class="math inline">\(1 \le n, m \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>二分答案，设二分出的答案为 <span class="math inline">\(d\)</span>。</p><p>对于每一组点对 <span class="math inline">\((x, y)\)</span>，可以确定一个点集（一个树上连通块），使得以该点集中的点为根时，答案 <span class="math inline">\(\le d\)</span>。接着只需要用树上差分判断这 <span class="math inline">\(m\)</span> 个点集是否有交即可。</p><p>需要纸上分几种情况讨论，红温了挺久。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optmize(<span class="hljs-string">&quot;Ofast&quot;</span>)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RMQ_LCA</span> &#123;<span class="hljs-type">int</span> n, tim;vector&lt;<span class="hljs-type">int</span>&gt; dfn, lg, twdep;vector&lt;<span class="hljs-type">int</span>&gt; dep, st;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj, fa, A, B;<span class="hljs-built_in">RMQ_LCA</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;Adj) &#123;<span class="hljs-keyword">this</span>-&gt;n = Adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;adj = Adj;<span class="hljs-built_in">init</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;dfn.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);lg.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);twdep.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);dep.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);st.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);tim = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;lg[i] = lg[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath, <span class="hljs-type">int</span> d)</span> </span>&#123;st[x] = ++tim;dfn[tim] = x;twdep[tim] = d;dep[x] = dep[fath] + <span class="hljs-number">1</span>;fa[x][<span class="hljs-number">0</span>] = fath;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lg[dep[x]] + <span class="hljs-number">1</span>; i++) &#123;fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!st[y]) &#123;<span class="hljs-built_in">dfs</span>(y, x, d + <span class="hljs-number">1</span>);dfn[++tim] = x;twdep[tim] = d;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;fa.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>));<span class="hljs-built_in">dfs</span>(rt, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);A.<span class="hljs-built_in">resize</span>(<span class="hljs-number">25</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>));B.<span class="hljs-built_in">resize</span>(<span class="hljs-number">25</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= tim; i++) &#123;A[<span class="hljs-number">0</span>][i] = twdep[i];B[<span class="hljs-number">0</span>][i] = dfn[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lg[tim]; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j + (<span class="hljs-number">1LL</span> &lt;&lt; i) - <span class="hljs-number">1</span> &lt;= tim; j++) &#123;<span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>][j] &lt; A[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)]) &#123;A[i][j] = A[i - <span class="hljs-number">1</span>][j];B[i][j] = B[i - <span class="hljs-number">1</span>][j];&#125; <span class="hljs-keyword">else</span> &#123;A[i][j] = A[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)];B[i][j] = B[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)];&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> l = <span class="hljs-built_in">min</span>(st[x], st[y]);<span class="hljs-type">int</span> r = <span class="hljs-built_in">max</span>(st[x], st[y]);<span class="hljs-type">int</span> k = lg[r - l + <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (A[k][l] &lt; A[k][r + <span class="hljs-number">1</span> - (<span class="hljs-number">1LL</span> &lt;&lt; k)]) &#123;<span class="hljs-keyword">return</span> B[k][l];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> B[k][r + <span class="hljs-number">1</span> - (<span class="hljs-number">1LL</span> &lt;&lt; k)];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> dep[x] + dep[y] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">LCA</span>(x, y)];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> len)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">24</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (len &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;x = fa[x][i];&#125;&#125;<span class="hljs-keyword">return</span> x;&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">RMQ_LCA <span class="hljs-title">G</span><span class="hljs-params">(adj)</span></span>;G.<span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>);vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">people</span>(m);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;people[i] = &#123;x, y&#125;;&#125;<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> goal) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : people) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * goal &lt; G.<span class="hljs-built_in">dist</span>(x, y)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">del</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> A = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : people) &#123;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, y) &lt;= goal) &#123;A++;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> lca = G.<span class="hljs-built_in">LCA</span>(x, y);<span class="hljs-type">int</span> tx, ty;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(lca, x) &gt;= goal) &#123;tx = G.<span class="hljs-built_in">jump</span>(x, goal);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> res = goal - G.<span class="hljs-built_in">dist</span>(lca, x);tx = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(lca, y) - res);&#125;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(lca, y) &gt;= goal) &#123;ty = G.<span class="hljs-built_in">jump</span>(y, goal);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> res = goal - G.<span class="hljs-built_in">dist</span>(lca, y);ty = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(lca, x) - res);&#125;<span class="hljs-type">int</span> <span class="hljs-type">lca_t</span> = G.<span class="hljs-built_in">LCA</span>(tx, ty);<span class="hljs-keyword">if</span> (lca == x || lca == y) &#123;del[<span class="hljs-type">lca_t</span>]++;<span class="hljs-type">int</span> son;<span class="hljs-keyword">if</span> (lca == x) &#123;son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, <span class="hljs-type">lca_t</span> == tx ? ty : tx) - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, <span class="hljs-type">lca_t</span> == tx ? ty : tx) - <span class="hljs-number">1</span>);&#125;del[son]--;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (lca == <span class="hljs-type">lca_t</span>) &#123;del[<span class="hljs-number">1</span>]++;<span class="hljs-type">int</span> son_x, son_y;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, tx) &lt;= G.<span class="hljs-built_in">dist</span>(x, ty)) &#123;son_x = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, tx) - <span class="hljs-number">1</span>);son_y = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, ty) - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;son_x = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, ty) - <span class="hljs-number">1</span>);son_y = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, tx) - <span class="hljs-number">1</span>);&#125;del[son_x]--;del[son_y]--;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> son;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, tx) &lt;= G.<span class="hljs-built_in">dist</span>(x, lca)) &#123;<span class="hljs-keyword">if</span> (G.dep[tx] &lt; G.dep[ty]) &#123;del[tx]++;son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, ty) - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;del[ty]++;son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, tx) - <span class="hljs-number">1</span>);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (G.dep[tx] &lt; G.dep[ty]) &#123;del[tx]++;son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, ty) - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;del[ty]++;son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, tx) - <span class="hljs-number">1</span>);&#125;&#125;del[son]--;&#125;&#125;&#125;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;del[x] += del[fa];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (del[i] == m - A) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, ans = <span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;ans = mid;r = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;l = mid + <span class="hljs-number">1</span>;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-tasks贪心">K. Tasks【贪心】</h3><div class="note note-info">            <p>有 <span class="math inline">\(n\)</span> 个区间，定义一个区间的烦躁度等于所有包含它的区间的最大烦躁值 <span class="math inline">\(+1\)</span>（如果没有包含它的区间，则烦躁值为 <span class="math inline">\(0\)</span>）。</p><p>现在你知道这 <span class="math inline">\(n\)</span> 个区间的左端点 <span class="math inline">\(l_i\)</span> 和烦躁值 <span class="math inline">\(b_i\)</span>，你需要构造对应的右端点以满足条件，或报告 <span class="math inline">\(-1\)</span>。</p><p>特别规定给出的构造需要满足没有两个完全相同的区间且没有一个右端点 <span class="math inline">\(&gt; 10^6\)</span>。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(1 \le l_i \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>把 <span class="math inline">\(b_i\)</span> 相同的区间看作一层，从 <span class="math inline">\(b_i=0\)</span> 开始从低层向高层构造。</p><p>对于同一层，若存在两个区间左端点相同，那么无解；否则必要条件是每个区间都要被一个上一层的区间包含。</p><p>那么有如下贪心的构造：从右向左考虑当前层的左端点，设当前左端点为 <span class="math inline">\(l\)</span>，那肯定是选上一层中左端点 <span class="math inline">\(&lt;l\)</span> 且离 <span class="math inline">\(l\)</span> 最近的区间来被包含。若有多个左端点满足，则选右端点最靠右的，这样能给下一层留够最多的空间。这个过程可以通过 <code>std::lower_bound</code> 简单实现。</p><p>如遇区间完全相同，右端点向左缩一位即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> l, b;cin &gt;&gt; l &gt;&gt; b;a[b + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(&#123;l, i&#125;);&#125;a[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;r[<span class="hljs-number">0</span>] = <span class="hljs-number">1e6</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-built_in">sort</span>(a[i].<span class="hljs-built_in">begin</span>(), a[i].<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j + <span class="hljs-number">1</span> &lt; a[i].<span class="hljs-built_in">size</span>(); j++) &#123;<span class="hljs-keyword">if</span> (a[i][j][<span class="hljs-number">0</span>] == a[i][j + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;<span class="hljs-type">int</span> R = <span class="hljs-number">1e6</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [l, id] : a[i]) &#123;<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>(), array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;&#123;l + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);<span class="hljs-keyword">if</span> (it == a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;it = <span class="hljs-built_in">prev</span>(it);<span class="hljs-keyword">auto</span> [lstL, lstid] = *it;R = <span class="hljs-built_in">min</span>(R, r[lstid]);<span class="hljs-keyword">if</span> (l == lstL &amp;&amp; R == r[lstid]) &#123;R--;&#125;<span class="hljs-keyword">if</span> (R &lt; l) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;r[id] = R;R--;&#125;<span class="hljs-built_in">sort</span>(a[i].<span class="hljs-built_in">begin</span>(), a[i].<span class="hljs-built_in">end</span>());&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; r[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="b.-charging-station最大权闭合子图">B. Charging Station【最大权闭合子图】</h3><div class="note note-info">            <p>有 <span class="math inline">\(3n\)</span> 个能源站，分为三级，每级 <span class="math inline">\(n\)</span> 个，从高级向低级编号为 <span class="math inline">\(1\sim n\)</span>，<span class="math inline">\(n\sim 2n\)</span>，<span class="math inline">\(2n\sim 3n\)</span>。</p><p>每个能源站有三种状态：不工作、供能、吸能。供能有供能功率 <span class="math inline">\(a_i\)</span>，吸能有吸能功率 <span class="math inline">\(b_i\)</span>。</p><p>有 <span class="math inline">\(m\)</span> 个限制关系，每一条形如 “能源站 <span class="math inline">\(x\)</span> 要处于供能状态当且仅当低一级的能源站 <span class="math inline">\(y\)</span> 在吸能状态”。</p><p>问最大总供能功率。</p><p><span class="math inline">\(1\le n, m\le 10^5\)</span>，<span class="math inline">\(1\le a_i,b_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>假设只有两级，并且低级能源站都处于吸能状态，那么就是经典的最大权闭合子图问题。</p><p>具体地，将供能站视作左部点，吸能站视作右部点。</p><p>源点 <span class="math inline">\(S\)</span> 向左部点连收益大小的边，左部点向右部点连正无穷的边，右部点向汇点 <span class="math inline">\(T\)</span> 连代价大小的边，最大供能功率就是 <strong>左部点权值之和 <span class="math inline">\(-\)</span> 最小割</strong>。</p><p>现在考虑这个三级模型。最高级的能源站只能处在供能或不工作状态，最低级的能源站只能处在供能或吸能状态（不工作还不如供能），中级能源站的状态则取决于上下两级。</p><p>假设这么一个初始状态：中级能源站供能，高级能源站不工作，低级能源站吸能。</p><p>当低级能源站由吸能 <span class="math inline">\(\to\)</span> 供能时，中级能源站只能供能 <span class="math inline">\(\to\)</span> 不工作；当高级能源站由不工作 <span class="math inline">\(\to\)</span> 供能时，中级能源站只能不工作 <span class="math inline">\(\to\)</span> 吸能。</p><p>于是我们把中级能源站拆成两个点，分别为 "供能 <span class="math inline">\(\to\)</span> 不工作" 和 "不工作 <span class="math inline">\(\to\)</span> 吸能"，对应的代价恰好为 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span>。建图如下：</p><p><img src="/image/academic/111.png" alt="id" style="zoom:50%;" /></p><p>其中，<span class="math inline">\(S\)</span> 向低级能源站连 <span class="math inline">\(a_i+b_i\)</span> 的边是因为只考虑从吸能状态转换为供能状态带来的总收益。</p><p>时间复杂度 <span class="math inline">\(O(m\sqrt{n})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span> &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<span class="hljs-type">int</span> x, cap;<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cap) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">cap</span>(cap) &#123;&#125; &#125;;<span class="hljs-type">int</span> n;vector&lt;Edge&gt; e;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; dep, cur;<span class="hljs-built_in">Dinic</span>(<span class="hljs-type">int</span> size) &#123;<span class="hljs-keyword">this</span>-&gt;n = size;adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cap)</span> </span>&#123;adj[x].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;y, cap&#125;);adj[y].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>&#125;);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;dep.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(S);dep[S] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : adj[x]) &#123;<span class="hljs-keyword">auto</span> [y, cap] = e[i];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == <span class="hljs-number">-1</span>) &#123;dep[y] = dep[x] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (y == T) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> T, <span class="hljs-type">int</span> limit)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == T) &#123;<span class="hljs-keyword">return</span> limit;&#125;<span class="hljs-type">int</span> r = limit;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i = cur[x]; i &lt; adj[x].<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-type">const</span> <span class="hljs-type">int</span> j = adj[x][i];<span class="hljs-keyword">auto</span> [y, cap] = e[j];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == dep[x] + <span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> t = <span class="hljs-built_in">dfs</span>(y, T, <span class="hljs-built_in">min</span>(r, cap));e[j].cap -= t;e[j ^ <span class="hljs-number">1</span>].cap += t;r -= t;<span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> limit;&#125;&#125;&#125;<span class="hljs-keyword">return</span> limit - r;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(S, T)) &#123;cur.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);flow += <span class="hljs-built_in">dfs</span>(S, T, inf); &#125; <span class="hljs-keyword">return</span> flow;&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span> * n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span> * n; i++) &#123;cin &gt;&gt; b[i];&#125;<span class="hljs-comment">// 1 ~ n：一级3n ~ 4n：三级</span><span class="hljs-comment">// n ~ 2n：二级供能 -&gt; 不工作</span><span class="hljs-comment">// 2n ~ 3n：二级不工作 -&gt; 吸能</span><span class="hljs-type">int</span> S = <span class="hljs-number">4</span> * n + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> T = <span class="hljs-number">4</span> * n + <span class="hljs-number">2</span>;<span class="hljs-function">Dinic <span class="hljs-title">G</span><span class="hljs-params">(T)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;G.<span class="hljs-built_in">add</span>(S, i, a[i]);G.<span class="hljs-built_in">add</span>(S, i + <span class="hljs-number">3</span> * n, a[i + <span class="hljs-number">2</span> * n] + b[i + <span class="hljs-number">2</span> * n]);G.<span class="hljs-built_in">add</span>(i + n, T, a[i + n]);G.<span class="hljs-built_in">add</span>(i + <span class="hljs-number">2</span> * n, T, b[i + n]);&#125;<span class="hljs-type">int</span> m;cin &gt;&gt; m;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;<span class="hljs-keyword">if</span> (x &lt;= n) &#123;G.<span class="hljs-built_in">add</span>(x, y, inf);G.<span class="hljs-built_in">add</span>(x, y + n, inf);&#125; <span class="hljs-keyword">else</span> &#123;G.<span class="hljs-built_in">add</span>(y + n, x, inf);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0ll</span>);ans -= G.<span class="hljs-built_in">dinic</span>(S, T);cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-diamond根号分治">G. Diamond【根号分治】</h3><div class="note note-info">            <p>给定一个长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span>。有 <span class="math inline">\(m\)</span> 次询问，每次指定 <span class="math inline">\(l, r, p, q\)</span> 四个参数，问若只保留下标在 <span class="math inline">\([l, r]\)</span> 内且值为 <span class="math inline">\(p\)</span> 或者 <span class="math inline">\(q\)</span> 的数，其它数全部删除，此时剩下序列的逆序对数量。询问间相互独立。</p><p><span class="math inline">\(2\le n \le 10^5\)</span>，<span class="math inline">\(1 \le m \le 10^5\)</span>，<span class="math inline">\(1\le a_i \le n\)</span>。</p>          </div><div class="note note-success">            <p>较为明显的根号分治。把每个数的出现位置存到 <code>std::vector</code> 中，记为 <code>pos</code>。</p><p>若 <span class="math inline">\(p,q\)</span> 的出现次数都 <span class="math inline">\(\le\sqrt{n}\)</span>，直接在 <code>pos</code> 上暴跳计算贡献，<span class="math inline">\(O(\sqrt{n})\)</span>。</p><p>否则 <span class="math inline">\(p, q\)</span> 中至少有一个出现次数 <span class="math inline">\(&gt;\sqrt{n}\)</span>。由于这样的数（设为 <span class="math inline">\(X\)</span>）不超过 <span class="math inline">\(\dfrac{n}{\sqrt{n}}=\sqrt{n}\)</span> 个，我们可以对 <span class="math inline">\(1\sim n\)</span> 的每一个位置 <span class="math inline">\(i\)</span> 处理出 <code>count[i][j]</code> 代表 <span class="math inline">\(1\sim i\)</span> 中值 <span class="math inline">\(j\in X\)</span> 出现了多少次。</p><p>那么对于一个区间 <span class="math inline">\([l, r]\)</span>，不妨设 <span class="math inline">\(p&lt;q\)</span>，答案就是： <span class="math display">\[\left(\sum_{i\in[l,r],a[i]=p}\text{count}[i][q]\right)-\text{occ}[l-1][q]\times\left(\text{occ}[r][p]-\text{occ}[l-1][p]\right)\]</span> 其中 <code>occ[i][j]</code> 代表 <span class="math inline">\(1\sim i\)</span> 中 <span class="math inline">\(j\in[1,n]\)</span> 的出现次数，这里只是为方便说明，实际存不下，可修改为 <code>occ[i]</code> 代表 <span class="math inline">\(1\sim i\)</span> 中 <span class="math inline">\(a[i]\)</span> 的出现次数，然后二分查询。</p><p>至于第一项，可以预处理出 <code>count[i][j]</code> 的前缀和，然后二分出 <span class="math inline">\(j\)</span> 在 <span class="math inline">\([l, r]\)</span> 中第一次出现和最后一次出现的位置 <span class="math inline">\(O(1)\)</span> 回答。</p><p>那如果 <span class="math inline">\(p&gt;q\)</span> 且 <span class="math inline">\(q\)</span> 的出现次数 <span class="math inline">\(\le \sqrt{n}\)</span> 呢？我们没处理出这样的 <code>count[i][q]</code>，但可以把 <span class="math inline">\(p,q\)</span> swap 一下求出顺序对的数量，然后容斥。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\sqrt{n})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> Block = <span class="hljs-number">320</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pos</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];cnt[a[i]]++;pos[a[i]].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (cnt[i] &gt; Block) &#123;id[i] = ++tim;&#125;&#125;<span class="hljs-function">vector <span class="hljs-title">count</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;count[i] = count[i - <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (cnt[a[i]] &gt; Block) &#123;count[i][id[a[i]]]++;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (pos[i].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; pos[i].<span class="hljs-built_in">size</span>(); j++) &#123;pre[pos[i][j]] = pos[i][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">occ</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;occ[i] = occ[pre[i]] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= tim; j++) &#123;count[i][j] += count[pre[i]][j];&#125;&#125;<span class="hljs-keyword">auto</span> calc_1 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q) &#123;<span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">lower_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">lower_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">if</span> (it1 == pos[p].<span class="hljs-built_in">end</span>() || it2 == pos[q].<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;&#125;<span class="hljs-type">int</span> A = it1 - pos[p].<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> B = it2 - pos[q].<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">if</span> (pos[p][A] &gt; r || pos[q][B] &gt; r) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;&#125;<span class="hljs-type">int</span> big = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-type">int</span> posA = (A &gt;= pos[p].<span class="hljs-built_in">size</span>() ? r + <span class="hljs-number">1</span> : pos[p][A]);<span class="hljs-type">int</span> posB = (B &gt;= pos[q].<span class="hljs-built_in">size</span>() ? r + <span class="hljs-number">1</span> : pos[q][B]);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(posA, posB) &gt; r) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (posA &lt; posB) &#123;res += big;A++;&#125; <span class="hljs-keyword">else</span> &#123;big++;B++;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-keyword">auto</span> calc_2 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q) &#123;<span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">lower_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">upper_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), r);<span class="hljs-keyword">auto</span> it3 = <span class="hljs-built_in">lower_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">auto</span> it4 = <span class="hljs-built_in">upper_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), r);<span class="hljs-keyword">if</span> (it1 == pos[p].<span class="hljs-built_in">end</span>() || it3 == pos[q].<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;&#125;<span class="hljs-type">int</span> A = it1 - pos[p].<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> B = it2 - pos[p].<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<span class="hljs-type">int</span> C = it3 - pos[q].<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> D = it4 - pos[q].<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (pos[p][A] &gt; r || pos[q][C] &gt; r) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;&#125;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (cnt[q] &gt; Block) &#123;res += count[pos[p][B]][id[q]] - (A &gt; <span class="hljs-number">0</span> ? count[pos[p][A - <span class="hljs-number">1</span>]][id[q]] : <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (C &gt; <span class="hljs-number">0</span>) &#123;res -= (occ[pos[p][B]] - (A &gt; <span class="hljs-number">0</span> ? occ[pos[p][A - <span class="hljs-number">1</span>]] : <span class="hljs-number">0</span>)) * occ[pos[q][C - <span class="hljs-number">1</span>]];&#125;&#125; <span class="hljs-keyword">else</span> &#123;res += count[pos[q][D]][id[p]] - (C &gt; <span class="hljs-number">0</span> ? count[pos[q][C - <span class="hljs-number">1</span>]][id[p]] : <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (A &gt; <span class="hljs-number">0</span>) &#123;res -= (occ[pos[q][D]] - (C &gt; <span class="hljs-number">0</span> ? occ[pos[q][C - <span class="hljs-number">1</span>]] : <span class="hljs-number">0</span>)) * occ[pos[p][A - <span class="hljs-number">1</span>]];&#125;<span class="hljs-type">int</span> all = B - A + <span class="hljs-number">1</span> + D - C + <span class="hljs-number">1</span>;all = all * (all - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;all -= (B - A + <span class="hljs-number">1</span>) * (B - A) / <span class="hljs-number">2</span>;all -= (D - C + <span class="hljs-number">1</span>) * (D - C) / <span class="hljs-number">2</span>;res = all - res;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> l, r, p, q;cin &gt;&gt; l &gt;&gt; r &gt;&gt; p &gt;&gt; q;<span class="hljs-keyword">if</span> (cnt[p] &lt;= Block &amp;&amp; cnt[q] &lt;= Block) &#123;cout &lt;&lt; <span class="hljs-built_in">calc_1</span>(l, r, p, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-built_in">calc_2</span>(l, r, p, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="nanjing-regional-ucup-2-11">2023 Nanjing Regional / Ucup 2-11</h2><h3 id="m.-trapping-rain-water吉司机线段树">M. Trapping Rain Water【吉司机线段树】</h3><div class="note note-info">            <p>给定长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span>，有 <span class="math inline">\(q\)</span> 次修改，每次将 <span class="math inline">\(a_{x_i}\)</span> 加上 <span class="math inline">\(v_i\)</span>。令 <span class="math inline">\(f_i=\max(a_1,a_2,\cdots,a_i)\)</span>，<span class="math inline">\(g_i=\max(a_i,a_{i + 1},\cdots,a_n)\)</span>，你需要在每次修改后回答： <span class="math display">\[\sum_{i=1}^{n}(\min(f_i,g_i)-a_i)\]</span> <span class="math inline">\(1\le n, q \le 10^6\)</span>，<span class="math inline">\(1\le a_i \le 10^6\)</span>，<span class="math inline">\(1\le v_i \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>这题最关键的观察是 <span class="math inline">\(\max(f_i,g_i)=\max a_i\)</span>，即 <span class="math inline">\(\min(f_i,g_i)=f_i+g_i-\max a_i\)</span>。</p><p>于是式子化为 <span class="math inline">\(\sum f_i+\sum g_i -n\cdot\max a_i-\sum a_i\)</span>.</p><p>后两项在修改时很容易维护，主要考虑前两项，这里以 <span class="math inline">\(\sum f_i\)</span> 为例。</p><p>根据 <span class="math inline">\(f_i\)</span> 的定义，设当前将 <span class="math inline">\(a_i\)</span> 增加至 <span class="math inline">\(x\)</span>，则相当于给 <span class="math inline">\(f_{i\sim n}\)</span> 中的每一项与 <span class="math inline">\(x\)</span> 取 <span class="math inline">\(\max\)</span>。</p><p>吉司机线段树处理即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; sum, mx, mn;vector&lt;<span class="hljs-type">int</span>&gt; tc, ta, L, R;<span class="hljs-meta">#<span class="hljs-keyword">define</span> N 4 * n + 5</span><span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">sum</span>(N), <span class="hljs-built_in">mx</span>(N), <span class="hljs-built_in">mn</span>(N), <span class="hljs-built_in">tc</span>(N), <span class="hljs-built_in">ta</span>(N), <span class="hljs-built_in">L</span>(N), <span class="hljs-built_in">R</span>(N) &#123;&#125; <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (L[p] + R[p] &gt;&gt; 1)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;sum[p] = sum[ls] + sum[rs];mx[p] = <span class="hljs-built_in">max</span>(mx[ls], mx[rs]);mn[p] = <span class="hljs-built_in">min</span>(mn[ls], mn[rs]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cover</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> w)</span> </span>&#123;sum[p] = (R[p] - L[p] + <span class="hljs-number">1</span>) * w;mx[p] = mn[p] = tc[p] = w;ta[p] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> w)</span> </span>&#123;sum[p] += (R[p] - L[p] + <span class="hljs-number">1</span>) * w;mx[p] += w;mn[p] += w;ta[p] += w;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">if</span> (tc[p] != inf) &#123;<span class="hljs-built_in">Cover</span>(ls, tc[p]);<span class="hljs-built_in">Cover</span>(rs, tc[p]);tc[p] = inf;&#125;<span class="hljs-keyword">if</span> (ta[p]) &#123;<span class="hljs-built_in">Add</span>(ls, ta[p]);<span class="hljs-built_in">Add</span>(rs, ta[p]);ta[p] = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;L[p] = l;R[p] = r;tc[p] = inf;<span class="hljs-keyword">if</span> (l == r) &#123;sum[p] = mx[p] = mn[p] = a[l];<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">build</span>(ls, l, mid, a);<span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r, a);<span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &lt;= L[p] &amp;&amp; r &gt;= R[p]) &#123;<span class="hljs-keyword">return</span> sum[p];&#125;<span class="hljs-built_in">pushdown</span>(p);<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (l &lt;= mid) &#123;res += <span class="hljs-built_in">get_sum</span>(ls, l, r);&#125;<span class="hljs-keyword">if</span> (r &gt; mid) &#123;res += <span class="hljs-built_in">get_sum</span>(rs, l, r);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_max</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> w)</span> </span>&#123;<span class="hljs-keyword">if</span> (mn[p] &gt;= w) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (l &lt;= L[p] &amp;&amp; r &gt;= R[p] &amp;&amp; mx[p] &lt;= w) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Cover</span>(p, w);&#125;<span class="hljs-built_in">pushdown</span>(p);<span class="hljs-keyword">if</span> (l &lt;= mid) &#123;<span class="hljs-built_in">modify_max</span>(ls, l, r, w);&#125;<span class="hljs-keyword">if</span> (r &gt; mid) &#123;<span class="hljs-built_in">modify_max</span>(rs, l, r, w);&#125;<span class="hljs-built_in">pushup</span>(p);&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-type">int</span> q;cin &gt;&gt; q;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">qry</span>(q);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> pos, x;cin &gt;&gt; pos &gt;&gt; x;qry[i] = &#123;pos, x&#125;;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">g</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;f[i] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>], a[i]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;g[i] = <span class="hljs-built_in">max</span>(g[i + <span class="hljs-number">1</span>], a[i]);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ansf</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ansg</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ans_mx</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ans_sum</span><span class="hljs-params">(q)</span></span>;<span class="hljs-type">int</span> Sum = <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);<span class="hljs-type">int</span> Mx = *<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());vector b = a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-keyword">auto</span> [pos, x] = qry[i];a[pos] += x;Sum += x;ans_sum[i] = Sum;Mx = <span class="hljs-built_in">max</span>(Mx, a[pos]);ans_mx[i] = Mx;&#125;a = b;<span class="hljs-function">Node <span class="hljs-title">t</span><span class="hljs-params">(n)</span></span>;t.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, f);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-keyword">auto</span> [pos, x] = qry[i];a[pos] += x;t.<span class="hljs-built_in">modify_max</span>(<span class="hljs-number">1</span>, pos, n, a[pos]);ansf[i] = t.<span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);&#125;a = b;t = <span class="hljs-built_in">Node</span>(n);t.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, g);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-keyword">auto</span> [pos, x] = qry[i];a[pos] += x;t.<span class="hljs-built_in">modify_max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, pos, a[pos]);ansg[i] = t.<span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> res = ansf[i] + ansg[i] - n * ans_mx[i] - ans_sum[i];cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="d.-red-black-treedp凸序列">D. Red Black Tree【dp，凸序列】</h3><p>现存网上的任何一篇题解都看得不是很明白，占坑。</p><hr /><h3 id="e.-extending-distance网络流对偶图">E. Extending Distance【网络流，对偶图】</h3><div class="note note-info">            <p>有一个 <span class="math inline">\(n\)</span> 行 <span class="math inline">\(m\)</span> 列的网格图，相邻格点之间有边，边有边权。</p><p>你可以进行任意次操作，每次操作可以使某条边的边权增加 <span class="math inline">\(1\)</span>。</p><p>求一种操作次数最少的方案使得从第一列任意一个点出发到最后一列任意一个点的最短路恰好增加 <span class="math inline">\(K\)</span>，输出方案。</p><p><span class="math inline">\(1 \le n\cdot m \le 5000\)</span>，<span class="math inline">\(1 \le K\le 100\)</span>。</p>          </div><div class="note note-success">            <p>网格图是一种特殊的平面图。所谓平面图，是指能画在平面上，满足任何两条边没有交叉。</p><p>将平面图 <span class="math inline">\(G\)</span> 的每个面看作一个点，<span class="math inline">\(G\)</span> 中每条边两侧的两个面（可以是同一个面）进行连边，就得到了一个对偶图。</p><p>一个经典的题目是 “P4001 狼抓兔子”，它展示了一种<strong>平面图最小割</strong>转<strong>对偶图最短路</strong>的思想，不再赘述。</p><p>同样地，对本题中的网格图进行对偶，那么<strong>原图的最短路</strong>等价于<strong>对偶图的最小割</strong>。</p><p>建图，将原图中的边费用设为 <span class="math inline">\(0\)</span>，流量设为边权；再对每条边建费用为 <span class="math inline">\(1\)</span>，流量为 <span class="math inline">\(+\infty\)</span> 的额外边。</p><p>此时题目等价于找一条流量为 <span class="math inline">\(D+K\)</span> 的费用最小的流，其中 <span class="math inline">\(D\)</span> 为原图的最短路。</p><p>分两步处理：</p><ul><li>先只连费用为 <span class="math inline">\(0\)</span> 的边，不连额外边。跑从源点 <span class="math inline">\(S\)</span> 流向汇点 <span class="math inline">\(T\)</span> 的最大流。</li><li>对每条边连额外边，再连一条从 super 源点 <span class="math inline">\(P\)</span> 向源点 <span class="math inline">\(S\)</span> 费用为 <span class="math inline">\(0\)</span> 流量为 <span class="math inline">\(K\)</span> 的边。跑从 super 源点 <span class="math inline">\(P\)</span> 流向汇点 <span class="math inline">\(T\)</span> 的最大流。此时跑出来的费用即为最小操作次数。</li></ul><p>至于方案，可以遍历残量网络上费用为 <span class="math inline">\(1\)</span> 的边，检查剩余流量。这条边的操作次数就是原始流量和剩余流量的差。</p><p>时间复杂度 <span class="math inline">\(O(n^2m^2k)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span> &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<span class="hljs-type">int</span> x, cap, cost, all;<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> cost) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">cap</span>(cap), <span class="hljs-built_in">cost</span>(cost), <span class="hljs-built_in">all</span>(cap) &#123;&#125;&#125;;<span class="hljs-type">int</span> n;vector&lt;Edge&gt; e;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; dis, pre, vis;vector&lt;<span class="hljs-type">int</span>&gt; h;<span class="hljs-built_in">Dinic</span>(<span class="hljs-type">int</span> size) &#123;<span class="hljs-keyword">this</span>-&gt;n = size;adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> f)</span> </span>&#123;adj[x].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;y, w, f&#125;);adj[y].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>, -f&#125;);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;dis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);pre.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<span class="hljs-meta">#<span class="hljs-keyword">define</span> Pair pair<span class="hljs-string">&lt;int, int&gt;</span></span>priority_queue&lt;Pair, vector&lt;Pair&gt;, greater&lt;Pair&gt;&gt; q;dis[S] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>().second;q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span> (vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : adj[x]) &#123;<span class="hljs-keyword">auto</span> [y, cap, cost, _] = e[i];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dis[y] &gt; dis[x] + h[x] - h[y] + cost) &#123;dis[y] = dis[x] + h[x] - h[y] + cost;pre[y] = i;q.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);&#125;&#125;&#125;<span class="hljs-keyword">return</span> (dis[T] != inf);&#125;<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>, cost = <span class="hljs-number">0</span>;h.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">while</span> (<span class="hljs-built_in">dijkstra</span>(S, T)) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;h[i] += dis[i];&#125;<span class="hljs-type">int</span> res = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>].x) &#123;res = <span class="hljs-built_in">min</span>(res, e[pre[i]].cap);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>].x) &#123;e[pre[i]].cap -= res;e[pre[i] ^ <span class="hljs-number">1</span>].cap += res;&#125;flow += res;cost += res * h[T];&#125;<span class="hljs-keyword">return</span> &#123;flow, cost&#125;;&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<span class="hljs-type">int</span> S = (n - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> T = S + <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> id = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> S;&#125; <span class="hljs-keyword">if</span> (x == n) &#123;<span class="hljs-keyword">return</span> T;&#125;<span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + y;&#125;;<span class="hljs-function">vector <span class="hljs-title">A</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m))</span></span>;<span class="hljs-function">vector <span class="hljs-title">B</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-function">Dinic <span class="hljs-title">G</span><span class="hljs-params">(T)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> w;cin &gt;&gt; w;A[i][j] = w;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);G.<span class="hljs-built_in">add</span>(x, y, w, <span class="hljs-number">0</span>);G.<span class="hljs-built_in">add</span>(y, x, w, <span class="hljs-number">0</span>);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-type">int</span> w;cin &gt;&gt; w;B[i][j] = w;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);G.<span class="hljs-built_in">add</span>(x, y, w, <span class="hljs-number">0</span>);G.<span class="hljs-built_in">add</span>(y, x, w, <span class="hljs-number">0</span>);&#125;&#125;<span class="hljs-keyword">auto</span> res1 = G.<span class="hljs-built_in">dinic</span>(S, T);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);G.<span class="hljs-built_in">add</span>(x, y, inf, <span class="hljs-number">1</span>);G.<span class="hljs-built_in">add</span>(y, x, inf, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);G.<span class="hljs-built_in">add</span>(x, y, inf, <span class="hljs-number">1</span>);G.<span class="hljs-built_in">add</span>(y, x, inf, <span class="hljs-number">1</span>);&#125;&#125;G.<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, S, k, <span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> res2 = G.<span class="hljs-built_in">dinic</span>(<span class="hljs-number">0</span>, T);cout &lt;&lt; res2[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-function">vector <span class="hljs-title">flow</span><span class="hljs-params">(T + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(T + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt;= T; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> id : G.adj[x]) &#123;<span class="hljs-keyword">auto</span> [y, cap, cost, all] = G.e[id];cap = all - cap;<span class="hljs-keyword">if</span> (cost == <span class="hljs-number">1</span> &amp;&amp; cap) &#123;flow[x][y] += cap;&#125;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);A[i][j] += flow[x][y] + flow[y][x];cout &lt;&lt; A[i][j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);B[i][j] += flow[x][y] + flow[y][x];&#125;cout &lt;&lt; B[i][j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p>一种较为简洁的网格图转对偶图建图方法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> id = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> S;&#125; <span class="hljs-keyword">if</span> (x == n) &#123;<span class="hljs-keyword">return</span> T;&#125;<span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + y;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);        <span class="hljs-comment">// x -&gt; y</span>&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);        <span class="hljs-comment">// x -&gt; y</span>&#125;&#125;</code></pre></div>          </div><h2 id="ukiepc-2023">UKIEPC 2023</h2><h3 id="g.-glacier-travel计算几何">G. Glacier Travel【计算几何】</h3><div class="note note-info">            <p>给定平面上 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((x_i,y_i)\)</span>，按顺序依次连成折线段。两个人一前一后沿着折线移动，它们的路程差固定为 <span class="math inline">\(s\)</span>，问移动过程中两人的最短距离。</p><p><span class="math inline">\(2\le n\le 10^6\)</span>，<span class="math inline">\(-10^6\le x_i,y_i\le 10^6\)</span>，<span class="math inline">\(1\le s \le 1000\)</span>。</p>          </div><div class="note note-success">            <p>可以从折线段的起点开始维护一对双指针，每次从状态 <span class="math inline">\(\{(x_A,y_A),(x_B,y_B)\}\)</span> 转移到状态 <span class="math inline">\(\{(x_A&#39;,y_A&#39;),(x_B&#39;,y_B&#39;)\}\)</span> 当且仅当 <span class="math inline">\((x_A&#39;,y_A&#39;)\)</span> 或 <span class="math inline">\((x_B&#39;,y_B&#39;)\)</span> 为某条线段的一个端点。</p><p>至于计算距离，有一个能使码量简单许多的转化：相对速度。</p><p>首先，两个人在同一条线段上移动肯定不优。否则假定 <span class="math inline">\(A\)</span> 不动，根据速度的合成法则，此时 <span class="math inline">\(B\)</span> 的运动轨迹是一条线段，于是可以三分或直接运用点到线段的距离公式计算。</p><p>具体地，答案是点 <span class="math inline">\((0,0)\)</span> 到线段 <span class="math inline">\((x_B-x_A,y_B-y_A)\sim(x_B&#39;-x_A&#39;,y_B&#39;-y_A&#39;)\)</span> 的距离。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    T x, y;    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;    <span class="hljs-keyword">operator</span> <span class="hljs-built_in">Point</span>&lt;U&gt;() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>&lt;U&gt;(<span class="hljs-built_in">U</span>(x), <span class="hljs-built_in">U</span>(y));    &#125;    Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;        x += p.x;        y += p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;        x -= p.x;        y -= p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;        x *= v;        y *= v;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a += b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a -= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;        <span class="hljs-keyword">return</span> a *= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;        <span class="hljs-keyword">return</span> b *= a;    &#125;    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;    &#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, Point &amp;p) &#123;        <span class="hljs-keyword">return</span> is &gt;&gt; p.x &gt;&gt; p.y;    &#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Point p) &#123;        <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">dot</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.x + a.y * b.y;&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dist</span><span class="hljs-params">(Point&lt;T&gt; p1, Point&lt;T&gt; p2)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrtl</span>(<span class="hljs-number">1.0</span> * (p1.x - p2.x) * (p1.x - p2.x) + <span class="hljs-number">1.0</span> * (p1.y - p2.y) * (p1.y - p2.y));&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;    Point&lt;T&gt; a, b;    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distToLine</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">cross</span>(p - l.a, l.b - l.a)) / <span class="hljs-built_in">dist</span>(l.a, l.b);&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; </span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distToSegment</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;    <span class="hljs-keyword">if</span> (l.a == l.b) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.a, p);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(p - l.a, l.b - l.a) &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.a, p);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(p - l.b, l.b - l.a) &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.b, p);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">distToLine</span>(p, l);&#125;<span class="hljs-keyword">using</span> P = Point&lt;<span class="hljs-type">double</span>&gt;;<span class="hljs-keyword">using</span> L = Line&lt;<span class="hljs-type">double</span>&gt;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">double</span> s;    cin &gt;&gt; s;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-function">vector&lt;P&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cin &gt;&gt; a[i];    &#125;    P X = a[<span class="hljs-number">0</span>], Y = a[<span class="hljs-number">0</span>];    <span class="hljs-type">int</span> ptr_x = <span class="hljs-number">1</span>, ptr_y = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (s &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">double</span> d = <span class="hljs-built_in">dist</span>(a[ptr_y], Y);        <span class="hljs-keyword">if</span> (d &lt; s) &#123;            s -= d;            Y = a[ptr_y++];        &#125; <span class="hljs-keyword">else</span> &#123;            Y += (a[ptr_y] - Y) * s * (<span class="hljs-number">1.0</span> / <span class="hljs-built_in">dist</span>(a[ptr_y], Y));            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-type">double</span> ans = <span class="hljs-built_in">dist</span>(X, Y);    <span class="hljs-keyword">while</span> (ptr_y &lt; n) &#123;        <span class="hljs-type">double</span> d1 = <span class="hljs-built_in">dist</span>(a[ptr_x], X);        <span class="hljs-type">double</span> d2 = <span class="hljs-built_in">dist</span>(a[ptr_y], Y);        P nxt_X, nxt_Y;        <span class="hljs-keyword">if</span> (d1 &lt; d2) &#123;            nxt_X = a[ptr_x++];            nxt_Y = Y + (a[ptr_y] - Y) * d1 * (<span class="hljs-number">1.0</span> / d2);            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">distToSegment</span>(P&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, L&#123;Y - X, nxt_Y - nxt_X&#125;));        &#125; <span class="hljs-keyword">else</span> &#123;            nxt_X = X + (a[ptr_x] - X) * d2 * (<span class="hljs-number">1.0</span> / d1);            nxt_Y = a[ptr_y++];            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">distToSegment</span>(P&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, L&#123;Y - X, nxt_Y - nxt_X&#125;));        &#125;        X = nxt_X;        Y = nxt_Y;    &#125;       cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">7</span>) &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">solve</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="h.-history-in-numbers线段树">H. History in Numbers【线段树】</h3><div class="note note-info">            <p>维护长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span>，并有 <span class="math inline">\(m\)</span> 次操作，每次可能是以下两种之一。</p><p><code>update l r d</code>：<span class="math inline">\(\forall i\in [l, r]\)</span>，<span class="math inline">\(a_i := a_i+d\)</span>。</p><p><code>check l r</code>：查询区间 <span class="math inline">\([l, r]\)</span> 的局部最小值序列是否严格递增。</p><p>区间 <span class="math inline">\([l,r]\)</span> 的局部最小值序列：将 <span class="math inline">\([l, r]\)</span> 中相邻且相同的元素只保留一个后，数值上小于两侧元素的数构成的集合。</p><p><span class="math inline">\(1 \le n,m \le 3\cdot 10^5\)</span>，<span class="math inline">\(-10^8\le a_i,d\le 10^8\)</span>。</p>          </div><div class="note note-success">            <p>线段树板题，就是维护起来细节比较多。</p><p>线段树维护七个值：</p><ul><li><code>l1</code>：区间左起第一个数。</li><li><code>l2</code>：区间左起和 <code>l1</code> 不同的第二个数。</li><li><code>r1</code>：区间右起第一个数。</li><li><code>r2</code>：区间右起和 <code>r1</code> 不同的第二个数。</li><li><code>f1</code>：区间左起第一个局部最小值的值。</li><li><code>f2</code>：区间右起第一个局部最小值的值。</li><li><code>ok</code>：该区间的局部最小值序列是否递增。</li></ul><p>然后就是分类讨论了，代码里我分区间去重后只有一个值，只有两个值，超过两个值讨论了一下。</p><p>注意区间左右两侧的边界情况需要特判。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazySegmentTree</span> &#123;    <span class="hljs-type">int</span> n;    vector&lt;Info&gt; tr;    vector&lt;Tag&gt; tag;    <span class="hljs-built_in">LazySegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;        n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;        <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = (<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>;        tr.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Info</span>());        tag.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Tag</span>());        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);    &#125;    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = a[l];            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(ls, l, m, a);        <span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        tr[p] = tr[ls] + tr[rs];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        tr[p].<span class="hljs-built_in">apply</span>(x);        tag[p].<span class="hljs-built_in">apply</span>(x);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-built_in">apply</span>(ls, tag[p]);        <span class="hljs-built_in">apply</span>(rs, tag[p]);        tag[p] = <span class="hljs-built_in">Tag</span>();    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = x;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-keyword">if</span> (pos &lt;= m) &#123;            <span class="hljs-built_in">modify</span>(ls, l, m, pos, x);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, pos, x);        &#125;        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, x);    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-keyword">return</span> tr[p];        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (qr &lt;= m) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ql &gt;= m + <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);        &#125;    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-built_in">apply</span>(p, x);            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">modify</span>(ls, l, m, ql, qr, x);        <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, x);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, x);    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findFirst</span>(ls, l, m, ql, qr, pred);        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;            res = <span class="hljs-built_in">findFirst</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFirst</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findLast</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;            res = <span class="hljs-built_in">findLast</span>(ls, l, m, ql, qr, pred);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findLast</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);    &#125;&#125;; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tag</span> &#123;    <span class="hljs-type">int</span> add = <span class="hljs-number">0</span>;    <span class="hljs-built_in">Tag</span>() &#123;&#125;    <span class="hljs-built_in">Tag</span>(<span class="hljs-type">int</span> A) &#123;        add = A;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;        add += t.add;    &#125;&#125;; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> l1 = inf;    <span class="hljs-type">int</span> l2 = inf;    <span class="hljs-type">int</span> r1 = inf;    <span class="hljs-type">int</span> r2 = inf;    <span class="hljs-type">int</span> f1 = inf;    <span class="hljs-type">int</span> f2 = inf;<span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">Info</span>() &#123;&#125;    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B) &#123;        l1 = r1 = A;        l = r = B;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;        l1 += t.add;        r1 += t.add;        <span class="hljs-keyword">if</span> (l2 != inf) &#123;            l2 += t.add;        &#125;        <span class="hljs-keyword">if</span> (r2 != inf) &#123;            r2 += t.add;        &#125;        <span class="hljs-keyword">if</span> (f1 != inf) &#123;            f1 += t.add;        &#125;        <span class="hljs-keyword">if</span> (f2 != inf) &#123;            f2 += t.add;        &#125;    &#125;&#125;;pair&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;, <span class="hljs-type">bool</span>&gt; <span class="hljs-built_in">check</span>(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> b1, <span class="hljs-type">int</span> b2) &#123;    <span class="hljs-keyword">if</span> (d == inf) &#123;        <span class="hljs-keyword">if</span> (a1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;b1, b2&#125;, <span class="hljs-literal">true</span>&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;a1, a2&#125;, <span class="hljs-literal">true</span>&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> &#123;&#123;a1, b2&#125;, a2 &lt; b1&#125;;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (a1 == inf &amp;&amp; b1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;d, d&#125;, <span class="hljs-literal">true</span>&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;d, b2&#125;, d &lt; b1&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;a1, d&#125;, a2 &lt; d&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> &#123;&#123;a1, b2&#125;, a2 &lt; d &amp;&amp; d &lt; b1&#125;;        &#125;    &#125;&#125;Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;    Info c;    <span class="hljs-keyword">if</span> (a.l2 == inf &amp;&amp; b.l2 == inf) &#123;        <span class="hljs-keyword">if</span> (a.l1 == b.l1) &#123;            c = a;        &#125; <span class="hljs-keyword">else</span> &#123;            c.l1 = a.l1;            c.l2 = b.l1;            c.r1 = b.r1;            c.r2 = a.r1;        &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.l2 == inf) &#123;        c = b;        <span class="hljs-keyword">if</span> (a.r1 != b.l1) &#123;            c.l1 = a.r1;            c.l2 = b.l1;            <span class="hljs-keyword">if</span> (a.r1 &gt; b.l1 &amp;&amp; b.l1 &lt; b.l2) &#123;                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, b.l1, b.f1, b.f2);                c.f1 = res[<span class="hljs-number">0</span>];                c.f2 = res[<span class="hljs-number">1</span>];                c.ok &amp;= t;            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b.l2 == inf) &#123;        c = a;        <span class="hljs-keyword">if</span> (a.r1 != b.l1) &#123;            c.r1 = b.l1;            c.r2 = a.r1;            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; a.r1 &lt; b.l1) &#123;                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, a.r1, b.f1, b.f2);                c.f1 = res[<span class="hljs-number">0</span>];                c.f2 = res[<span class="hljs-number">1</span>];                c.ok &amp;= t;            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        c.l1 = a.l1;        c.l2 = a.l2;        c.r1 = b.r1;        c.r2 = b.r2;        c.ok = (a.ok &amp;&amp; b.ok);        <span class="hljs-type">int</span> d = inf;        <span class="hljs-keyword">if</span> (a.r1 == b.l1) &#123;            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; b.l1 &lt; b.l2) &#123;                d = a.r1;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; a.r1 &lt; b.l1) &#123;                d = a.r1;            &#125;            <span class="hljs-keyword">if</span> (a.r1 &gt; b.l1 &amp;&amp; b.l1 &lt; b.l2) &#123;                d = b.l1;            &#125;        &#125;        <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, d, b.f1, b.f2);        c.f1 = res[<span class="hljs-number">0</span>];        c.f2 = res[<span class="hljs-number">1</span>];        c.ok &amp;= t;    &#125;    c.l = <span class="hljs-built_in">min</span>(a.l, b.l);    c.r = <span class="hljs-built_in">max</span>(a.r, b.r);    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;Info&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[i] = <span class="hljs-built_in">Info</span>(x, i);&#125;<span class="hljs-function">LazySegmentTree&lt;Info, Tag&gt; <span class="hljs-title">seg</span><span class="hljs-params">(a)</span></span>;<span class="hljs-type">int</span> q;cin &gt;&gt; q;<span class="hljs-keyword">while</span> (q--) &#123;string s;<span class="hljs-type">int</span> l, r;cin &gt;&gt; s &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;update&quot;</span>) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;            seg.<span class="hljs-built_in">modify</span>(l, r, Tag&#123;x&#125;);&#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">auto</span> cur = seg.<span class="hljs-built_in">query</span>(l, r);            <span class="hljs-keyword">if</span> (cur.l1 &lt; cur.l2) &#123;                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(inf, inf, cur.l1, cur.f1, cur.f2);                cur.f1 = res[<span class="hljs-number">0</span>];                cur.f2 = res[<span class="hljs-number">1</span>];                cur.ok &amp;= t;            &#125;            <span class="hljs-keyword">if</span> (cur.r1 &lt; cur.r2) &#123;                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(cur.f1, cur.f2, cur.r1, inf, inf);                cur.f1 = res[<span class="hljs-number">0</span>];                cur.f2 = res[<span class="hljs-number">1</span>];                cur.ok &amp;= t;            &#125;            cur.ok |= cur.l2 == inf;            cout &lt;&lt; (cur.ok ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="neerc-2019-2020">NEERC 2019-2020</h2><h3 id="l.-lengths-and-periods后缀自动机">L. Lengths and Periods【后缀自动机】</h3><p>SAM 真是人类智慧的结晶啊！占坑。</p><h2 id="上海市赛">2024 上海市赛</h2><h3 id="f.-羁绊大师bitset-优化背包">F. 羁绊大师【bitset 优化背包】</h3><div class="note note-info">            <p>有 <span class="math inline">\(n\)</span> 个英雄，每个英雄有 <span class="math inline">\(a_i,b_i\)</span> 两种羁绊，且不存在 <span class="math inline">\(i,j\in[1,n]\)</span> 使得 <span class="math inline">\(a_i=a_j\land b_i=b_j\)</span>。</p><p>共有 <span class="math inline">\(m\)</span> 种羁绊，每种羁绊至多只有两个英雄拥有。当上阵英雄中有两个英雄拥有此羁绊时，该羁绊为激活状态。</p><p>对 <span class="math inline">\(k\in[1,n]\)</span> 分别回答当有 <span class="math inline">\(k\)</span> 个英雄上阵时，激活羁绊的最大数量。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(n \le m \le 2n\)</span>，<span class="math inline">\(1\le a_i &lt; b_i \le m\)</span>。</p>          </div><div class="note note-success">            <p>将英雄看成点，羁绊看成边，拥有相同羁绊的两个英雄连边，问题转化为对 <span class="math inline">\(k\in [1,n]\)</span> 分别回答选中 <span class="math inline">\(k\)</span> 个点时导出子图的最大边数。</p><p>这个图具有特殊性质——每个点的度数至多是 <span class="math inline">\(2\)</span>，因此图中只包含环或链。</p><p>对于同样数目的点，选环比选链更具性价比，而对于两条链，优先选更长的链肯定也不劣。于是推断出以下策略：</p><ul><li>选择一些环使得这些环的总点数 <span class="math inline">\(x\le k\)</span> 且 <span class="math inline">\(x\)</span> 尽可能大。</li><li>按链的长度降序选择直到剩下的 <span class="math inline">\(k-x\)</span> 个点用完。</li></ul><p>第一步可以做 <span class="math inline">\(01\)</span> 背包 <span class="math inline">\(O(n^2)\)</span> 地解决。又因为这是存在性背包，于是可以用 <code>std::bitset</code> 优化到 <span class="math inline">\(O(\frac{n^2}{w})\)</span>。</p><p>第二步用一个指针维护当前选择的边数即可。</p><p>时间复杂度 <span class="math inline">\(O(\frac{n^2}{w})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">bel</span>(m + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;bel[x].<span class="hljs-built_in">push_back</span>(i);bel[y].<span class="hljs-built_in">push_back</span>(i);&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-keyword">if</span> (bel[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<span class="hljs-type">int</span> x = bel[i][<span class="hljs-number">0</span>];<span class="hljs-type">int</span> y = bel[i][<span class="hljs-number">1</span>];adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; cir, line;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> len) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">bool</span> end = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[y] = <span class="hljs-literal">true</span>;end = <span class="hljs-literal">false</span>;<span class="hljs-built_in">self</span>(self, y, len + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (end) &#123;<span class="hljs-keyword">if</span> (adj[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;line.<span class="hljs-built_in">push_back</span>(len - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;cir.<span class="hljs-built_in">push_back</span>(len);&#125;&#125;&#125;; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; adj[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;vis[i] = <span class="hljs-literal">true</span>;<span class="hljs-built_in">dfs</span>(dfs, i, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; adj[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;vis[i] = <span class="hljs-literal">true</span>;<span class="hljs-built_in">dfs</span>(dfs, i, <span class="hljs-number">1</span>);&#125;&#125;bitset&lt;N&gt; dp;dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;dp |= dp &lt;&lt; x;&#125;<span class="hljs-built_in">sort</span>(line.<span class="hljs-built_in">begin</span>(), line.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());<span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);<span class="hljs-type">int</span> ptr = <span class="hljs-number">0</span>, ex = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (dp[i]) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;ex = <span class="hljs-number">0</span>;res = i;<span class="hljs-keyword">continue</span>;&#125;ex++;<span class="hljs-keyword">if</span> (i &lt;= sum) &#123;cout &lt;&lt; (ex &gt;= <span class="hljs-number">2</span> ? i - <span class="hljs-number">1</span> : res) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (ptr &gt;= line.<span class="hljs-built_in">size</span>()) &#123;cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (ex &gt; line[ptr]) &#123;res += line[ptr];ptr++;ex = <span class="hljs-number">0</span>;&#125;cout &lt;&lt; res + (ex &gt;= <span class="hljs-number">2</span> ? ex - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="d.-咸鱼跑酷线段树">D. 咸鱼跑酷【线段树】</h3><div class="note note-info">            <p>长为 <span class="math inline">\(n\)</span> 的操作序列，每个位置有两种操作，形如 <code>+x</code> 或 <code>*x</code>。</p><p>给定 <span class="math inline">\(q\)</span> 组询问，每次给定 <code>u l r</code>，问以初值 <span class="math inline">\(u\)</span>，执行 <span class="math inline">\(l\to r\)</span> 的操作序列，每个位置可以选择两种给定操作中的一种，最后能得到的最大数值。答案对 998244353 取模。</p><p><span class="math inline">\(1\le n,q \le 10^5\)</span>，<span class="math inline">\(1\le x,u \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>对于一个位置，如果都是 <code>+</code> 或都是 <code>*</code>，那么一定选数字大的那个；否则一加一乘，且只有乘的数 <span class="math inline">\(&gt;1\)</span> 时才有选择的可能，我们称这样的位置为关键位置。</p><p>注意到 <span class="math inline">\(1\le x \le 10^9\)</span>，故当当前 <span class="math inline">\(u&gt;10^9\)</span> 时，选乘一定比选加更优。</p><p>又因为每次经过一个关键位置，数字大小至少<span class="math inline">\(\times 2\)</span>，故经过 <span class="math inline">\(O(\log W)\)</span> 个关键位置之后当前数字就会超过临界值。</p><p>于是我们预处理出下一个关键位置的坐标，暴力跳 <span class="math inline">\(O(\log W)\)</span> 个段。由于段间都为 <code>+</code> 操作，故维护一个前缀和即可。</p><p>当跳到数值 <span class="math inline">\(&gt;10^9\)</span>，之后的选择就固定了。用线段树维护一段区间累计乘了多少，累计加了多少，就能快速计算。</p><p>pushup 的方式：</p><div class="code-wrapper"><pre><code class="hljs c++">Mul[p] = Mul[p &lt;&lt; <span class="hljs-number">1</span>] * Mul[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]Add[p] = Add[p &lt;&lt; <span class="hljs-number">1</span>] * Mul[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] + Add[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]</code></pre></div><p>时间复杂度 <span class="math inline">\(O(n\log n+q\log(nW))\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; Add, Mul;<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size) &#123;n = size;Add.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);Mul.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;Mul[p] = Mul[ls] * Mul[rs] % modp;Add[p] = (Add[ls] * Mul[rs] + Add[rs]) % modp;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &amp;val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;        Mul[p] = val[<span class="hljs-number">0</span>];        Add[p] = val[<span class="hljs-number">1</span>];            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;        <span class="hljs-built_in">modify</span>(ls, l, mid, pos, val);        &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">modify</span>(rs, mid + <span class="hljs-number">1</span>, r, pos, val);        &#125;        <span class="hljs-built_in">pushup</span>(p);    &#125;<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> &#123;Mul[p], Add[p]&#125;;&#125;array&lt;<span class="hljs-type">int</span>, 2&gt; res = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">if</span>(ql &lt;= mid) &#123;<span class="hljs-keyword">auto</span> o = <span class="hljs-built_in">query</span>(ls, l, mid, ql, qr);res[<span class="hljs-number">0</span>] = res[<span class="hljs-number">0</span>] * o[<span class="hljs-number">0</span>] % modp;res[<span class="hljs-number">1</span>] = (res[<span class="hljs-number">1</span>] * o[<span class="hljs-number">0</span>] + o[<span class="hljs-number">1</span>]) % modp;&#125;<span class="hljs-keyword">if</span>(qr &gt; mid) &#123;<span class="hljs-keyword">auto</span> o = <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);res[<span class="hljs-number">0</span>] = res[<span class="hljs-number">0</span>] * o[<span class="hljs-number">0</span>] % modp;res[<span class="hljs-number">1</span>] = (res[<span class="hljs-number">1</span>] * o[<span class="hljs-number">0</span>] + o[<span class="hljs-number">1</span>]) % modp;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; val)</span> </span>&#123;        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, val);    &#125;<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;string s;cin &gt;&gt; s;<span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;add[i] = <span class="hljs-built_in">max</span>(add[i], <span class="hljs-built_in">stoll</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>)));&#125; <span class="hljs-keyword">else</span> &#123;mul[i] = <span class="hljs-built_in">max</span>(mul[i], <span class="hljs-built_in">stoll</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>)));&#125;&#125;&#125;<span class="hljs-function">SegmentTree <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (mul[i] == <span class="hljs-number">1</span>) &#123;seg.<span class="hljs-built_in">modify</span>(i, &#123;<span class="hljs-number">1</span>, add[i]&#125;);&#125; <span class="hljs-keyword">else</span> &#123;seg.<span class="hljs-built_in">modify</span>(i, &#123;mul[i], <span class="hljs-number">0</span>&#125;);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;pre[i] = pre[i - <span class="hljs-number">1</span>] + add[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;nxt[i] = mul[i] &gt; <span class="hljs-number">1</span> ? i : nxt[i + <span class="hljs-number">1</span>];&#125;<span class="hljs-type">int</span> q;cin &gt;&gt; q;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> u, l, r;cin &gt;&gt; u &gt;&gt; l &gt;&gt; r;<span class="hljs-type">int</span> pl = l;<span class="hljs-keyword">while</span> (pl &lt;= r &amp;&amp; u &lt; <span class="hljs-number">1e9</span>) &#123;<span class="hljs-type">int</span> pr = <span class="hljs-built_in">min</span>(r, nxt[pl] - <span class="hljs-number">1</span>);u += pre[pr] - pre[pl - <span class="hljs-number">1</span>];pl = pr + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (u &gt;= <span class="hljs-number">1e9</span> || pl &gt; r) &#123;<span class="hljs-keyword">break</span>;&#125;u = <span class="hljs-built_in">max</span>(u + add[pl], u * mul[pl]);pl++;&#125;<span class="hljs-keyword">auto</span> [Mul, Add] = seg.<span class="hljs-built_in">query</span>(pl, r);<span class="hljs-type">int</span> ans = (u % modp * Mul % modp + Add) % modp;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="seerc-2022">SEERC 2022</h2><h3 id="i.-inadequate-operation贪心单调栈">I. Inadequate Operation【贪心、单调栈】</h3><div class="note note-info">            <p>给定长为 <span class="math inline">\(n\)</span> 的非负序列 <span class="math inline">\(\{a\}\)</span>，每次操作你可以选择一个 <span class="math inline">\(i\in[1,n)\)</span>，满足 <span class="math inline">\(\max(a_i,a_{i+1}) &gt;0\)</span>，然后用 <span class="math inline">\(\max(a_i,a_{i + 1})-1\)</span> 替换 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span>。问使得序列所有元素变为 <span class="math inline">\(0\)</span> 的最小操作次数。</p><p><span class="math inline">\(2 \le n \le 2\cdot 10^5\)</span>，<span class="math inline">\(0\le a_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>略微诈骗。因为这个操作每次最多让两个位置 <span class="math inline">\(-1\)</span>（即 <span class="math inline">\(a_i=a_{i+1}\)</span> 时），就算你让一个位置 <span class="math inline">\(-1\)</span>，另一个位置被拉高，你继续操作这个下标操作次数也不会更劣。于是策略就是贪心地从大到小删。</p><p>对于一个相同高度长为 <span class="math inline">\(L\)</span> 的连续段，删掉它需要 <span class="math inline">\(\lceil \frac{L}{2}\rceil\)</span> 次操作。形式化地，答案是： <span class="math display">\[\sum_{i=1}^{mx}\left(\left\lceil\frac{L_{i1}}{2}\right\rceil +\left\lceil\frac{L_{i2}}{2}\right\rceil +\cdots\right)\]</span> 其中 <span class="math inline">\(L_i\)</span> 是指考虑所有 <span class="math inline">\(\ge i\)</span> 的元素，它们形成的若干连续段长度。</p><p>进一步地，记 <span class="math inline">\(l_i\)</span> 为 <span class="math inline">\(i\)</span> 左侧第一个 <span class="math inline">\(&lt;a_i\)</span> 的位置，<span class="math inline">\(r_i\)</span> 为 <span class="math inline">\(i\)</span> 右侧第一个 <span class="math inline">\(&lt;a_i\)</span> 的位置。式子可以化成： <span class="math display">\[\sum_{i=1}^{n}\left\lceil\frac{r_i-l_i-1}{2}\right\rceil(a_i-\max(a_{l_i},a_{r_i}))\]</span> 实现的时候，可以维护一个内部递增的单调栈，扫一遍就能求出 <span class="math inline">\(l_i\)</span> 和 <span class="math inline">\(r_i\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        并查集ver.    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i][<span class="hljs-number">0</span>];a[i][<span class="hljs-number">1</span>] = i;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n, lst = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-type">int</span> j = i;<span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j][<span class="hljs-number">0</span>] == a[i][<span class="hljs-number">0</span>]) &#123;j--;&#125;<span class="hljs-type">int</span> len = lst;<span class="hljs-type">int</span> del = a[i][<span class="hljs-number">0</span>] - (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : a[j][<span class="hljs-number">0</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt;= i; k++) &#123;<span class="hljs-type">int</span> pos = a[k][<span class="hljs-number">1</span>];vis[pos] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (vis[pos - <span class="hljs-number">1</span>]) &#123;len -= (dsu.<span class="hljs-built_in">size</span>(pos - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;dsu.<span class="hljs-built_in">merge</span>(pos, pos - <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (vis[pos + <span class="hljs-number">1</span>]) &#123;len -= (dsu.<span class="hljs-built_in">size</span>(pos + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;dsu.<span class="hljs-built_in">merge</span>(pos, pos + <span class="hljs-number">1</span>);&#125;len += (dsu.<span class="hljs-built_in">size</span>(pos) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;ans += len * del;lst = len;i = j + <span class="hljs-number">1</span>;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        单调栈ver.    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stk</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; a[stk.<span class="hljs-built_in">back</span>()] &gt;= a[i]) &#123;r[stk.<span class="hljs-built_in">back</span>()] = i;stk.<span class="hljs-built_in">pop_back</span>();&#125;<span class="hljs-keyword">if</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;l[i] = stk.<span class="hljs-built_in">back</span>();&#125;stk.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ans += (r[i] - l[i]) / <span class="hljs-number">2</span> * (a[i] - <span class="hljs-built_in">max</span>(a[l[i]], a[r[i]]));&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-knowledge-testing-problem整体二分">K. Knowledge Testing Problem【整体二分】</h3><div class="note note-info">            <p>给定一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向图，边有边权 <span class="math inline">\(w_i\)</span>。其中任意一条边 <span class="math inline">\(x_i\to y_i\)</span> 都满足 <span class="math inline">\(|x_i-y_i|\le 10\)</span>。给定 <span class="math inline">\(q\)</span> 组询问，每次询问两个点问最短路。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<span class="math inline">\(1\le m \le 2\cdot 10^5\)</span>，<span class="math inline">\(1\le q \le 2.5\cdot 10^4\)</span>，<span class="math inline">\(1 \le w_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>考虑整体二分。</p><p>对于当前区间 <span class="math inline">\([l, r]\)</span>，设中点为 <span class="math inline">\(m\)</span>，取中点周围 <span class="math inline">\([m-4,m+5]\)</span> 共 <span class="math inline">\(10\)</span> 个点，并以这些点为起点跑单源最短路（经过的点必须在 <span class="math inline">\([l,r]\)</span> 内，即只连两个端点都在 <span class="math inline">\([l, r]\)</span> 内的边），然后再以这些点为中转点分治下去。</p><p>对于一个询问 <span class="math inline">\(x,y\)</span>，若 <span class="math inline">\(\max(x,y)&lt;m-4\)</span>，就把它放到 <span class="math inline">\([l,m-4)\)</span> 里继续更新；若 <span class="math inline">\(\min(x,y)&gt;m+5\)</span>，就把它放到 <span class="math inline">\((m+5,r]\)</span> 里继续更新；否则此次更新完后不用继续更新，因为必然以 <span class="math inline">\(x,y\)</span> 中的至少一个点为起点跑了单源最短路。</p><p>保证正确性的根据是：对于一个询问 <span class="math inline">\(x,y\)</span>（不妨设 <span class="math inline">\(x&lt;y&lt;m-4\)</span>），如果最短路需要经过 <span class="math inline">\(m+5\)</span> 右侧的点，就必然经过 <span class="math inline">\([m-4,m+5]\)</span> 中的某一个（因为任意一条边两侧的点编号相差 <span class="math inline">\(\le 10\)</span>），故以这 <span class="math inline">\(10\)</span> 个点为中转点更新出的最短路能覆盖所有的情况。</p><p>假设 <span class="math inline">\(n,m\)</span> 同级，时间复杂度 <span class="math inline">\(O(nd\log^2n)\)</span>，<span class="math inline">\(d=10\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, q;cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; E, Q;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;E.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;Q.<span class="hljs-built_in">push_back</span>(&#123;x, y, i&#125;);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q, inf)</span></span>;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, inf)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dijkstra = [&amp;] (<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;dis[i] = inf;vis[i] = <span class="hljs-literal">false</span>;&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> P pair<span class="hljs-string">&lt;int, int&gt;</span></span>priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq;pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);dis[S] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> [dist, x] = pq.<span class="hljs-built_in">top</span>();pq.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span> (vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (dis[y] &gt; dist + w) &#123;dis[y] = dist + w;pq.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);&#125;&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; &amp;vE, vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; &amp;vQ) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (l &gt; r) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;adj[i].<span class="hljs-built_in">clear</span>();&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : vE) &#123;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">max</span>(l, mid - <span class="hljs-number">4</span>); i &lt;= <span class="hljs-built_in">min</span>(r, mid + <span class="hljs-number">5</span>); i++) &#123;<span class="hljs-built_in">dijkstra</span>(i, l, r);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, id] : vQ) &#123;ans[id] = <span class="hljs-built_in">min</span>(ans[id], dis[x] + dis[y]);&#125;&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; lE, rE, lQ, rQ;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : vE) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(x, y) &lt;= mid - <span class="hljs-number">5</span>) &#123;lE.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(x, y) &gt;= mid + <span class="hljs-number">6</span>) &#123;rE.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, id] : vQ) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(x, y) &lt;= mid - <span class="hljs-number">5</span>) &#123;lQ.<span class="hljs-built_in">push_back</span>(&#123;x, y, id&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(x ,y) &gt;= mid + <span class="hljs-number">6</span>) &#123;rQ.<span class="hljs-built_in">push_back</span>(&#123;x, y, id&#125;);&#125;&#125;<span class="hljs-built_in">self</span>(self, l, mid - <span class="hljs-number">5</span>, lE, lQ);<span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">6</span>, r, rE, rQ);&#125;;<span class="hljs-built_in">calc</span>(calc, <span class="hljs-number">1</span>, n, E, Q);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; (x == inf ? <span class="hljs-number">-1</span> : x) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="nwerc-2021">NWERC 2021</h2><h3 id="h.-heating-up双向链表">H. Heating Up【双向链表】</h3><div class="note note-info">            <p>有 <span class="math inline">\(n\)</span> 个辣椒，第 <span class="math inline">\(i\)</span> 个辣度为 <span class="math inline">\(a_i\)</span>，排成环形（即 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n\)</span> 看作相邻）。你要吃光这些辣椒，你可以任意选择一个辣椒开始，并在之后每一步选择"已选择辣椒"中的一个相邻辣椒吃下。你初始有忍耐度 <span class="math inline">\(f\)</span>，你吃下一个辣度为 <span class="math inline">\(k\)</span> 的辣椒当且仅当 <span class="math inline">\(f\ge k\)</span>，并且当你吃掉它后你的忍耐值会增加 <span class="math inline">\(k\)</span> 个单位。问吃光所有辣椒所需的最小初始忍耐值。</p><p><span class="math inline">\(3\le n \le 5\cdot 10^5\)</span>，<span class="math inline">\(0\le a_i \le 10^{13}\)</span>。</p>          </div><div class="note note-success">            <p>二分答案，设二分出的答案为 <span class="math inline">\(s\)</span>，问题转化为判定初始忍耐值为 <span class="math inline">\(s\)</span> 时是否能吃完所有辣椒。</p><p>拆环成链，用一个双向链表操作以下过程：</p><ul><li>遍历 <span class="math inline">\(i\in[1,2n]\)</span>，若 <span class="math inline">\(a_i&gt;s\)</span>，跳过；否则以点 <span class="math inline">\(i\)</span> 为中心向两侧尝试扩张。</li><li>对每一个连续段维护这个段 <span class="math inline">\(a_i\)</span> 的最小值 <span class="math inline">\(b\)</span>，当忍耐值不小于这个值时，就可以吞并这个段，新的 <span class="math inline">\(b\)</span> 即两段取 <span class="math inline">\(\min\)</span>。</li><li>这个被合并的段有贡献 <span class="math inline">\(\sum a_i\)</span>，合并时可以另开一个数组 <span class="math inline">\(c\)</span> 维护。</li><li>判定成功当且仅当链表合并到最后只剩一个元素，即删除了 <span class="math inline">\(2n-1\)</span> 个元素。</li></ul><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 为二分值域。具体实现见代码。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];a[i + n] = a[i];&#125;a[<span class="hljs-number">0</span>] = a[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>] = inf;<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> st) &#123;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">L</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>), <span class="hljs-built_in">R</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;L[i] = i - <span class="hljs-number">1</span>;R[i] = i + <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> cnt = <span class="hljs-number">2</span> * n;<span class="hljs-keyword">auto</span> del = [&amp;] (<span class="hljs-keyword">auto</span> pos) &#123;L[R[pos]] = L[pos];R[L[pos]] = R[pos];cnt--;&#125;;vector b = a, c = a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i = R[i]) &#123;<span class="hljs-keyword">if</span> (b[i] &gt; st) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> cur = st + b[i];<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> ((L[i] &lt; <span class="hljs-number">1</span> || b[L[i]] &gt; cur) &amp;&amp; (R[i] &gt; <span class="hljs-number">2</span> * n || b[R[i]] &gt; cur)) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (L[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; b[L[i]] &lt;= cur) &#123;cur += c[L[i]];c[i] += c[L[i]];b[i] = <span class="hljs-built_in">min</span>(b[i], b[L[i]]);<span class="hljs-built_in">del</span>(L[i]);&#125;<span class="hljs-keyword">if</span> (R[i] &lt;= <span class="hljs-number">2</span> * n &amp;&amp; b[R[i]] &lt;= cur) &#123;cur += c[R[i]];c[i] += c[R[i]];b[i] = <span class="hljs-built_in">min</span>(b[i], b[R[i]]);<span class="hljs-built_in">del</span>(R[i]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> cnt == <span class="hljs-number">1</span>;&#125;;<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e13</span>, ans = <span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;ans = mid;r = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;l = mid + <span class="hljs-number">1</span>;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="swerc-2023">SWERC 2023</h2><h3 id="g.-favourite-dish凸包">G. Favourite Dish【凸包】</h3><div class="note note-info">            <p>有 <span class="math inline">\(n\)</span> 道菜，第 <span class="math inline">\(i\)</span> 道菜有属性 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span>。有 <span class="math inline">\(m\)</span> 个客人，第 <span class="math inline">\(i\)</span> 个人有属性 <span class="math inline">\(c_{i}\)</span> 和 <span class="math inline">\(d_i\)</span>。</p><p>第 <span class="math inline">\(i\)</span> 个人对第 <span class="math inline">\(j\)</span> 道菜的喜爱度为 <span class="math inline">\(\dfrac{c_ia_j+d_ib_j}{c_i+d_i}\)</span>，即加权平均值。你需要对每个人求出他最喜欢的菜品编号（若对两道菜的喜爱度相同，取编号较小者）。保证有序对 <span class="math inline">\((a_i,b_i)\)</span> 两两不同，<span class="math inline">\((c_i,d_i)\)</span> 两两不同。</p><p><span class="math inline">\(1\le n,m\le 5\cdot 10^5\)</span>，<span class="math inline">\(0\le a_i,b_i,c_i,d_i\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>把每个人看作一个询问。对于单个询问，<span class="math inline">\(c+d\)</span> 固定，衡量指标是 <span class="math inline">\(ac+bd\)</span>。</p><p>问题转化为给定 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((a, b)\)</span>，每次询问一个 <span class="math inline">\((c, d)\)</span>，问 <span class="math inline">\(ac+bd\)</span> 取到最大值时对应点的编号。</p><p>这是一个经典问题。令 <span class="math inline">\(w=ac+bd\)</span>，两边除以 <span class="math inline">\(d\)</span>： <span class="math display">\[\frac{w}{d}=\frac{ac}{d}+b\longrightarrow b=(-\frac{c}{d})a+\frac{w}{d}\]</span> 这是一个 <span class="math inline">\(y=kx+b\)</span> 形式的直线方程，让 <span class="math inline">\(w\)</span> 最大，即让这条直线的截距 <span class="math inline">\(\left(\dfrac{w}{d}\right)\)</span> 最大。</p><p>由于 <span class="math inline">\(a,b,c,d\)</span> 均为非负整数，我们可以求出这 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((a, b)\)</span> 在第一象限的上凸壳，将询问按斜率 <span class="math inline">\(\left(-\dfrac{c}{d}\right)\)</span> 排序，用一对双指针即可维护。（一个在凸壳上顺时针扫，一个按直线斜率从大到小扫）</p><p>时间复杂度 <span class="math inline">\(O(n\log n+m\log m)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">a</span>(n);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;a[i] = &#123;x, y, i&#125;;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), [&amp;] (array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; i, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; j) &#123;<span class="hljs-keyword">return</span> i[<span class="hljs-number">0</span>] == j[<span class="hljs-number">0</span>] ? i[<span class="hljs-number">1</span>] &gt; j[<span class="hljs-number">1</span>] : i[<span class="hljs-number">0</span>] &lt; j[<span class="hljs-number">0</span>];&#125;);<span class="hljs-keyword">auto</span> getk = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<span class="hljs-built_in">return</span> (<span class="hljs-type">double</span>)(a[j][<span class="hljs-number">1</span>] - a[i][<span class="hljs-number">1</span>]) / (a[j][<span class="hljs-number">0</span>] - a[i][<span class="hljs-number">0</span>]);&#125;;vector&lt;<span class="hljs-type">int</span>&gt; h&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">while</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getk</span>(h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>], h.<span class="hljs-built_in">back</span>()) &lt; <span class="hljs-built_in">getk</span>(h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>], i)) &#123;h.<span class="hljs-built_in">pop_back</span>();&#125;h.<span class="hljs-built_in">push_back</span>(i);&#125;vector&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt; l;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> c, d;cin &gt;&gt; c &gt;&gt; d;l.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">-1.0L</span> * c / d, i&#125;);&#125;<span class="hljs-built_in">sort</span>(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, res = inf; i &lt; m; i++) &#123;<span class="hljs-keyword">auto</span> [k, id] = l[i];<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; k == l[i - <span class="hljs-number">1</span>].first) &#123;ans[id] = res;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; h.<span class="hljs-built_in">size</span>() &amp;&amp; k &lt; <span class="hljs-built_in">getk</span>(h[j], h[j + <span class="hljs-number">1</span>])) &#123;j++;&#125;res = a[h[j]][<span class="hljs-number">2</span>];<span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; h.<span class="hljs-built_in">size</span>() &amp;&amp; k == <span class="hljs-built_in">getk</span>(h[j], h[j + <span class="hljs-number">1</span>])) &#123;j++;res = <span class="hljs-built_in">min</span>(res, a[h[j]][<span class="hljs-number">2</span>]);&#125;ans[id] = res;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p><span class="math inline">\(1.0\cdot \text{int}=\text{double}\)</span></p><p><span class="math inline">\(1.0L\cdot \text{int}=\text{long double}\)</span></p><p>望周知 (QwQ)。</p>          </div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>UESTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【游记】2024 UESTC 暑假集训 第一轮</title>
    <link href="/posts/61a1a0ca.html"/>
    <url>/posts/61a1a0ca.html</url>
    
    <content type="html"><![CDATA[<p>半年没写过游记了，因为懒。</p><p>感觉还是要写点什么才行。</p><h3 id="day--2">【7.5】 Day -2</h3><p>我暑假呢？</p><h3 id="day--1">【7.6】 Day -1</h3><p>我暑假呢？我暑假呢？</p><h3 id="day-0">【7.7】 Day 0</h3><p>我暑假呢？我暑假呢？我暑假呢？</p><h3 id="day-1">【7.8】 Day 1</h3><p>前一晚因为不可抗力没睡着。</p><p>唉，暑假结束了（？）</p><p>本来预定的是早上 7 点 10 分的校车，结果开窗一看下了很大的雨，倒霉！</p><p>干脆取消了改成 8 点的校车，好在雨停了，但我有衣服还没干，唉先上车再说。</p><p>到清水河了，脑浆都要颠出来了，体验最差的一次班车，还贼堵。</p><p>到宿舍了，怎么是 6 楼阿！累晕了，也气晕了。</p><p>光是上楼就满身汗，唉。</p><p>早上 10 点，有 yp 讲话。到了立人楼发现里面又挤又热，直接把凳子搬出来坐门边了。</p><p>刚坐出来，怎么专题开了鸭，看了一眼感觉都好难鸭qwq。</p><p>听 yp 讲零基础逆袭故事，有点自卑。</p><p>继续听，更自卑了。</p><p>下午的开盒环节提前了，要说自己有没有高中信息学基础。思索了一下，挺可笑的，参加了几次 csp 和 noip 结果只是稍微会写签到题，甚至不会写签到题的水平，这能叫有基础么。</p><p>于是说了零基础，但大家好像不是很理解我。</p><p>听 yp 讲暑假集训有多残酷，感觉要拿到 div.1 的资格我还差得远。</p><p>不知不觉真的讲了一个半小时，期间 lyc 还率先开卷。我把所有题都阅览了一遍，感觉都入手不能，遂放弃。</p><p>后面合照不知道为什么不拍了，商量了一下去朝阳吃午饭。</p><p>朝阳二楼吃的 ¥17 原汤五谷牛肉，淡而无味。而且这粉我吃不惯，不知道是不是地域原因，这种细而溜的像粉丝一样的东西能有啥味？不理解。</p><p>当时阿姨本来想多给一块牛肉，结果夹了三次夹不上她直接放弃了，可惜！</p><p>如果能打 1~5 星的话这玩意最多 2 星。</p><p>回宿舍吹空调，但只吹了 15 分钟，又要赶 1 点的车回沙河搬东西。烦死了。</p><p>不过好在这一来一回比上午那班车体验好多了，补了一点觉，但又感觉没补。</p><p>6 点，终于把行李搬上 6 楼了，虽然我带的行李应该是最少的，但这也太为难大胖子了。</p><p>床板质量令人堪忧，感觉一踩上去就会裂成几大块，不过铺上凉席之后感觉还行鸭。</p><p>7 点收到了波波王的果茶！好喝捏，幸福捏。</p><p>然后不知道干什么了，不知道是专题启动还是 tr 启动。</p><p>室友是不是都在学阿！</p><p>打成共识，开泰！</p><p>怎么群号被群主复读了，这下似摸Q了。</p><h3 id="day-2">【7.9】 Day 2</h3><p>8 点 05 准时起床，看了眼专题过题情况，大家都好努力。但不计一血，我也不急。</p><p>早餐没吃，感觉以后也没什么必要。</p><p>xcy 讲课，感觉 ppt 做的好认真鸭，出乎意料的除了势能分析都听懂了，虽然讲的是最基础的 kmp。</p><p>接着 lxy 讲课，我爆了，z 函数听不懂一点，上面板书也小小的看不清。讲到后面写的更小了，这我听集贸啊，就不听了。</p><p>翻了下 oiwiki，写的一般鸭，更加认真地看了看，还是放弃了，去翻洛谷题解了。</p><p>稍微会了点，果然有点图示会好很多。</p><p>提前下课！好也不好，外卖点了个 ¥20 的猪脚饭。时间还早，冒雨去便利店买了点物资，这便利店完爆沙河。</p><p>外卖被偷了。骑手找了半天，说一分钟前刚放。我不知道该说什么，到了清水河这边干啥都不顺，心态感觉不出几天就垮完了。</p><p>中午补了一下课件上提到的四题。</p><hr /><div class="note note-info">            <p>【CF1200E Compress Words】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个单词，需要依次合并他们，使得最终单词尽可能短。</p><p><span class="math inline">\(\sum|S|\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>需要尽可能短，那对于合并后的母串 <span class="math inline">\(S\)</span> 和待并入的子串 <span class="math inline">\(T\)</span>，要找到 <span class="math inline">\(S\)</span> 的最长后缀使之和 <span class="math inline">\(T\)</span> 相应长度的前缀等同。</p><p>不难发现所求即为 <span class="math inline">\(T + S\)</span> 的 border。</p><p>对于每一个串都要对 <span class="math inline">\(T+S\)</span> 做一次 KMP 是不能接受的，因为 <span class="math inline">\(S\)</span> 会随着合并越来越长。</p><p>由于我们只关心 border，所以只需要截取 <span class="math inline">\(S[\max(0,|S|-|T|),|S|]\)</span>。</p><p>故每回合用来跑 KMP 的串为 <span class="math inline">\(T + @ + S[\max(0,|S|-|T|),|S|]\)</span>。</p><p>中间的特殊字符是用来防止相交的，例如 <span class="math inline">\(S =aba\)</span>，<span class="math inline">\(T = aaba\)</span>，若使用 <span class="math inline">\(aabaaba\)</span>，border 是 <span class="math inline">\(4\)</span>，而 <span class="math inline">\(1\)</span> 是正确的，所以使用 <span class="math inline">\(aaba@aba\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;string ans = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">while</span> (n--) &#123;string s;cin &gt;&gt; s;string t = <span class="hljs-string">&quot; &quot;</span> + s + <span class="hljs-string">&quot;@&quot;</span> + ans.<span class="hljs-built_in">substr</span>(ans.<span class="hljs-built_in">size</span>() - <span class="hljs-built_in">min</span>(ans.<span class="hljs-built_in">size</span>(), s.<span class="hljs-built_in">size</span>()));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(t.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; t[i] != t[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (t[i] == t[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;&#125;ans += s.<span class="hljs-built_in">substr</span>(fail[t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P2375 [NOI2014] 动物园】</p><p>题意：求出一个 <span class="math inline">\(\text{num}\)</span> 数组，<span class="math inline">\(\text{num}[i]\)</span> 代表字符串 <span class="math inline">\(S[1,i]\)</span> 的子串中既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重合。</p><p><span class="math inline">\(1 \le |S| \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>暴力做法是跑 KMP，对每个 <span class="math inline">\(i\)</span> 跳 fail，找出所有的 border。跳了几次 <span class="math inline">\(\text{num[i]}\)</span> 就是多少。</p><p>不重叠也就是只把长度小于原串一半的 border 计入答案。</p><p>倍增优化，<span class="math inline">\(jp[i][j]\)</span> 代表字符串第 <span class="math inline">\(i\)</span> 个位置跳了 <span class="math inline">\(2^j\)</span> 次后的 border 长度。</p><p>时间复杂度 <span class="math inline">\(O(|S|\log |S|)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s;cin &gt;&gt; s;s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function">vector <span class="hljs-title">jp</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;jp[i][<span class="hljs-number">0</span>] = fail[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">25</span>; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;jp[i][j] = jp[ jp[i][j - <span class="hljs-number">1</span>] ][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x = i;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">24</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (jp[x][j] * <span class="hljs-number">2</span> &gt; i) &#123;x = jp[x][j];&#125;&#125;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">24</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (jp[x][j]) &#123;res += <span class="hljs-number">1LL</span> &lt;&lt; j;x = jp[x][j];&#125;&#125;ans *= (res + <span class="hljs-number">1</span>) % modp;ans %= modp;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>但这个跳了几次的问题在预处理时就能记录。</p><p>因为每转移一次相当于跳了的次数 <span class="math inline">\(+1\)</span>，假如更新了 <code>fail[i] = p</code>，那么直接 <code>num[i] = num[p] + 1</code> 即可。</p><p>不重叠同上处理，跳到长度符合要求为止。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s;cin &gt;&gt; s;s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n)</span>, <span class="hljs-title">num</span><span class="hljs-params">(n)</span></span>;num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;num[i] = num[p] + <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;<span class="hljs-keyword">while</span> (p * <span class="hljs-number">2</span> &gt; i) &#123;p = fail[p];&#125;ans *= (num[p] + <span class="hljs-number">1</span>) % modp;ans %= modp;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P3435 [POI2006] OKR-Periods of Words】</p><p>题意：给定字符串 <span class="math inline">\(S\)</span>，对于字符串 <span class="math inline">\(T\)</span>，称 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(S\)</span> 的周期当且仅当 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(S\)</span> 的真前缀且 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(T + T\)</span> 的前缀。</p><p>求给定 <span class="math inline">\(S\)</span> 的所有前缀的最大周期长度之和。</p><p><span class="math inline">\(1 \le |S| \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p><span class="math inline">\(S\)</span> 是 <span class="math inline">\(T+T\)</span> 的前缀可以理解为把 <span class="math inline">\(S\)</span> 的一个前缀复制一份之后能完全包含 <span class="math inline">\(S\)</span>。</p><p>设这个前缀为 <span class="math inline">\(S[1,i]\)</span>，那么 <span class="math inline">\(S[i+1,|S|]\)</span> 必然和 <span class="math inline">\(S[1,|S|-i]\)</span> 相等，即把前缀拿走之后剩余的部分必须是原串的一个 border。</p><p>这个前缀又要最长，那么就是最短 border。</p><p>根据 fail 数组的性质，一直跳到空串之前即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;string s;cin &gt;&gt; n &gt;&gt; s;s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> p = i;<span class="hljs-keyword">while</span> (fail[p]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (fail[i]) &#123;fail[i] = p;&#125;ans += i - p;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P5829 【模板】失配树】</p><p>题意：给定一个字符串 <span class="math inline">\(S\)</span>，<span class="math inline">\(m\)</span> 组询问。每次给定 <span class="math inline">\(p,q\)</span>，求 <span class="math inline">\(S\)</span> 的 <span class="math inline">\(p\)</span> 前缀和 <span class="math inline">\(q\)</span> 前缀的最长公共 border 的长度。</p><p><span class="math inline">\(1\le p,q\le |S| \le 10^6\)</span>，<span class="math inline">\(1\le m \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>fail 树，顾名思义就是连边 <span class="math inline">\(fail[i] \to i\)</span> 形成的树，不断往上跳父亲跳到根就能得到这个字符串所有的 border。</p><p>那题目所求相当于 fail 树上点 <span class="math inline">\(p\)</span> 和点 <span class="math inline">\(q\)</span> 的 <span class="math inline">\(\text{LCA}\)</span>。</p><p>特别注意：如果求出来的 <span class="math inline">\(\text{LCA}\)</span> 是 <span class="math inline">\(p\)</span> 或者 <span class="math inline">\(q\)</span>，那么还要往上跳一格，因为自己不是自己的 border。</p><p>时间复杂度 <span class="math inline">\(O(m\log |S|)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s;cin &gt;&gt; s;<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);adj[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;adj[fail[i]].<span class="hljs-built_in">push_back</span>(i);&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fa</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>, <span class="hljs-number">0</span>));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">depth</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;fa[x][<span class="hljs-number">0</span>] = fath;depth[x] = depth[fath] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= __lg(depth[x]) + <span class="hljs-number">1</span>; i++) &#123;fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y != fath) &#123;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span> (depth[x] &lt; depth[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;<span class="hljs-keyword">while</span> (depth[x] &gt; depth[y]) &#123;x = fa[x][__lg(depth[x] - depth[y])];&#125;<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(depth[x]); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i]) &#123;x = fa[x][i];y = fa[y][i];&#125;&#125;<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> m;cin &gt;&gt; m;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;<span class="hljs-type">int</span> res = <span class="hljs-built_in">LCA</span>(x, y);<span class="hljs-keyword">if</span> (res == x || res == y) &#123;res = fa[res][<span class="hljs-number">0</span>];&#125;cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>下午 QHJ 讲计算几何，没睡过，但雨一直下，走过去还要 20 分钟，摆！</p><p>看了看集训计划确认了每个专题第一节不点名，就呆在宿舍听了。</p><p>然后就后悔了，声音断断续续的，基本就是看 PPT。</p><p>怎么感觉都是套板子鸭，很符合我之前对计算几何的印象。</p><p>但我怎么例题都不会做鸭（</p><p>正好有一段声音几乎没了，估计是在黑板上涂涂写写，我听着也难受，就去做了两个 PPT 上的题。</p><p>感觉下午亏麻了鸭！</p><hr /><div class="note note-info">            <p>【2024 四川省赛】F. Isoball: 2D Version</p><p>题意：给定一个圆和一个平行坐标轴的矩形，现给定一组方向向量，该圆开始沿此方向运动，问是否存在一个时刻使得圆完全包含在给定矩形中。</p>          </div><div class="note note-success">            <p>当圆完全被矩形包含时，圆心到该矩形四条边的距离均 <span class="math inline">\(\ge r\)</span>。</p><p>那么我们可以把这个矩形的四条边向彼此均移动 <span class="math inline">\(r\)</span>，得到一个缩小版矩形。</p><p>此时只需要判断圆心是否在这个缩小版矩形中。</p><p>圆心的轨迹是一条射线，题目也转化为该射线是否和矩形的某一条边有交点。</p><p>射线求交即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    T x, y;    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;    <span class="hljs-keyword">operator</span> <span class="hljs-built_in">Point</span>&lt;U&gt;() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>&lt;U&gt;(<span class="hljs-built_in">U</span>(x), <span class="hljs-built_in">U</span>(y));    &#125;    Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;        x += p.x;        y += p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;        x -= p.x;        y -= p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;        x *= v;        y *= v;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a += b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a -= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;        <span class="hljs-keyword">return</span> a *= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;        <span class="hljs-keyword">return</span> b *= a;    &#125;    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;    Point&lt;T&gt; a, b;    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">lineIntersection</span><span class="hljs-params">(Line&lt;T&gt; l1, Line&lt;T&gt; l2)</span> </span>&#123;    <span class="hljs-keyword">return</span> l1.a + (l1.b - l1.a) * (<span class="hljs-built_in">cross</span>(l2.b - l2.a, l1.a - l2.a) / <span class="hljs-built_in">cross</span>(l2.b - l2.a, l1.a - l1.b));&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pointOnSegment</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">cross</span>(p - l.a, l.b - l.a) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">min</span>(l.a.x, l.b.x) &lt;= p.x &amp;&amp; p.x &lt;= <span class="hljs-built_in">max</span>(l.a.x, l.b.x)    &amp;&amp; <span class="hljs-built_in">min</span>(l.a.y, l.b.y) &lt;= p.y &amp;&amp; p.y &lt;= <span class="hljs-built_in">max</span>(l.a.y, l.b.y);&#125;<span class="hljs-comment">// 0 : not intersect</span><span class="hljs-comment">// 1 : strictly intersect</span><span class="hljs-comment">// 2 : overlap</span><span class="hljs-comment">// 3 : intersect at endpoint</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;tuple&lt;<span class="hljs-type">int</span>, Point&lt;T&gt;, Point&lt;T&gt;&gt; <span class="hljs-built_in">segmentIntersection</span>(Line&lt;T&gt; l1, Line&lt;T&gt; l2) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(l1.a.x, l1.b.x) &lt; <span class="hljs-built_in">min</span>(l2.a.x, l2.b.x)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(l1.a.x, l1.b.x) &gt; <span class="hljs-built_in">max</span>(l2.a.x, l2.b.x)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(l1.a.y, l1.b.y) &lt; <span class="hljs-built_in">min</span>(l2.a.y, l2.b.y)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(l1.a.y, l1.b.y) &gt; <span class="hljs-built_in">max</span>(l2.a.y, l2.b.y)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cross</span>(l1.b - l1.a, l2.b - l2.a) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cross</span>(l1.b - l1.a, l2.a - l1.a) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">auto</span> maxx1 = <span class="hljs-built_in">max</span>(l1.a.x, l1.b.x);            <span class="hljs-keyword">auto</span> minx1 = <span class="hljs-built_in">min</span>(l1.a.x, l1.b.x);            <span class="hljs-keyword">auto</span> maxy1 = <span class="hljs-built_in">max</span>(l1.a.y, l1.b.y);            <span class="hljs-keyword">auto</span> miny1 = <span class="hljs-built_in">min</span>(l1.a.y, l1.b.y);            <span class="hljs-keyword">auto</span> maxx2 = <span class="hljs-built_in">max</span>(l2.a.x, l2.b.x);            <span class="hljs-keyword">auto</span> minx2 = <span class="hljs-built_in">min</span>(l2.a.x, l2.b.x);            <span class="hljs-keyword">auto</span> maxy2 = <span class="hljs-built_in">max</span>(l2.a.y, l2.b.y);            <span class="hljs-keyword">auto</span> miny2 = <span class="hljs-built_in">min</span>(l2.a.y, l2.b.y);            <span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">p1</span><span class="hljs-params">(max(minx1, minx2), max(miny1, miny2))</span></span>;            <span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(min(maxx1, maxx2), min(maxy1, maxy2))</span></span>;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pointOnSegment</span>(p1, l1)) &#123;                <span class="hljs-built_in">swap</span>(p1.y, p2.y);            &#125;            <span class="hljs-keyword">if</span> (p1 == p2) &#123;                <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">3</span>, p1, p2&#125;;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">2</span>, p1, p2&#125;;            &#125;        &#125;    &#125;    <span class="hljs-keyword">auto</span> cp1 = <span class="hljs-built_in">cross</span>(l2.a - l1.a, l2.b - l1.a);    <span class="hljs-keyword">auto</span> cp2 = <span class="hljs-built_in">cross</span>(l2.a - l1.b, l2.b - l1.b);    <span class="hljs-keyword">auto</span> cp3 = <span class="hljs-built_in">cross</span>(l1.a - l2.a, l1.b - l2.a);    <span class="hljs-keyword">auto</span> cp4 = <span class="hljs-built_in">cross</span>(l1.a - l2.b, l1.b - l2.b);        <span class="hljs-keyword">if</span> ((cp1 &gt; <span class="hljs-number">0</span> &amp;&amp; cp2 &gt; <span class="hljs-number">0</span>) || (cp1 &lt; <span class="hljs-number">0</span> &amp;&amp; cp2 &lt; <span class="hljs-number">0</span>) || (cp3 &gt; <span class="hljs-number">0</span> &amp;&amp; cp4 &gt; <span class="hljs-number">0</span>) || (cp3 &lt; <span class="hljs-number">0</span> &amp;&amp; cp4 &lt; <span class="hljs-number">0</span>)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;        Point p = <span class="hljs-built_in">lineIntersection</span>(l1, l2);    <span class="hljs-keyword">if</span> (cp1 != <span class="hljs-number">0</span> &amp;&amp; cp2 != <span class="hljs-number">0</span> &amp;&amp; cp3 != <span class="hljs-number">0</span> &amp;&amp; cp4 != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, p, p&#125;;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">3</span>, p, p&#125;;    &#125;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">double</span> x, y, r, vx, vy;cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; vx &gt;&gt; vy;<span class="hljs-type">double</span> lx, ly, rx, ry;cin &gt;&gt; lx &gt;&gt; ly &gt;&gt; rx &gt;&gt; ry;lx += r;rx -= r;ly += r;ry -= r;<span class="hljs-keyword">if</span> (lx &gt; rx || ly &gt; ry) &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">double</span> mx = <span class="hljs-number">1e7</span>;<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(&#123;x, y&#125;, &#123;x + vx * mx, y + vy * mx&#125;)</span></span>;vector&lt;Line&lt;<span class="hljs-type">double</span>&gt;&gt; lines = &#123;&#123;&#123;lx, ly&#125;, &#123;rx, ly&#125;&#125;,&#123;&#123;rx, ly&#125;, &#123;rx, ry&#125;&#125;,&#123;&#123;rx, ry&#125;, &#123;lx, ry&#125;&#125;,&#123;&#123;lx, ry&#125;, &#123;lx, ly&#125;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> line : lines) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-built_in">segmentIntersection</span>(l, line)) &gt; <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>晚饭还是点外卖，一雪前耻。点了个 ¥27 的麻辣香锅，好吃捏好吃捏，分量也足，能有 4 星半（?）</p><p>专题还是不想做，动力全无。</p><p>研究了一下 PPT，本来想搞一套自己的板子，最后还是直接扒的 jiangly 的，因为哥哥写的代码实在是太好看了鸭。不过流传的版本缺失了很多内容，我照葫芦画瓢补了点上去。</p><p>专题有几题过了挺多人了，跟下榜？</p><p>十分钟写了个签到 pick 定理，然后坐了两小时牢。</p><p>菜输了，感觉还没到能徒手干专题的水平，先放着好了。</p><h3 id="day-3">【7.10】 Day 3</h3><p>起床，洗漱。</p><p>然后发现不对。</p><p>我趣，怎么我 8 点 05 的闹钟定成 7 点 05 了，太难崩了。</p><p>不知道舍友是不是被我吵醒了，脑子越来越不好使了，完蛋。</p><p>不想睡回笼觉，溜了一遍昨天学的 z 函数和 manacher。</p><p>到教室了，感觉今天讲的内容挺重要的，就坐在了前排。</p><p>结果中间想爆一下群巨被抓包了qwq。</p><p>徐神讲课还是讲得超级棒口牙，都听懂了（吗？）</p><p>甚至细到现写代码，好贴心鸭/se/se/se</p><p>后面 lxy 讲课一如既往的听不懂：讲序列自动机，嗯，开始听，讲完了？讲最小表示法，开始听，听不懂，讲完了？到 Lyndon 分解，讲完了？问我们听没听懂，此时的我 belike：<del>（数据删除）</del></p><p>中午想着要不要去图书馆借个词典，但懒了，希望下午不要伏笔回收。</p><p>又点了一次昨天那个麻辣香锅，只不过换了个口味，爽爽爽。</p><p>今天还是不想睡午觉，正好 xjj 问我第二次队内赛的 H，我想起那题之前我线段树优化建图被卡爆了，就稍微写了写。</p><p>对着题解搓了一发前后缀优化建图，直接 AC，爽！</p><hr /><div class="note note-info">            <p>【2024 - 暑假前集训队内赛 2 - H. 金铲铲，启动！】</p><p><a href="https://121-48-165-90.vpn.uestc.edu.cn:8118/contest/253/problem/H">Link</a></p>          </div><div class="note note-success">            <p>和图论专题 L 很类似，看题识 2sat，对于拥有小羁绊的奕子 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span>，有 <span class="math inline">\(u \lor v\)</span>。</p><p>而对于拥有相同大羁绊的奕子集合 <span class="math inline">\(s\)</span>，<span class="math inline">\(\forall x,y\in s\)</span>，<span class="math inline">\(\lnot x \lor \lnot y\)</span>。</p><p>可以线段树优化建图，每个集合中的第 <span class="math inline">\(i\)</span> 个点向第 <span class="math inline">\([1,i-1]\)</span> 和第 <span class="math inline">\([i+1,|s|]\)</span> 的点连边。</p><p>但这样连的边还是太多了，需要采用前后缀优化建图。</p><figure><img src="/image/academic/5.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>如图连边即可。第一次见到，很智慧。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        线段树优化建图    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf INT_MAX</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegEdge</span> &#123;<span class="hljs-type">int</span> n, K, all;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; id;<span class="hljs-built_in">SegEdge</span>() &#123;&#125;<span class="hljs-built_in">SegEdge</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;K = <span class="hljs-number">4</span> * n;all = <span class="hljs-number">8</span> * n;adj.<span class="hljs-built_in">resize</span>(all + <span class="hljs-number">1</span>);id.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;adj[id[i]].<span class="hljs-built_in">push_back</span>(&#123;id[i] + K, <span class="hljs-number">0</span>&#125;);adj[id[i] + K].<span class="hljs-built_in">push_back</span>(&#123;id[i], <span class="hljs-number">0</span>&#125;);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> id[l] = p, <span class="hljs-built_in">void</span>();adj[p].<span class="hljs-built_in">push_back</span>(&#123;p &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);adj[p].<span class="hljs-built_in">push_back</span>(&#123;p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);adj[(p &lt;&lt; <span class="hljs-number">1</span>) + K].<span class="hljs-built_in">push_back</span>(&#123;p + K, <span class="hljs-number">0</span>&#125;);adj[(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>) + K].<span class="hljs-built_in">push_back</span>(&#123;p + K, <span class="hljs-number">0</span>&#125;);<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> rx, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> opt)</span> </span>&#123;<span class="hljs-keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;<span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) adj[x + K].<span class="hljs-built_in">push_back</span>(&#123;p, w&#125;);<span class="hljs-keyword">else</span> adj[p + K].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (lx &lt;= mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, lx, rx, x, w, opt);<span class="hljs-keyword">if</span> (rx &gt; mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, lx, rx, x, w, opt);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtoP</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;adj[id[x] + K].<span class="hljs-built_in">push_back</span>(&#123;id[y], w&#125;);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtoS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> w)</span> </span>&#123;<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, id[x], w, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StoP</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> w)</span> </span>&#123;<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, id[x], w, <span class="hljs-number">2</span>);&#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoSat</span> &#123;<span class="hljs-type">int</span> n;<span class="hljs-built_in">TwoSat</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addbind</span><span class="hljs-params">(SegEdge &amp;seg, <span class="hljs-type">int</span> x, <span class="hljs-type">bool</span> ok1, <span class="hljs-type">int</span> y, <span class="hljs-type">bool</span> ok2)</span> </span>&#123;seg.<span class="hljs-built_in">PtoP</span>(x + n / <span class="hljs-number">8</span> * (!ok1), y + n / <span class="hljs-number">8</span> * ok2, <span class="hljs-number">1</span>);seg.<span class="hljs-built_in">PtoP</span>(y + n / <span class="hljs-number">8</span> * (!ok2), x + n / <span class="hljs-number">8</span> * ok1, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">(SegEdge &amp;seg)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x] = low[x] = ++tim;vis[x] = <span class="hljs-literal">true</span>;stack_[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : seg.adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span>&#123;now = stack_[top--];vis[now] = <span class="hljs-literal">false</span>;c[now] = cnt;&#125; <span class="hljs-keyword">while</span> (x != now);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / <span class="hljs-number">8</span>; i++) &#123;<span class="hljs-keyword">if</span> (c[seg.id[i]] == c[seg.id[i + n / <span class="hljs-number">8</span>]]) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[i] = &#123;x, i&#125;;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ys</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">R</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;R[a[i][<span class="hljs-number">0</span>]] = <span class="hljs-built_in">max</span>(R[a[i][<span class="hljs-number">0</span>]], i);ys[a[i][<span class="hljs-number">1</span>]] = i;&#125;<span class="hljs-function">SegEdge <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;<span class="hljs-function">TwoSat <span class="hljs-title">ts</span><span class="hljs-params">(<span class="hljs-number">8</span> * n)</span></span>;<span class="hljs-keyword">auto</span> Add = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;seg.<span class="hljs-built_in">PtoS</span>(x + n, l, r, <span class="hljs-number">1</span>);seg.<span class="hljs-built_in">StoP</span>(l + n, r + n, x, <span class="hljs-number">1</span>);&#125;;<span class="hljs-type">int</span> now = n;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (R[a[i][<span class="hljs-number">0</span>]] != i) &#123;<span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> r = R[a[i][<span class="hljs-number">0</span>]];<span class="hljs-built_in">Add</span>(i, l, r);&#125;&#125;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;x = ys[x];y = ys[y];ts.<span class="hljs-built_in">addbind</span>(seg, x, <span class="hljs-number">1</span>, y, <span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> ans = ts.<span class="hljs-built_in">work</span>(seg);<span class="hljs-keyword">if</span> (ans) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Teamfight Tactics\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Crown Legends: Battlefury\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// fre(test);</span>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        前后缀优化建图    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf INT_MAX</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoSat</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-built_in">TwoSat</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;adj.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);ans.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addbind</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">bool</span> ok1, <span class="hljs-type">int</span> y, <span class="hljs-type">bool</span> ok2)</span> </span>&#123;adj[x + n * (!ok1)].<span class="hljs-built_in">push_back</span>(y + n * ok2);adj[y + n * (!ok2)].<span class="hljs-built_in">push_back</span>(x + n * ok1);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x] = low[x] = ++tim;vis[x] = <span class="hljs-literal">true</span>;stack_[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span>&#123;now = stack_[top--];vis[now] = <span class="hljs-literal">false</span>;c[now] = cnt;scc[cnt].<span class="hljs-built_in">push_back</span>(now);&#125; <span class="hljs-keyword">while</span> (x != now);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (c[i] == c[i + n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;ans[i] = c[i] &gt; c[i + n] ? <span class="hljs-number">1ll</span> : <span class="hljs-number">0ll</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getans</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ans;&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(k + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];b[a[i]].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-function">TwoSat <span class="hljs-title">ts</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<span class="hljs-keyword">if</span> (b[i].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; b[i].<span class="hljs-built_in">size</span>(); j++) &#123;ts.adj[b[i][j] + <span class="hljs-number">2</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j] + <span class="hljs-number">3</span> * n);ts.adj[b[i][j] + n].<span class="hljs-built_in">push_back</span>(b[i][j]);<span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; b[i].<span class="hljs-built_in">size</span>()) &#123;ts.adj[b[i][j] + <span class="hljs-number">3</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j + <span class="hljs-number">1</span>] + <span class="hljs-number">3</span> * n);&#125;<span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;ts.adj[b[i][j] + n].<span class="hljs-built_in">push_back</span>(b[i][j - <span class="hljs-number">1</span>] + n);&#125;<span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; b[i].<span class="hljs-built_in">size</span>()) &#123;ts.adj[b[i][j] + <span class="hljs-number">3</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j + <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;ts.adj[b[i][j] + <span class="hljs-number">2</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j - <span class="hljs-number">1</span>] + n);&#125;&#125;&#125;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;ts.<span class="hljs-built_in">addbind</span>(x, <span class="hljs-number">1</span>, y, <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (ts.<span class="hljs-built_in">work</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Teamfight Tactics\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Crown Legends: Battlefury\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>下午队内赛，寄完了，3/10（Rank 5）</p><p>一开始随机开题，感觉 C 一眼，然后开始写，然后就不会写了，最后也没写出来。</p><p>F 题意挂了一个半小时，最后终于读懂了是 “开始和移动过程可能在同一个位置，最后不能在同一个位置，也就是一串连续的坐标，然后除了递增还可能是递减”。</p><p>E 题意至少读了 10 遍，还是搞不懂这题想求什么。我怎么感觉只有每个字符串的首字母有用，样例我也搞不懂。</p><p>挺唐的，赛时感觉很多题都能猜到是怎么做的，但写不出来。</p><p>菜。</p><hr /><p>晚饭在商业街吃了个炸鸡，一般，三星。</p><p>回到宿舍 emo 完洗完澡就 10 点了（？？？中间干了什么？？？）。</p><p>补了两题就过 12 点了，AC 自动机的例题还没看（</p><p>完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了。</p><hr /><div class="note note-info">            <p>【队内赛 1E - gym104022 K. Browser Games】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个字符串 <span class="math inline">\(\{s\}\)</span>，对于每个 <span class="math inline">\(i\in[1, n]\)</span> 回答最少用几个字符串组成字符串集 <span class="math inline">\(T\)</span>，才能使第 <span class="math inline">\(1\sim i\)</span> 个字符串在 <span class="math inline">\(T\)</span> 中都至少有一个前缀，且第 <span class="math inline">\(i + 1\sim n\)</span> 个字符串的所有前缀在 <span class="math inline">\(T\)</span> 中不存在。</p><p><span class="math inline">\(1 \le n \le 5\cdot 10^4\)</span>，<span class="math inline">\(|s| \le 50\)</span>，字符串含 <span class="math inline">\(a\sim z\)</span>，小数点和斜杠。</p>          </div><div class="note note-success">            <p>考虑增加了一个字符串，那么这个字符串在增加之前造成的限制消失了，消失了多少？</p><p>我们把字符串放到 trie 树上考虑，记录每个节点最近一次的访问来自于哪个字符串（<code>flag</code>）以及字符串末尾标记（<code>id</code>）。增加字符串 <span class="math inline">\(i\)</span> 时，可以从 <code>id[i]</code> 不断向上跳父亲，直到节点 <code>flag</code> 不为 <span class="math inline">\(i\)</span> 为止，目前这段链就是使得答案增加的罪魁祸首。</p><p>为了统计增加了多少，我们再为 trie 树上的每个节点引入标记 <code>cnt</code>。意为该节点确认作为 <span class="math inline">\(T\)</span> 中的一个答案：每次跳父亲之后，所在的满足 <code>flag</code> 不为 <code>i</code> 的节点就确认作为一个前缀，因此 <code>cnt++</code>；而每次答案也减少了这条链上的 <code>cnt</code> 个数。</p><p>时间复杂度 <span class="math inline">\(O(n|s|)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">28</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> fa, flag, cnt;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, flag&#123;<span class="hljs-number">-1</span>&#125;, cnt&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">Trie</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);t[<span class="hljs-number">1</span>].fa = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> i)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;x = <span class="hljs-number">26</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;x = <span class="hljs-number">27</span>;&#125; <span class="hljs-keyword">else</span> &#123;x = c - <span class="hljs-string">&#x27;a&#x27;</span>;&#125;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].fa = p;&#125;p = t[p].nxt[x];t[p].flag = i;&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].flag;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].cnt;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fa;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;Trie tr;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;cin &gt;&gt; s;id[i] = tr.<span class="hljs-built_in">add</span>(s, i);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> j = id[i];<span class="hljs-keyword">while</span> (i == tr.<span class="hljs-built_in">flag</span>(j)) &#123;res += tr.<span class="hljs-built_in">cnt</span>(j);j = tr.<span class="hljs-built_in">fa</span>(j);&#125;tr.t[j].cnt++;ans += <span class="hljs-number">1</span> - res;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// fre(test);</span>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><p>但它 MLE 了，所以还要提前 reserve 一下（唉，卡常。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">28</span>;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2.5e6</span> + <span class="hljs-number">2</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> fa, flag, cnt;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, flag&#123;<span class="hljs-number">-1</span>&#125;, cnt&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">Trie</span>() &#123;t.<span class="hljs-built_in">reserve</span>(N);t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);t[<span class="hljs-number">1</span>].fa = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> i)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;x = <span class="hljs-number">26</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;x = <span class="hljs-number">27</span>;&#125; <span class="hljs-keyword">else</span> &#123;x = c - <span class="hljs-string">&#x27;a&#x27;</span>;&#125;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].fa = p;&#125;p = t[p].nxt[x];t[p].flag = i;&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].flag;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].cnt;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fa;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;Trie tr;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;cin &gt;&gt; s;id[i] = tr.<span class="hljs-built_in">add</span>(s, i);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> j = id[i];<span class="hljs-keyword">while</span> (i == tr.<span class="hljs-built_in">flag</span>(j)) &#123;res += tr.<span class="hljs-built_in">cnt</span>(j);j = tr.<span class="hljs-built_in">fa</span>(j);&#125;tr.t[j].cnt++;ans += <span class="hljs-number">1</span> - res;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 1B - gym104022 B. The Great Wall】</p><p>题意：给定长为 <span class="math inline">\(n\)</span> 的数组，你需要将其划分为 <span class="math inline">\(k\)</span> 段，定义每段的权值为该段元素的极差，总权值为各段的权值和。对每个 <span class="math inline">\(k=1\sim n\)</span> 给出最大总权值。</p><p><span class="math inline">\(1 \le n \le 10^4\)</span>，<span class="math inline">\(1 \le a_i \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>妙妙题，第一步转化就十分 amazing。</p><p>一眼 dp，但每段的极差不好处理。不妨把极差转化为 <span class="math inline">\(\max(将该段一个数 \times 1，一个数 \times -1 后二者的和)\)</span>。</p><p>令 <span class="math inline">\(dp[i][j][k=0\sim3]\)</span> 表示处理了前 <span class="math inline">\(i\)</span> 个数，分成了 <span class="math inline">\(j\)</span> 段，且此时第 <span class="math inline">\(j\)</span> 段的状态为 <span class="math inline">\(k\)</span>。</p><ul><li><span class="math inline">\(k = 0\)</span>：既没有选 <span class="math inline">\(\times1\)</span> 的数，也没有选 <span class="math inline">\(\times -1\)</span> 的数。</li><li><span class="math inline">\(k = 1\)</span>：已经选了 <span class="math inline">\(\times -1\)</span> 的数，但没选 <span class="math inline">\(\times 1\)</span> 的数。</li><li><span class="math inline">\(k = 2\)</span>：已经选了 <span class="math inline">\(\times 1\)</span> 的数，但没选 <span class="math inline">\(\times -1\)</span> 的数。</li><li><span class="math inline">\(k = 3\)</span>：已经选了 <span class="math inline">\(\times 1\)</span> 的数，也选了 <span class="math inline">\(\times -1\)</span> 的数。</li></ul><p>这样就可以转移了，第一维可以滚动。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, vector(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, -inf)))</span></span>;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;t ^= <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;dp[t][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>],   dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);dp[t][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>],    dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + a[i],    dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] + a[i]&#125;);dp[t][j][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">2</span>],    dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - a[i],    dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] - a[i]&#125;);dp[t][j][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">3</span>],    dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>],    dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">2</span>] + a[i],    dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] - a[i]&#125;);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; dp[t][i][<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 1J - gym102920 H. Needle】</p><p>题意：有三条平行 <span class="math inline">\(x\)</span> 轴直线，直线上有缺口，三条直线上的缺口坐标分别给定为 <span class="math inline">\(\{a\},\{b\},\{c\}\)</span>，问有多少组三点共线。</p><p><span class="math inline">\(1 \le n_a,n_b,n_c \le 5\cdot 10^4\)</span>，<span class="math inline">\(-3\cdot10^4 \le a_i,b_i,c_i \le 3\cdot 10^4\)</span>。</p>          </div><div class="note note-success">            <p>结论：等效于求满足 <span class="math inline">\(a_i+c_k=2\cdot b_j\)</span> 的三元组 <span class="math inline">\((i, j, k)\)</span> 的数量。由中点性质易证。</p><p>移项，得 <span class="math inline">\(a_i - b_j = -c_k + b_j\)</span>。</p><p>将 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(-c_k\)</span> 存到 bitset 中，一个左移 <span class="math inline">\(b_j\)</span> 一个右移 <span class="math inline">\(b_j\)</span>，之后 <span class="math inline">\(\&amp;\)</span> 起来为 <span class="math inline">\(1\)</span> 的位置数目就是所求。</p><p>可以直接调用 bitset 中的 <code>count()</code> 函数，时间复杂度 <span class="math inline">\(O(\frac{n^2}{w})\)</span>。</p><p>注意负数，需要整体加一个数全变为正数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6e4</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> eps = <span class="hljs-number">3e4</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> A;cin &gt;&gt; A;bitset&lt;N&gt; a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= A; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[x + eps] = <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> B;cin &gt;&gt; B;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(B + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= B; i++) &#123;cin &gt;&gt; b[i];&#125;<span class="hljs-type">int</span> C;cin &gt;&gt; C;bitset&lt;N&gt; c;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= C; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;c[-x + eps] = <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= B; i++) &#123;<span class="hljs-keyword">if</span> (b[i] &gt; <span class="hljs-number">0</span>) &#123;ans += ( (a &gt;&gt; b[i]) &amp; (c &lt;&lt; b[i]) ).<span class="hljs-built_in">count</span>();&#125; <span class="hljs-keyword">else</span> &#123;ans += ( (a &lt;&lt; (-b[i]) ) &amp; (c &gt;&gt; (-b[i]) ) ).<span class="hljs-built_in">count</span>();&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>凌晨两点多了，AC 自动机的例题明天再说叭。</p><h3 id="day-4">【7.11】 Day 4</h3><p>被闹钟闹醒了，困困困，困困困。</p><p>上午听课，两个人讲课听起来都很舒服鸭，也不会很困。</p><p>一个是 lg，另一个是 QHJ 还是 pmh？昨天没来，不知道 QHJ 长啥样，不知道是谁。</p><p>凸包进阶那块感觉理解还差一点，计算几何我认为结合代码来学理论才能有更深的理解。</p><p>圆这部分同样，听能听懂，但代码就不知道怎么写了，后面还要自己摸索一下。</p><p>11 点不到就结束了。</p><p>中午在朝阳吃 ￥16 水煮牛肉，本来想打四星，但肉不过瘾，那就三星半。</p><p>回去没补例题，去做昨天队内赛的 C 了，一个多小时调不出来，红温了，睡了半小时。</p><hr /><p>下午队内赛2，我怎么又寄了。5/8（Rank 9）</p><p>开完两道究极签到，然后看了眼榜，有人过 D 了，就去看了 D，然后我怎么就看了一个半小时。</p><p>怎么大家都会 D，自闭了。一开始想的是也许构造一个 <span class="math inline">\(2 \times 2\)</span> 的就可以。然后脑子烧了，绕来绕去的。</p><p>过了一个小时才想到研究一下样例，感觉 <span class="math inline">\(2\times 3\)</span> 可行，就是从 <span class="math inline">\((1, 1)\)</span> 到 <span class="math inline">\((2,2)\)</span> 决策的时候选择错误的 <span class="math inline">\((2,1)\)</span> 而不是 <span class="math inline">\((1,2)\)</span>，但脑子又烧了。</p><p>看了下榜，怎么就到第二页了，急了。</p><p>去看了 E 和 F，E 马上能注意到满足条件的是一个矩形，但后面没想清楚就交，WA 了两发，不过马上就想清楚了。F 秒了。</p><p>直到这会稍微冷静了才会了 D，唉。</p><p>又急了，排名还是拉跨，看了下 C，但怎么只剩半小时了，乱交几发，不出意外过不了一点（</p><hr /><p>晚上￥26 炙烤蟹柳寿司，好吃，四星。</p><p>然后继续和昨天队内赛 C 搏斗，搏斗完怎么九点了？？？？？</p><p>一想到还有好多工作没做就难受。</p><hr /><div class="note note-info">            <p>【队内赛 1C - gym104022 D. Farm】</p><p>题意：给定一个 <span class="math inline">\(n\)</span> 个点的图，一开始没有边。再给定 <span class="math inline">\(m\)</span> 条边，边有边权，意为联通代价。你需要花最少的代价让图联通，同时必须满足 <span class="math inline">\(q\)</span> 个限制条件。第 <span class="math inline">\(i\)</span> 个条件形如从编号为 <span class="math inline">\(u_i\)</span> 和 <span class="math inline">\(v_i\)</span> 的边中至少选择一条。输出最小代价。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<span class="math inline">\(1 \le m \le 5 \cdot 10^5\)</span>，<span class="math inline">\(0 \le q\le 16\)</span>。</p>          </div><div class="note note-success">            <p>看 <span class="math inline">\(q\)</span> 范围知二进制枚举，此时直接枚举边做最小生成树，是 <span class="math inline">\(O(2^q \cdot q\cdot m\alpha)\)</span>。</p><p>瓶颈是枚举的边太多了，可以想象 <span class="math inline">\(q\)</span> 既然小，那么在最后的生成树中一定有很多边是确定的，不受限制条件的约束。</p><p>考虑将所有限制条件中的边（即每一个 <span class="math inline">\(u_i\)</span> 和每一个 <span class="math inline">\(v_i\)</span>）都建出来，然后跑最小生成树，此时新建出来的边（以下称作固定边）就是必须要选的。</p><p>那我们继续考虑一个只有固定边的新图 <span class="math inline">\(G\)</span>，此时需要枚举的边是 “两个端点在 <span class="math inline">\(G\)</span> 中不连通的边”。用一个可持久化并查集执行每次加边，到新的二进制状态就回退，能过吗？还是不能，因为边还是太多了，如果每一个孤立点都和其它所有点连边，就是 <span class="math inline">\(O(nq)\)</span> 的边。</p><p>但我们注意到除了孤立点以外的 <span class="math inline">\(G\)</span> 是一个大的连通块，我们用一个 <code>std::map</code> 存联通任意两个连通块的最小边，这样边数就是 <span class="math inline">\(O(q^2)\)</span> 的了。</p><p>时间复杂度 <span class="math inline">\(O(m\log m+2^q \cdot q^2)\)</span> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; ver;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<span class="hljs-built_in">iota</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);siz.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;ver.<span class="hljs-built_in">push_back</span>(&#123;x, y, siz[x]&#125;);siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">roll</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<span class="hljs-keyword">while</span> (ver.<span class="hljs-built_in">size</span>() &gt; v) &#123;<span class="hljs-keyword">auto</span> [x, y, szx] = ver.<span class="hljs-built_in">back</span>();ver.<span class="hljs-built_in">pop_back</span>();f[y] = y;siz[x] = szx;&#125;&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;a.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);&#125;<span class="hljs-type">int</span> q;cin &gt;&gt; q;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; choose;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">have_choosed</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;x--; y--;choose.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);have_choosed[x] = <span class="hljs-literal">true</span>;have_choosed[y] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-keyword">if</span> (have_choosed[i]) &#123;dsu.<span class="hljs-built_in">merge</span>(a[i][<span class="hljs-number">1</span>], a[i][<span class="hljs-number">2</span>]);&#125;&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; sorted_a = a;<span class="hljs-built_in">sort</span>(sorted_a.<span class="hljs-built_in">begin</span>(), sorted_a.<span class="hljs-built_in">end</span>());vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; must_choose;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : sorted_a) &#123;<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">merge</span>(x, y)) &#123;must_choose.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);&#125;&#125;<span class="hljs-function">DSU <span class="hljs-title">dsu2</span><span class="hljs-params">(n)</span></span>; <span class="hljs-type">int</span> ori_w = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : must_choose) &#123;dsu2.<span class="hljs-built_in">merge</span>(x, y);ori_w += w;&#125;<span class="hljs-type">int</span> ori_ver = dsu2.ver.<span class="hljs-built_in">size</span>(); map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; minw;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; waiting_choose;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : sorted_a) &#123;<span class="hljs-type">int</span> xx = dsu2.<span class="hljs-built_in">find</span>(x);<span class="hljs-type">int</span> yy = dsu2.<span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (xx == yy) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (!minw.<span class="hljs-built_in">count</span>(&#123;xx, yy&#125;)) &#123;minw[&#123;xx, yy&#125;] = minw[&#123;yy, xx&#125;] = w;waiting_choose.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);&#125;&#125;<span class="hljs-type">int</span> ans = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; q); i++) &#123;dsu2.<span class="hljs-built_in">roll</span>(ori_ver);<span class="hljs-type">int</span> res = ori_w;unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; q; j++) &#123;<span class="hljs-type">int</span> edge = choose[j][i &gt;&gt; j &amp; <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (mp[edge]) &#123;<span class="hljs-keyword">continue</span>;&#125;mp[edge] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">auto</span> [w, x, y] = a[edge];dsu2.<span class="hljs-built_in">merge</span>(x, y);res += w;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : waiting_choose) &#123;<span class="hljs-keyword">if</span> (dsu2.<span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) == n) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (dsu2.<span class="hljs-built_in">merge</span>(x, y)) &#123;res += w;&#125;&#125;<span class="hljs-keyword">if</span> (dsu2.<span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) == n) &#123;ans = <span class="hljs-built_in">min</span>(ans, res);&#125;&#125;<span class="hljs-keyword">if</span> (ans == inf) &#123;ans = <span class="hljs-number">-1</span>;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><p>今天的队内赛明天再补好了，明天又是字符串专题，上次字符串专题还没搞懂一点。</p><p>写了下 AC 自动机课件上的五个例题。</p><hr /><div class="note note-info">            <p>【P5357 【模板】AC 自动机】</p><p>题意：给定一个文本串 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(n\)</span> 个模式串 <span class="math inline">\(T_{1\sim n}\)</span>。求每个模式串在文本串中的出现次数。</p><p><span class="math inline">\(1 \le n,\sum|T| \le 2\cdot 10^5\)</span>，<span class="math inline">\(1\le |S| \le 2\cdot 10^6\)</span>。</p>          </div><div class="note note-success">            <p>AC 自动机上 fail 指针指向的是最长真后缀。fail 指针构成一棵树。</p><p>那么当一个节点被匹配时，其祖先也被匹配。相当于每次将根到某个单词末尾的一条链上的点 +1。</p><p>可以在树上维护 <code>sz[x]</code>，给 <span class="math inline">\(S\)</span> 对应的链上的点 <code>sz[x]++</code>。</p><p>那么单词末尾对应的节点的 <code>sz</code> 就是它在文本串中的出现次数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">26</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> len, fail;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : len&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">ACTree</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);t[<span class="hljs-number">0</span>].len = <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].len = t[p].len + <span class="hljs-number">1</span>;&#125;p = t[p].nxt[x];&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;t[x].nxt[i] = t[t[x].fail].nxt[i];&#125; <span class="hljs-keyword">else</span> &#123;t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fail;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].len;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;ACTree G;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;cin &gt;&gt; s;id[i] = G.<span class="hljs-built_in">add</span>(s);&#125;G.<span class="hljs-built_in">work</span>();string t;cin &gt;&gt; t;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-type">int</span> x = t[i] - <span class="hljs-string">&#x27;a&#x27;</span>;p = G.<span class="hljs-built_in">next</span>(p, x);sz[p]++;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);sz[x] += sz[y];&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cout &lt;&lt; sz[id[i]] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// fre(test);</span>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//</span></code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P3966 [TJOI2013] 单词】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个单词，对每个单词询问在这 <span class="math inline">\(n\)</span> 个单词组成的文章中出现了多少次。</p><p>例如给定 <code>a</code> <code>aa</code> <code>aaa</code>，则第二个单词出现了 <span class="math inline">\(3\)</span> 遍。</p><p><span class="math inline">\(1 \le n \le 200\)</span>，<span class="math inline">\(单词总长度 \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>看了样例才读明白题。</p><p>和 AC 自动机模板的区别就是单词之间不能跨越。</p><p>那我们直接在中间插一个特殊字符就行了，其它都一样。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">27</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> len, fail;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : len&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">ACTree</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);t[<span class="hljs-number">0</span>].len = <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].len = t[p].len + <span class="hljs-number">1</span>;&#125;p = t[p].nxt[x];&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;t[x].nxt[i] = t[t[x].fail].nxt[i];&#125; <span class="hljs-keyword">else</span> &#123;t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fail;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].len;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;string t = <span class="hljs-string">&quot;&quot;</span>;ACTree G;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;cin &gt;&gt; s;t += s + <span class="hljs-string">&quot;@&quot;</span>;id[i] = G.<span class="hljs-built_in">add</span>(s);&#125;G.<span class="hljs-built_in">work</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-type">int</span> x = t[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span> (t[i] == <span class="hljs-string">&#x27;@&#x27;</span>) &#123;x = <span class="hljs-number">26</span>;&#125;p = G.<span class="hljs-built_in">next</span>(p, x);sz[p]++;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);sz[x] += sz[y];&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cout &lt;&lt; sz[id[i]] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P2414 [NOI2011] 阿狸的打字机】</p><p>题意：给定一个含 <span class="math inline">\(a\sim z,B,P\)</span> 的字符串 <span class="math inline">\(T\)</span>，现按规则生成字符串集合 <span class="math inline">\(S\)</span>：</p><ul><li>有一个 Cache，初始为空，开始从左到右读取 <span class="math inline">\(T\)</span> 中字符。</li><li>若读取到 <span class="math inline">\(a\sim z\)</span>，在 Cache 中加入相应字符。</li><li>若读取到 <span class="math inline">\(P\)</span>，将 Cache 中的字符串拷贝一份到 <span class="math inline">\(S\)</span> 中。</li><li>若读取到 <span class="math inline">\(B\)</span>，删除 Cache 中最后一次加入的字符。</li></ul><p>给定 <span class="math inline">\(m\)</span> 个询问，每次给定 <span class="math inline">\(x, y\)</span>，询问 <span class="math inline">\(S\)</span> 中的第 <span class="math inline">\(x\)</span> 个字符串在第 <span class="math inline">\(y\)</span> 个字符串中出现了几次。</p><p><span class="math inline">\(1 \le x, y \le 10^5\)</span>，<span class="math inline">\(1 \le m \le 10^5\)</span>，<span class="math inline">\(1 \le |T| \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>暴力是对于每一个询问都建 AC 自动机并询问。</p><p>进阶一点可以对于相同的 <span class="math inline">\(y\)</span> 记录所有的 <span class="math inline">\(x\)</span>，这样是一次建树多次询问。</p><p>这里的 “建树” 是指给字符串 <span class="math inline">\(y\)</span> 在 fail 树上对应的链设置 <code>sz</code>。</p><p>还可以更聪明一点，我们思考 <span class="math inline">\(P\)</span> 操作和 <span class="math inline">\(B\)</span> 操作的本质：</p><ul><li><span class="math inline">\(P\)</span> 操作拷贝了一份 Cache，但迫于空间限制我们肯定不能显式储存，于是只储存该字符串的 endpos。</li><li><span class="math inline">\(B\)</span> 操作 “退格” 相当于将当前指针移动到父亲节点的位置。</li></ul><p>这样我们就可以像读取一般字符串一样读取 <span class="math inline">\(T\)</span> 了！</p><p>将 <span class="math inline">\(T\)</span> 放到 AC 自动机上跑，对于 <span class="math inline">\(a\sim z\)</span> 就直接 <code>sz[p]++</code>，删除操作就 <code>sz[p]--</code>。</p><p>对于询问，我们知道 endpos，相当于子树求和，而上一行的两个操作相当于单点加，就有用树状数组维护 <code>sz</code> 的思路了。对着 fail 树进行 dfs，记录 dfn 即可。</p><p>时间复杂度 <span class="math inline">\(O(|T|+m)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fenwick</span> &#123;<span class="hljs-type">int</span> n;vector&lt;T&gt; tr;<span class="hljs-built_in">Fenwick</span>() &#123;&#125;<span class="hljs-built_in">Fenwick</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;n = n;tr.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, (T)&#123;&#125;);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, T x)</span> </span>&#123;<span class="hljs-keyword">while</span> (pos &lt;= n) &#123;tr[pos] += x;pos += pos &amp; -pos;&#125;&#125;<span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;T res = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (pos) &#123;res += tr[pos];pos -= pos &amp; -pos;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>);&#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">26</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> fa, fail;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;vector&lt;<span class="hljs-type">int</span>&gt; endpos;<span class="hljs-built_in">ACTree</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;P&#x27;</span>) &#123;endpos.<span class="hljs-built_in">push_back</span>(p);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;p = t[p].fa;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].fa = p;&#125;p = t[p].nxt[x];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;t[x].nxt[i] = t[t[x].fail].nxt[i];&#125; <span class="hljs-keyword">else</span> &#123;t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fail;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fa;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string t;cin &gt;&gt; t;ACTree G;G.<span class="hljs-built_in">add</span>(t);G.<span class="hljs-built_in">work</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span>, <span class="hljs-title">dfn</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;dfn[x] = ++tim;sz[x] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);sz[x] += sz[y];&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);<span class="hljs-type">int</span> m;cin &gt;&gt; m;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">qry</span>(G.endpos.<span class="hljs-built_in">size</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;x--; y--;qry[y].<span class="hljs-built_in">push_back</span>(&#123;x, i&#125;);&#125;<span class="hljs-function">Fenwick&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fen</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>, tot = <span class="hljs-number">-1</span>, i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-keyword">if</span> (t[i] == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;fen.<span class="hljs-built_in">add</span>(dfn[p], <span class="hljs-number">-1</span>);p = G.<span class="hljs-built_in">fa</span>(p);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[i] != <span class="hljs-string">&#x27;P&#x27;</span>) &#123;p = G.<span class="hljs-built_in">next</span>(p, t[i] - <span class="hljs-string">&#x27;a&#x27;</span>);fen.<span class="hljs-built_in">add</span>(dfn[p], <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;tot++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [id, qid] : qry[tot]) &#123;<span class="hljs-type">int</span> x = G.endpos[id];ans[qid] = fen.<span class="hljs-built_in">query</span>(dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P2444 [POI2000] 病毒】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(01\)</span> 串，问是否存在一个无限长的 <span class="math inline">\(01\)</span> 串不包含任何一个给定的 <span class="math inline">\(01\)</span> 串作为子串。</p><p><span class="math inline">\(1 \le n \le 2000\)</span>，<span class="math inline">\(1\le \sum|S| \le 3\cdot 10^4\)</span>。</p>          </div><div class="note note-success">            <p>假定存在这么一个无限长的 <span class="math inline">\(01\)</span> 串，记作 <span class="math inline">\(T\)</span>。</p><p>那么把 <span class="math inline">\(T\)</span> 放到这 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(01\)</span> 串构成的 AC 自动机上跑，一定是不断失配，并且跳 fail 指针跳到的点不在任何 endpos 的子树中。</p><p>为此，我们把所有的 endpos 及其子树都标记为危险节点。具体的，bfs 构建 fail 指针的时候，如果 fail 指针指向的点（最长后缀）是危险节点，那么当前节点就标记为危险。</p><p>因为是无限，所以指针肯定是在一个不存在危险节点的环上绕圈。</p><p>在 next 指针上跑 dfs 找环即可，注意避开危险节点。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">2</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> end, fail;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : end&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">ACTree</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();&#125;p = t[p].nxt[x];&#125;t[p].end = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;t[x].nxt[i] = t[t[x].fail].nxt[i];&#125; <span class="hljs-keyword">else</span> &#123;t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];<span class="hljs-keyword">if</span> (t[t[t[x].nxt[i]].fail].end) &#123;t[t[x].nxt[i]].end = <span class="hljs-literal">true</span>;&#125;q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fail;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isend</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].end;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;ACTree G;<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; s[i];G.<span class="hljs-built_in">add</span>(s[i]);&#125;G.<span class="hljs-built_in">work</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(G.size())</span>, <span class="hljs-title">circle</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">int</span> &#123;circle[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : &#123;G.<span class="hljs-built_in">next</span>(x, <span class="hljs-number">0</span>), G.<span class="hljs-built_in">next</span>(x, <span class="hljs-number">1</span>)&#125;) &#123;<span class="hljs-keyword">if</span> (circle[y]) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (vis[y] || G.<span class="hljs-built_in">isend</span>(y)) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[y] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>(self, y)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;circle[x] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;TAK\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;NIE\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>还有一题，但是太难了，我先放着。</p><h3 id="day-5">【7.12】 Day 5</h3><p>醒了，下床，趴桌上继续睡。</p><p>上午按安排徐神讲后缀数组，包大爷讲后缀自动机。因为听起来就高级，我也没接触过，所以打起了十二分精神捏。</p><p>先讲后缀数组，刚开始听觉得很有道理，但怎么逐渐听不懂了。也不算逐渐，就徐神讲怎么从长度为 <span class="math inline">\(d\)</span> 扩展到长度为 <span class="math inline">\(2d\)</span> 的时候就懵了（</p><p>感觉再听听就懂了，就没问，结果一直懵，懵到最后我不好意思让徐神重新讲了QAQ。</p><p>我认为也许是后缀数组本身就很难不容易讲明白。</p><p>后面讲后缀自动机我状态就好多了，包大爷发音清晰思维缜密我坐第一排<del>看着它真是大帅辣</del>听它讲真是幸福捏。</p><p>中午朝阳￥15 可乐鸡饭，很牛啊，4 星。这个默认给你的饭很少，下次得向阿姨要多一点。</p><p>回到宿舍水了下群直接睡了。以往中午我都不怎么睡，但可能昨晚睡比较晚？</p><hr /><p>下午第三次队内赛，我怎么又白给了。4/8（Rank16）</p><p>一个小时开了 ABI，然后怎么 C 又坐牢了鸭。</p><p>不能算坐牢，这个是刚开始就有思路，但写了一坨还调不对（</p><p>wa5，wa6，wa10，tle61...</p><p>唉，没想清楚导致的。</p><p>D 红晕了，上手就搞了个 <span class="math inline">\(\text{dp[2][N]}\)</span>，我在写什么？？？？</p><p>赛后发现 D 和 F 都是 ez，前者一个 dfs，后者直接把差值扔进优先队列。<a href="https://codeforces.com/gym/535326/submission/270158995">Link-D</a> <a href="https://codeforces.com/gym/535326/submission/270160661">Link-F</a></p><p>这下遥遥落后了。</p><p>更自卑了。想似，就这样吧，说不定我的实力真的止于 div2C 了。</p><hr /><p>晚上没吃。</p><div class="note note-info">            <p>【队内赛 3E - CF406D. Hill Climbing】</p><p>题意：有 <span class="math inline">\(n\)</span> 座山，第 <span class="math inline">\(i\)</span> 座山山顶在 <span class="math inline">\((x_i,y_i)\)</span>。如果两个人站在两座山的山顶可以互相看到，则这两座山之间有绳子连接。有 <span class="math inline">\(m\)</span> 支队伍，每队有两个人，每个人都可以通过绳子到达直连的最右边的山顶。现给定每支队伍两个人初始所在的山的编号 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，问他们在哪座山的山顶相遇。</p><p><span class="math inline">\(1 \le n,m \le 10^5\)</span>，<span class="math inline">\(1 \le x_i \le10^7\)</span>，<span class="math inline">\(1 \le y_i \le 10^{11}\)</span>。</p>          </div><div class="note note-success">            <p>题图画的很清楚，因为选的是尽可能往后连的绳子，所以两个人通过绳子攀爬的路径都是凸的。</p><p>换言之，每座山选择向右到达的山的编号（*）是唯一的，连边能构成一棵树。</p><p>那么答案就是两个人所在点的 LCA。</p><p>（*）可以在求上凸包的过程中处理出来，即栈顶编号。</p><p>时间复杂度 <span class="math inline">\(O(n\log n+m\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    <span class="hljs-type">int</span> x, y;    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;&#125;;<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;    <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;&#125;Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(a.x + b.x, a.y + b.y);&#125;Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(a.x - b.x, a.y - b.y);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cross</span><span class="hljs-params">(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getUpHull</span><span class="hljs-params">(vector&lt;Point&gt; p)</span> </span>&#123;    <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">size</span>();    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n)</span></span>;    vector&lt;<span class="hljs-type">int</span>&gt; h;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;    <span class="hljs-keyword">while</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">cross</span>(p[i] - p[h.<span class="hljs-built_in">back</span>()], p[i] - p[h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]]) &gt; <span class="hljs-number">0</span>) &#123;            h.<span class="hljs-built_in">pop_back</span>();        &#125;        <span class="hljs-keyword">if</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;        nxt[i] = h.<span class="hljs-built_in">back</span>();        &#125; <span class="hljs-keyword">else</span> &#123;        nxt[i] = n - <span class="hljs-number">1</span>;        &#125;        h.<span class="hljs-built_in">push_back</span>(i);    &#125;    <span class="hljs-keyword">return</span> nxt;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;Point&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;a[i] = &#123;x, y&#125;;&#125;vector&lt;<span class="hljs-type">int</span>&gt; nxt = <span class="hljs-built_in">getUpHull</span>(a);vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;adj[nxt[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(i);&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fa</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>, <span class="hljs-number">0</span>));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;fa[x][<span class="hljs-number">0</span>] = fath;dep[x] = dep[fath] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= __lg(dep[x]) + <span class="hljs-number">1</span>; i++) &#123;fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y != fath) &#123;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;<span class="hljs-keyword">while</span> (dep[x] &gt; dep[y]) &#123;x = fa[x][__lg(dep[x] - dep[y])];&#125;<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(dep[x]); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i]) &#123;x = fa[x][i];y = fa[y][i];&#125;&#125;<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];&#125;;<span class="hljs-built_in">dfs</span>(dfs, n, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> m;cin &gt;&gt; m;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;cout &lt;&lt; <span class="hljs-built_in">LCA</span>(x, y) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>剩下一个 G，本来不想写的，但题解的做法让人称奇道妙。</p><p>但一个多小时了还有几处细节想不清楚，先欠着。</p><p>昨天的队内赛还没补，那就补两题。</p><hr /><div class="note note-info">            <p>【队内赛 2C - CF337D. Book of Evil】</p><p>题意：给定一棵 <span class="math inline">\(n\)</span> 个节点的树，树上有 <span class="math inline">\(m\)</span> 个关键点，点集设为 <span class="math inline">\(S\)</span>。再给定一个整数 <span class="math inline">\(d\)</span>，求满足 <span class="math inline">\(\forall i\in S,dis(x,i)\le d\)</span> 的节点 <span class="math inline">\(x\)</span> 的个数。</p><p><span class="math inline">\(1 \le m\le n\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>等价于对于每个点判断离它半径为 <span class="math inline">\(d\)</span> 的范围内是否有 <span class="math inline">\(m\)</span> 个关键点。</p><p>将关键点权值设为 <span class="math inline">\(1\)</span>，其余为 <span class="math inline">\(0\)</span>。就变成了以某个点为中心的范围权值和。</p><p>点分树即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mx = <span class="hljs-number">5e6</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;    <span class="hljs-type">int</span> sum;    Node *ch[<span class="hljs-number">2</span>];&#125; node[mx]; <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;    Node *rt;    <span class="hljs-built_in">SegmentTree</span>() &#123;    rt = <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-function">Node *<span class="hljs-title">New</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> &amp;node[cnt++];    &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node *&amp;p, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (!p) &#123;p = <span class="hljs-built_in">New</span>();&#125;<span class="hljs-keyword">if</span> (l == r) &#123;p-&gt;sum += val;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;<span class="hljs-built_in">add</span>(p-&gt;ch[<span class="hljs-number">0</span>], pos, val, l, mid);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">add</span>(p-&gt;ch[<span class="hljs-number">1</span>], pos, val, mid + <span class="hljs-number">1</span>, r);&#125;p-&gt;sum = (p-&gt;ch[<span class="hljs-number">0</span>] ? p-&gt;ch[<span class="hljs-number">0</span>]-&gt;sum : <span class="hljs-number">0</span>) +  (p-&gt;ch[<span class="hljs-number">1</span>] ? p-&gt;ch[<span class="hljs-number">1</span>]-&gt;sum : <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node *p, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (!p) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (l == ql &amp;&amp; r == qr) &#123;<span class="hljs-keyword">return</span> p-&gt;sum;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (qr &lt;= mid) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">0</span>], ql, qr, l, mid);&#125;<span class="hljs-keyword">if</span> (ql &gt; mid) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">1</span>], ql, qr, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">0</span>], ql, mid, l, mid) +    <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">1</span>], mid + <span class="hljs-number">1</span>, qr, mid + <span class="hljs-number">1</span>, r);&#125;;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, d;cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[x] = <span class="hljs-number">1</span>;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">st</span>(<span class="hljs-number">18</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">lg2</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;dep[x] = dep[fath] + <span class="hljs-number">1</span>;st[<span class="hljs-number">0</span>][++tim] = x;id[x] = tim;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y != fath) &#123;<span class="hljs-built_in">self</span>(self, y, x);st[<span class="hljs-number">0</span>][++tim] = x;&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> Lower = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">return</span> dep[x] &lt; dep[y] ? x : y;&#125;;<span class="hljs-keyword">auto</span> getST = [&amp;] () &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= tim; i++) &#123;lg2[i] = lg2[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= tim; i++) &#123;<span class="hljs-type">int</span> w = (<span class="hljs-number">1</span> &lt;&lt; i);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j + w - <span class="hljs-number">1</span> &lt;= tim; j++) &#123;st[i][j] = <span class="hljs-built_in">Lower</span>(st[i - <span class="hljs-number">1</span>][j], st[i - <span class="hljs-number">1</span>][j + w / <span class="hljs-number">2</span>]);&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;x = id[x];y = id[y];<span class="hljs-keyword">if</span> (x &gt; y) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;<span class="hljs-type">int</span> i = lg2[y - x + <span class="hljs-number">1</span>];<span class="hljs-keyword">return</span> <span class="hljs-built_in">Lower</span>(st[i][x], st[i][y - (<span class="hljs-number">1</span> &lt;&lt; i) + <span class="hljs-number">1</span>]);&#125;;<span class="hljs-keyword">auto</span> dist = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">return</span> dep[x] + dep[y] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">LCA</span>(x, y)];&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-built_in">getST</span>();<span class="hljs-type">int</span> all = n, rt = <span class="hljs-number">-1</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mx</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> getsz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;        sz[x] = <span class="hljs-number">1</span>;        mx[x] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;            <span class="hljs-keyword">if</span> (y == fa || vis[y]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-built_in">self</span>(self, y, x);            sz[x] += sz[y];            mx[x] = <span class="hljs-built_in">max</span>(mx[x], sz[y]);        &#125;        mx[x] = <span class="hljs-built_in">max</span>(mx[x], all - sz[x]);        <span class="hljs-keyword">if</span> (mx[x] &lt; mx[rt]) &#123;            rt = x;        &#125;    &#125;;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dsz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dfa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">auto</span> dfz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;    vis[x] = <span class="hljs-literal">true</span>;    dsz[x] = all;    dfa[x] = fa;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;    <span class="hljs-keyword">if</span> (y == fa || vis[y]) &#123;    <span class="hljs-keyword">continue</span>;    &#125;    all = sz[y];            mx[rt = <span class="hljs-number">0</span>] = inf;            <span class="hljs-built_in">getsz</span>(getsz, y, x);            <span class="hljs-built_in">getsz</span>(getsz, rt, <span class="hljs-number">0</span>);            <span class="hljs-built_in">self</span>(self, rt, x);    &#125;    &#125;;    mx[rt = <span class="hljs-number">0</span>] = inf;    <span class="hljs-built_in">getsz</span>(getsz, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">getsz</span>(getsz, rt, <span class="hljs-number">0</span>);    <span class="hljs-built_in">dfz</span>(dfz, rt, <span class="hljs-number">0</span>);    <span class="hljs-function">vector&lt;SegmentTree&gt; <span class="hljs-title">seg1</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">seg2</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">auto</span> Add = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val) -&gt; <span class="hljs-type">void</span> &#123;    <span class="hljs-type">int</span> now = x;    <span class="hljs-keyword">while</span> (now) &#123;    <span class="hljs-type">int</span> fa = dfa[now];    seg1[now].<span class="hljs-built_in">add</span>(seg1[now].rt, <span class="hljs-built_in">dist</span>(now, x), val, <span class="hljs-number">0</span>, dsz[now]);    <span class="hljs-keyword">if</span> (fa) &#123;    seg2[now].<span class="hljs-built_in">add</span>(seg2[now].rt, <span class="hljs-built_in">dist</span>(fa, x), val, <span class="hljs-number">0</span>, dsz[fa]);    &#125;    now = fa;    &#125;    &#125;;    <span class="hljs-keyword">auto</span> Query = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k) -&gt; <span class="hljs-type">int</span> &#123;    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> now = x, lst = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (now) &#123;    <span class="hljs-type">int</span> dt = <span class="hljs-built_in">dist</span>(now, x);    <span class="hljs-keyword">if</span> (dt &gt; k) &#123;    lst = now;    now = dfa[now];    <span class="hljs-keyword">continue</span>;    &#125;    res += seg1[now].<span class="hljs-built_in">query</span>(seg1[now].rt, <span class="hljs-number">0</span>, k - dt, <span class="hljs-number">0</span>, dsz[now]);    <span class="hljs-keyword">if</span> (lst) &#123;    res -= seg2[lst].<span class="hljs-built_in">query</span>(seg2[lst].rt, <span class="hljs-number">0</span>, k - dt, <span class="hljs-number">0</span>, dsz[now]);    &#125;    lst = now;    now = dfa[now];    &#125;    <span class="hljs-keyword">return</span> res;    &#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">if</span> (a[i]) <span class="hljs-built_in">Add</span>(i, a[i]);    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    ans += <span class="hljs-built_in">Query</span>(i, d) == m;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>但这题显然有更简单的结论做法。</p><p>类比树的直径的性质：距离树上任意一点最远的点一定是直径两个端点中的一个。</p><p>可以得到结论：距离树上任意一点最远的关键点一定是 “树上距离最远的两个关键点” 中的一个。</p><p>证明需要分类讨论，见 <a href="https://www.luogu.com.cn/article/bqixrrho">Link</a>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, d;cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">auto</span> getdis = [&amp;] (<span class="hljs-type">int</span> rt) &#123;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">dis</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;dis[x] = dis[fa] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;dis[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> dis;&#125;;vector&lt;<span class="hljs-type">int</span>&gt; dis1 = <span class="hljs-built_in">getdis</span>(<span class="hljs-number">1</span>);<span class="hljs-type">int</span> ml = <span class="hljs-number">0</span>, mr = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> mxdis = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<span class="hljs-keyword">if</span> (dis1[x] &gt; mxdis) &#123;mxdis = dis1[x];ml = x;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; dis2 = <span class="hljs-built_in">getdis</span>(ml);mxdis = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<span class="hljs-keyword">if</span> (dis2[x] &gt; mxdis) &#123;mxdis = dis2[x];mr = x;&#125;&#125;dis1 = <span class="hljs-built_in">getdis</span>(mr);<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (dis1[i] &lt;= d &amp;&amp; dis2[i] &lt;= d) &#123;ans++;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>上面两种方法一个写起来复杂，一个取巧，那么还有一个比较套路的换根 dp 做法。</p><p>我们钦定 <span class="math inline">\(i\)</span> 为根，定义 <span class="math inline">\(dp_{i,0/1}\)</span>。</p><ul><li><span class="math inline">\(dp_{i,0}\)</span> 代表 <span class="math inline">\(i\)</span> 离与它最远的关键点 <span class="math inline">\(j\)</span> 之间的距离，即最后答案。</li><li><span class="math inline">\(dp_{i,1}\)</span> 代表除 <span class="math inline">\(j\)</span> 所在的 <span class="math inline">\(i\)</span> 的子树外，与 <span class="math inline">\(i\)</span> 距离最远的关键点和 <span class="math inline">\(i\)</span> 之间的距离。</li></ul><p>第一次以 <span class="math inline">\(1\)</span> 为根进行 dfs，同时 <span class="math inline">\(fr_i\)</span> 记录 <span class="math inline">\(dp_{i,0}\)</span> 从哪个节点转移而来：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, -inf))</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">from</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (a[x]) &#123;dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);<span class="hljs-type">int</span> t = dp[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>] = t;from[x] = y;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = t;&#125;&#125;&#125;;</code></pre></div><p>此时的 <span class="math inline">\(dp_{i}\)</span> 从节点 <span class="math inline">\(1\)</span> 辐向 <span class="math inline">\(i\)</span> 的一侧拥有符合上述意义的答案。</p><p>考虑换根，从 <span class="math inline">\(fa\to x\)</span>，根据 <span class="math inline">\(fr_{fa}\)</span> 是否等于 <span class="math inline">\(x\)</span>，选择 <span class="math inline">\(dp_{fa,0}\)</span> 或 <span class="math inline">\(dp_{fa,1}\)</span> 进行转移。</p><p>记得此时更新 <span class="math inline">\(dp_{x,0}\)</span> 时也要同步更新 <span class="math inline">\(fr_x\)</span>。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">int</span> t;<span class="hljs-keyword">if</span> (from[fa] != x) &#123;t = dp[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;t = dp[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>] = t;from[x] = fa;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = t;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x); &#125;&#125;;</code></pre></div><p>不理解可以模拟一下题目的样例，以及将节点 <span class="math inline">\(4\)</span> 也变为关键点的情况。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, d;cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[x] = <span class="hljs-number">1</span>;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, -inf))</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">from</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (a[x]) &#123;dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);<span class="hljs-type">int</span> t = dp[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>] = t;from[x] = y;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = t;&#125;&#125;&#125;;<span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">int</span> t;<span class="hljs-keyword">if</span> (from[fa] != x) &#123;t = dp[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;t = dp[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>] = t;from[x] = fa;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = t;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x); &#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[<span class="hljs-number">1</span>]) &#123;<span class="hljs-built_in">dfs2</span>(dfs2, y, <span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (dp[i][<span class="hljs-number">0</span>] &lt;= d) &#123;ans++;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>还有一题但是点分树折磨了我两个小时，我要睡觉了。</p><p>骗自己罢了，不眠之夜。</p><h3 id="day-6">【7.13】 Day 6</h3><p>雨一直下。</p><h3 id="day-7">【7.14】 Day 7</h3><p>雨一直下。</p><p>晚上躺在床上突然想通了什么，伟大的一步。</p><p>晚上快 22 点多了才下床，笔记本充电器不知道去哪了，应该是在 234。骑车过去拿，但灯都黑了，无功而返，跟 xxx 借了一个。</p><p>0 点 35，vp 了昨天的 abc，6/7，G 把板子喂到嘴里了。</p><p>就 F 有点意思，写一下。</p><hr /><div class="note note-info">            <p>题意：给定一棵 <span class="math inline">\(n\)</span> 个点的树，定义 <span class="math inline">\(dis(x, y)\)</span> 为树上 <span class="math inline">\(x,y\)</span> 间的距离。有一个 <span class="math inline">\(n\)</span> 个点的完全图 <span class="math inline">\(G\)</span>，其中 <span class="math inline">\(w(x,y)=dis(x,y)\)</span>。求这个完全图的一个最大权匹配，输出匹配方案。</p><p><span class="math inline">\(2 \le n \le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>结论：令 <span class="math inline">\(c\)</span> 为树的重心，则满足以下条件的匹配 <span class="math inline">\(S\)</span> 为答案：</p><ul><li><span class="math inline">\(\forall (x_i,y_i)\in S\)</span>，<span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(y_i\)</span> 位于重心两侧。</li></ul>          </div><div class="note note-success">            <p>证明：拆贡献，令一条边两侧的点数为 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(n-a\)</span>，则该边的贡献为 <span class="math inline">\(\min(a,n-a)\)</span>。因为理想情况点少的这一侧的所有点都能跨过这条边寻找自己的匹配。那么答案的上界就是所有边的贡献和，即 <span class="math inline">\(\sum\min(a,n-a)\)</span>。</p><p>对于重心 <span class="math inline">\(c\)</span>，我们令 <span class="math inline">\(e\)</span> 为以 <span class="math inline">\(c\)</span> 为根的某个子树中的某一条边，此时 <span class="math inline">\(e\)</span> 的两侧中点比较少的一定是远离重心方向的这一侧。 按照我们的理论，这一侧的点只要跨越了这条边寻找匹配就成功了，此时它们匹配了重心另一侧的点，满足条件。</p><p>不难发现对于以 <span class="math inline">\(c\)</span> 为根的每一个子树中的所有边都满足上述条件，达到了贡献最大值，证毕。</p>          </div><div class="note note-success">            <p>于是我们可以进行如下构造：</p><ul><li>找到树的重心 <span class="math inline">\(c\)</span>，令 <span class="math inline">\(c\)</span> 的若干子树为 <span class="math inline">\(T_1,T_2,\cdots\)</span>。</li><li>令数组 <span class="math inline">\(A=\{T_1 中点的编号,T_2 中点的编号,\cdots\}\)</span>。</li><li>若 <span class="math inline">\(n\)</span> 为偶数，将 <span class="math inline">\(c\)</span> 补在 <span class="math inline">\(A\)</span> 的末尾。</li><li><span class="math inline">\(\forall i\in[0,\frac{n}{2})\)</span>，<span class="math inline">\((A_i,A_{i+\frac{n}{2}})\)</span> 为一个匹配。<span class="math inline">\((0-\text{index})\)</span></li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mx</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> rt = <span class="hljs-number">-1</span>;<span class="hljs-keyword">auto</span> getsz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;sz[x] = <span class="hljs-number">1</span>;mx[x] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);sz[x] += sz[y];mx[x] = <span class="hljs-built_in">max</span>(mx[x], sz[y]);&#125;mx[x] = <span class="hljs-built_in">max</span>(mx[x], n - sz[x]);<span class="hljs-keyword">if</span> (mx[x] &lt; mx[rt]) &#123;rt = x;&#125;&#125;;<span class="hljs-built_in">getsz</span>(getsz, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;a.<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;<span class="hljs-built_in">dfs</span>(dfs, x, rt);&#125;<span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;a.<span class="hljs-built_in">push_back</span>(rt);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[i + n / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="day-8">【7.15】 Day 8</h3><p>10 点 30 的闹钟，10 点 28 醒了，正好提前两分钟下床等着关闹钟（</p><p>中午大伙一起去朝阳吃饭，点了个￥16 叉烧鸡，很一般，两星半或者三星。</p><p>吃完到 234 打队内赛五。开始前几分钟发现 <code>solved 1 of 11</code>，很乐，截个图发到了群里，然后发现大伙怎么都做过。结果比赛开始就被菜猫换掉了，虽然没换掉也是当成新题做的说。</p><hr /><p>开局直接 A 上手，写着写着怎么不会了。看来以后写题还是得养成想好再动笔的习惯（后有伏笔</p><p>第一个小时开了四道签到，唉，爽！再看榜怎么大伙签得比我快这么多鸭。我主要是被那个字符串奇数位升序偶数位降序卡手了，后面灵机一动字母换成数字，然后偶数位取反。唉，差点就没签出来。</p><p>J 也是一眼，但怎么又开始 wa3，wa4 了。干脆直接跳转到 F，这不是龙数吗，咔咔咔一顿码，样例忒弱，疯狂提交，最好的结果是 tle6，自闭了。冷静分析了一下但感觉最多就是 2log，更何况还有神秘的势能分析加持，怎么会事呢？</p><p>那干脆再跳转到 E，哎呀这不是每个点向直连的编号最小点连边吗，怎么 wa9。红晕了。</p><p>中途发现 J 原来是有个 special 的情况，判掉就好了。E 又一通交，终于发现自己连最小生成树都不会写了（</p><p>B 过了一堆，但我不是很懂。I 也过了一堆，怎么大伙都会构造。</p><p>6/11（Rank 23）收尾，蒸蒸日下了。</p><hr /><p>晚上回朝阳吃了个可乐鸡饭。</p><p>回宿舍本来想着洗个澡就回 234 补题，但碰了床就想睡，就睡到了八点多。</p><p>洗完澡回到 234，补一题就差不多 CF 了。</p><hr /><div class="note note-info">            <p>【队内赛 5i. 唉，构造 - gym104160 F. Half Mixed】</p><p>题意：给定正整数 <span class="math inline">\(n,m\)</span>，你需要构造一个 <span class="math inline">\(n\times m\)</span> 的 <span class="math inline">\(01\)</span> 矩阵，使得纯子矩阵个数 <span class="math inline">\(=\)</span> 杂子矩阵个数。</p><p>纯子矩阵指内部只有 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span> 的矩阵。杂子矩阵指内部既有 <span class="math inline">\(0\)</span> 又有 <span class="math inline">\(1\)</span> 的矩阵。</p><p>输出构造方案或报告不存在。</p><p><span class="math inline">\(1\le n,m\le 10^6\)</span>，<span class="math inline">\(1\le \sum n\cdot m\le 5\cdot10^6\)</span>。</p>          </div><div class="note note-success">            <p>对于一个 <span class="math inline">\(1\times m\)</span> 的矩形，其子矩阵个数为 <span class="math inline">\(A=\dfrac{m(m + 1)}{2}\)</span>。</p><p>对于一个 <span class="math inline">\(n\times 1\)</span> 的矩形，其子矩阵个数为 <span class="math inline">\(B=\dfrac{n(n + 1)}{2}\)</span>。</p><p>乘法原理，对于 <span class="math inline">\(n\times m\)</span> 的矩形，子矩阵个数为 <span class="math inline">\(C=\dfrac{n(n + 1)}{2}\cdot\dfrac{m(m + 1)}{2}\)</span>。</p><p>那么，纯子矩阵个数 <span class="math inline">\(=\)</span> 杂子矩阵个数 <span class="math inline">\(= \dfrac{C}{2}\)</span>。若 <span class="math inline">\(C\)</span> 为奇数，无法构造。</p><p>否则，<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 至少有一个偶数，不妨令 <span class="math inline">\(A\)</span> 为偶数。根据乘法原理，如果我们能够构造一个拥有 <span class="math inline">\(\dfrac{A}{2}\)</span> 个纯子矩阵（杂子矩阵）的 <span class="math inline">\(1\times m\)</span> 的矩阵。复制 <span class="math inline">\(n\)</span> 份，总纯子矩阵个数就是 <span class="math inline">\(\dfrac{A}{2}\cdot B=\dfrac{C}{2}\)</span>，满足题意。</p><p>而这 <span class="math inline">\(1\times m\)</span> 的矩阵必然由若干 <span class="math inline">\(01\)</span> 段组成，设每段的长度为 <span class="math inline">\(d_i\)</span>，则需要构造 <span class="math inline">\(d_i\)</span> 满足：</p><ul><li><span class="math inline">\(\sum d_i=m\)</span></li><li><span class="math inline">\(\sum \dfrac{d_i(d_i+1)}{2}=\dfrac{A}{2}=\dfrac{m(m+1)}{4}\)</span></li></ul><p>按题解的说法此时贪心从大到小枚举 <span class="math inline">\(d_i\)</span>，就一定会有合适的取值，正确性我并没有想得很透彻。</p><p>我的做法是二分 <span class="math inline">\(d_i\)</span>，设二分出的 <span class="math inline">\(d_i=mid\)</span>，此时剩下 <span class="math inline">\(left-mid\)</span> 段，二式剩下 <span class="math inline">\(T\)</span>。假设每段独立，即 <span class="math inline">\(01010\cdots\)</span>，产生 <span class="math inline">\(left-mid\)</span> 的贡献。那么只要 <span class="math inline">\(\dfrac{mid(mid+1)}{2} \le T-(left-mid)\)</span> 就往更大的方向更新。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-type">int</span> all = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (all &amp; <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-type">bool</span> rev = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> ((n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">swap</span>(n, m);rev = <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> T = m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">4</span>, left = m;vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-keyword">while</span> (T) &#123;<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = left, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (mid * (mid + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;= T - (left - mid)) &#123;res = mid;l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;r = mid - <span class="hljs-number">1</span>;&#125;&#125;T -= res * (res + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;left -= res;a.<span class="hljs-built_in">push_back</span>(res);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> now = <span class="hljs-number">1</span>, ths = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;ths ^= <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now; i &lt;= now + x - <span class="hljs-number">1</span>; i++) &#123;ans[i] = ths;&#125;now += x;&#125;<span class="hljs-keyword">while</span> (now &lt;= m) &#123;ths ^= <span class="hljs-number">1</span>;ans[now] = ths;now++;&#125;<span class="hljs-keyword">if</span> (!rev) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;cout &lt;&lt; ans[j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m];&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; ans[j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>晚上打 CF，前三题基本都挺顺利的。</p><p>A 冷静了一分钟感觉直接用个 <code>std::multiset</code> 模拟就成，只要不把分离出的 <span class="math inline">\(1\)</span> 塞回去就不会很慢。（赛后发现就我最笨了）</p><p>B 注意到一段 <span class="math inline">\(0\)</span> 可以缩成一个 <span class="math inline">\(0\)</span>，<span class="math inline">\(1\)</span> 自然是越多越好，不用处理，最后比较 <span class="math inline">\(1\)</span> 的个数是否 <span class="math inline">\(&gt;\)</span> <span class="math inline">\(0\)</span> 的个数就行。</p><p>C 卡了 10 分钟，但很快把样例 <code>bitset</code> 输出了一下，就发现端倪了，每次只要 <span class="math inline">\(0\)</span> 的位次从高位向地位移动就行。</p><p>长度就是 <code>popcount(n) + 1</code>。</p><p>你说得对，但是：</p><div class="note note-warning">            <p><code>std::__builtin_popcount(S)</code> 不彳亍！</p><p><code>std::__builtin_popcountll(S)</code> 彳亍！</p>          </div><p>浪费了十分钟，警钟长鸣。</p><p>D 上手就写了个取两次取完所有点的，看了下榜发现 lyc 和 wbc 都瞬 wa 了，就发现不对劲。</p><p>思考了一下，三次取完所有点是不是就行了！很牛啊，写写写，唉，wa 了。</p><p>怎么会是呢，是不是要钦定若干条边 dp，看看第三次取哪些。</p><p>然后时间很快就过了，唉，好像三次不彳亍！唉，这下不牛了。</p><p>怎么大伙都过 D 了，又垫底了。</p><hr /><p>赛后发现这题有 2log，1log，甚至线性的做法，都写写看好了。</p><div class="note note-info">            <p>【CF1988 - D. The Omnipotent Monster Killer】</p><p>题意：给定一棵树，点有点权，意为将该点留下所需的代价。你可以分若干轮将这棵树的所有节点删空，要求每一轮次中，每条边两侧的顶点不能同时被删，每轮结束剩下的点结算代价。问将树删空的最小代价。</p><p><span class="math inline">\(1 \le n \le 3\cdot 10^5\)</span>，<span class="math inline">\(1 \le a_i \le 10^{12}\)</span>。</p>          </div><div class="note note-success">            <p>【solution - <span class="math inline">\(O(n\log^2n)/O(n\log n)\)</span>】</p><p>可以想象贪心必不优。同时猜测删空所需的轮数并不多，实际不超过 <span class="math inline">\(O(\log n)\)</span> 轮。</p><p>令 <span class="math inline">\(dp_{x, t}\)</span> 代表删空 <span class="math inline">\(x\)</span> 的子树，且在第 <span class="math inline">\(t\)</span> 轮删去 <span class="math inline">\(x\)</span> 的最小代价。</p><p>得到以下转移方程： <span class="math display">\[dp_{x,t}=\sum_{y\in son_x}\left(\min_{t&#39;\neq t}dp_{y, t&#39;}\right)+w_x\times(t+1)\]</span> 答案为 <span class="math inline">\(\min\limits_{i=1}^{\log_n} dp_{1,i}\)</span>。</p><p>暴力枚举 <span class="math inline">\(t\)</span> 和 <span class="math inline">\(t&#39;\)</span> 进行转移，时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><p>虽然 <span class="math inline">\(t&#39;=t\)</span> 不计入答案，但 <span class="math inline">\(t&#39;&lt;t\)</span> 和 <span class="math inline">\(t&#39; &gt; t\)</span> 计入答案。故记录前缀 <span class="math inline">\(\min\)</span> 和后缀 <span class="math inline">\(\min\)</span>，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        2log    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>))</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;dp[x][i] = (i + <span class="hljs-number">1</span>) * a[x];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<span class="hljs-type">int</span> mn = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">20</span>; j++) &#123;<span class="hljs-keyword">if</span> (i == j) &#123;<span class="hljs-keyword">continue</span>;&#125;mn = <span class="hljs-built_in">min</span>(mn, dp[y][j]);&#125;dp[x][i] += mn;&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);cout &lt;&lt; *<span class="hljs-built_in">min_element</span>(dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        1log    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>))</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;dp[x][i] = (i + <span class="hljs-number">1</span>) * a[x];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);pre[<span class="hljs-number">0</span>] = dp[y][<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;pre[i] = <span class="hljs-built_in">min</span>(pre[i - <span class="hljs-number">1</span>], dp[y][i]);&#125;suf[<span class="hljs-number">19</span>] = dp[y][<span class="hljs-number">19</span>];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">18</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;suf[i] = <span class="hljs-built_in">min</span>(suf[i + <span class="hljs-number">1</span>], dp[y][i]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<span class="hljs-type">int</span> t = inf;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;t = <span class="hljs-built_in">min</span>(t, pre[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">19</span>) &#123;t = <span class="hljs-built_in">min</span>(t, suf[i + <span class="hljs-number">1</span>]);&#125;dp[x][i] += t;&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);cout &lt;&lt; *<span class="hljs-built_in">min_element</span>(dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><p>线性我还不会，明日再补。</p><hr /><h3 id="day-9">【7.16】 Day 9</h3><p>10 点 35 被闹醒，下床继续睡到 11 点。</p><p>朝阳，￥15 烤肉饭两荤两素，感觉素菜和荤菜品种都不如沙河阳光餐厅。</p><p>烤肉饭就是烤肉饭的味道，本来是三星，但它那个鸡腿搞得挺好吃，三星半把。</p><p>预感到又是坐牢的一天呐米娜桑。</p><hr /><p>猜对了，继续蒸蒸日下。</p><p>先是 A 维护得一坨，再是两个半小时没做出 F，糖丸了。</p><p>赛后发现 <span class="math inline">\(n\)</span> 怎么是 <span class="math inline">\(5000\)</span> 鸭，下意识以为是 <span class="math inline">\(1e5\)</span> 之类的了。虽然正解也不是 <span class="math inline">\(O(n^2)\)</span> 的，但没准 <span class="math inline">\(O(n^2)\)</span> 就恰好会呢？呜呜。</p><p>被 F 红晕了，H 都没仔细看。赛后发现就是 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 互相问，十五分钟秒了（</p><p>菜，直接补题吧，没什么好说的。</p><hr /><div class="note note-info">            <p>【队内赛 6 - F. 迫近的客星 - CF370C. Mittens】</p><p>题意：给定一个 <span class="math inline">\(n\)</span> 个数的数组 <span class="math inline">\(\{a\}\)</span>，你需要寻找 <span class="math inline">\(\{a\}\)</span> 的一个排列 <span class="math inline">\(\{b\}\)</span>（指 <span class="math inline">\(\{b\}\)</span> 和 <span class="math inline">\(\{a\}\)</span> 仅有元素排列顺序不同） 使得满足 <span class="math inline">\(a_i \neq b_i\)</span> 的下标数量尽可能多。</p><p><span class="math inline">\(1 \le n \le 5000\)</span>，<span class="math inline">\(1 \le m \le 100\)</span>。</p>          </div><div class="note note-success">            <p>结论：将 <span class="math inline">\(\{a\}\)</span> 排序后右移 <span class="math inline">\(\dfrac{n}{2}\)</span> 再复原排序得到 <span class="math inline">\(\{b\}\)</span>。（该题只要求输出映射方案，不需要复原排序）</p><p>很智慧的构造，设 <span class="math inline">\(\{a\}\)</span> 排序之后最长连续段长度为 <span class="math inline">\(d\)</span>，分两种情况讨论：</p><ul><li><p>若 <span class="math inline">\(d \le \left\lfloor\dfrac{n}{2}\right\rfloor\)</span>，如下图。最长段（蓝色）可以错开，剩下的连续段长度都不超过 <span class="math inline">\(d\)</span>，因此可以用其它段（红色）补足空隙，此时上下两个数组就没有重合的地方了。</p><figure><img src="/image/academic/11.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li><li><p>考虑右移 <span class="math inline">\(\dfrac{n}{2}\)</span>，如下图。最长段显然不会重合，其它段用不同颜色进行了标明，意在说明若在空隙的地方（即 <span class="math inline">\(l_2\)</span> 右端）<span class="math inline">\(\{a\}\)</span>，<span class="math inline">\(\{b\}\)</span> 有重合，那么其他段的长度至少要从 <span class="math inline">\(l_1\)</span> 右端开始直到 <span class="math inline">\(l_2\)</span> 右端，长度 <span class="math inline">\(&gt; \dfrac{n}{2}\)</span>，与假设相悖。</p><figure><img src="/image/academic/12.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li><li><p>若 <span class="math inline">\(d &gt; \dfrac{n}{2}\)</span>，如下图。最长段（蓝色）已经不可避免地相交，剩下段（红色）不可能再重叠，因此最大匹配的下标数量为 <span class="math inline">\(n-d\)</span>。</p><figure><img src="/image/academic/13.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li><li><p>考虑右移 <span class="math inline">\(\dfrac{n}{2}\)</span>，如下图。因为右移之后蓝色段 <span class="math inline">\((&gt;\dfrac{n}{2})+\dfrac{n}{2}\to (&gt;n)\)</span> 必然超出右边界，因此剩下的区域仍然要么被 <span class="math inline">\(\{a\}\)</span> 的蓝色段覆盖，要么被 <span class="math inline">\(\{b\}\)</span> 的蓝色段覆盖，取到最大匹配。</p><figure><img src="/image/academic/14.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;ans += a[i] != a[(i + n / <span class="hljs-number">2</span>) % n];&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[(i + n / <span class="hljs-number">2</span>) % n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 6 - E. 辞行久远之躯 - CF1242B. 0-1 MST】</p><p>题意：给定一个包含 <span class="math inline">\(n\)</span> 个节点的完全图，以及图中的 <span class="math inline">\(m\)</span> 条长度为 <span class="math inline">\(1\)</span> 的边，其它边长度均为 <span class="math inline">\(0\)</span>。求该图最小生成树的权值。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<span class="math inline">\(1 \le m\le \min(\frac{n(n-1)}{2}, 10^5)\)</span>。</p>          </div><div class="note note-success">            <p>我们发现大部分的边都是 <span class="math inline">\(0\)</span> 边，换种说法如果只保留图上的 <span class="math inline">\(0\)</span> 边，之后只有少量的边需要我们连接。对于两个全 <span class="math inline">\(0\)</span> 连通块，若用一条 <span class="math inline">\(1\)</span> 边连接它们，那么这一大苟的连通块相当于拥有权值为 <span class="math inline">\(1\)</span> 的最小生成树。</p><p>同理，若该图全 <span class="math inline">\(0\)</span> 连通块的个数为 <span class="math inline">\(c\)</span>，那么需要用 <span class="math inline">\(c-1\)</span> 条 <span class="math inline">\(1\)</span> 边连接它们使整个图联通，这个图的最小生成树的权值自然就是 <span class="math inline">\(c-1\)</span>。</p><p>现在考虑求 <span class="math inline">\(c\)</span>。以下面的 <span class="math inline">\(K_4\)</span> 完全图（图A）为例：</p><figure><img src="/image/academic/21.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>其中红色虚边为 <span class="math inline">\(0\)</span> 边，绿色实边为 <span class="math inline">\(1\)</span> 边。我们按照编号顺序依次遍历 <span class="math inline">\(1\sim n\)</span>，关注连通块的变化。</p><p>一开始有节点 <span class="math inline">\(1\)</span>，全 <span class="math inline">\(0\)</span> 连通块默认为 <span class="math inline">\(1\)</span>。现在加进来节点 <span class="math inline">\(2\)</span>，如何判断全 <span class="math inline">\(0\)</span> 连通块个数是否增加？</p><p>要知道，<span class="math inline">\(0\)</span> 边数量是极多的，我们不能遍历 <span class="math inline">\(0\)</span> 边，我们能操作的只有 <span class="math inline">\(1\)</span> 边。那么遍历与 <span class="math inline">\(2\)</span> 相连的 <span class="math inline">\(1\)</span> 边，发现没有（目前只考虑节点 <span class="math inline">\(1,2\)</span> 构成的子图，所以连向右侧的 <span class="math inline">\(1\)</span> 边暂不考虑）。那么自然全是 <span class="math inline">\(0\)</span> 边，用并查集把 <span class="math inline">\(1,2\)</span> 连起来，全 <span class="math inline">\(0\)</span> 连通块个数不变。</p><p>现在加进来节点 <span class="math inline">\(3\)</span>，发现存在 <span class="math inline">\(1\)</span> 边 <span class="math inline">\((1,3)\)</span> 和 <span class="math inline">\((2,3)\)</span>。我们不妨用一个标记数组 <code>cnt</code> 标记一下，即对于 <span class="math inline">\(1\)</span> 边 <span class="math inline">\(x\to y(y &lt; x)\)</span> 有 <code>cnt[dsu.find(y)]++</code>。接着我们遍历先前的连通块，判断是否有连通块 <span class="math inline">\(x\)</span> 的大小 <code>dsu.size(x)</code> 比 <code>cnt[x]</code> 大。因为两个点之间不是 <span class="math inline">\(1\)</span> 边就是 <span class="math inline">\(0\)</span> 边，如果 <code>dsu.size(x)</code> 更大，说明向这个连通块连的边有 <span class="math inline">\(0\)</span> 边，进一步说明全 <span class="math inline">\(0\)</span> 连通块的个数没有增加，如下图（图B）。</p><figure><img src="/image/academic/22.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>该图满足 <code>dsu.size(1) = 2 &gt; cnt[1] = 1</code>。此时节点 <span class="math inline">\(3\)</span> 的加入不影响全 <span class="math inline">\(0\)</span> 连通块个数，直接用并查集并起来。</p><p>而图 A 则是 <code>dsu.size(1) = 2 &lt;= cnt[1] = 2</code>。此时全 <span class="math inline">\(0\)</span> 连通块个数 <span class="math inline">\(+1\)</span>。</p><p>现在会了怎么判断全 <span class="math inline">\(0\)</span> 连通块个数增加，那会不会减少呢？</p><figure><img src="/image/academic/23.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>这是添加节点 <span class="math inline">\(5\)</span> 之后的另一个例子，不难看出此时全 <span class="math inline">\(0\)</span> 连通块数量发生了 <span class="math inline">\(2\to 1\)</span> 的变化。</p><p>那我们动态维护这个数值就有点困难了。但我们只关心最后的结果：节点 <span class="math inline">\(5\)</span> 添加，老样子判断 <code>dsu.size(1) = 2 &gt; cnt[1] = 0</code> 且 <code>dsu.size(3) = 2 &gt; cnt[3] = 0</code>，就把 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(5\)</span>，<span class="math inline">\(3\)</span> 和 <span class="math inline">\(5\)</span> 所在的连通块并起来了。此时对于节点 <span class="math inline">\(1\sim 5\)</span>，恰有一个满足 <code>dsu.find(i) = i</code>。这启示我们最后的答案就是 <code>dsu.find(i) = i</code> 的节点的个数，不必动态维护连通块个数。</p><p>复杂度分析：对于每个节点，都有并或不并。合并显然最多 <span class="math inline">\(n\)</span> 次；而不合并，那么该节点至少和先前的连通块存在一条 <span class="math inline">\(1\)</span> 边，<span class="math inline">\(1\)</span> 边一共有 <span class="math inline">\(m\)</span> 条。因此是 <span class="math inline">\(O(n\alpha+m)\)</span> 的。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125; siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; rt;map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cnt.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[i]) &#123;<span class="hljs-keyword">if</span> (x &lt; i) &#123;cnt[dsu.<span class="hljs-built_in">find</span>(x)]++;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : rt) &#123;x = dsu.<span class="hljs-built_in">find</span>(x);<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">size</span>(x) &gt; cnt[x]) &#123;dsu.<span class="hljs-built_in">merge</span>(x, i);&#125;&#125;<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">find</span>(i) == i) &#123;rt.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ans += dsu.<span class="hljs-built_in">find</span>(i) == i;&#125;cout &lt;&lt; ans - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 6 - G. 我们终将重逢 - CF1117D. Magic Gems】</p><p>题意：有无数个魔法宝石，每个魔法宝石可以分解成 <span class="math inline">\(m\)</span> 个普通宝石，两种宝石都占据 <span class="math inline">\(1\)</span> 的空间，后者不能再被分解。问有多少种分解方案，可以使最后得到的宝石恰好占据 <span class="math inline">\(n\)</span> 个空间。两种分解方案不同当且仅当分解的魔法宝石数量不同，或者是所用宝石的编号不同。答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p><p><span class="math inline">\(1 \le n \le 10^{18}\)</span>，<span class="math inline">\(2 \le m \le 100\)</span>。</p>          </div><div class="note note-success">            <p>可以将题目概括为用若干个 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(0\)</span> 和若干个 <span class="math inline">\(1\)</span> 组成的长为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 串计数。</p><p>不妨令 <span class="math inline">\(f_i\)</span> 代表长为 <span class="math inline">\(i\)</span> 的这样的串的数目，则转移为： <span class="math display">\[f_i = \begin{cases}1&amp;, i &lt; m \\f_{i - 1} + f_{i - m}&amp;, \text{otherwise}\end{cases}\]</span> 意为可以在长为 <span class="math inline">\(i-1\)</span> 的串末尾加 <span class="math inline">\(1\)</span> 或长为 <span class="math inline">\(i-m\)</span> 的串末尾加 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(0\)</span> 来达到该状态。</p><p>取其中 <span class="math inline">\(f_i\)</span> 和 <span class="math inline">\(f_{i-m}\)</span>，列出在它们之间的转移式如下： <span class="math display">\[\begin{align}f_i = 1\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 1\cdot f_{i - m} \\f_{i-1} = 1\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\f_{i-2} = 0\cdot f_{i - 1}+1\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\f_{i-3} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 1\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\\vdots \\f_{i-m+2} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+1\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\f_{i-m+1} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 1\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\\end{align}\]</span> 取系数矩阵，得到可以用矩阵快速幂加速的转移形式： <span class="math display">\[\begin{bmatrix}f_i \\f_{i-1} \\\vdots \\f_{i-m+2} \\f_{i+m-1}\end{bmatrix}=\begin{bmatrix}1&amp; &amp; &amp; &amp; &amp;1\\1&amp; &amp; &amp; &amp; &amp; \\ &amp;1&amp; &amp; &amp; &amp; \\ &amp; &amp;\ddots&amp; &amp; &amp;\\ &amp; &amp; &amp;1&amp; &amp; \\ &amp; &amp; &amp; &amp;1&amp; \\\end{bmatrix}\begin{bmatrix}f_{i-1} \\f_{i-2} \\\vdots \\f_{i-m+1} \\f_{i-m}\end{bmatrix}\]</span> 时间复杂度 <span class="math inline">\(O(m^3\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span> &#123;<span class="hljs-type">int</span> n, m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(n), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)) &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)) &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, k)) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cin &gt;&gt; a[i][j];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(n, m); i++) &#123;a[i][i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function">matrix <span class="hljs-title">tp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(m, n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;z.a[j][i] = a[i][j];&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;&#125;;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> matrix &amp;x, <span class="hljs-type">const</span> matrix &amp;y) &#123;<span class="hljs-built_in">assert</span>(x.m == y.n);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(x.n, y.m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; x.m; k++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; y.m; j++) &#123;z.a[i][j] += x.a[i][k] * y.a[k][j] % modp;z.a[i][j] %= modp;&#125;&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function">matrix <span class="hljs-title">qpow</span><span class="hljs-params">(matrix a, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-built_in">assert</span>(a.n == a.m);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(a.n)</span></span>;z.<span class="hljs-built_in">build</span>();<span class="hljs-keyword">for</span> ( ; k; k &gt;&gt;= <span class="hljs-number">1</span>, a = a * a) &#123;<span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) z = z * a;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">if</span> (n &lt; m) &#123;cout &lt;&lt; <span class="hljs-string">&quot;1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function">matrix <span class="hljs-title">G</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;G.a[i + <span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;&#125;G.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;G.a[<span class="hljs-number">0</span>][m - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;matrix ans = <span class="hljs-built_in">qpow</span>(G, n - m + <span class="hljs-number">1</span>) * <span class="hljs-built_in">matrix</span>(m, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);cout &lt;&lt; ans.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="day-10">【7.17】 Day 10</h3><p>床起晚了，还下雨，直接赶到教室了。</p><p>上午徐神和包爷讲字符串专题。</p><p>虽然此前想象过，但事实是除了 C 这个签到之外其它题都没听懂 QAQ</p><p>甚至 C 的证明也没怎么懂，不知道会字符串的那帮人脑子是怎么转的。</p><p>慢慢来吧。</p><p>午饭外卖搞了个￥22 方便面炒鸡，肉给的很多，性价比在线，吃起来也香，四星半。</p><p>中午倒头就睡，一直在梦里的感觉真好鸭。</p><hr /><p>又到了悲闻哀见的队内赛时间。</p><p>开局 wa，难崩。</p><p>半小时开完三道签到，然后转向 C。一看就是分类讨论，这种题我一直捏不准，所以写的格外有条理。</p><p>大概写了二十来分钟，交！wa3！尼玛！果断拍！卧槽怎么十万组没拍出来！啊？</p><p>后面终于发现是最开始的特判错了！因为对拍很难拍无解我就略过了！唉，浪费了半小时左右。</p><p>然后看 B，啊？又是分类讨论？写！交！wa50！啊？？？？？？？？？？</p><p>不知道为什么刚刚 C 拍的这么果断我这时候又犹豫了，开始手动检查逻辑，不出意外没检查出来。</p><p>磨磨唧唧了半天才拍，结果一下就拍出来了，是一个非常细的地方。</p><p>这次竟然浪费了 40 分钟，尼玛的。那只剩 25 分钟看 H 那个构造了，思前想后感觉只能知道后 <span class="math inline">\(n-k+1\)</span> 个数和第 <span class="math inline">\(k\)</span> 个数的大小关系，不知道前 <span class="math inline">\(1\sim k-1\)</span> 个数。结束了，后面看了题解大呼智慧。</p><hr /><p>晚上和沙河的大伙一起去吃了 Kingburger！拼了鸡块和汉堡，我又搞了个 9.9 的 1+1，爽了。</p><p>味道不知道怎么评价，毕竟汉堡就是汉堡的味道，薯条就是薯条的味道，甜辣酱就是甜辣酱的味道。就好比在广西三品王就是三品王味，粉之都就是粉之都味一样，从小吃到大的东西，平时啥时候灵机一动就想吃，吃了上顿又不想吃下顿。</p><p>吃完和 xxx 回到基础实验大楼补题。</p><hr /><div class="note note-info">            <p>【队内赛 7 - H. 再多看一眼就会爆炸 - CF1720D. Strange Device】</p><p>题意：交互题。系统初始一个长为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(\{a\}\)</span>，保证所有元素互不相同。给定正整数 <span class="math inline">\(k\)</span>，你每次可以询问 <span class="math inline">\(k\)</span> 个不同的下标，系统会返回对应的 <span class="math inline">\(k\)</span> 个数中的第 <span class="math inline">\(m\)</span> 小的数的下标和值。最多可以询问 <span class="math inline">\(n\)</span> 次，需要让你猜出 <span class="math inline">\(m\)</span>。</p><p><span class="math inline">\(1 \le k &lt; n \le 500\)</span>，<span class="math inline">\(1 \le a_i \le 10^9\)</span>。保证 <span class="math inline">\(1 \le m \le k\)</span>。</p>          </div><div class="note note-success">            <p>据说有做法能只用下标而不用值，很牛。这里只说最简单的做法（不一定最容易想）</p><p>一种消耗 <span class="math inline">\(k+1\le n\)</span> 次询问的方案如下：</p><ul><li>只取前 <span class="math inline">\(k+1\)</span> 个数，其余部分可以扔掉。</li><li>第 <span class="math inline">\(i\)</span> 次询问序列：<span class="math inline">\([1,i-1]\land[i+1,k+1]\)</span>。</li><li>不难发现答案只会有两个值，分别是这 <span class="math inline">\(k+1\)</span> 个数的第 <span class="math inline">\(m\)</span> 小数和第 <span class="math inline">\(m+1\)</span> 小数。当去掉的数 <span class="math inline">\(a_i \le m\)</span> 时询问到的就是后者，否则前者。</li><li>那么第 <span class="math inline">\(m + 1\)</span> 小数被询问到的次数恰好是 <span class="math inline">\(m\)</span>。取这上述两个值中的较大者，出现次数就是答案。</li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;! 1&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">auto</span> query = [&amp;] (<span class="hljs-type">int</span> pos) -&gt; array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &#123;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">if</span> (i == pos) &#123;<span class="hljs-keyword">continue</span>;&#125;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-type">int</span> id, x;cin &gt;&gt; id &gt;&gt; x;<span class="hljs-keyword">return</span> &#123;id, x&#125;;&#125;;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(k + <span class="hljs-number">2</span>);map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) &#123;a[i] = <span class="hljs-built_in">query</span>(i);mp[a[i][<span class="hljs-number">1</span>]]++;&#125; <span class="hljs-type">int</span> ans;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, x] : mp) &#123;ans = x;&#125;cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 7 - D. 这种感觉我从未有 - CF1720D. Cut and Stick】</p><p>题意：给定长为 <span class="math inline">\(n\)</span> 的数组以及 <span class="math inline">\(q\)</span> 次询问。每次询问一个区间 <span class="math inline">\([l, r]\)</span>，问把该区间最少分为几个子序列，使每个子序列（设长度为 <span class="math inline">\(len\)</span>）众数的出现次数 <span class="math inline">\(\le \left\lceil\frac{len}{2}\right\rceil\)</span>。</p><p><span class="math inline">\(1\le n,q,a_i \le 3\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>设区间长度为 <span class="math inline">\(len\)</span>，众数的出现次数是 <span class="math inline">\(x\)</span>。若 <span class="math inline">\(x\le \left\lceil\frac{len}{2}\right\rceil\)</span>，答案是 <span class="math inline">\(1\)</span>。否则考虑分组，一种最优方案如下：</p><ul><li>其它非众数一共有 <span class="math inline">\(len-x\)</span> 个，将其与 <span class="math inline">\(len-x+1\)</span> 个众数组合，因为此时长度是奇数，故组合后的序列是合法的。</li><li>剩下的众数有 <span class="math inline">\(x-(len-x+1)=2x-len-1\)</span> 个，每个众数单独一组。</li><li>此时有了 <span class="math inline">\(2x-len\)</span> 组，可以证明这是最优的。</li></ul><p>证明就是此时划分成的每个子序列 "众数 <span class="math inline">\(-\)</span> 非众数" 都达到了最大值 <span class="math inline">\(1\)</span>，为最饱和的状态。</p><p>剩下的问题就变成了典题 “求区间众数个数“，常用莫队和主席树。</p><p>同时众数因为有比较强的数量特征，随机化取众数也是十分可行的。这在数据结构专题 <span class="math inline">\(L\)</span> 题有充分体现。</p><p>两种方法的时间复杂度分别是 <span class="math inline">\(O((n+q)\log n)\)</span> <span class="math inline">\(\text{and}\)</span> <span class="math inline">\(O(n+Aq\log n)\)</span>，<span class="math inline">\(A\)</span> 为常数。</p><p>我这里糅合<del>(懒)</del>了一下，写了个莫队 <span class="math inline">\(+\)</span> 随机化，<span class="math inline">\(O(q\log n+Aq\sqrt{n})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rand</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">rng</span>() % (r - l + <span class="hljs-number">1</span>) + l;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">qry</span>(q);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;qry[i] = &#123;l, r, i&#125;;&#125;<span class="hljs-type">int</span> sz = n / <span class="hljs-built_in">sqrtl</span>(<span class="hljs-number">1.0</span> * q * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>);<span class="hljs-built_in">sort</span>(qry.<span class="hljs-built_in">begin</span>(), qry.<span class="hljs-built_in">end</span>(), [&amp;] (array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; i, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; j) &#123; <span class="hljs-keyword">if</span> (i[<span class="hljs-number">0</span>] / sz == j[<span class="hljs-number">0</span>] / sz) &#123; <span class="hljs-keyword">if</span> ((i[<span class="hljs-number">0</span>] / sz) % <span class="hljs-number">2</span>) &#123; <span class="hljs-keyword">return</span> i[<span class="hljs-number">1</span>] &lt; j[<span class="hljs-number">1</span>]; &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> i[<span class="hljs-number">1</span>] &gt; j[<span class="hljs-number">1</span>]; &#125; &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> i[<span class="hljs-number">0</span>] / sz &lt; j[<span class="hljs-number">0</span>] / sz; &#125;&#125;) ;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> add = [&amp;] (<span class="hljs-type">int</span> x) &#123;cnt[a[x]]++;&#125;;<span class="hljs-keyword">auto</span> del = [&amp;] (<span class="hljs-type">int</span> x) &#123;cnt[a[x]]--;&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [ql, qr, id] : qry) &#123;<span class="hljs-keyword">while</span> (l &gt; ql) &#123;<span class="hljs-built_in">add</span>(--l);&#125;<span class="hljs-keyword">while</span> (l &lt; ql) &#123;<span class="hljs-built_in">del</span>(l++);&#125;<span class="hljs-keyword">while</span> (r &lt; qr) &#123;<span class="hljs-built_in">add</span>(++r);&#125;<span class="hljs-keyword">while</span> (r &gt; qr) &#123;<span class="hljs-built_in">del</span>(r--);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;<span class="hljs-type">int</span> pos = <span class="hljs-built_in">Rand</span>(l, r);<span class="hljs-keyword">if</span> (cnt[a[pos]] &gt; (r - l + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>) &#123;ans[id] = <span class="hljs-number">2</span> * cnt[a[pos]] - (r - l + <span class="hljs-number">1</span>);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (!ans[id]) &#123;ans[id] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="day-11">【7.18】 Day 11</h3><p>起床了吗？如起。</p><p>午饭没吃，起床直接传送到 234 了。</p><hr /><p>下午 5h 队内赛。</p><p>前面稳扎稳打，比赛不到一半开了 6 题，自我感觉还是不错的。</p><p>然后就急转直下了，后面都在杠 F，怎么大家都会做？</p><p>赛后发现原来是我刚看 F 就得出了一个错误的结论 ”边界四个角只能选一个“，因为数据范围比较小后面我就往二分想了。这也太蠢了。</p><p>但二分的话最密也只能压缩到 <span class="math inline">\(9\sim10\)</span> 次左右，红晕了。</p><p>最后半小时看了下榜随便开了个 K，看样例猜了个 BSGS，不出意料 wa2 了。</p><hr /><p>赛后 Vingying 讲题，思路很清晰鸭，甚至还有回放，爱了！期待下一次 vy 场OwO！</p><p>晚上跟 xxx 和 jbx 出去麦。</p><p>麦完回来又睡了，虽然很不情愿，一堆题没补，字符串也没看，但还是想打 CF 的时候能精神一点。</p><hr /><p>两个小时醒来 CF 继续唐！B 样例都没读懂代码就写完了，wa2 之后又搞到第 35 分钟才搞对。</p><p>C 一个简单 dp，也想了一个来小时。</p><p>剩半个小时，看了眼榜感觉 E 有希望，盲猜硬贪什么的。</p><p>结果把 xor 看成 or 了，完蛋。赛后发现是原，原题我还 AC 过，唐！</p><hr /><p>先从队内赛开始补，感觉 vy 选的题很有 edu 意义。CF 的题择日吧。</p><div class="note note-info">            <p>【队内赛 8 - C. ズッコケ問答 - gym103469E. Eulerian?】</p><p>题意：交互题。系统隐藏了一个 <span class="math inline">\(n\)</span> 个点的无向连通图 <span class="math inline">\(G\)</span>，保证没有重边和自环。</p><p>你可以进行至多 <span class="math inline">\(60\)</span> 次询问，每次询问 <span class="math inline">\(G\)</span> 中一个点集，系统会返回该点集构成的导出子图的边数。</p><p>你的目标是确定 <span class="math inline">\(G\)</span> 中是否存在一条欧拉回路。交互器不会自适应。</p><p><span class="math inline">\(3 \le n \le 10^4\)</span>，保证 <span class="math inline">\(G\)</span> 中边数不超过 <span class="math inline">\(10^5\)</span>。</p>          </div><div class="note note-success">            <p>交互器无法自适应（即 <span class="math inline">\(G\)</span> 不会随着询问而变化）提示我们采用随机化方法。</p><p>一个无向图存在欧拉回路的充要条件是所有顶点的度均为偶数。</p><p>我们考虑将 <span class="math inline">\(G\)</span> 中的顶点随机分成两个集合 <span class="math inline">\(A, B\)</span>。此时 <span class="math inline">\(G\)</span> 中的边被分成了三部分：在 <span class="math inline">\(A\)</span> 的导出子图中，在 <span class="math inline">\(B\)</span> 的导出子图之中，以及横跨在 <span class="math inline">\(A, B\)</span> 两个点集之间。</p><p>如果 <span class="math inline">\(A\)</span> 中的顶点的度均为偶数，那么 <span class="math inline">\(A\)</span> 中所有顶点的度数和也为偶数，又因为在 <span class="math inline">\(A\)</span> 中的边每条贡献 <span class="math inline">\(2\)</span> 的度数，不改变奇偶性，那么横跨在 <span class="math inline">\(A,B\)</span> 之间的边也应该是偶数条。</p><p>故有如下询问方案：</p><ul><li>消耗 <span class="math inline">\(1\)</span> 次询问所有的 <span class="math inline">\(n\)</span> 个点，得到 <span class="math inline">\(G\)</span> 的总边数。</li><li>重复 <span class="math inline">\(29\)</span> 次将 <span class="math inline">\(G\)</span> 随机划分成 <span class="math inline">\(A,B\)</span>。消耗 <span class="math inline">\(29\cdot2\)</span> 次分别询问 <span class="math inline">\(A,B\)</span> 导出子图中的边数，从而用总边数减去它们得到横跨边的数量。</li><li>若至少 <span class="math inline">\(1\)</span> 次询问到了 <span class="math inline">\(A,B\)</span> 间有奇数条横跨边，判定不存在欧拉回路；反之存在。</li></ul><p>正确性证明：横跨边数目为奇数或偶数各占 <span class="math inline">\(\frac{1}{2}\)</span> 概率，<span class="math inline">\(29\)</span> 次判定仍旧失败的概率为 <span class="math inline">\(\frac{1}{2^{29}}\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;cin &gt;&gt; m;<span class="hljs-type">int</span> test_case = <span class="hljs-number">29</span>;<span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (test_case--) &#123;vector&lt;<span class="hljs-type">int</span>&gt; A, B;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> o = <span class="hljs-built_in">rng</span>() % <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (o &gt; <span class="hljs-number">0</span>) &#123;A.<span class="hljs-built_in">push_back</span>(i);&#125; <span class="hljs-keyword">else</span> &#123;B.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; A.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : A) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-type">int</span> cnt1;cin &gt;&gt; cnt1;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; B.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : B) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-type">int</span> cnt2;cin &gt;&gt; cnt2;<span class="hljs-type">int</span> mid = m - cnt1 - cnt2;<span class="hljs-keyword">if</span> (mid &amp; <span class="hljs-number">1</span>) &#123;ok = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (ok) &#123;cout &lt;&lt; <span class="hljs-string">&quot;! YES&quot;</span> &lt;&lt; endl;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;! NO&quot;</span> &lt;&lt; endl;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 8 - K. 世界のまん中 - gym103469F. Fancy Formulas】</p><p>题意：给定一个质数 <span class="math inline">\(p\)</span>，以及 <span class="math inline">\(q\)</span> 组询问。每次给定两个二元组 <span class="math inline">\((a,b)\)</span> 和 <span class="math inline">\((c,d)\)</span>，保证 <span class="math inline">\(p\nmid (a+b)\)</span>。</p><p>一次操作可以选择如下其一，你可以无限次操作。问是否能将 <span class="math inline">\((a,b)\)</span> 转化为 <span class="math inline">\((c,d)\)</span>。</p><ul><li><span class="math inline">\((a,b):=(2a\bmod p, (b+p-a)\bmod p)\)</span></li><li><span class="math inline">\((a, b):=((a+p-b)\bmod p, 2b\bmod p)\)</span></li></ul><p><span class="math inline">\(2 \le p \le 10^9+7\)</span>，<span class="math inline">\(1\le q\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>无论那种操作，操作后的 <span class="math inline">\((a, b)\)</span> 均满足 <span class="math inline">\(s=(a+b)\bmod p\)</span> 不变。</p><p>那么知道 <span class="math inline">\((a,b)\)</span> 中的 <span class="math inline">\(a\)</span> 或 <span class="math inline">\(b\)</span>，另一个也同时确定，<span class="math inline">\((c,d)\)</span> 同理。</p><p>于是不妨将问题转化为：每次将一个整数 <span class="math inline">\(a\)</span> 进行 <span class="math inline">\(a:=2a\)</span> 或 <span class="math inline">\(a:= a-b\)</span> 的操作，能否将 <span class="math inline">\(a\to c\)</span>。</p><p>而 <span class="math inline">\(a:=a-b \Leftrightarrow a:=a-(s-a)\)</span>。即 <span class="math inline">\(a:=2a-s\)</span>。</p><p>但有 <span class="math inline">\(s\)</span> 在仍旧不好处理，考虑给 <span class="math inline">\(a,c\)</span> 都乘上 <span class="math inline">\(s^{-1}\)</span>，此时满足 <span class="math inline">\((a+b)\bmod p = 1\)</span>。</p><p>问题再次转化为每次将一个整数 <span class="math inline">\(a\)</span> 进行 <span class="math inline">\(a:=2a\)</span> 或 <span class="math inline">\(a:=2a-1\)</span> 的操作，能否将 <span class="math inline">\(a\to c\)</span>。</p><p>这样就变成了单变量问题。注意到对 <span class="math inline">\(a\)</span> 进行 <span class="math inline">\(k\)</span> 次操作后得到的数一定在一个区间范围内连续分布，具体的，是 <span class="math inline">\([2^ka-(2^k-1), 2^ka]\)</span>。而当 <span class="math inline">\(k &gt; 30\)</span> 的时候，这个区间的长度会 <span class="math inline">\(\ge p\)</span>，意味着在 <span class="math inline">\(\bmod p\)</span> 意义下拥有 <span class="math inline">\(0\sim p-1\)</span> 中的所有取值，就一定能找到和 <span class="math inline">\(c\bmod p\)</span> 同余的数。</p><p>于是直接枚举 <span class="math inline">\(k\)</span>，当值域区间内第一次存在和 <span class="math inline">\(c\)</span> 同余的数时，对应的 <span class="math inline">\(k\)</span> 就是答案。</p><p>时间复杂度 <span class="math inline">\(O(q\log p)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % p) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % p;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> p, q;cin &gt;&gt; p &gt;&gt; q;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> a, b, c, d;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<span class="hljs-keyword">if</span> ((a + b) % p != (c + d) % p) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> s = (a + b) % p;a = a * <span class="hljs-built_in">qpow</span>(s, p - <span class="hljs-number">2</span>, p) % p;c = c * <span class="hljs-built_in">qpow</span>(s, p - <span class="hljs-number">2</span>, p) % p;<span class="hljs-keyword">if</span> (a == c) &#123;cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> cover = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, l = a, r = a; ; i++) &#123;l = l * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;r = r * <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span>) &#123;l = p - <span class="hljs-number">1</span>;r = p;&#125;<span class="hljs-type">int</span> len = r - l + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (len &gt;= p) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-type">int</span> lp = l % p;<span class="hljs-type">int</span> rp = r % p;<span class="hljs-keyword">if</span> (lp &lt;= rp &amp;&amp; lp &lt;= c &amp;&amp; c &lt;= rp) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (lp &gt; rp &amp;&amp; (c &gt;= lp || c &lt;= rp)) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 8 - G. 名前をつけてやる - gym102471H. King】</p><p>题意：给定一个质数 <span class="math inline">\(p\)</span>。一个长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span> 被称作 good，当且仅当 <span class="math inline">\(\exists q\in[1,p), \forall i \in[2, n], qa_{i-1}\equiv a_i \pmod{p}\)</span>。</p><p>给定一个序列 <span class="math inline">\(\{b\}\)</span>，设其最长的 good 子序列长度为 <span class="math inline">\(len\)</span>。若 <span class="math inline">\(len \ge \frac{n}{2}\)</span> 输出 <span class="math inline">\(len\)</span>；否则输出 <span class="math inline">\(-1\)</span>。</p><p><span class="math inline">\(2 \le n \le 2 \cdot 10^5\)</span>，<span class="math inline">\(2 \le p \le 10^9+7\)</span>。</p>          </div><div class="note note-success">            <p>题目中 <span class="math inline">\(len \ge \frac{n}{2}\)</span> 其实是一个随机化暗示。这意味着组成该子序列的元素在原序列中分布的十分密集。</p><p>如果 <span class="math inline">\(n\)</span> 为奇数，那么至少存在一对相邻的数，它们的比值正好是公比（鸽笼原理）。</p><p>如果 <span class="math inline">\(n\)</span> 为偶数，极限情况也是 <span class="math inline">\(\text{xoxoxoxo}\)</span>（<span class="math inline">\(\text{x}\)</span> 代表出现在最长的 good 子序列中），此时正好占到总长度的 <span class="math inline">\(\frac{1}{2}\)</span>。</p><p>那么我们可以进行以下操作若干次以得到正确答案：</p><ul><li>从 <span class="math inline">\(\{b\}\)</span> 中随机选一对数 <span class="math inline">\((x, y)\)</span>，满足 <span class="math inline">\(y = x + 1\)</span> or <span class="math inline">\(y = x + 2\)</span>。</li><li>令公比为 <span class="math inline">\(\dfrac{b_y}{b_x}\)</span>，向 <span class="math inline">\(x\)</span> 左侧和 <span class="math inline">\(y\)</span> 右侧拓展得到满足该公比的最长 good 序列，设长度为 <span class="math inline">\(m\)</span>。</li><li>若 <span class="math inline">\(2 \cdot m \ge n\)</span>，更新答案。</li></ul><p>正确性证明：不是很会，但显然失败概率极低。实际取 <span class="math inline">\(50\)</span> 次左右就能 AC 了。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rand</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">rng</span>() % (r - l + <span class="hljs-number">1</span>) + l;&#125;<span class="hljs-type">int</span> modp;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n &gt;&gt; modp;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">inv</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; b[i];inv[i] = <span class="hljs-built_in">qpow</span>(b[i], modp - <span class="hljs-number">2</span>);&#125;<span class="hljs-type">int</span> test_case = <span class="hljs-number">50</span>;<span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (test_case--) &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">Rand</span>(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : &#123;x + <span class="hljs-number">1</span>, x + <span class="hljs-number">2</span>&#125;) &#123;<span class="hljs-keyword">if</span> (y &gt; n) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> d = b[y] * inv[x] % modp;<span class="hljs-type">int</span> res = <span class="hljs-number">2</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = y + <span class="hljs-number">1</span>, lst = y; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (b[i] * inv[lst] % modp == d) &#123;res++;lst = i;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x - <span class="hljs-number">1</span>, lst = x; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-keyword">if</span> (b[lst] * inv[i] % modp == d) &#123;res++;lst = i;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * res &gt;= n) &#123;ans = <span class="hljs-built_in">max</span>(ans, res);&#125;&#125; &#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 8 - J. ワンターフォゲール - gym102992D. Degree of Spanning Tree】</p><p>题意：给你一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向图，你需要找到它的一个生成树，满足所有节点度数 <span class="math inline">\(\le \frac{n}{2}\)</span>。</p><p><span class="math inline">\(2 \le n \le 10^5\)</span>，<span class="math inline">\(n - 1\le m\le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>有正常做法，也有随机化做法，这里叙述后者。</p><p>我们先将所有边都连起来，尝试 dfs 找到一棵符合要求的生成树。</p><p>重复以下过程若干次：</p><ul><li>随机一个起点，开始 dfs。</li><li>每到一个未经过的点 <span class="math inline">\(x\)</span>，将 <span class="math inline">\(x\)</span> 的邻接边序列 shuffle 一遍。</li><li>遍历邻接边序列，在 <span class="math inline">\(x\)</span> 不超度数的情况下能连边就连边，递归到点 <span class="math inline">\(y\)</span>。</li><li>若遍历完所有点即找到一个连边方案。</li></ul><p>实测 <span class="math inline">\(50\)</span> 次就能 AC。正确性最不好证明的一集。</p><p>时间复杂度 <span class="math inline">\(O(50n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; ans;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-built_in">shuffle</span>(adj[x].<span class="hljs-built_in">begin</span>(), adj[x].<span class="hljs-built_in">end</span>(), rng);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y] || deg[x] &gt;= n / <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;deg[x]++;deg[y]++;ans.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);<span class="hljs-built_in">self</span>(self, y);&#125;&#125;;<span class="hljs-type">int</span> test_case = <span class="hljs-number">100</span>;<span class="hljs-keyword">while</span> (test_case--) &#123;vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);deg.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);ans.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-built_in">rng</span>() % n + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() == n - <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-keyword">return</span> ;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="day-12">【7.19】 Day 12</h3><p>定了 9 点的闹钟，但经典下床继续睡。</p><p>中午在基础实验大楼一楼售货机买了一个面包一盒纯牛奶。鉴定为贪睡导致的。</p><p>下午是 psk 场，不知道会不会整什么花活（然而并没有）。</p><hr /><p>经典从 M 倒序开题，我超，真是原。这题我怎么感觉在哪里见过啊？但没能想起来，悲。</p><p>手算了一下样例，发现样例都算不对。</p><p>跟榜过了三道签到。但 lyc 15min 过的 J 我怎么签不出来鸭？第一感觉是直接横坐标 <span class="math inline">\(+1\)</span> 或纵坐标 <span class="math inline">\(+1\)</span>，狂wa，遂放着。</p><p>看榜 wbc 过了 D，看了下题，感觉和第三场队内赛的某个题很像，都是中间夹了个回文串，抄了个 manacher 就过了。</p><p>然后看 E，观察到一定是 <span class="math inline">\(1/3\)</span> 一组 <span class="math inline">\(2\)</span> 一组，就写了个二分图染色交了上去，怎么又 wa 了鸭。再次确定了一下思路，又捏了几个边界情况，感觉都没问题，就直接对拍启动了。结果拍出来是我 dfs 挂了，不是哥们？</p><p>继续看 J，我超为什么不对呢？干脆又写了个对拍。马上拍出来了，原来不一定是端点旁边啊？那我不会了。</p><p>看榜 lyc 过了 G，看题这不是逆序对模板题吗？15min 秒了。</p><p>怎么 J 和 L 过了一堆了鸭。L 还是推不出样例，J 画了几个图猜了个结论，又 wa。</p><p>红温了红温了红温了红温了红温了。直到赛后也没有过 J。</p><hr /><p>没有讲题，就去吃饭了。朝阳￥16 黑椒牛肉，还不错，三星半或者四星。</p><p>回 234 补题，但是头晕晕的，不知道什么时候就趴桌子上睡着了。醒来快 9 点半了。</p><p>感觉一天什么都没做，倒是欠的题又多了一堆。</p><h3 id="day-13">【7.20】 Day 13</h3><p>没起，起了。</p><p>没吃，吃了。（精神错乱）</p><p>下午和 B 搏斗 3h，终于在最后把 B 做出来了，排名鉴定为人口普查，唉。</p><hr /><div class="note note-info">            <p>【队内赛 10 - Being Meltdown - CF1516D. Cut】</p><p>题意：给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span>，<span class="math inline">\(q\)</span> 次询问。每次询问一段区间 <span class="math inline">\([l, r]\)</span>，问至少要把这个区间分为几个子区间，才能使每个子区间的数的乘积等于这个子区间内所有数的 <span class="math inline">\(\text{Lcm}\)</span>。</p><p><span class="math inline">\(1 \le n,q,a_i \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>区间乘积 <span class="math inline">\(=\)</span> 区间 $ $ 区间中的数两两互质。</p><p>那么对于每个询问只需要从左往右扫，如果加上这个数之后区间不满足两两互质，就新开另一个区间。</p><p>考虑优化这个过程，通过枚举质因数，可以预处理出 <span class="math inline">\(nxt_i\)</span> 代表 <span class="math inline">\(i\)</span> 后面第一个不和 <span class="math inline">\(a_i\)</span> 互质的数的位置。</p><p>那么一段区间两两互质等价于右端点是 <span class="math inline">\([l, r]\)</span> 中所有的 <span class="math inline">\(nxt_i-1\)</span> 取 <span class="math inline">\(\min\)</span>。</p><p>具体地，令 <span class="math inline">\(dp_i\)</span> 代表以 <span class="math inline">\(i\)</span> 为左端点时，下一个左端点的位置，即：<span class="math inline">\(dp_i = \min\limits_{j = i}^{nxt_i - 1}nxt_j\)</span>。这个式子可以用 st 表 <span class="math inline">\(O(n\log n)\)</span> 预处理。</p><p>那么每次询问就可以不断跳到下一个左端点的位置，以求出区间数量。</p><p>套路化地，还可以倍增加速：令 <span class="math inline">\(dp_{i, j}\)</span> 代表 <span class="math inline">\(i\)</span> 后面第 <span class="math inline">\(2^j\)</span> 个左端点的位置。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>vector&lt;<span class="hljs-type">int</span>&gt; prime;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">not_prime</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span>(!not_prime[i]) &#123;prime.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j : prime) &#123;<span class="hljs-keyword">if</span> (i * j &gt; n) &#123;<span class="hljs-keyword">break</span>;&#125;not_prime[i * j] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SparseTable</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ST;<span class="hljs-built_in">SparseTable</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr) &#123;<span class="hljs-keyword">this</span>-&gt;n = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;ST.<span class="hljs-built_in">resize</span>(n +<span class="hljs-number">1</span> ,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ST[i][<span class="hljs-number">0</span>] = arr[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= __lg(n); j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1LL</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++) &#123;ST[i][j] = <span class="hljs-built_in">min</span>(ST[i][j - <span class="hljs-number">1</span>], ST[i + (<span class="hljs-number">1LL</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> len = __lg(r - l + <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ST[l][len], ST[r - (<span class="hljs-number">1LL</span> &lt;&lt; len) + <span class="hljs-number">1</span>][len]);&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-type">int</span> mx = *<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(mx + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x = a[i];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : prime) &#123;<span class="hljs-keyword">if</span> (p * p &gt; x) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (x % p == <span class="hljs-number">0</span>) &#123;b[p].<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">while</span> (x % p == <span class="hljs-number">0</span>) &#123;x /= p;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;b[x].<span class="hljs-built_in">push_back</span>(i);&#125;&#125; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= mx; i++) &#123;<span class="hljs-keyword">if</span> (b[i].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; b[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j++) &#123;nxt[b[i][j]] = <span class="hljs-built_in">min</span>(nxt[b[i][j]], b[i][j + <span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-function">SparseTable <span class="hljs-title">st</span><span class="hljs-params">(nxt)</span></span>;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">3</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;dp[i][<span class="hljs-number">0</span>] = st.<span class="hljs-built_in">query</span>(i, <span class="hljs-built_in">min</span>(n, nxt[i] - <span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">25</span>; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;dp[i][j] = dp[dp[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;<span class="hljs-type">int</span> pos = l, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (dp[pos][i] &gt; <span class="hljs-number">0</span> &amp;&amp; dp[pos][i] &lt;= r) &#123;res += <span class="hljs-number">1</span> &lt;&lt; i;pos = dp[pos][i];&#125;&#125;cout &lt;&lt; res + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-built_in">init_phi</span>(<span class="hljs-number">1e5</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>晚上 atc，犯病了，E 拉了坨大的，后面发现只要把四周框起来就行了。</p><p>CF 继续犯病，D 很快就想到一行里黑色格子的数量大于 <span class="math inline">\(4\)</span> 就直接消行。但剩下的 <span class="math inline">\(n\times 4\)</span> 不会处理，脑子里一直想的状压 dp，一行记作一个状态，结果转移直到比赛结束都没写出来。</p><hr /><div class="note note-info">            <p><a href="https://atcoder.jp/contests/abc363/tasks/abc363_e">E - Sinking Land (atcoder.jp)</a></p>          </div><div class="note note-success">            <p>新建一个超级源点，先用并查集把边框和源点连起来。那么从 <span class="math inline">\(1\sim Y\)</span>，依次遍历海拔高度为 <span class="math inline">\(i\)</span> 的点，看其四周有没有海拔小于等于它的点，有就并起来，那么和源点并起来的点的个数就是被淹没的点的个数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, t;cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;<span class="hljs-function">vector <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">2</span>))</span></span>;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">b</span>(t + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;cin &gt;&gt; a[i][j];<span class="hljs-keyword">if</span> (a[i][j] &lt;= t) &#123;b[a[i][j]].<span class="hljs-built_in">push_back</span>(&#123;i, j&#125;);&#125;&#125;&#125;<span class="hljs-type">int</span> S = (n + <span class="hljs-number">2</span>) * (m + <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(S)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m + <span class="hljs-number">2</span>; j++) &#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> || i == n + <span class="hljs-number">1</span> || j == m + <span class="hljs-number">1</span>) &#123;dsu.<span class="hljs-built_in">merge</span>(S, i * (m + <span class="hljs-number">2</span>) + j);&#125;&#125;&#125;<span class="hljs-type">int</span> init = dsu.<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>);<span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : b[i]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<span class="hljs-type">int</span> xx = x + dx[j];<span class="hljs-type">int</span> yy = y + dy[j];<span class="hljs-keyword">if</span> (a[xx][yy] &lt;= a[x][y]) &#123;dsu.<span class="hljs-built_in">merge</span>(x * (m + <span class="hljs-number">2</span>) + y, xx * (m + <span class="hljs-number">2</span>) + yy);&#125;&#125;&#125;cout &lt;&lt; n * m - (dsu.<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) - init) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>题意：给定一个 <span class="math inline">\(n\times n\)</span> 的网格，第 <span class="math inline">\(i\)</span> 行前 <span class="math inline">\(a_i\)</span> 个格子是黑色，其余为白色。每一次操作可以选择将一行全部涂白或将一个 <span class="math inline">\(2\times 2\)</span> 的区域全部涂白，问将所有格子涂白所需的最小操作次数。</p><p><span class="math inline">\(1 \le n \le 2\cdot 10^5\)</span>，<span class="math inline">\(0 \le a_i \le n\)</span>。</p>          </div><div class="note note-success">            <p>首先某一行如果有巨多黑色格子，直接运用第一种操作显然最佳。</p><p>第一个观察：若某行有大于 <span class="math inline">\(4\)</span> 个黑色格子，直接整行涂白。</p><ul><li>证明：大于 <span class="math inline">\(4\)</span> 个格子，那么至少用 <span class="math inline">\(3\)</span> 次 <span class="math inline">\(2\times 2\)</span> 操作，最优情况将这一行连带下一行一起清理完，但如果用涂整行的操作的话仅用 <span class="math inline">\(2\)</span> 次。</li></ul><p>现在问题变为了将 <span class="math inline">\(n\times 4\)</span> 的矩阵涂白的最小操作次数。</p><p>考虑一个逐行的贪心，同时引出第二个观察：若某行剩余黑格数 <span class="math inline">\(&gt; 2\)</span>，直接整行涂白。</p><ul><li>证明：当剩余黑格数 <span class="math inline">\(&gt;2\)</span> 时，说明该行一定没有被上一行连带消去过任何一个格子。此时用 <span class="math inline">\(2\times 2\)</span> 消除至少需要 <span class="math inline">\(2\)</span> 次，最优情况将下一行连带清理完，仍然不如使用 <span class="math inline">\(2\)</span> 次整行涂白。</li></ul><p>综上，设 <code>flag = 0 / 1 / 2</code> 代表该行没被上一行连带消除<span class="math inline">\(/\)</span>被连带消除了 <span class="math inline">\(1\sim2\)</span> 列的黑格<span class="math inline">\(/\)</span>被连带消除了 <span class="math inline">\(3\sim 4\)</span> 列的黑格，逐行贪心即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">4</span>) &#123;a[i] = <span class="hljs-number">0</span>;ans++;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 1~2 cols have colored = 1</span><span class="hljs-comment">// 3~4 cols have colored = 2</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (a[i] &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;ans++;<span class="hljs-keyword">if</span> (a[i] &lt;= <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span> (flag[i] == <span class="hljs-number">1</span>) &#123;flag[i + <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;a[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<span class="hljs-number">2ll</span>, a[i + <span class="hljs-number">1</span>]);&#125; <span class="hljs-keyword">else</span>  &#123;flag[i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;a[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">2</span>;&#125;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="day-14">【7.21】 Day 14</h3><p>难得的周末，但是在睡梦中度过了。</p><p>我越来越喜欢睡觉了，只是有时候事情积压的太多了，只能熬夜去赶进度。</p><p>梦里什么都有，只是上一次做梦些许是半个月之前了。梦到了知更鸟，以及一些散装的小剧场。</p><p>网上有一种说法是人每次睡觉都会做梦，只是回想不起来罢了。</p><p>也许是记忆被抹杀才带来的孤独。</p><p>下午才醒，不是很想动，感觉训练对我作用不大，我的智商就摆在这里了。</p><p>越来越菜了，高中我也何尝不是这样呢？暑假一轮只剩一周，也许到最后没比赛打，没人愿意和我组队，甚至队都没进。</p><p>我努力过了吗？努力的时候不敢说自己努力了，不努力的时候也不敢说自己什么都没干。这么问也就显得乏之无味。</p><p>对不起很多人，集训队的大家，青柠工作室，以及嵌入式工作室的大家，他们都很看好我，但我就像不谙世事的孩子一样，又时不时吐露出自己悲哀的那一面。</p><p>翻了个身，之后又联想到很多心酸的事实，旁人的责备，又或者是 galgame 里的一段刀子，就像走马灯一样。</p><p>当一个人濒临崩溃的时候，它会想些什么呢？</p><p>啜泣，心绞痛，干脆继续睡了过去。</p><p>希望有羽毛和翅膀。</p><hr /><h3 id="day-15">【7.22】 Day 15</h3><p>昨晚直接在基础实验大楼睡了。11 点 30 有人推门我就醒了。</p><p>午饭又没吃，是不是只要 5h 场就没吃过午饭，好像真是。</p><hr /><p>下午队内赛，很奇怪的场，怎么我每题必 wa，真是病入膏肓了鸭。</p><p>开局 L，我用二进制考虑，结果卡壳了，遂看其它的。</p><p>开了三题怎么用了一个多小时啊，最慢的一集。感觉自己状态有问题，情绪被影响了，打字都很佛系。</p><p>再开 C，wa，稍微用力的想了下，红温之后想到负数会出问题，加了个判断过了。</p><p>L 也会了，宏观的考虑先一直乘 <span class="math inline">\(2\)</span>，看需要减多少，再分配到前面乘 <span class="math inline">\(2\)</span> 的操作之间。</p><p>然后开始博弈，上次博弈挂完了，想雪耻。</p><p>雪耻失败了，两个小时没做出博弈，只想到 <span class="math inline">\(n\le 3\)</span> 怎么做，<span class="math inline">\(n\)</span> 大了脑子就转不动了。</p><p>完败，还好后面红温了也能看清 K，写了个最短路就过了。</p><hr /><p>晚上直接在 234 点了外卖，焖饼炒鸡！一般，三星半。</p><div class="note note-info">            <p>【队内赛 11E - gym105161K. Number Deletion Game】</p><p>题意：给定 <span class="math inline">\(n\)</span> 堆石子，第 <span class="math inline">\(i\)</span> 堆数量 <span class="math inline">\(a_i\)</span>。两名玩家博弈，每轮玩家可以选择拿走最多的一堆石子中的任意个，无法操作则判输。问先手是否有必胜策略。</p>          </div><div class="note note-success">            <p>典题。结论是：<span class="math inline">\(a_i\)</span> 最大值出现奇数次，先手胜；否则后手胜。</p><p>证明使用归纳法：</p><ul><li><span class="math inline">\(\max = 1\)</span>，显然成立。</li><li>设对 <span class="math inline">\(\max =1\sim k\)</span> 成立，则对 <span class="math inline">\(\max= k+1\)</span>：<ul><li>若 <span class="math inline">\(k+1\)</span> 出现奇数次，则操作最后一个 <span class="math inline">\(k+1\)</span> 的是先手。先手可以决定次大值出现偶数次，这样后手输，先手胜。</li><li>若 <span class="math inline">\(k+1\)</span> 出现偶数次，则操作最后一个 <span class="math inline">\(k+1\)</span> 的是后手，同理后手胜。</li><li>故结论对 <span class="math inline">\(\max=k+1\)</span> 成立，于是对最大值为任意正整数都成立，证毕。</li></ul></li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, j = n - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j - <span class="hljs-number">1</span>] == a[n - <span class="hljs-number">1</span>]) &#123;j--;cnt++;&#125;<span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 11J - CF730J. Bottles】</p><p>题意：有 <span class="math inline">\(n\)</span> 瓶水，第 <span class="math inline">\(i\)</span> 瓶水的水量为 <span class="math inline">\(a_i\)</span>，容量为 <span class="math inline">\(b_i\)</span>。将 <span class="math inline">\(1\)</span> 单位水从一个瓶子转移到另一个瓶子所消耗时间为 <span class="math inline">\(1\)</span> 秒，且可以进行无限次转移。求储存所有水所需最小瓶子数 <span class="math inline">\(k\)</span> 以及该情况下所用最小时间 <span class="math inline">\(t\)</span>。</p><p><span class="math inline">\(1 \le n, a_i, b_i \le 100\)</span>。</p>          </div><div class="note note-success">            <p><span class="math inline">\(k\)</span> 比较简单，将容量降序排序，之后按顺序取到 <span class="math inline">\(\min\limits_{k}\sum\limits_{i=1}^{k}b_i \ge \sum a_i\)</span> 即可。</p><p>对于求最小时间 <span class="math inline">\(t\)</span>，可以转化为在这 <span class="math inline">\(n\)</span> 个瓶中取 <span class="math inline">\(k\)</span> 个瓶，使得剩余瓶子的水量之和最小，也就是使这 <span class="math inline">\(k\)</span> 个瓶的水量之和最大。</p><p>这是经典的 <span class="math inline">\(01\)</span> 背包问题，令 <span class="math inline">\(dp_{i, j, s}\)</span> 代表前 <span class="math inline">\(i\)</span> 个瓶中选了 <span class="math inline">\(j\)</span> 个瓶，容量之和为 <span class="math inline">\(s\)</span> 时的最大水量，则： <span class="math display">\[dp_{i, j, s} = \max(dp_{i-1, j, s}, dp_{i-1, j-1, s-b_i}+a_i)\]</span> 其中第一维可以滚动，或者倒序枚举压缩掉。</p><p>时间复杂度 <span class="math inline">\(O(n^4)\)</span>，空间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> water, vol;<span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;<span class="hljs-keyword">return</span> a.vol &gt; b.vol;&#125;;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> sum_water = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i].water;sum_water += a[i].water;&#125;<span class="hljs-type">int</span> sum_vol = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i].vol;sum_vol += a[i].vol;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> ans1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;sum += a[i].vol;<span class="hljs-keyword">if</span> (sum &gt;= sum_water) &#123;ans1 = i;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(ans1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(sum_vol + <span class="hljs-number">1</span>, -inf))</span></span>;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = ans1; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = sum_vol; k &gt;= a[i].vol; k--) &#123;dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j - <span class="hljs-number">1</span>][k - a[i].vol] + a[i].water);&#125;&#125;&#125;<span class="hljs-type">int</span> ans2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sum_water; i &lt;= sum_vol; i++) &#123;ans2 = <span class="hljs-built_in">max</span>(ans2, dp[ans1][i]);&#125;cout &lt;&lt; ans1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; sum_water - ans2 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 11D - gym105161B. Area of the Devil】</p><p>题意：给一个半径为 <span class="math inline">\(r\)</span> 的圆上的五段不相交的圆弧，从每个圆弧依次选择一个点然后按顺序连成一个五角星，求五角星的面积并。</p><p><span class="math inline">\(1\le T \le 10^4\)</span>，<span class="math inline">\(1 \le r \le 10^3\)</span>。</p>          </div><div class="note note-success">            <p>如下图。我们用整个圆的面积减去五个（小三角 <span class="math inline">\(+\)</span> 弓形）的面积即可。</p><p>令 <span class="math inline">\(A_{is}\)</span> 代表第 <span class="math inline">\(i\)</span> 段圆弧的极角最小点，<span class="math inline">\(A_{it}\)</span> 代表第 <span class="math inline">\(i\)</span> 段圆弧的极角最大点。</p><p>以 <span class="math inline">\(\Delta A_{1s}B_{1}A_{5t}\)</span> 为例，<span class="math inline">\(B_1\)</span> 可以通过直线 <span class="math inline">\(A_{2s}A_{5t}\)</span> 和 <span class="math inline">\(A_{1s}A_{4t}\)</span> 求交点得到。知道了三角形三个点的坐标，利用叉积公式即可求得面积。</p><p>弓形 <span class="math inline">\(\overset{\frown}{A_{1s}A_{5t}}\)</span> 也等价于 <span class="math inline">\(S_{\text{扇形}OA_{1s}A_{5t}} - S_{\Delta OA_{1s}A_{5t}}\)</span>。</p><figure><img src="/image/academic/31.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>时间复杂度 <span class="math inline">\(O(T)\)</span>。</p><p>值得注意的是，使用叉积公式时不需要加绝对值，因为我们求的是有向面积。</p><p>如下图（可爱的 xing4c 画出来的！），当出现优弧时，阴影部分的面积应该被加上而不是减去。</p><figure><img src="/image/academic/32.png" alt="xing4c" /><figcaption aria-hidden="true">xing4c</figcaption></figure>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pi acos(-1)</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    T x, y;    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;        Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;        x += p.x;        y += p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;        x -= p.x;        y -= p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;        x *= v;        y *= v;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a += b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a -= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;        <span class="hljs-keyword">return</span> a *= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;        <span class="hljs-keyword">return</span> b *= a;    &#125;    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;    Point&lt;T&gt; a, b;    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">lineIntersection</span><span class="hljs-params">(Line&lt;T&gt; l1, Line&lt;T&gt; l2)</span> </span>&#123;    <span class="hljs-keyword">return</span> l1.a + (l1.b - l1.a) *     (<span class="hljs-built_in">cross</span>(l2.b - l2.a, l1.a - l2.a) /      <span class="hljs-built_in">cross</span>(l2.b - l2.a, l1.a - l1.b));&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(vector&lt;Point&lt;T&gt;&gt; a)</span> </span>&#123;    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();    <span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        res += <span class="hljs-built_in">cross</span>(a[i], a[(i + <span class="hljs-number">1</span>) % n]);    &#125;    res /= <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> r;cin &gt;&gt; r;vector&lt;Point&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">5</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">5</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ori_a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">ori_b</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;cin &gt;&gt; ori_a[i];<span class="hljs-type">double</span> x = r * <span class="hljs-built_in">cos</span>((<span class="hljs-number">1.0</span> * ori_a[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);<span class="hljs-type">double</span> y = r * <span class="hljs-built_in">sin</span>((<span class="hljs-number">1.0</span> * ori_a[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);a[i] = &#123;x, y&#125;;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;cin &gt;&gt; ori_b[i];<span class="hljs-type">double</span> x = r * <span class="hljs-built_in">cos</span>((<span class="hljs-number">1.0</span> * ori_b[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);<span class="hljs-type">double</span> y = r * <span class="hljs-built_in">sin</span>((<span class="hljs-number">1.0</span> * ori_b[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);b[i] = &#123;x, y&#125;;&#125;<span class="hljs-type">double</span> circle = <span class="hljs-number">1.0</span> * r * r * pi;<span class="hljs-type">double</span> res = circle;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l1</span><span class="hljs-params">(&#123;a[i], b[(i + <span class="hljs-number">3</span>) % <span class="hljs-number">5</span>]&#125;)</span></span>;<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l2</span><span class="hljs-params">(&#123;a[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>], b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>]&#125;)</span></span>;Point&lt;<span class="hljs-type">double</span>&gt; p = <span class="hljs-built_in">lineIntersection</span>(l1, l2);res -= <span class="hljs-built_in">area</span>(vector&#123;p, b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>], a[i]&#125;);res -= (circle * ((ori_a[i] - ori_b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>] + <span class="hljs-number">360</span>) % <span class="hljs-number">360</span>) / <span class="hljs-number">360</span>) - <span class="hljs-built_in">area</span>(vector&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>], a[i]&#125;);&#125;cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>) &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-primary">            <h4 id="后缀自动机sam小记">后缀自动机（SAM）小记</h4><ul><li><p>架构</p><ul><li>不包含后缀链接时是一张有向无环图。</li><li>至多 <span class="math inline">\(2n-1\)</span> 个点，<span class="math inline">\(3n-4\)</span> 条边。</li><li>在线的线性算法。</li></ul></li><li><p>Endpos</p><ul><li><p><span class="math inline">\(\text{endpos}\)</span> 是子串在 <span class="math inline">\(S\)</span> 中结束位置的集合，<span class="math inline">\(\text{endpos}\)</span> 相等的子串归为一个等价类。</p></li><li><p>图上到达该节点的所有路径构成了以该等价类为结尾的所有后缀子串。</p></li><li><p>最长的子串称作 <span class="math inline">\(\text{longest(x)}\)</span>，将 <span class="math inline">\(\text{endpos}\)</span> 等价类中的子串按长度从大到小排序得到了 <span class="math inline">\(\text{longest(x)}\)</span> 长度连续的后缀。</p></li><li><p>原串的每个前缀都是 <span class="math inline">\(\text{longest}\)</span>。</p></li></ul></li><li><p>Link</p><ul><li>一个状态的 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(\text{link(x)}\)</span> 连接到最长的后缀 <span class="math inline">\(y\)</span>，满足 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 拥有属于不同等价类。</li><li>如果满足条件的后缀是空串，会直接连向起始节点。</li><li>SAM 维护的三个信息：<span class="math inline">\(\text{longest(x)}\)</span> 的长度 <span class="math inline">\(\text{len(x)}\)</span>，后缀链接 <span class="math inline">\(\text{link(x)}\)</span>，转移 <span class="math inline">\(\text{nxt(x, c)}\)</span>。</li><li>节点和 <span class="math inline">\(\text{link}\)</span> 构成一棵树，称作 <span class="math inline">\(\text{parent}\)</span> 树。</li></ul></li><li><p>构建</p><ul><li>每插入 <span class="math inline">\(c\)</span> 一定会出现一个新的状态（设为 <span class="math inline">\(\text{cur}\)</span>），且一定是 <span class="math inline">\(\text{longest(lst)}+c = \text{longest(cur)}\)</span>。</li><li>开始时 <span class="math inline">\(\text{cur}\)</span> 只有一个串。让指针从 <span class="math inline">\(\text{lst}\)</span> 开始，通过 <span class="math inline">\(\text{link}\)</span> 往起点的方向跳。对于路径上的状态 <span class="math inline">\(\text{p}\)</span>，如果没有 <span class="math inline">\(\text{nxt(p,c)}\)</span> 的转移，那么 <span class="math inline">\(\text{nxt(p, c) = cur}\)</span>。</li><li>因为 <span class="math inline">\(\text{link}\)</span> 指向的都是 <span class="math inline">\(\text{longest}\)</span> 的后缀，所以自然构成新的子串。</li><li>如果已经存在转移，设当前状态为 <span class="math inline">\(\text{p}\)</span>，<span class="math inline">\(\text{q=nxt(p,c)}\)</span>，存在两种情况：<ul><li>若 <span class="math inline">\(\text{len(q)=len(p)+1}\)</span>，说明 <span class="math inline">\(\text{q}\)</span> 中最长的字符串一定是 <span class="math inline">\(\text{longest(p)+c}\)</span>，故连 <span class="math inline">\(\text{link(cur)=q}\)</span>，退出。</li><li>否则把 <span class="math inline">\(\text{q}\)</span> 拷贝到一个新状态 <span class="math inline">\(\text{clone}\)</span>，<span class="math inline">\(\text{clone}\)</span> 拥有 <span class="math inline">\(\text{link(q)}\)</span> 以及 <span class="math inline">\(q\)</span> 所有的出边。令 <span class="math inline">\(\text{link(clone)=link(p)+1}\)</span>，再把 <span class="math inline">\(\text{q}\)</span> 和 <span class="math inline">\(\text{cur}\)</span> 都 <span class="math inline">\(\text{link}\)</span> 到这个点。</li><li>继续从 <span class="math inline">\(\text{p}\)</span> 向起点跳 <span class="math inline">\(\text{link}\)</span>，若存在指向 <span class="math inline">\(\text{q}\)</span> 的出边，改成指向 <span class="math inline">\(\text{clone}\)</span>；否则退出。</li><li>这么做是因为 <span class="math inline">\(\text{q}\)</span> 原来就存在，但我们不清楚 <span class="math inline">\(\text{q}\)</span> 的最长串是不是 <span class="math inline">\(\text{longest(p)+c}\)</span>，于是将 <span class="math inline">\(\text{longest(p)+c}\)</span> 和其在 <span class="math inline">\(\text{q}\)</span> 中的后缀单独拿出来，形成一个新的节点 <span class="math inline">\(\text{clone}\)</span>，以满足 <span class="math inline">\(\text{link(cur)}\)</span> 的要求。</li></ul></li></ul></li></ul>          </div><h3 id="day-16">【7.23】 Day 16</h3><p>要结束了啊，希望今天队内赛能打好一点。</p><p>rating 已经排到 20 名开外了，脑子再不发力就真寄了，脑子给点力哇qwq。</p><hr /><p>队内赛12，开题最慢的一次，不是怎么大家都会勾股数？输！</p><p>注意到了当 <span class="math inline">\(a\)</span> 是质数的时候 <span class="math inline">\(b,c\)</span> 一定连续，交！wa！</p><p>受不了了跟榜看 b，还好是一个简单二分，要不然 1h 过不了一题（</p><p>继续看勾股数，不是所有数质因数分解都能有解，比如 <span class="math inline">\(2\)</span> 就没有一组解，又不会了。</p><p>继续看榜，K 中位数很有意思，map 搞了一下过了。G，H 都 wa2，2h 了，急急急。</p><p>F 有一个人过了，我一看，我趣！这不跑两遍就行了吗，这么简单竟然 2h 才开出来，G 加了特判也过了。</p><p>然后终于会勾股数了，特判了一组 <code>8 15 17</code>，<span class="math inline">\(8\)</span> 之后 <span class="math inline">\(2\)</span> 的倍数都这么搞。</p><p>H 是个分类讨论，wa119，红温！拍！成了！但改了好久。你说得对但 M 怎么一直过不了鸭。</p><p>赛后在群里说，感觉做法没什么问题。结果 wbc 一眼看出我用 <code>lower_bound</code> 搜了一个无序的数组，尼玛！</p><div class="note note-warning">            <p><code>std::lower_bound</code> 需要保证数组有序。</p><p><code>std::erase(std::vector)</code> 就算你指定了在迭代器的哪个位置，删除也是线性的！</p>          </div><hr /><p>晚上本来想在 234 打 CF 的，外卖都直接点到了 234，暴暴锅好吃捏。</p><p>但太累了，支持不住，还是回宿舍睡了。</p><hr /><p>快进到赛后，稳定汤碗。</p><p>B2 做了 90min，原来是模拟题，乐。</p><p>如果不看 B2 直接看 C 分都会高很多，掐点过样例，气得睡不着觉。</p><p>但还是睡了，因为感觉总是上午 11 点起有点那啥了，还是得调整一下。</p><h3 id="day-17">【7.24】 Day 17</h3><p>8 点下床，怎么又睡了？？不过好在 9 点醒了，不算荒废了很多。</p><p>这几天要开始学字符串，学几何，写专题了。毕竟专题不做个五六道真进不了队了。</p><p>时间紧，直接把补题停了。</p><p>所以之后几天你只能在这篇文章里看到流水账了（</p><p>专题解题报告可能也会发到博客上，不过一轮结束前不能够公开。</p><p>中午朝阳，鸡扒饭，出品很稳定啊，四星。</p><hr /><p>下午队内赛 13，开局怎么这么顺，上一次 1h 过四题不知道是什么时候了。</p><p>心里正乐着结果 J 又开始了，wa3，wa5，wa9，wa11，wa27。</p><p>爆了，去看 K，类似生命游戏。直接广搜，搜完发现读错题了，我以为是 “周围有不同颜色的块就变化”。</p><p>于是看 H，裸 meet in the middle，一发过。然后 K 发现改一下就行。</p><p>J 继续红温，感觉交了得有二十多发。转向 C，写了个割边构造，wa8，没救了！</p><p>继续交 J，三十多发了，寄！</p><hr /><p>赛后听芙兰朵和小武说看我代码看乐了，然后才知道我二分图判定直接退出会导致同一个连通块搜两遍。</p><p>啊，红温了红温了红温了红温了红温了红温了红温了红温了红温了红温了红温了红温了。</p><p>于是和可爱的 xing4c 去汉堡王降温，爽点，爽吃。</p><p>菠萝派真的好好吃鸭，还点了个可可味的派，也好吃！</p><p>晚上宿舍睡了，然后 10 点多爬起来洗了个澡，看专题。</p><h3 id="后日谈">【7.28】后日谈</h3><p>真的结束了啊？想起 7.8 的时候还在为暑假哀悼，一转眼就到尾声了。</p><p>当然，指的是一轮集训。能否进得了二轮还有待商榷，负责人把最关键的 Rating 排名藏起来了，真是趣味呢。</p><p>尝试回忆我经历了什么，第一个想到的就是群主 xcy。</p><p>他很贴心，可爱，好说话。集训的时候有一天我因为个人原因没有去，他就来宿舍找我；我听讲座他下来看我，我跟他抱怨除了第一题都没听懂，他也安慰我慢慢来。</p><p>也许很多年之后别人问我暑假集训是怎么样的，我也只能说上来这些。</p><p>毕竟学到了什么知识，谁讲课讲的特别好，谁的 PPT 又做得根屎一样，都经不住时间的冲刷。</p><p>也正是因为这样，记录才有记录的价值。就比如讲课讲得特别好的，徐神，包大✌，vingying，这些都能脱口而出。讲得烂的，啊这是能说的吗？前文已经有了，这里就不重复提了（真没有贬低的意思）。然后队内赛打得牛的，lyc，czz，rzy。尤其 lyc 鸭，经常被 2n，照这个进步速度估计明年就和银牌✌组队了啊！</p><p>此外，能想起来的就是集训队的大家。为什么这么说，因为我虽然线下唯唯诺诺，但是事<del>水群糕手</del>。真的是这样，水群水的多，就能记得住集训队的大伙。大伙喜欢什么，爱看什么，经常说什么话，最后都会变成回忆的一部分。</p><p>说回集训，时间安排还是十分紧密的。这篇博客本身就能看出很多东西，就比如我不知不觉埋了各式各样的坑，几周前说的 “明天再补吧” 或许今天都没能补的上。但与其说紧吧，感觉也没那么阴沉，因为算法本身我认为就是充满乐趣的。就算我没能进队，我也会继续打 CF，明年暑假集训我还能继续陪跑。</p><p>然后不得不说的就是舍友了，jbx，xjj，还有 everflame。因为都是沙河的，所以也聊得来，队内赛打得不好，CF 打挂了都可以相互抱怨，有什么八卦也都可以图一乐。</p><p>真的结束了吗？</p><hr /><p><span class="math display">\[\begin{align}&amp;\color{Rhodamine}無くなったのか　始まったのか分からないけど\\&amp;\color{Cerulean}究竟是失去还是开始\\\\&amp;\color{Rhodamine}行くしか方法は無いんだろう？\\&amp;\color{Cerulean}可除了前进也没有其它办法了吧？\\\\&amp;\color{Rhodamine}正解がなんだ　価値なんて無いんだ\\&amp;\color{Cerulean}正确答案是什么 \ \ 毫无价值可言\\\\&amp;\color{Rhodamine}あたしは生涯　あたし以外じゃ生きられないよ\\&amp;\color{Cerulean}我终其一生 \ \ 都无法活成别人的模样\\\\&amp;\color{Rhodamine}これ以上かき乱しても明日はない\\&amp;\color{Cerulean}哪怕将一切颠覆搅乱仍不会迎来明天\\\\&amp;\color{Rhodamine}どう足掻いても明日はない\\&amp;\color{Cerulean}如何竭力挣扎都不会迎来明天\\\\&amp;\qquad\qquad\qquad\qquad——\small \text{ GIRLS BAND CRY}\normalsize《空の箱\normalsize》\end{align}\]</span></p><hr /><p>UPD：进队了！不知道是不是被群巨捞了QAQ</p><p>队友是可爱的 <a href="https://codeforces.com/profile/everflame">everflame</a> 和可爱的 <a href="https://codeforces.com/profile/nicnaknic">nicnaknic</a>，队名是 UESTC_EndlessEmbrace！</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>UESTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【NNSZCP2023】南宁三中第13届科技文化节程序设计竞赛 G,H,I</title>
    <link href="/posts/996d8e6.html"/>
    <url>/posts/996d8e6.html</url>
    
    <content type="html"><![CDATA[<p><img src="/image/nnsz/1.jpg" /></p><p><img src="/image/nnsz/2.jpg" /></p><h2 id="闲话">闲话</h2><p>比赛的前一天下午听<a href="https://www.luogu.com.cn/user/137242">NNSZ捞王</a>说明天母校要办比赛，后面再打听说还是 <span class="math inline">\(\text{IOI}\)</span> 赛制，很快啊，马上就来捧场了。</p><p>明明才毕业不到半年，就已经要用“母校”称呼了，真是令人感慨。</p><p>比赛快开始的时候跟 <span class="math inline">\(\text{hdm}\)</span> 要了账号，感觉上次打 <span class="math inline">\(\text{OI}\)</span> 还是在不久前（实际已经退役一年半了），又感慨了一下。</p><p>赛题质量高得出乎意料，尤其是最后几题。我曾经也办过三场 <span class="math inline">\(\text{Eden Round}\)</span>，知道每一道原创题背后的付出远比表面看上去要多，所以赛后还是很欣喜的。</p><p>题是好，但时间真的太仓促了，<span class="math inline">\(\text{I}\)</span> 题刚出了思路，比赛啪的一下就结束了，<span class="math inline">\(\text{3h}\)</span> 的时间感觉真对不起这些题。不过后来看了终榜才发现来比赛的基本都是初学者，那也怪不得。</p><p>赛时前半段状态不是很好，前 <span class="math inline">\(6\)</span> 题签了大概 <span class="math inline">\(90\min\)</span>（主要 <span class="math inline">\(\text{C}\)</span> 题题意想岔了浪费了 <span class="math inline">\(20\)</span> 来分钟，<span class="math inline">\(\text{D}\)</span> 题又愣了一下才推出来）。后面一个半小时也只是做了两题，不过已经相当满意了。因为上次写换根 <span class="math inline">\(\text{dp}\)</span> 都不知道是几年前了，能调出来说明脑子还是稍微能动的。</p><p><span class="math inline">\(\text{J}\)</span> 题看了一眼就爆炸了，所以做完 <span class="math inline">\(\text{H}\)</span> 之后都在想 <span class="math inline">\(\text{I}\)</span>。没注意到 <span class="math inline">\(2\)</span> 的幂次的奇偶性，还以为是一堆线段的容斥，把每种同余情况列成了一个表，感觉是 <span class="math inline">\(\text{2-SAT}\)</span>+线段树优化建图类物，赛后发现对了一半。</p><p><span class="math inline">\(\text{GHI}\)</span> 三题我都觉得很棒，就写了题解放在下面，加深一下印象。</p><p>希望能参加下一次，如果还能有的话）</p><p>我们 <span class="math inline">\(01\)</span> 社正在蒸蒸日上啊！（无贬义</p><h2 id="g.-排序算法">G. 排序算法</h2><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a_i\)</span>。</p><p>判断以下算法是否能将 <span class="math inline">\(a\)</span> 排序为严格不下降序列。</p><p>若能，输出 <code>std::swap(a[i],a[j])</code> 的执行次数。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)        <span class="hljs-keyword">if</span> (a[i] &lt; a[j])             std::<span class="hljs-built_in">swap</span>(a[i], a[j]);</code></pre></div><p><span class="math inline">\(1\le n\le 2 \cdot 10^5\)</span>，<span class="math inline">\(1\le a_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>考察直观想象，样例那个 <code>5 4 3 2 1</code> 给的就很不错，手推一下就能发现性质。</p><p>首先算法一定是正确的，外层执行完 <span class="math inline">\(i\)</span> 时，<span class="math inline">\(a_i\)</span> 必定是 <span class="math inline">\(i\)</span> 前缀的最大值，且第一轮循环已经把序列最大值放到了 <span class="math inline">\(a_1\)</span>，那么当 <span class="math inline">\(j&gt;i\)</span> 时也不会出现 <span class="math inline">\(a_i&lt;a_j\)</span> 的情况，即不会交换。</p><p>那么我们只需要计算 <span class="math inline">\(i\)</span> 前缀的贡献，不难发现这个值是前缀中比 <span class="math inline">\(a_i\)</span> 大的不同元素的个数。</p><p>用一个支持插入元素和查询大于某个元素的不同元素个数的数据结构维护：树状数组、线段树和平衡树都是不错的选择。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) puts(x);return ;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fenwick</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; tr;<span class="hljs-built_in">Fenwick</span>() &#123;&#125;<span class="hljs-built_in">Fenwick</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-keyword">this</span>-&gt;n = n;tr.<span class="hljs-built_in">assign</span>(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">while</span>(pos&lt;=n)&#123;tr[pos]+=x;pos+=pos&amp;-pos;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(pos)&#123;res+=tr[pos];pos-=pos&amp;-pos;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r)-<span class="hljs-built_in">sum</span>(l<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">// tr[x] count the cnt of x</span><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;res+=(<span class="hljs-number">1</span>&lt;&lt;i);<span class="hljs-keyword">if</span>(res&gt;n || cnt+tr[res]&gt;=k)&#123;res-=(<span class="hljs-number">1</span>&lt;&lt;i);&#125; <span class="hljs-keyword">else</span> &#123;cnt+=tr[res];&#125;&#125;<span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();b[i]=a[i];&#125;<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());b.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>()),b.<span class="hljs-built_in">end</span>());map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pos;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;b.<span class="hljs-built_in">size</span>();++i) &#123;pos[b[i]]=i;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;a[<span class="hljs-number">1</span>]) &#123;++ans;<span class="hljs-built_in">swap</span>(a[i],a[<span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">Fenwick <span class="hljs-title">fen</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans+=tot-fen.<span class="hljs-built_in">sum</span>(pos[a[i]]);<span class="hljs-keyword">if</span>(!vis[pos[a[i]]]) &#123;vis[pos[a[i]]]=<span class="hljs-literal">true</span>;tot++;fen.<span class="hljs-built_in">add</span>(pos[a[i]],<span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="h.-购买车券">H. 购买车券</h2><div class="note note-info">            <p>题意：给定一棵 <span class="math inline">\(n\)</span> 个点的无根树，每次删去一个叶子节点（指上一次操作后度数不大于 <span class="math inline">\(1\)</span> 的节点），直至删空。问合法的操作序列数。操作序列不同，当且仅当某一次删去的叶子节点不同。</p><p><span class="math inline">\(1\le n\le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>换根 <span class="math inline">\(\text{dp}\)</span>。先计算一个根 <span class="math inline">\(x\)</span> 的结果（即 <span class="math inline">\(x\)</span> 最后才删的方案数）<span class="math inline">\(dp_x\)</span>，再转移，答案就是 <span class="math inline">\(\sum dp_x\)</span>。</p><p>第一遍 <span class="math inline">\(\text{dfs}\)</span>，对于当前子树和其它子树的状态合并（即一段操作序列插到另一端操作序列中），其实就是一个多重集的排列：具体的，两段长分别为 <span class="math inline">\(n,m\)</span> 的序列相互插（元素互不相同），相当于 <span class="math inline">\(n\)</span> 个无区别球放入 <span class="math inline">\(m\)</span> 个有区别盒子且允许空盒，即能形成 <span class="math inline">\(C_{m+n-1}^{n}\)</span> 种序列（<a href="https://kisuraop.github.io/posts/f9da5f78.html#j.-ihis-homework">参考this</a>）。</p><p>用 <span class="math inline">\(sz_x\)</span> 表示 <span class="math inline">\(x\)</span> 的子树大小，那么对于 <span class="math inline">\(x\)</span> 的一个儿子 <span class="math inline">\(y\)</span>，这里 <span class="math inline">\(n,m\)</span> 就分别是 <span class="math inline">\(sz_{y}\)</span> 和 <span class="math inline">\(sz_{x}-sz_y\)</span>，状态转移可以写成： <span class="math display">\[dp_x=\prod\limits_{y\in son_x} \bigg[\binom{sz_x-1}{sz_y}dp_y\bigg]\]</span> 第二遍 <span class="math inline">\(\text{dfs}\)</span>，考虑将根从 <span class="math inline">\(x\)</span> 转移到 <span class="math inline">\(y\)</span>，此时序列 <span class="math inline">\(n\)</span> 中的一个节点跑到了 <span class="math inline">\(m\)</span> 中，即： <span class="math display">\[sz_y\rightarrow sz_y-1\]</span> <span class="math display">\[sz_x-sz_y\rightarrow sz_x-sz_y+1\]</span> 也可以根据 <span class="math inline">\(C_{m+n-1}^{n}\)</span> 的结构得知：底数 <span class="math inline">\(m,n\)</span> 一加一减抵消，贡献就从 <span class="math inline">\(\binom{n-1}{sz_y}\rightarrow \binom{n-1}{sz_y-1}\)</span>。</p><p>那么转移可以写成： <span class="math display">\[dp_y=dp_x\cdot\frac{\binom{n-1}{sz_y-1}}{\binom{n-1}{sz_y}}=dp_x\cdot\frac{sz_y}{n-sz_y}\]</span> 时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) puts(x);return ;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;    <span class="hljs-type">int</span> x;    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == a.x; &#125;;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x != a.x; &#125;;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * y * a.x % mod);&#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(y) / a;&#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="hljs-keyword">return</span> is &gt;&gt; t.x;&#125;    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;            mul *= mul;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (b) &#123;            <span class="hljs-type">int</span> t = a / b;            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);        &#125;        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;        <span class="hljs-keyword">return</span> u;    &#125;    &#125;;<span class="hljs-keyword">using</span> mint = ModInt&lt;modp&gt;;<span class="hljs-function"><span class="hljs-keyword">inline</span> mint <span class="hljs-title">qpow</span><span class="hljs-params">(mint k,<span class="hljs-type">int</span> n)</span> </span>&#123;mint s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s=s*k;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">math</span> &#123;<span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;vector&lt;mint&gt; frac;vector&lt;mint&gt; inv;<span class="hljs-built_in">math</span>() &#123;&#125;<span class="hljs-built_in">math</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;frac.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);inv.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);frac[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size+<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;frac[i]=frac[i<span class="hljs-number">-1</span>]*i;&#125;inv[n]=<span class="hljs-built_in">qpow</span>(frac[n],modp<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=size+<span class="hljs-number">1</span>;--i) &#123;inv[i<span class="hljs-number">-1</span>]=inv[i]*i;&#125;size=n;&#125;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m || m&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(n&gt;size) <span class="hljs-built_in">init</span>(n);<span class="hljs-keyword">return</span> frac[n]*inv[m]*inv[n-m];&#125;&#125;binom;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">return</span> binom.<span class="hljs-built_in">C</span>(n,m); &#125;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(mint n,mint m)</span> </span>&#123;<span class="hljs-keyword">return</span> binom.<span class="hljs-built_in">C</span>(n.<span class="hljs-built_in">val</span>(),m.<span class="hljs-built_in">val</span>()); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;mint&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs1 = [&amp;](<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;sz[x]=<span class="hljs-number">1</span>;dp[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fath) &#123;<span class="hljs-built_in">self</span>(self,y,x);dp[x]*=dp[y]*<span class="hljs-built_in">C</span>(sz[x]+sz[y]<span class="hljs-number">-1</span>,sz[y]);sz[x]+=sz[y];&#125;&#125;&#125;;<span class="hljs-built_in">dfs1</span>(dfs1,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> dfs2 = [&amp;](<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fath) &#123;dp[y]=dp[x]*<span class="hljs-built_in">C</span>(n<span class="hljs-number">-1</span>,sz[y]<span class="hljs-number">-1</span>)/<span class="hljs-built_in">C</span>(n<span class="hljs-number">-1</span>,sz[y]);<span class="hljs-built_in">self</span>(self,y,x);&#125;&#125;&#125;;<span class="hljs-built_in">dfs2</span>(dfs2,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(),dp.<span class="hljs-built_in">end</span>(),(mint)<span class="hljs-number">0</span>));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="i.-花卉培育">I. 花卉培育</h2><div class="note note-info">            <p>题意：构造序列 <span class="math inline">\(\{a_i\}\)</span> 使其同时满足 <span class="math inline">\(q\)</span> 个限制。</p><p>其中第 <span class="math inline">\(j\in[1,q]\)</span> 个限制形如 <span class="math inline">\(\bigg(\prod\limits_{i=l_j}^{r_j}a_i\bigg)\equiv v_j\pmod{3}\)</span>.</p><p><span class="math inline">\(1\le n,q \le 3\cdot 10^5\)</span>，<span class="math inline">\(0\le a_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>首先，在模 <span class="math inline">\(3\)</span> 意义下，<span class="math inline">\(0\le a_i\le 10^9\)</span> 等价于 <span class="math inline">\(0\le a_i \le 2\)</span>。</p><p>那么我们只需考量 <span class="math inline">\(a_i=0/1/2\)</span> 时在序列中的性质：</p><p>若 <span class="math inline">\(a_i=0\)</span>，那么所有含 <span class="math inline">\(a_i\)</span> 的区间乘积都是 <span class="math inline">\(0\)</span>。因此在每个 <span class="math inline">\(v_j\neq 0\)</span> 的区间中不能含有 <span class="math inline">\(0\)</span>。</p><p>再考虑 <span class="math inline">\(v_j=0\)</span> 的限制，<span class="math inline">\(a_i=1\)</span> 对乘积没有任何影响，对于 <span class="math inline">\(a_i=2\)</span> 则有一个经典结论： <span class="math display">\[\begin{cases}3|(2^n+1)\ ,n\textbf{ 为奇数}\\3|(2^n-1)\ ,n\textbf{ 为偶数}\end{cases}\quad\Longrightarrow\quad 2^k \bmod{3} = \begin{cases}2\ ,k\textbf{ 为奇数}\\1\ ,k\textbf{ 为偶数}\end{cases}\]</span></p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        证明？    </div>    <div class='spoiler-content'>        <p>当 <span class="math inline">\(n\)</span> 为偶数时，令 <span class="math inline">\(n=2k\)</span>，则： <span class="math display">\[\begin{align}\quad2^{2k}-1&amp;=4^k-1\\&amp;=(3+1)^k-1\\&amp;=3^k+\tbinom{k}{1}3^{k-1}+\tbinom{k}{2}3^{k-2}+\dots+1-1\\&amp;\equiv1-1\pmod{3}\\&amp;\equiv 0 \pmod{3}\end{align}\]</span> 当 <span class="math inline">\(n\)</span> 为奇数时，令 <span class="math inline">\(n=2k+1\)</span>，则： <span class="math display">\[\begin{align}2^{2k+1}+1&amp;=2\cdot{2^{2k}+1}\\&amp;=2\cdot (3+1)^{k}+1\\&amp;=2(3^k+\tbinom{k}{1}3^{k-1}+\tbinom{k}{2}3^{k-2}+\dots+1)+1\\&amp;\equiv 2\cdot1+1\pmod{3}\\&amp;\equiv 0 \pmod{3}\end{align}\]</span> 证毕。</p>    </div></div><div class="note note-success">            <p>这能带来两个巧思：</p><ol type="1"><li>若干个 <span class="math inline">\(1,2\)</span> 相乘不会出现 <span class="math inline">\(3\)</span> 的倍数，意味着满足限制 <span class="math inline">\(v_j=0\)</span> 的充要条件是 <span class="math inline">\([l_j,r_j]\)</span> 间有 <span class="math inline">\(0\)</span>。即若有 <span class="math inline">\(v_j=0\)</span> 的区间完全包含在 <span class="math inline">\(v_j\neq0\)</span> 的区间的并中，无解。</li><li>有解情形下，只要每个限制区间 <span class="math inline">\(2\)</span> 的个数的奇偶性满足条件，通过用 <span class="math inline">\(1\)</span> 补齐的方式一定能构造出可行解。</li></ol><p>那么问题转化为是否能有一种构造方案使得每个限制区间中 <span class="math inline">\(2\)</span> 的个数的奇偶性满足要求。</p><p>妙手：记 <span class="math inline">\(a_i=2\)</span> 的位置 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(x_i=1\)</span>，那么对于 <span class="math inline">\([l,r]\)</span>，有如下等价形式： <span class="math display">\[x_l\oplus x_{l+1}\oplus \dots\oplus x_{r-1}\oplus x_{r}=\begin{cases}0\ ,[l,r]\textbf{ 中有偶数个 }2\\1\ ,[l,r]\textbf{ 中有奇数个 }2\end{cases} \ =s_{l-1}\oplus s_r\]</span> 其中 <span class="math inline">\(s_i\)</span> 是 <span class="math inline">\(x_i\)</span> 的前缀异或和。</p><p>换言之，对于一个限制条件，可以转化为两个单点的异或，进而转化为如下二元按位关系： <span class="math display">\[\begin{align}s_{l-1} \oplus s_r=1 \rightarrow (s_{l-1}\lor s_r)\land(\neg s_{l-1} \lor \neg s_r)\\s_{l-1} \oplus s_r=0 \rightarrow (s_{l-1}\lor \neg s_r)\land(\neg s_{l-1} \lor  s_r)\end{align}\]</span></p><p>用 <span class="math inline">\(\small\text{2-SAT}\)</span> 求解，时间复杂度 <span class="math inline">\(O(n+q)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) puts(x);return ;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoSet</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-built_in">TwoSet</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;adj.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>);ans.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addbind</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">bool</span> ok1,<span class="hljs-type">int</span> y,<span class="hljs-type">bool</span> ok2)</span> </span>&#123;adj[x+n*(!ok1)].<span class="hljs-built_in">push_back</span>(y+n*ok2);adj[y+n*(!ok2)].<span class="hljs-built_in">push_back</span>(x+n*ok1);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> tim=<span class="hljs-number">0</span>,top=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x]=low[x]=++tim;vis[x]=<span class="hljs-literal">true</span>;stack_[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[y]) &#123;low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-type">int</span> now;++cnt;<span class="hljs-keyword">do</span>&#123;now=stack_[top--];vis[now]=<span class="hljs-literal">false</span>;c[now]=cnt;scc[cnt].<span class="hljs-built_in">push_back</span>(now);&#125;<span class="hljs-keyword">while</span>(x!=now);&#125;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) &#123;<span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(c[i]==c[i+n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;ans[i]=c[i]&gt;c[i+n]?<span class="hljs-number">1ll</span>:<span class="hljs-number">0ll</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getans</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ans;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();<span class="hljs-meta">#<span class="hljs-keyword">define</span> FAIL while(n--) printf(<span class="hljs-string">&quot;-1 &quot;</span>);return ;</span><span class="hljs-function">TwoSet <span class="hljs-title">ts</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n+<span class="hljs-number">2</span>)</span></span>;vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; arr0;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) &#123;arr0.<span class="hljs-built_in">push_back</span>(&#123;l,r+<span class="hljs-number">1</span>,x&#125;);&#125; <span class="hljs-keyword">else</span> &#123;sum[l]++;sum[r+<span class="hljs-number">1</span>]--;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) &#123;ts.<span class="hljs-built_in">addbind</span>(l,<span class="hljs-number">0</span>,r+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>); ts.<span class="hljs-built_in">addbind</span>(l,<span class="hljs-number">1</span>,r+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>); &#125; <span class="hljs-keyword">else</span> &#123;ts.<span class="hljs-built_in">addbind</span>(l,<span class="hljs-number">0</span>,r+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);ts.<span class="hljs-built_in">addbind</span>(l,<span class="hljs-number">1</span>,r+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) &#123;sum[i]+=sum[i<span class="hljs-number">-1</span>];&#125;sum.<span class="hljs-built_in">insert</span>(sum.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>);sum.<span class="hljs-built_in">pop_back</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i:sum) &#123;i=(<span class="hljs-type">bool</span>)i;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) &#123;sum[i]+=sum[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [l,r,x]:arr0) &#123;<span class="hljs-keyword">if</span>(sum[r]-sum[l]==r-l) &#123;FAIL;&#125;&#125;<span class="hljs-keyword">if</span>(!ts.<span class="hljs-built_in">work</span>()) &#123;FAIL;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(sum[i]!=sum[i+<span class="hljs-number">1</span>]) &#123;ts.ans[i]==ts.ans[i+<span class="hljs-number">1</span>] ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 &quot;</span>) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2 &quot;</span>); &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 &quot;</span>);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>nnsz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】Codeforces Round 910 (Div.2) B,D,E,F</title>
    <link href="/posts/79faf3ae.html"/>
    <url>/posts/79faf3ae.html</url>
    
    <content type="html"><![CDATA[<h2 id="b.-milena-and-admirer">B. Milena and Admirer</h2><p><a href="https://codeforces.com/contest/1898/problem/B">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，每次可以选定一个 <span class="math inline">\(a_i\)</span> 和正整数 <span class="math inline">\(x\in[1,x)\)</span>，并将 <span class="math inline">\(a_i\)</span> 替换成 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(a_i -x\)</span>。问使序列单调不降的最小操作次数。</p><p><span class="math inline">\(1\le n \le 2\times 10^5\)</span>，<span class="math inline">\(1\le a_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>倒序考虑。</p><p>对于每一个 <span class="math inline">\(a_i,a_{i+1}\)</span>：</p><ul><li>若 <span class="math inline">\(a_i\le a_{i+1}\)</span>，不进行任何操作。</li><li>若 <span class="math inline">\(a_i &gt; a_{i+1}\)</span>，记操作次数为 <span class="math inline">\(cnt\)</span>。可以证明，最优策略肯定是使分裂序列最左端的数（即最小数）最大：例如 <span class="math inline">\([21,6]\)</span> 中的 <span class="math inline">\(21\)</span> 拆分成 <span class="math inline">\([{\color{Red}5},5,5,6]\)</span> 肯定要比 <span class="math inline">\([{\color{Red}3},6,6,6]\)</span> 更优，这样继续倒序操作会有更大的操作空间。具体地：<ul><li>若 <span class="math inline">\(a_{i+1} \mid a_i\)</span>，则将 <span class="math inline">\(a_i\)</span> 拆分成 <span class="math inline">\(\dfrac{a_i}{a_{i+1}}\)</span> 个 <span class="math inline">\(a_{i+1}\)</span>，<span class="math inline">\(cnt=\dfrac{a_i}{a_{i+1}}-1\)</span>。</li><li>否则，会多出一个余数，则 <span class="math inline">\(cnt=\left\lfloor\dfrac{a_{i}}{a_{i+1}}\right\rfloor\)</span>。此时最左端的数最大为 <span class="math inline">\(\left\lfloor\dfrac{a_i}{cnt}\right\rfloor\)</span>。</li><li>每次的 <span class="math inline">\(a_{i+1}\)</span> 其实就是上一次操作后最左端的数。</li></ul></li></ul><p>可以用 <code>std::queue</code> 模拟这一加数过程。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;deque&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;--i) &#123;q.<span class="hljs-built_in">push_back</span>(a[i]);&#125;vector&lt;<span class="hljs-type">int</span>&gt; b;b.<span class="hljs-built_in">push_back</span>(a[n]);<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();<span class="hljs-keyword">if</span>(x&lt;=b.<span class="hljs-built_in">back</span>()) &#123;b.<span class="hljs-built_in">push_back</span>(x);q.<span class="hljs-built_in">pop_front</span>();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> y=b.<span class="hljs-built_in">back</span>();<span class="hljs-type">int</span> cnt=x/y;res+=cnt<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(x%y) &#123;res++;<span class="hljs-type">int</span> z=x/(cnt+<span class="hljs-number">1</span>);b.<span class="hljs-built_in">push_back</span>(z);&#125;q.<span class="hljs-built_in">pop_front</span>();&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-absolute-beauty">D. Absolute Beauty</h2><p><a href="https://codeforces.com/contest/1898/problem/D">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a,b\)</span>。你可以交换 <span class="math inline">\(b\)</span> 中的任意两个数一次或不进行任何操作，求 <span class="math inline">\(\max(\sum\limits_{i=1}^n|a_i-b_i|)\)</span>。</p><p><span class="math inline">\(2\le n \le 2\cdot 10^5\)</span>，<span class="math inline">\(1\le a_i,b_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>将每一组 <span class="math inline">\((a_i,b_i)\)</span> 看作线段（若 <span class="math inline">\(a_i&gt;b_i\)</span> 则交换），一共 <span class="math inline">\(n\)</span> 条线段。</p><p>此时 <span class="math inline">\(|a_i-b_i|\)</span> 即线段的长度，我们要求 <span class="math inline">\(n\)</span> 条线段长度和的最大值。</p><p>考虑交换一组 <span class="math inline">\(b_i,b_j\)</span> 对答案的影响：即交换两条线段的某两个端点。</p><p>可能的情况如下（不完全）：</p><p><img src="/image/academic/CF910_1.png" /></p><p><img src="/image/academic/CF910_2.png" /></p><p><img src="/image/academic/CF910_3.png" /></p><p>会发现只有第一组线段的长度得以扩张，且扩张值为原先线段间空白长度的两倍。</p><p>那么我们找到所有 <span class="math inline">\((a_i,b_i)\)</span> 中最小的右端点 <span class="math inline">\(s\)</span> 和最大的左端点 <span class="math inline">\(t\)</span>。</p><p>有 <span class="math inline">\(ans=\max(0,2(t-s))+\sum\limits_{i=1}^n |a_i-b_i|\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-type">int</span> minn=inf,maxn=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;res+=<span class="hljs-built_in">abs</span>(a[i]-b[i]);minn=<span class="hljs-built_in">min</span>(minn,<span class="hljs-built_in">max</span>(a[i],b[i]));maxn=<span class="hljs-built_in">max</span>(maxn,<span class="hljs-built_in">min</span>(a[i],b[i]));&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res+<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,<span class="hljs-number">2</span>*(maxn-minn)));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="e.-sofia-and-strings">E. Sofia and Strings</h2><p><a href="https://codeforces.com/contest/1898/problem/E">Problem</a></p><div class="note note-info">            <p>题意：给定两个由小写字母构成的字符串 <span class="math inline">\(S,T\)</span>，长度分别为 <span class="math inline">\(n,m\)</span>。你可以进行以下两种操作任意次，问是否能将 <span class="math inline">\(S\)</span> 转化成 <span class="math inline">\(T\)</span>。</p><ol type="1"><li>删除 <span class="math inline">\(S\)</span> 中的一个元素。</li><li>使 <span class="math inline">\(S\)</span> 中的某个子段按字典序排序。</li></ol><p><span class="math inline">\(1\le m\le n\le 2 \cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>首先，因为不计操作次数，所以操作 <span class="math inline">\(2\)</span> 其实可以转化为每次排序两个相邻字母。</p><p>例如，<span class="math inline">\(\text{cba}\to\)</span> <span class="math inline">\(\text{abc}\)</span> 其实相当于 <span class="math inline">\(\text{cba} \to \text{cab} \to \text{acb} \to \text{abc}\)</span>。</p><p>其次，逐个匹配 <span class="math inline">\(T\)</span> 中字符，观察匹配过程：假若当前匹配字母 <span class="math inline">\(\text{d}\)</span>，那么在 <span class="math inline">\(S\)</span> 中找到第一个仍未被匹配的 <span class="math inline">\(\text{d}\)</span>，由于当且仅当字典序小的字母紧跟在字典序大的字母后面时才会发生交换，那么在确定 <span class="math inline">\(\text{d}\)</span> 的位置的同时，位于 <span class="math inline">\(\text{d}\)</span> 之前且字典序比 <span class="math inline">\(\text{d}\)</span> 小的字母（<span class="math inline">\(\text{a,b,c}\)</span>）就失去了贡献，无法参与后续匹配。因为后续匹配继续向 <span class="math inline">\(\text{d}\)</span> 的右侧寻找，而 <span class="math inline">\(\text{a,b,c}\)</span> 无论如何也跨越不了这个 <span class="math inline">\(\text{d}\)</span>。</p><p>用 <code>std::vector</code> 记录每个字母出现的下标，逐个扫描 <span class="math inline">\(T\)</span>，并将符合上述要求不再有贡献的下标从容器中移除。若能一直匹配到 <span class="math inline">\(T\)</span> 末尾，则必然存在一个解。否则无解。</p><p>时间复杂度 <span class="math inline">\(O(n+m\cdot 26)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();string s,t;cin&gt;&gt;s&gt;&gt;t;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pos</span>(<span class="hljs-number">26</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;pos[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-type">int</span> x=t[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span>(pos[x].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> fir=pos[x].<span class="hljs-built_in">back</span>();pos[x].<span class="hljs-built_in">pop_back</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x;++j) &#123;<span class="hljs-keyword">while</span>(!pos[j].<span class="hljs-built_in">empty</span>() &amp;&amp; pos[j].<span class="hljs-built_in">back</span>()&lt;fir) &#123;pos[j].<span class="hljs-built_in">pop_back</span>();&#125;&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="f.-vova-escapes-the-matrix">F. Vova Escapes the Matrix</h2><p><a href="https://codeforces.com/contest/1898/problem/F">Problem</a></p><div class="note note-info">            <p>题意：给定一个 <span class="math inline">\(n\times m\)</span> 的矩形迷宫和初始坐标，迷宫的出口定义为位于迷宫边缘且没有障碍且能从初始位置走到的格子。一个迷宫有三种状态：没有出口，有一个出口，有两个及以上出口。问在不破坏迷宫状态的前提下，能再往这个迷宫中添加多少障碍物。</p><p><span class="math inline">\(3\le n,m\le 1000\)</span>。</p>          </div><div class="note note-success">            <p>先从起点跑一遍 <span class="math inline">\(\text{bfs}\)</span>，预处理出 <span class="math inline">\(dis_{i,j}\)</span> 代表起点到点 <span class="math inline">\((i,j)\)</span> 的最短距离。</p><p>设迷宫出口数量为 <span class="math inline">\(k\)</span>，初始有 <span class="math inline">\(p\)</span> 个可放障碍的点，出口点集为 <span class="math inline">\(T\)</span>：</p><ul><li><span class="math inline">\(k=0\)</span>，把迷宫塞满，<span class="math inline">\(ans=p\)</span>。</li><li><span class="math inline">\(k=1\)</span>，无脑塞，只留一条通向出口的最短路，<span class="math inline">\(ans=p-\min(dis_T)\)</span>。</li><li><span class="math inline">\(k\ge2\)</span>，显然最后只保留两个出口。以 <span class="math inline">\(i\in T\)</span> 为起点再跑 <span class="math inline">\(\text{bfs}\)</span>，记录出 <span class="math inline">\(diss_{i,j,0/1}\)</span> 表示点 <span class="math inline">\((i,j)\)</span> 到最近出口的距离和到次近出口的距离，则 <span class="math inline">\(ans=p-\min(dis_{i,j}+diss_{i,j,0}+diss_{i,j,1})\)</span>。</li></ul><p>时间复杂度 <span class="math inline">\(O(mn)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-type">int</span> sx,sy;<span class="hljs-type">int</span> blank=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;cin&gt;&gt;s[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;V&#x27;</span>) &#123;sx=i;sy=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>) &#123;blank++;&#125;&#125;&#125;<span class="hljs-type">int</span> dx[]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span> dy[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-keyword">auto</span> overline = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">return</span> x&lt;<span class="hljs-number">0</span> || x&gt;=n || y&lt;<span class="hljs-number">0</span> || y&gt;=m;&#125;;<span class="hljs-keyword">auto</span> isexit = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<span class="hljs-built_in">return</span> (x==<span class="hljs-number">0</span> || x==n<span class="hljs-number">-1</span> || y==<span class="hljs-number">0</span> || y==m<span class="hljs-number">-1</span>) &amp;&amp; s[x][y]!=<span class="hljs-string">&#x27;#&#x27;</span>;&#125;;queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dis</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m,<span class="hljs-number">-1</span>));q.<span class="hljs-built_in">push</span>(&#123;sx,sy&#125;);dis[sx][sy]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> exit=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> [x,y]=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();exit+=<span class="hljs-built_in">isexit</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i) &#123;<span class="hljs-type">int</span> xx=x+dx[i],yy=y+dy[i];<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">overline</span>(xx,yy) &amp;&amp; dis[xx][yy]==<span class="hljs-number">-1</span> &amp;&amp; s[xx][yy]!=<span class="hljs-string">&#x27;#&#x27;</span>) &#123;dis[xx][yy]=dis[x][y]+<span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(&#123;xx,yy&#125;);&#125;&#125;&#125;<span class="hljs-keyword">if</span>(!exit) &#123;<span class="hljs-type">int</span> ans=blank;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exit==<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isexit</span>(i,j) &amp;&amp; dis[i][j]!=<span class="hljs-number">-1</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,dis[i][j]);&#125;&#125;&#125;ans=blank-ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125; <span class="hljs-keyword">else</span> &#123;queue&lt;array&lt;<span class="hljs-type">int</span>,<span class="hljs-number">4</span>&gt;&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isexit</span>(i,j)) &#123;q.<span class="hljs-built_in">push</span>(&#123;i,j,<span class="hljs-number">0</span>,i*m+j&#125;);&#125;&#125;&#125;<span class="hljs-function">vector <span class="hljs-title">diss</span><span class="hljs-params">(n,vector(m,array&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;))</span></span>;<span class="hljs-function">vector <span class="hljs-title">id</span><span class="hljs-params">(n,vector&lt;<span class="hljs-type">int</span>&gt;(m,<span class="hljs-number">-1</span>))</span></span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> [x,y,d,pid]=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(diss[x][y][<span class="hljs-number">0</span>]==<span class="hljs-number">-1</span>) &#123;diss[x][y][<span class="hljs-number">0</span>]=d;id[x][y]=pid;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diss[x][y][<span class="hljs-number">1</span>]==<span class="hljs-number">-1</span> &amp;&amp; pid!=id[x][y]) &#123;diss[x][y][<span class="hljs-number">1</span>]=d;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i) &#123;<span class="hljs-type">int</span> xx=x+dx[i],yy=y+dy[i];<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">overline</span>(xx,yy) &amp;&amp; s[xx][yy]!=<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; diss[xx][yy][<span class="hljs-number">1</span>]==<span class="hljs-number">-1</span>) &#123;q.<span class="hljs-built_in">push</span>(&#123;xx,yy,d+<span class="hljs-number">1</span>,pid&#125;);&#125;&#125;&#125;<span class="hljs-type">int</span> ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(s[i][j]!=<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; dis[i][j]!=<span class="hljs-number">-1</span> &amp;&amp; diss[i][j][<span class="hljs-number">1</span>]!=<span class="hljs-number">-1</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,dis[i][j]+diss[i][j][<span class="hljs-number">0</span>]+diss[i][j][<span class="hljs-number">1</span>]);&#125;&#125;&#125;ans=blank-ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】GenshinOI Round 3 A~C</title>
    <link href="/posts/81a98245.html"/>
    <url>/posts/81a98245.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://sy.hhwdd.com/RequireFile.do?fid=aZQ9MeAe" /></p><h2 id="a.-wbybld">A. wbyblD</h2><p><a href="https://www.luogu.com.cn/problem/P9815?contestId=141486">Problem</a></p><div class="note note-info">            <p>题意：有 <span class="math inline">\(n+2\)</span> 个点排成一排，编号 <span class="math inline">\(0\sim n+1\)</span>。对每个 <span class="math inline">\(0\le i\le n+1\)</span> 号点有两个整数 <span class="math inline">\(a_i,b_i\)</span>。初始时 <span class="math inline">\(a_0=b_0=a_{n+1}=b_{n+1}=0\)</span>。</p><p>设你当前在第 <span class="math inline">\(x\)</span> 号点，移动方向为 <span class="math inline">\(y\)</span>，初始时 <span class="math inline">\(x=0,y=1\)</span>。</p><p>接下来你按如下方式移动直到 <span class="math inline">\(x,y\)</span> 某一次变化后满足 <span class="math inline">\(x=0,y=-1\)</span> 或 <span class="math inline">\(x=n+1,y=1\)</span>。</p><ul><li>若 <span class="math inline">\(y=1\)</span>，先将 <span class="math inline">\(x\)</span> 加 <span class="math inline">\(1\)</span>，此时若 <span class="math inline">\(a_x&gt;0\)</span> 则将 <span class="math inline">\(y\)</span> 变成 <span class="math inline">\(-1\)</span>，否则 <span class="math inline">\(y\)</span> 不变，最后再将 <span class="math inline">\(a_x\)</span> 减 <span class="math inline">\(1\)</span>。</li><li>若 <span class="math inline">\(y=-1\)</span>，先将 <span class="math inline">\(x\)</span> 减 <span class="math inline">\(1\)</span>，此时若 <span class="math inline">\(b_x&gt;0\)</span> 则将 <span class="math inline">\(y\)</span> 变成 <span class="math inline">\(1\)</span>，否则 <span class="math inline">\(y\)</span> 不变，最后再将 <span class="math inline">\(b_x\)</span> 减 <span class="math inline">\(1\)</span>。</li></ul><p>问最后结束时 <span class="math inline">\(x\)</span> 会在 <span class="math inline">\(0\)</span> 号点还是 <span class="math inline">\(n+1\)</span> 号点。</p><p><span class="math inline">\(1\le \sum n\le 10^6\)</span>，<span class="math inline">\(0\le a_i,b_i\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>看到题很快写了个线段树二分。咦，怎么样例不对？哦，看错题了，乐。</p><p>脑海里模拟一下，发现对于一组 <span class="math inline">\(a_i,b_{i-1}\)</span> 相当于较量谁大直到一方变为 <span class="math inline">\(0\)</span>，而在这之前你只能左右横跳。</p><p>如果 <span class="math inline">\(a_i\)</span> 较大，那你往回走，如果凑不够足够的 <span class="math inline">\(\sum b_{j} \text{ }, j\in[1,i-1]\)</span> （指比较后剩下的 <span class="math inline">\(b_j\)</span>），那你就回家了。</p><p>重复这个过程，思路转个弯，实际上就是对每个 <span class="math inline">\(i\)</span> 比较 <span class="math inline">\(\sum a_{1\sim i}\)</span> 和 <span class="math inline">\(\sum b_{1\sim{i-1}}\)</span>。</p><p>前缀和记录，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">2</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;<span class="hljs-number">0</span>) &#123;sum-=a[i];&#125;<span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span>(b[i]&gt;<span class="hljs-number">0</span>) &#123;sum+=b[i];&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-少项式复合幂">B. 少项式复合幂</h2><p><a href="https://www.luogu.com.cn/problem/P9816?contestId=141486">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定多项式 <span class="math inline">\(f(x)=\sum_{i=1}^ma_ix^{b_i}\)</span>。定义 <span class="math inline">\(f_1(x)=f(x)\)</span>，<span class="math inline">\(f_n(x)=f(f_{n-1}(x))\)</span>。</p><p>给定模数 <span class="math inline">\(p\)</span>。有 <span class="math inline">\(q\)</span> 次询问，每次给出 <span class="math inline">\(x,y\)</span>，查询 <span class="math inline">\(f_y(x)\bmod p\)</span> 的值。</p><p><span class="math inline">\(1\le m\le 20\)</span>，<span class="math inline">\(0\le a_i,b_i\le 10^5\)</span>，<span class="math inline">\(2\le p\le 10^5\)</span>，<span class="math inline">\(1\le q\le 3\times 10^5\)</span>，<span class="math inline">\(1\le x,y\le 10^7\)</span>。</p>          </div><div class="note note-success">            <p>诈骗题。</p><p>注意到模数 <span class="math inline">\(p\)</span> 十分小，而每次经过 <span class="math inline">\(f(x)\)</span> 运算后得出的结果只能是 <span class="math inline">\([0,p)\)</span>。</p><p>那么只需要对每个 <span class="math inline">\(i\in[0,p)\)</span> 代进函数预处理出 <span class="math inline">\(f(i)\)</span>，那么进行一次询问的复杂度降到 <span class="math inline">\(O(y)\)</span>。</p><p>总复杂度 <span class="math inline">\(O(qy)\)</span> ，继续优化。</p><p>倍增，令 <span class="math inline">\(f_{i,j}\)</span> 为数 <span class="math inline">\(i\)</span> 经过 <span class="math inline">\(2^j\)</span> 次迭代后得到的结果。</p><p>询问时对 <span class="math inline">\(y\)</span> 的二进制下的每一位考虑即可。</p><p>时间复杂度 <span class="math inline">\(O(mp+q\log y)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k%p) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s=s*k%p;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> m=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>(),modp=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-type">int</span> x) &#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;res+=a[i]*<span class="hljs-built_in">qpow</span>(x,b[i],modp)%modp;res%=modp;&#125;<span class="hljs-keyword">return</span> res;&#125;;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(modp,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;modp;++i) &#123;f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">calc</span>(i);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">25</span>;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;modp;++i) &#123;f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()%modp,y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">25</span>;++j) &#123;<span class="hljs-keyword">if</span>(y&gt;&gt;j&amp;<span class="hljs-number">1</span>) &#123;x=f[x][j];&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p>倍增的写法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">25</span>;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];&#125;&#125;</code></pre></div><p>选从 <span class="math inline">\(i\)</span> 开始的第 <span class="math inline">\(2^j\)</span> 个相当于选从 <span class="math inline">\(i\)</span> 往后 <span class="math inline">\(2^{j-1}\)</span> 处开始的第 <span class="math inline">\(2^{j-1}\)</span> 个。</p>          </div><h2 id="c.-imxcsld">C. ImxcslD</h2><p><a href="https://www.luogu.com.cn/problem/P9817?contestId=141486">Problem</a></p><div class="note note-info">            <p>题意：定义长度为 <span class="math inline">\(m\)</span> 的非空序列 <span class="math inline">\(p_1,p_2,...,p_m\)</span> 是<strong>乱</strong>的当且仅当满足以下条件。</p><ul><li><span class="math inline">\(\sum_{i=1}^m p_i\le n\)</span>。</li><li><span class="math inline">\(\forall\text{ } i\in[1,m]\)</span>，<span class="math inline">\(p_i=1\)</span> 或 <span class="math inline">\(p_i\)</span> 为质数。</li></ul><p>定义一个<strong>乱</strong>的序列 <span class="math inline">\(p_1,p_2,...,p_m\)</span> 的<strong>乱斗值</strong>为 <span class="math inline">\(\sum_{i=1}^m (p_i-k)^2\)</span>。</p><p>特别的，定义一个<strong>不乱</strong>的序列的乱斗值为 <span class="math inline">\(0\)</span>。</p><p>现在给定正整数 <span class="math inline">\(n,k\)</span>，问所有序列中<strong>乱斗值</strong>最大的序列的<strong>乱斗值</strong>是多少。</p><p><span class="math inline">\(1\le T\le 10^3\)</span>，<span class="math inline">\(1\le n\le 10^9\)</span>，<span class="math inline">\(1\le k\le 5\times 10^4\)</span>。</p>          </div><div class="note note-success">            <p>有难度的贪心。</p><p>考虑什么时候结果是最优的：我们要让 <span class="math inline">\((p_i-k)^2\)</span> 尽可能的大，也就是 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(k\)</span> 的差值大，分为两种情况：</p><ul><li>当 <span class="math inline">\(p_i&lt;k\)</span> 时，要离 <span class="math inline">\(k\)</span> 越远，肯定是全为 <span class="math inline">\(1\)</span> 最优。</li><li>当 <span class="math inline">\(p_i&gt;k\)</span> 时，考虑写上一个 <span class="math inline">\(p_i\)</span> 对答案的影响。<ul><li>一开始构造序列全为 <span class="math inline">\(1\)</span>，答案是 <span class="math inline">\(m(1-k)^2\)</span>。</li><li>写出一个 <span class="math inline">\(p_i\)</span> 时，相当于划掉了 <span class="math inline">\(p_i\)</span> 个 <span class="math inline">\(1\)</span>，答案增加了 <span class="math inline">\((p_i-k)^2-p_i(1-k)^2\)</span>。</li><li>发现每次变更总是可以选择大的 <span class="math inline">\(p_i\)</span>，而答案也只和当时 <span class="math inline">\(1\)</span> 的个数相关。</li><li>所以可以递归，每次选择小于等于 <span class="math inline">\(n\)</span> 的最大的质数 <span class="math inline">\(P\)</span>，看看最大值能不能更新，然后将问题递归到 <span class="math inline">\((n-P,k)\)</span>。</li></ul></li></ul><p>这并不严谨，需要感性理解。</p><p>复杂度不会分析，只能说感觉能接受？</p><p>预处理出质数表能 <span class="math inline">\(O(\frac{\sqrt{n}}{\ln n})\)</span> 查找质数，但事实 <span class="math inline">\(O(\sqrt{n})\)</span> 也完全卡不满。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> prime[N],mark[N],phi[N],tot_prime;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getphi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;        <span class="hljs-keyword">if</span>(!mark[i]) &#123;            prime[++tot_prime]=i;            phi[i]=i<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot_prime;j++) &#123;            <span class="hljs-keyword">if</span>(i*prime[j]&gt;n) &#123;            <span class="hljs-keyword">break</span>;            &#125;            mark[i*prime[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) &#123;                phi[i*prime[j]]=phi[i]*prime[j];                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> &#123;            phi[i*prime[j]]=phi[i]*phi[prime[j]];            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(tot_prime) &#123;<span class="hljs-keyword">return</span> x<span class="hljs-number">-1</span>==phi[x];&#125;<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(x);++i) &#123;<span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> res=n*(k<span class="hljs-number">-1</span>)*(k<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,sum=res;i&gt;=<span class="hljs-number">1</span>;--i) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isprime</span>(i)) &#123;sum-=i*(k<span class="hljs-number">-1</span>)*(k<span class="hljs-number">-1</span>);sum+=(k-i)*(k-i);res=<span class="hljs-built_in">max</span>(res,sum);n-=i;i=<span class="hljs-built_in">min</span>(n,i)+<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Luogu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>Luogu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】UESTC-XCPC集训队2023年9月招新赛 第二场</title>
    <link href="/posts/f9da5f78.html"/>
    <url>/posts/f9da5f78.html</url>
    
    <content type="html"><![CDATA[<p>比赛链接：<a href="https://vjudge.net/contest/583377#overview">Link</a></p><p>为避免 MyGO!!!!! 污染，以下均采用原题头。</p><p>按个人感官难度排序，及其主观。</p><p>题选的相当棒，值得反复品味。</p><h2 id="b.-hello-acmer">B. Hello, ACMer!</h2><div class="note note-info">            <p>题意：统计给定字符串中 <code>hznu</code> 的出现次数。</p>          </div><div class="note note-success">            <p>模拟即可。</p><p>记得特判字符串长度小于 <span class="math inline">\(4\)</span> 的情况。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;string s;cin&gt;&gt;s;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">4</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>),<span class="hljs-built_in">void</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-4</span>;++i) &#123;string t=s.<span class="hljs-built_in">substr</span>(i,<span class="hljs-number">4</span>);<span class="hljs-keyword">if</span>(t==<span class="hljs-string">&quot;hznu&quot;</span>) &#123;res++;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-new-string">C. New String</h2><div class="note note-info">            <p>题意：给定一个自定义字典序排序规则以及若干字符串，求字典序第 <span class="math inline">\(k\)</span> 小的串。</p><p><span class="math inline">\(1\le|S|\le 1000\)</span>。</p>          </div><div class="note note-success">            <p>用 <code>std::map</code> 还原字典序或自定义 <code>std::sort</code> 排序规则均可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;string all;cin&gt;&gt;all;map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; mp,yl;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;all.<span class="hljs-built_in">size</span>();++i) &#123;mp[all[i]]=(<span class="hljs-string">&#x27;a&#x27;</span>+i);yl[<span class="hljs-string">&#x27;a&#x27;</span>+i]=all[i];&#125;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;cin&gt;&gt;s[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;s[i].<span class="hljs-built_in">size</span>();++j) &#123;s[i][j]=mp[s[i][j]];&#125;&#125;<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> K=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s[K<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>();++i) &#123;cout&lt;&lt;yl[s[K<span class="hljs-number">-1</span>][i]];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;&#125;</code></pre></div>    </div></div><h2 id="l.-klees-wonderful-adventure">L. Klee's Wonderful Adventure</h2><div class="note note-info">            <p>题意：平面直角坐标系上有 <span class="math inline">\(n\)</span> 个点，相同第 <span class="math inline">\(i\)</span> 象限间点的移动速度为 <span class="math inline">\(v_i\)</span>，不同象限间点间的移动速度为 <span class="math inline">\(v_0\)</span>，求从起点 <span class="math inline">\(s\)</span> 到终点 <span class="math inline">\(t\)</span> 的最短时间。</p><p><span class="math inline">\(1\le n\le 3\times 10^3\)</span>。</p>          </div><div class="note note-success">            <p>注意到 <span class="math inline">\(n\)</span> 很小，直接预处理出通过任意两点所需的时间，再跑 <code>dijkstra</code> 就行了。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3002</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-type">int</span> x,y;&#125;a[N];<span class="hljs-type">double</span> dis[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">whd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span> &amp;&amp; y&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">-1</span> &amp;&amp; y&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">-1</span> &amp;&amp; y&lt;=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span> &amp;&amp; y&lt;=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> v[<span class="hljs-number">6</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();v[<span class="hljs-number">1</span>]=<span class="hljs-built_in">read</span>(),v[<span class="hljs-number">2</span>]=<span class="hljs-built_in">read</span>(),v[<span class="hljs-number">3</span>]=<span class="hljs-built_in">read</span>(),v[<span class="hljs-number">4</span>]=<span class="hljs-built_in">read</span>(),v[<span class="hljs-number">0</span>]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> st=<span class="hljs-built_in">read</span>(),ed=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i].x=<span class="hljs-built_in">read</span>(),a[i].y=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;dis[i][j]=<span class="hljs-built_in">sqrt</span>( (a[i].x-a[j].x)*(a[i].x-a[j].x) + (a[i].y-a[j].y)*(a[i].y-a[j].y));<span class="hljs-type">int</span> fir=<span class="hljs-built_in">whd</span>(a[i].x,a[i].y);<span class="hljs-type">int</span> sec=<span class="hljs-built_in">whd</span>(a[j].x,a[j].y);<span class="hljs-keyword">if</span>(fir==sec) &#123;dis[i][j]/=v[fir];&#125; <span class="hljs-keyword">else</span> &#123;dis[i][j]/=v[<span class="hljs-number">0</span>];&#125;&#125;&#125;vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;adj[i].<span class="hljs-built_in">push_back</span>(&#123;j,dis[i][j]&#125;);adj[j].<span class="hljs-built_in">push_back</span>(&#123;i,dis[i][j]&#125;);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">real_dis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dijkstra = [&amp;] (<span class="hljs-type">int</span> s) &#123;real_dis.<span class="hljs-built_in">assign</span>(n+<span class="hljs-number">1</span>,<span class="hljs-number">1.0</span>*inf);vis.<span class="hljs-built_in">assign</span>(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>);priority_queue&lt;pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt;&gt; q;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0.0</span>,s&#125;);real_dis[s]=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().second;q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[x]=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,z]:adj[x]) &#123;<span class="hljs-keyword">if</span>(real_dis[y]&gt;real_dis[x]+z) &#123;real_dis[y]=real_dis[x]+z;q.<span class="hljs-built_in">push</span>(&#123;-real_dis[y],y&#125;);&#125;&#125;&#125;&#125;;<span class="hljs-built_in">dijkstra</span>(st);<span class="hljs-type">double</span> ans=real_dis[ed];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8lf\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-check-problems">D. Check Problems</h2><div class="note note-info">            <p>题意：有 <span class="math inline">\(n\)</span> 个人查验题目，第 <span class="math inline">\(i\)</span> 个人在第 <span class="math inline">\(j\)</span> 秒会查验编号为 <span class="math inline">\(a_i+j-1\)</span> 的题。<span class="math inline">\(q\)</span> 次询问，每次问第 <span class="math inline">\(t\)</span> 秒时有多少道题目已经被查验。</p><p><span class="math inline">\(1\le n,q\le 5\times 10^5\)</span>，<span class="math inline">\(1\le a_1 \le a_2 \le \dots \le a_n \le 10^{18}\)</span>，<span class="math inline">\(0\le t \le 10^{18}\)</span>。</p>          </div><div class="note note-success">            <p>相当于数轴上 <span class="math inline">\(n\)</span> 个点，每个点每次向右扩张一个单位。</p><p>那么当一个点触到离它右边的一个点时，往后它就没有贡献了。</p><p>并且当一个点没有贡献时，间隔比它小对应的点也都没有了贡献，符合单调性。</p><p>因此我们把每个点间的间隔距离 <span class="math inline">\(a_i-a_{i-1}\)</span> 记录下来，排序，记录前缀和，再在上面二分。</p><p>每次查询总是前缀和 <span class="math inline">\(+\)</span> 没有扩张完的剩下段。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125; <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,x);&#125;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,a.<span class="hljs-built_in">end</span>());vector&lt;<span class="hljs-type">int</span>&gt; d;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;d.<span class="hljs-built_in">push_back</span>(a[i]-a[i<span class="hljs-number">-1</span>]);&#125;<span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(),d.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;sum[<span class="hljs-number">0</span>]=d[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;d.<span class="hljs-built_in">size</span>();++i) &#123;sum[i]=sum[i<span class="hljs-number">-1</span>]+d[i];&#125;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),pos;<span class="hljs-keyword">auto</span> p=<span class="hljs-built_in">upper_bound</span>(d.<span class="hljs-built_in">begin</span>(),d.<span class="hljs-built_in">end</span>(),x);<span class="hljs-keyword">if</span>(p==d.<span class="hljs-built_in">end</span>()) &#123;pos=n<span class="hljs-number">-1</span>; &#125; <span class="hljs-keyword">else</span> &#123; pos=p-d.<span class="hljs-built_in">begin</span>(); &#125; <span class="hljs-type">int</span> res = pos==<span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : sum[pos<span class="hljs-number">-1</span>]; res+=(n-pos)*x; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;&#125;</code></pre></div>    </div></div><h2 id="e.-tree-problem">E. Tree Problem</h2><div class="note note-info">            <p>题意：给定 <span class="math inline">\(n\)</span> 个点的树，<span class="math inline">\(q\)</span> 次询问每次询问一个点 <span class="math inline">\(x\)</span>，问树上有多少条简单路径途径点 <span class="math inline">\(x\)</span>。</p><p><span class="math inline">\(2\le n \le 10^5\)</span>，<span class="math inline">\(1\le q\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>简单画个图，经过 <span class="math inline">\(x\)</span> 的简单路径的数量就是 <span class="math inline">\(x\)</span> 所有子树大小的两两乘积。</p><p>由于每个子树算了两遍，贡献要除以 <span class="math inline">\(2\)</span>。</p><p>别忘记 <span class="math inline">\(x\)</span> 作为简单路径端点的 <span class="math inline">\(n-1\)</span> 种情况。</p><p>时间复杂度 <span class="math inline">\(O(n+q)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">fa</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs = [&amp;] (<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath) &#123;sz[x]=<span class="hljs-number">1</span>;fa[x]=fath;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y==fath) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);sz[x]+=sz[y];&#125;&#125;;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> calc = [&amp;](<span class="hljs-type">int</span> x)&#123;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y==fa[x]) &#123;sum+=(n-sz[x]);&#125; <span class="hljs-keyword">else</span> &#123;sum+=sz[y];&#125;&#125;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y==fa[x]) &#123;res+=(n-sz[x])*(sum-(n-sz[x]));&#125; <span class="hljs-keyword">else</span> &#123;res+=sz[y]*(sum-sz[y]);&#125;&#125;<span class="hljs-keyword">return</span> res/<span class="hljs-number">2</span>+n<span class="hljs-number">-1</span>;&#125;; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!ans[x]) &#123;ans[x]=<span class="hljs-built_in">calc</span>(x);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[x]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;&#125;</code></pre></div>    </div></div><h2 id="g.-subarrays">G. Subarrays</h2><div class="note note-info">            <p>题意：给定长度为 <span class="math inline">\(n\)</span> 的正整数序列 <span class="math inline">\(a\)</span>，求满足子段和为 <span class="math inline">\(k\)</span> 的倍数的子段数量。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(1\le k,a_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>令 <span class="math inline">\(sum\)</span> 为前缀和，即求满足 <span class="math inline">\(sum[l,r]\equiv 0 \pmod k\)</span> 的区间个数。</p><p>即： <span class="math display">\[sum[l,r] \bmod k =(sum[r]-sum[l-1])\bmod k = 0\]</span> 也就是： <span class="math display">\[sum[l-1]\equiv sum[r] \pmod k\]</span> 于是题目变成了对每个位置 <span class="math inline">\(i\)</span> 求小于 <span class="math inline">\(i\)</span> 的所有前缀和中有多少模 <span class="math inline">\(k\)</span> 值相同，用 <code>std::map</code> 维护即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">sum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];&#125;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cnt;cnt[<span class="hljs-number">0</span>]++;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;res+=cnt[sum[i]%k];cnt[sum[i]%k]++;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="f.-easy-problem">F. Easy Problem</h2><div class="note note-info">            <p>题意：<span class="math inline">\(A,B\)</span> 在 <span class="math inline">\(n\times n\)</span> 的网格图上游走，每次移动它们能选择上下左右四个方向中的一个，然后两个人按该方向行走一格（如前方是边界或障碍物则不移动），问两人相遇所需的最小移动步数。</p><p><span class="math inline">\(2\le n \le 50\)</span>。</p>          </div><div class="note note-success">            <p>只要想到把两个玩家的位置同时压缩成一个状态就迎刃而解了。</p><p>令 <span class="math inline">\(dep[ax][ay][bx][by]\)</span> 为 <span class="math inline">\(A\)</span> 在点 <span class="math inline">\((ax,ay)\)</span>，<span class="math inline">\(B\)</span> 在点 <span class="math inline">\((bx,by)\)</span> 时两人相遇所需的最短步数。</p><p>广度优先搜索，每次移动若新位置对应的状态非 <span class="math inline">\(0\)</span>，则代表有更短的路径到达那个位置。</p><p>那么我们不移动，否则步数 <span class="math inline">\(+1\)</span> 进行转移。</p><p>当 <span class="math inline">\((ax,ay)=(bx,by)\)</span> 时代表两人到达同一点。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-type">int</span> sx,sy,fx,fy;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;cin&gt;&gt;s[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) &#123;<span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;a&#x27;</span>) &#123;sx=i;sy=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;b&#x27;</span>) &#123;fx=i;fy=j;&#125;&#125;&#125;<span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; node;<span class="hljs-type">int</span> dx[]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;queue&lt;node&gt; q;map&lt;node,<span class="hljs-type">int</span>&gt; dep;dep[&#123;sx,sy,fx,fy&#125;]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;sx,sy,fx,fy&#125;);<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> point=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">auto</span> [ax,ay,bx,by]=point;<span class="hljs-keyword">if</span>(ax==bx &amp;&amp; ay==by) &#123;<span class="hljs-type">int</span> res=dep[point];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i) &#123;<span class="hljs-type">int</span> nax=ax+dx[i],nay=ay+dy[i];<span class="hljs-type">int</span> nbx=bx+dx[i],nby=by+dy[i];<span class="hljs-keyword">if</span>(nax&lt;<span class="hljs-number">0</span> || nax&gt;=n || nay&lt;<span class="hljs-number">0</span> || nay&gt;=n || s[nax][nay]==<span class="hljs-string">&#x27;*&#x27;</span>) &#123;nax=ax;nay=ay;&#125;<span class="hljs-keyword">if</span>(nbx&lt;<span class="hljs-number">0</span> || nbx&gt;=n || nby&lt;<span class="hljs-number">0</span> || nby&gt;=n || s[nbx][nby]==<span class="hljs-string">&#x27;*&#x27;</span>) &#123;nbx=bx;nby=by;&#125;node npoint=&#123;nax,nay,nbx,nby&#125;;<span class="hljs-keyword">if</span>(dep.<span class="hljs-built_in">find</span>(npoint)==dep.<span class="hljs-built_in">end</span>()) &#123;q.<span class="hljs-built_in">push</span>(npoint);dep[npoint]=dep[point]+<span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;no solution&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="j.-ihis-homework">J. IHI's Homework</h2><div class="note note-info">            <p>题意：给定整数 <span class="math inline">\(s\)</span> 和序列 <span class="math inline">\(a\)</span>，令答案为满足 <span class="math inline">\(x_1+x_2+\dots+x_n\le s\)</span> 且 <span class="math inline">\(\forall x_i \ge a_i\)</span> 的序列 <span class="math inline">\(x\)</span> 的方案数。<span class="math inline">\(q\)</span> 次询问每次更改 <span class="math inline">\(a\)</span> 中的一个数，问每次变动后的答案。</p><p><span class="math inline">\(1\le n,q,a_i \le 2\times 10^5\)</span>，<span class="math inline">\(0\le s\le 2\times 10^5\)</span>。</p>          </div><div class="note note-success">            <p>简单排列组合，但我不会数学，这题就显得很难。</p><p>将题目转化成球盒问题，有 <span class="math inline">\(n\)</span> 个盒子和 <span class="math inline">\(s\)</span> 个球，将无区分的球放进有区分的盒子，可以有空盒，且第 <span class="math inline">\(i\)</span> 个盒子至少得有 <span class="math inline">\(x_i\)</span> 个球，每次修改一个 <span class="math inline">\(x_i\)</span>，问方案数。</p><p>首先把每个盒子放入 <span class="math inline">\(x_i\)</span> 个球，剩下 <span class="math inline">\(t=s-\sum x_i\)</span> 个球可以任意放入 <span class="math inline">\(n\)</span> 个盒子。</p><p>结论：<span class="math inline">\(n\)</span> 个无区别球放入 <span class="math inline">\(m\)</span> 个有区别盒子，允许空盒的方案数是 <span class="math inline">\(C_{m+n-1}^{n}\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Why?    </div>    <div class='spoiler-content'>        <p>高中数学学过插板法。</p><p>如果每个盒子至少有一个球，那么我们可以用 <span class="math inline">\(m-1\)</span> 个板去插 <span class="math inline">\(n-1\)</span> 个空，方案数是 <span class="math inline">\(C_{n-1}^{m-1}\)</span>。</p><p>如果允许空盒，那么要做一个转化：</p><p>转化为 <span class="math inline">\(n\)</span> 个无区别球和 <span class="math inline">\(m-1\)</span> 个无区别板的一个自由排列，再把这 <span class="math inline">\(m-1\)</span> 个板选出来，也就是 <span class="math inline">\(C_{n+m-1}^{m-1}=C_{n+m-1}^{n}\)</span>。</p>    </div></div><div class="note note-success">            <p>那么答案就是： <span class="math display">\[\sum_{i=1}^t C_{n+i-1}^{i}\]</span> 发现对于相同的 <span class="math inline">\(t\)</span> 答案相同，那么只要预处理出上式的前缀和就可以 <span class="math inline">\(O(1)\)</span> 回答询问。</p><p>时间复杂度 <span class="math inline">\(O(n+s+q)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;    <span class="hljs-type">int</span> x;    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == a.x; &#125;;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x != a.x; &#125;;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * y * a.x % mod);&#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(y) / a;&#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="hljs-keyword">return</span> is &gt;&gt; t.x;&#125;    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;            mul *= mul;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (b) &#123;            <span class="hljs-type">int</span> t = a / b;            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);        &#125;        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;        <span class="hljs-keyword">return</span> u;    &#125;    &#125;;<span class="hljs-keyword">using</span> mint = ModInt&lt;modp&gt;;<span class="hljs-function"><span class="hljs-keyword">inline</span> mint <span class="hljs-title">qpow</span><span class="hljs-params">(mint k,<span class="hljs-type">int</span> n)</span> </span>&#123;mint s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s=s*k;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">math</span> &#123;<span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;vector&lt;mint&gt; frac;vector&lt;mint&gt; inv;<span class="hljs-built_in">math</span>() &#123;&#125;<span class="hljs-built_in">math</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;frac.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);inv.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);frac[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size+<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;frac[i]=frac[i<span class="hljs-number">-1</span>]*i;&#125;inv[n]=<span class="hljs-built_in">qpow</span>(frac[n],modp<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=size+<span class="hljs-number">1</span>;--i) &#123;inv[i<span class="hljs-number">-1</span>]=inv[i]*i;&#125;size=n;&#125;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m || m&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(n&gt;size) <span class="hljs-built_in">init</span>(n);<span class="hljs-keyword">return</span> frac[n]*inv[m]*inv[n-m];&#125;&#125;binom;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">return</span> binom.<span class="hljs-built_in">C</span>(n,m); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),s=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();sum+=a[i];&#125;<span class="hljs-function">vector&lt;mint&gt; <span class="hljs-title">p</span><span class="hljs-params">(s+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;++i) &#123;p[i]=<span class="hljs-built_in">C</span>(n+i<span class="hljs-number">-1</span>,i);<span class="hljs-keyword">if</span>(i) p[i]+=p[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> pos=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>();sum+=x-a[pos];a[pos]=x;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s-sum&gt;=<span class="hljs-number">0</span> ? p[s-sum] : <span class="hljs-number">0ll</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="k.-ihis-magic-string">K. IHI's Magic String</h2><div class="note note-info">            <p>题意：现在有一个空字符串和三种操作，输出 <span class="math inline">\(q\)</span> 次操作后的字符串。</p><ol type="1"><li>把一个指定小写字母插到末尾。</li><li>删除字符串末尾的字符（若为空字符串则不操作）</li><li>把目前所有的字符 <span class="math inline">\(x\)</span> 替换成字符 <span class="math inline">\(y\)</span>。</li></ol><p><span class="math inline">\(1\le q \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>一般这种正着做简单但时间复杂度高的题总是考虑倒着做。</p><p>倒着做的好处在于：假设有操作 <span class="math inline">\(a\to b\)</span>，那么之后添加的 <span class="math inline">\(a\)</span> 都可以直接用 <span class="math inline">\(b\)</span> 替代，那如果再有 <span class="math inline">\(b\to c\)</span> 呢？</p><p>用 <span class="math inline">\(mp[i]\)</span> 表示在添加 <span class="math inline">\(i\)</span> 时应该添加 <span class="math inline">\(mp[i]\)</span>，初始 <span class="math inline">\(mp[i]=i\)</span>。</p><p>那么对于上面那种情况实际等效于 <span class="math inline">\(a\to c\)</span>，我们直接 <span class="math inline">\(mp[a]=mp[b]\)</span>。</p><p>这其实类似并查集的路径压缩方法。</p><p>对于删除操作，可以直接用一个延迟标记（这里是 <span class="math inline">\(\text{del}\)</span>），来 <span class="math inline">\(O(1)\)</span> 判断当前字符是否计入答案，很妙。</p><p>时间复杂度 <span class="math inline">\(O(q\log 26)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; ver;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> opt=<span class="hljs-built_in">read</span>(),a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> t[<span class="hljs-number">3</span>];<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;t);a=t[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;t);a=t[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;t);b=t[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>;&#125;ver.<span class="hljs-built_in">push_back</span>(&#123;opt,a,b&#125;);&#125;map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i) &#123;mp[i]=i;&#125;<span class="hljs-type">int</span> del=<span class="hljs-number">0</span>;string res=<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ver.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-keyword">auto</span> [opt,a,b] = ver[i];<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(del) &#123;del--;&#125; <span class="hljs-keyword">else</span> &#123;res+=mp[a]+<span class="hljs-string">&#x27;a&#x27;</span>;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>) &#123;del++;&#125; <span class="hljs-keyword">else</span> &#123;mp[a]=mp[b];&#125;&#125;<span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The final string is empty&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;cout&lt;&lt;res&lt;&lt;endl;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="i.-optimal-biking-strategy">I. Optimal Biking Strategy</h2><div class="note note-info">            <p>题意：<span class="math inline">\(\text{Alice}\)</span> 要去到 <span class="math inline">\(p\)</span> 米外的超市，他可以走路或骑车。路上有 <span class="math inline">\(n\)</span> 个停车点，能且仅能在停车点上下车，一块钱最多能骑 <span class="math inline">\(s\)</span> 米（骑 <span class="math inline">\(x\)</span> 米需花费 <span class="math inline">\(\left\lceil \frac{x}{s} \right\rceil\)</span> 元）。他现在只有 <span class="math inline">\(k\)</span> 元，问最少需要走路多远。</p><p><span class="math inline">\(1\le n \le 10^6\)</span>，<span class="math inline">\(1\le p,s \le 10^9\)</span>，<span class="math inline">\(1\le k\le 5\)</span>。</p>          </div><div class="note note-success">            <p>场上写了一个 <span class="math inline">\(O(nk\log n)\)</span> 很奇怪的背包一直调不出来，后面发现完全是假的。</p><p>感觉我到现在对于 <span class="math inline">\(\text{dp}\)</span> 一直是模棱两可的状态，很烦。</p><p>用 <span class="math inline">\(dp_{i,j}\)</span> 代表前 <span class="math inline">\(i\)</span> 个停车点花费 <span class="math inline">\(j\)</span> 能骑的最远距离，那么答案就是 <span class="math inline">\(p-dp_{n,k}\)</span> 。</p><p>至于转移，根据题意算钱要上取整，所以多个相邻的骑车区间肯定是直接合并。</p><p>因为连续，所以可以二分，对于每一个 <span class="math inline">\(k\in[1,j]\)</span> 二分出花费 <span class="math inline">\(k\)</span> 能骑到的最远距离再转移。</p><p>具体地，当前在 <span class="math inline">\(i\)</span>，就从满足 <span class="math inline">\(a_i-a_l\le sk\)</span> 的最远的 <span class="math inline">\(l\)</span> 处转移而来，即： <span class="math display">\[dp_{i,j}=\max(dp_{i,j},dp_{l,j-k}+a_i-a_l)\]</span> 时间复杂度 <span class="math inline">\(O(nk^2\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;    <span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),dis=<span class="hljs-built_in">read</span>(),per_cost=<span class="hljs-built_in">read</span>();    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        a[i]=<span class="hljs-built_in">read</span>();    &#125;    <span class="hljs-type">int</span> V=<span class="hljs-built_in">read</span>();    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(V+<span class="hljs-number">1</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=V;++j) &#123;            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j];            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=j;++k) &#123;                <span class="hljs-type">int</span> mx=per_cost*k;                <span class="hljs-comment">// a[i]-a[lst]&lt;=mx</span>                <span class="hljs-comment">// a[lst]&gt;=a[i]-mx</span>                <span class="hljs-type">int</span> id=<span class="hljs-built_in">lower_bound</span>(a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,a.<span class="hljs-built_in">end</span>(),a[i]-mx)-a.<span class="hljs-built_in">begin</span>();                <span class="hljs-keyword">if</span>(id&lt;=n) &#123;                    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[id][j-k]+a[i]-a[id]);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> res=dis-dp[n][V];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//fre(test);</span>    <span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(T--) &#123;        <span class="hljs-built_in">solve</span>();        <span class="hljs-comment">//fflush(stdout);</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="h.-ganyu-segment-tree">H. Ganyu Segment Tree</h2><div class="note note-info">            <p>题意：给定一个长度 <span class="math inline">\(n\)</span> 初值全为 <span class="math inline">\(1\)</span> 的序列 <span class="math inline">\(a\)</span>，每个位置有上锁和不上锁两种状态。</p><p>三种操作，共操作 <span class="math inline">\(m\)</span> 次：</p><ul><li><code>flip p</code> ：改变 <span class="math inline">\(a_p\)</span> 的状态。</li><li><code>mul l r x</code> ：把子段 <span class="math inline">\([l,r]\)</span> 中所有未上锁元素乘以 <span class="math inline">\(x\)</span>。</li><li><code>div l r x</code> ：查询子段 <span class="math inline">\([l,r]\)</span> 中所有元素（包括上锁）是否是 <span class="math inline">\(x\)</span> 的倍数，输出 <code>Yes</code> 或 <code>No</code> 。若为 <code>Yes</code> ，将 <span class="math inline">\([l,r]\)</span> 中的所有未上锁元素除以 <span class="math inline">\(x\)</span>。</li></ul><p><span class="math inline">\(1\le n,m \le 10^5\)</span>，<span class="math inline">\(1\le x \le 30\)</span>。</p>          </div><div class="note note-success">            <p>修改的数 <span class="math inline">\(x\)</span> 很小，所以可以把 <span class="math inline">\(x\)</span> 质因数分解，而 <span class="math inline">\([1,30]\)</span> 内就 <span class="math inline">\(10\)</span> 个质数。</p><p>我们对每个质数都建一颗线段树，而处理是否能整除只需判断是否该区间都含有某个质因子。</p><p>具体的，对于操作 <code>mul l r x</code>，若 <span class="math inline">\(x\)</span> 能分解成 <span class="math inline">\(cnt\)</span> 个质因子 <span class="math inline">\(y\)</span>，则在 <span class="math inline">\(y\)</span> 所属的线段树上区间 <span class="math inline">\(+ cnt\)</span>。</p><p>那么对于操作 <code>div l r x</code>，检查 <span class="math inline">\(x\)</span> 的每个质因子 <span class="math inline">\(y\)</span>，若 <span class="math inline">\(y\)</span> 所属的线段树在 <span class="math inline">\([l,r]\)</span> 内的区间最小值比 <span class="math inline">\(cnt\)</span> 小，那么该区间不能被整除。否则区间 <span class="math inline">\(-cnt\)</span>。</p><p>现在考虑如何维护解锁与未解锁。是一个很清奇的技巧：</p><p>对于每颗线段树开两个值 <span class="math inline">\(tr1,tr2\)</span>，分别代表当前区间未锁定元素的最小值和区间锁定元素的最小值，初始化 <span class="math inline">\(tr1=0,tr2=inf\)</span>。</p><p>对于 <code>mul</code> 和 <code>div</code> 操作，只对 <span class="math inline">\(tr1\)</span> 进行操作。</p><p>对于 <code>flip</code> 操作，只需单点 <span class="math inline">\(swap(tr1,tr2)\)</span>。</p><p>对于查询操作，我们返回 <span class="math inline">\(\min(tr1,tr2)\)</span>。</p><p>我们发现 <span class="math inline">\(inf\)</span> 和加减的值不在一个数量级，相当于没有影响，所以这么做是正确的。</p><p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout)</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; tree1,tree2;vector&lt;<span class="hljs-type">int</span>&gt; lazy_add;<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size) &#123;n = size+<span class="hljs-number">1</span>;tree1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);tree2.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n+<span class="hljs-number">1</span>,inf);lazy_add.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;tree1[p] = <span class="hljs-built_in">min</span>(tree1[p&lt;&lt;<span class="hljs-number">1</span>], tree1[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);tree2[p] = <span class="hljs-built_in">min</span>(tree2[p&lt;&lt;<span class="hljs-number">1</span>], tree2[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> </span>&#123;<span class="hljs-keyword">if</span>(lazy_add[p]) &#123;<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   += lazy_add[p];lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] += lazy_add[p];tree1[p&lt;&lt;<span class="hljs-number">1</span>]       += lazy_add[p];tree1[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]     += lazy_add[p];lazy_add[p] = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_build</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<span class="hljs-keyword">if</span>(left == right) &#123;tree1[p] = nums[left];tree2[p] = inf;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">in_build</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,nums);<span class="hljs-built_in">in_build</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,nums);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_add</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;tree1[p]    += val;lazy_add[p] += val;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql &lt;= mid) <span class="hljs-built_in">update_add</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);<span class="hljs-keyword">if</span>(qr &gt; mid)  <span class="hljs-built_in">update_add</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,ql,qr,val);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_change</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ql &lt;= left &amp;&amp; qr &gt;= right) &#123;            <span class="hljs-built_in">swap</span>(tree1[p], tree2[p]);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">pushdown</span>(p,left,right);            <span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (ql &lt;= mid) <span class="hljs-built_in">update_change</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);            <span class="hljs-keyword">if</span> (qr &gt; mid)  <span class="hljs-built_in">update_change</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,ql,qr,val);            <span class="hljs-built_in">pushup</span>(p);        &#125;    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(tree1[p], tree2[p]);&#125;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-type">int</span> res = inf;<span class="hljs-keyword">if</span>(ql &lt;= mid) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">range_query</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr));<span class="hljs-keyword">if</span>(qr &gt; mid)  res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">range_query</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,ql,qr));<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<span class="hljs-built_in">in_build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,nums);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-built_in">update_add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-built_in">update_change</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr);&#125;&#125;;<span class="hljs-type">int</span> prime[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;SegmentTree&gt; <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">10</span>,SegmentTree(n))</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;seg[i].<span class="hljs-built_in">build</span>(a);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">char</span> opt[<span class="hljs-number">5</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;opt);<span class="hljs-keyword">if</span>(opt[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;f&#x27;</span>) &#123;<span class="hljs-type">int</span> pos=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;seg[i].<span class="hljs-built_in">change</span>(pos,pos,<span class="hljs-number">0</span>);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;m&#x27;</span>) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%prime[i]==<span class="hljs-number">0</span>) &#123;cnt++;x/=prime[i];&#125;seg[i].<span class="hljs-built_in">add</span>(l,r,cnt);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>();<span class="hljs-type">bool</span> ok=<span class="hljs-literal">true</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;<span class="hljs-keyword">while</span>(x%prime[i]==<span class="hljs-number">0</span>) &#123;cnt[i]++;x/=prime[i];&#125;<span class="hljs-keyword">if</span>(seg[i].<span class="hljs-built_in">query</span>(l,r)&lt;cnt[i]) &#123;ok=<span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">if</span>(!ok) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;seg[i].<span class="hljs-built_in">add</span>(l,r,-cnt[i]);&#125;&#125;&#125;&#125; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="a.-skills">A. Skills</h2><div class="note note-info">            <p>题意：现有 <span class="math inline">\(3\)</span> 项技能，编号 <span class="math inline">\(1,2,3\)</span>。初始每项技能的熟练度为 <span class="math inline">\(0\)</span>。接下来有 <span class="math inline">\(n\)</span> 天，第 <span class="math inline">\(i\)</span> 天可以选择一项技能（假设是第 <span class="math inline">\(j\)</span> 项）进行练习，然后在这天结束时让这项技能的熟练度增加 <span class="math inline">\(a_{i,j}\)</span>。同时，如果某一项技能（假设是第 <span class="math inline">\(k\)</span> 项）已经有 <span class="math inline">\(x\)</span> 天没有练习，那么在这天结束时，这项技能的熟练度会减少 <span class="math inline">\(x\)</span>（不会减少到 <span class="math inline">\(0\)</span> 以下）。</p><p>问在第 <span class="math inline">\(n\)</span> 天结束后，这 <span class="math inline">\(3\)</span> 项技能的熟练度之和最大为多少。</p><p><span class="math inline">\(1\le n \le 1000\)</span>，<span class="math inline">\(\forall\text{ } 1\le i\le n\)</span>，<span class="math inline">\(1\le j \le 3\)</span>，<span class="math inline">\(0\le a_{i,j} \le 10^4\)</span>。</p>          </div><div class="note note-success">            <p><span class="math inline">\(\text{dp}\)</span> 题。</p><p>首先要注意到最优解里面，一个技能如果开始学习了，那么中间过程熟练度不会降到 <span class="math inline">\(0\)</span> 以下。否则不如不学。</p><p>其次假如一个技能有 <span class="math inline">\(t\)</span> 天没有学习，那么将会损失 <span class="math inline">\(1+2+\dots+t=\dfrac{t(t+1)}{2}\)</span> 点熟练度。</p><p>也就是说一个技能如果开始学习了，不会停止学习超过 <span class="math inline">\(2\sqrt W +O(1)\)</span> 天，其中 <span class="math inline">\(W=\max (a_{i,j})\)</span>。</p><p>令 <span class="math inline">\(dp_{i,j,x,y}\)</span> 代表到第 <span class="math inline">\(i\)</span> 天，在这天选择练习技能 <span class="math inline">\(j\)</span> ，其它两项技能分别有 <span class="math inline">\(x\)</span> 天和 <span class="math inline">\(y\)</span> 天没有练习了能带来的最大收益。每次转移从上一天练习的三种情况转移而来。</p><p>那么 <span class="math inline">\(ans=\max(dp_{n,1\sim 3,0\sim W,0\sim W})\)</span>。</p><p>其中第一维可以滚动，总状态数不超过 <span class="math inline">\(O(W^2)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(nW^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout)</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">205</span>;<span class="hljs-type">int</span> arr[N][<span class="hljs-number">3</span>];<span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][W][W];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j) &#123;arr[i][j]=<span class="hljs-built_in">read</span>();&#125;&#125;<span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>],<span class="hljs-number">-0x3f</span>,<span class="hljs-keyword">sizeof</span> dp[<span class="hljs-number">0</span>]);dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> lst=<span class="hljs-number">1</span>,now=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;a&lt;n;++a) &#123;lst^=<span class="hljs-number">1</span>;now^=<span class="hljs-number">1</span>;<span class="hljs-built_in">memset</span>(dp[now],<span class="hljs-number">-0x3f</span>,<span class="hljs-keyword">sizeof</span> dp[now]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;b&lt;<span class="hljs-number">3</span>;++b) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;c&lt;W;++c) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;d&lt;W;++d) &#123;<span class="hljs-type">int</span> x=(!c) ? <span class="hljs-number">0ll</span> : c+<span class="hljs-number">1</span>;<span class="hljs-type">int</span> y=(!d) ? <span class="hljs-number">0ll</span> : d+<span class="hljs-number">1</span>;dp[now][b][x][y]=<span class="hljs-built_in">max</span>(dp[now][b][x][y],dp[lst][b][c][d]+arr[a][b]-x-y);                    dp[now][(b+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][y][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[now][(b+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>][y][<span class="hljs-number">1</span>],dp[lst][b][c][d]+arr[a][(b+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>]<span class="hljs-number">-1</span>-y);                    dp[now][(b+<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>][x]=<span class="hljs-built_in">max</span>(dp[now][(b+<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>][x],dp[lst][b][c][d]+arr[a][(b+<span class="hljs-number">2</span>)%<span class="hljs-number">3</span>]<span class="hljs-number">-1</span>-x);&#125;&#125;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">3</span>;++a) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;b&lt;W;++b) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;c&lt;W;++c) &#123;ans=<span class="hljs-built_in">max</span>(ans,dp[now][a][b][c]);&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>UESTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】蓝桥算法双周赛 第一场</title>
    <link href="/posts/55f142fc.html"/>
    <url>/posts/55f142fc.html</url>
    
    <content type="html"><![CDATA[<h2 id="d.-健身">D. 健身</h2><div class="note note-info">            <p>题意：在未来 <span class="math inline">\(1\sim n\)</span> 天中可以安排健身计划。有 <span class="math inline">\(m\)</span> 个健身计划，第 <span class="math inline">\(i\)</span> 个计划需要连续的 <span class="math inline">\(2^{k_i}\)</span> 天，增益为 <span class="math inline">\(s_i\)</span>。一个计划可以多次完成并获得多次增益，但一天不能同时进行多个计划。在 <span class="math inline">\(1\sim n\)</span> 天中有 <span class="math inline">\(q\)</span> 天有其它安排，不能健身。问能获得的最大增益。</p><p><span class="math inline">\(1\le q\le n \le 2\times 10^5\)</span>，<span class="math inline">\(1\le m \le 50\)</span>，<span class="math inline">\(1\le s_i \le 10^9\)</span>，<span class="math inline">\(0\le k \le 20\)</span>。</p>          </div><div class="note note-success">            <p>对于相同的 <span class="math inline">\(k\)</span>，显然只需要保留增益最大的 <span class="math inline">\(s_i\)</span>。</p><p>令 <span class="math inline">\(w_k\)</span> 表示锻炼 <span class="math inline">\(2^k\)</span> 天能得到的最大增益值。</p><p>令 <span class="math inline">\(dp_i\)</span> 表示锻炼到 <span class="math inline">\(i\)</span> 天可以得到的最大增益，那么： <span class="math display">\[dp_i=\max(dp_{i-1},dp_{i-2^k}+w_k)\]</span> 转移的前提是第 <span class="math inline">\(i-2^k+1\)</span> 天到第 <span class="math inline">\(i\)</span> 天必须空闲。</p><p>判断一段时间是否空闲可以用前缀和 <span class="math inline">\(O(1)\)</span> 判断。</p><p>时间复杂度 <span class="math inline">\(O(nk)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();sum[x]++;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;sum[i]+=sum[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>(),s=<span class="hljs-built_in">read</span>();val[k]=<span class="hljs-built_in">max</span>(val[k],s);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;dp[i]=dp[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">22</span>;++k) &#123;<span class="hljs-type">int</span> step=<span class="hljs-number">1</span>&lt;&lt;k;<span class="hljs-keyword">if</span>(i-step&gt;=<span class="hljs-number">1</span> &amp;&amp; sum[i]-sum[i-step]==<span class="hljs-number">0</span>) &#123;dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[i-step]+val[k]);&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="e.-契合匹配">E. 契合匹配</h2><div class="note note-info">            <p>题意：用一个首尾相接的由英文字母组成的字符串表示一个齿轮。两个齿轮是契合的当且仅当每个对应位是同一个字母的大小写，如 <code>AbCDeFgh</code> 和 <code>aBcdEfGH</code> 。齿轮是环形的，问第一个齿轮 <span class="math inline">\(S\)</span> 至少旋转多少位能与第二个齿轮 <span class="math inline">\(T\)</span> 完全契合，或无论如何都不能契合。</p><p><span class="math inline">\(1\le |S|,|T|\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>套路：破环成链。</p><p>以题例为例，<span class="math inline">\(S=\text{AbCDeFgh}\)</span>，延长一倍后变成 <span class="math inline">\(S=\text{AbCDeFghAbCDeFgh}\)</span>。</p><p>另外，可以将 <span class="math inline">\(S\)</span> 大小写反转，变成纯粹的字符串匹配问题，如反转后：</p><p><span class="math inline">\(S=\text{aBcdEfGHaBcdEfGH}\)</span>，<span class="math inline">\(T=\text{aBcdEfGH}\)</span></p><p>那么假设 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 中出现的首位为 <span class="math inline">\(p\)</span>，则 <span class="math inline">\(ans=\min(p-1,n-p+1)\)</span>。</p><p>利用 KMP 算法匹配字符串，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();string a,b;cin&gt;&gt;a&gt;&gt;b;a+=a;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">islower</span>(a[i])) &#123;a[i]=<span class="hljs-built_in">toupper</span>(a[i]);&#125; <span class="hljs-keyword">else</span> &#123;a[i]=<span class="hljs-built_in">tolower</span>(a[i]);&#125;&#125;<span class="hljs-comment">// find b in a</span>vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">auto</span> KMP = [&amp;] (string a,string b) &#123;<span class="hljs-type">int</span> ha=a.<span class="hljs-built_in">size</span>();<span class="hljs-type">int</span> hb=b.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>) &#123;ha--;&#125; <span class="hljs-keyword">else</span> &#123;a=<span class="hljs-string">&#x27; &#x27;</span>+a;&#125;<span class="hljs-keyword">if</span>(b[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>) &#123;hb--;&#125; <span class="hljs-keyword">else</span> &#123;b=<span class="hljs-string">&#x27; &#x27;</span>+b;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(hb+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,p=<span class="hljs-number">0</span>;i&lt;=hb;++i) &#123;<span class="hljs-keyword">while</span>(p &amp;&amp; b[i]!=b[p+<span class="hljs-number">1</span>]) &#123;p=nxt[p];&#125;<span class="hljs-keyword">if</span>(b[i]==b[p+<span class="hljs-number">1</span>]) &#123;p++;&#125;nxt[i]=p;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,p=<span class="hljs-number">0</span>;i&lt;=ha;++i) &#123;<span class="hljs-keyword">while</span>(p &amp;&amp; a[i]!=b[p+<span class="hljs-number">1</span>]) &#123;p=nxt[p];&#125;<span class="hljs-keyword">if</span>(a[i]==b[p+<span class="hljs-number">1</span>]) &#123;p++;&#125;<span class="hljs-keyword">if</span>(p==hb) &#123;ans.<span class="hljs-built_in">push_back</span>(i-hb+<span class="hljs-number">1</span>);p=nxt[p];&#125;&#125;<span class="hljs-keyword">return</span> nxt;&#125;;<span class="hljs-built_in">KMP</span>(a,b);<span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-type">int</span> res=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:ans) &#123;res=<span class="hljs-built_in">min</span>(res,k<span class="hljs-number">-1</span>);res=<span class="hljs-built_in">min</span>(res,n-(k<span class="hljs-number">-1</span>));&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="f.-奇怪的线段">F. 奇怪的线段</h2><div class="note note-info">            <p>题意：数轴上给定 <span class="math inline">\(n\)</span> 个线段 <span class="math inline">\([l_i,r_i]\)</span>。<span class="math inline">\(q\)</span> 次询问两个点 <span class="math inline">\(a,b\)</span> 问有多少个线段包含 <span class="math inline">\(a\)</span> 而不含 <span class="math inline">\(b\)</span>。</p><p><span class="math inline">\(1\le n,q,a_i,b_i \le 2 \times 10^5\)</span>，<span class="math inline">\(1\le l_i &lt; r_i \le 2\times 10^5\)</span>。</p>          </div><div class="note note-success">            <p>先考虑只有条件 “ 有多少个线段包含 <span class="math inline">\(a\)</span> ” 怎么做。</p><p>用一个 <code>vector</code> 存以 <span class="math inline">\(i\)</span> 为左端点的线段的右端点是哪些。</p><p>从左到右扫，每遇到一个左端点就把右端点插进线段树（单点加一），每遇到一个右端点就把该点从线段树中删掉（单点减一），遇到 <span class="math inline">\(a\)</span> 时查询线段树中的节点数量（区间求和）就是答案。</p><p>ps. 数轴上的一个点可能是多个线段的左/右端点，所以实际上我们是减去对应 <code>vector</code> 的大小。</p><p>但现在是 " 包含 <span class="math inline">\(a\)</span> 而不包含 <span class="math inline">\(b\)</span> " 。</p><p>改进方法是：查询局部区间和而不是全局区间和。</p><p>具体的：</p><ol type="1"><li>如果 <span class="math inline">\(a=b\)</span>，答案为 <span class="math inline">\(0\)</span> 。</li><li>如果 <span class="math inline">\(a&lt;b\)</span>，从左到右扫描，遇到左端点把右端点插进线段树；遇到右端点则将右端点从线段树中移除，扫描到 <span class="math inline">\(a\)</span> 时，查询 <span class="math inline">\([a,b)\)</span> 区间和即为答案。</li><li>如果 <span class="math inline">\(a&gt;b\)</span>，从右到左扫描，遇到右端点把左端点插进线段树；遇到左端点则将左端点从线段树中移除，扫描到 <span class="math inline">\(a\)</span> 时，查询 <span class="math inline">\((b,a]\)</span> 区间和即为答案。</li></ol><p>预处理出 <span class="math inline">\(2,3\)</span> 两种情况对应的询问，扫两次即可。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code 线段树版本    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n,modp;vector&lt;<span class="hljs-type">int</span>&gt; tree;vector&lt;<span class="hljs-type">int</span>&gt; lazy_add;vector&lt;<span class="hljs-type">int</span>&gt; lazy_mul;<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> MOD = LLONG_MAX) &#123;n = size;modp = MOD;tree.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);lazy_add.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);lazy_mul.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;tree[p] = (tree[p&lt;&lt;<span class="hljs-number">1</span>] + tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]) % modp;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> </span>&#123;<span class="hljs-keyword">if</span>(lazy_mul[p]!=<span class="hljs-number">1</span>) &#123;lazy_mul[p&lt;&lt;<span class="hljs-number">1</span>]   = lazy_mul[p&lt;&lt;<span class="hljs-number">1</span>]   * lazy_mul[p] % modp;lazy_mul[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] = lazy_mul[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] * lazy_mul[p] % modp;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   = lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   * lazy_mul[p] % modp;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] = lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] * lazy_mul[p] % modp;tree[p&lt;&lt;<span class="hljs-number">1</span>]       = tree[p&lt;&lt;<span class="hljs-number">1</span>]       * lazy_mul[p] % modp;tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]     = tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]     * lazy_mul[p] % modp;lazy_mul[p] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(lazy_add[p]) &#123;<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   = (lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   + lazy_add[p]) % modp;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] = (lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] + lazy_add[p]) % modp;tree[p&lt;&lt;<span class="hljs-number">1</span>]       = (tree[p&lt;&lt;<span class="hljs-number">1</span>]   + (mid-left+<span class="hljs-number">1</span>)  * lazy_add[p] % modp) % modp;tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]     = (tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] + (right-mid)   * lazy_add[p] % modp) % modp;lazy_add[p] = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_build</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<span class="hljs-keyword">if</span>(left == right) &#123;tree[p] = nums[left];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">in_build</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,nums);<span class="hljs-built_in">in_build</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,nums);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit_change</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left == right) &#123;        nums[left] += tree[p];    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">pushdown</span>(p,left,right);        <span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">submit_change</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,nums);        <span class="hljs-built_in">submit_change</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,nums);        <span class="hljs-built_in">pushup</span>(p);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_add</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;tree[p]     = (tree[p]     + (right-left+<span class="hljs-number">1</span>) * val % modp) % modp;lazy_add[p] = (lazy_add[p] + val) % modp;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql &lt;= mid) <span class="hljs-built_in">update_add</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);<span class="hljs-keyword">if</span>(qr &gt; mid) <span class="hljs-built_in">update_add</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,ql,qr,val);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_mul</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;tree[p]     = tree[p]     * val % modp;lazy_add[p] = lazy_add[p] * val % modp;lazy_mul[p] = lazy_mul[p] * val % modp;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql &lt;= mid) <span class="hljs-built_in">update_mul</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);<span class="hljs-keyword">if</span>(qr &gt; mid) <span class="hljs-built_in">update_mul</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,ql,qr,val);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_change</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ql &lt;= left &amp;&amp; qr &gt;= right) &#123;            tree[p] = (val * (right - left + <span class="hljs-number">1</span>)) % modp;            lazy_add[p] = val;            lazy_mul[p] = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">pushdown</span>(p,left,right);            <span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (ql &lt;= mid) <span class="hljs-built_in">update_change</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);            <span class="hljs-keyword">if</span> (qr &gt; mid) <span class="hljs-built_in">update_change</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,ql,qr,val);            <span class="hljs-built_in">pushup</span>(p);        &#125;    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;<span class="hljs-keyword">return</span> tree[p] % modp;&#125;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql &lt;= mid) res = (res + <span class="hljs-built_in">range_query</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr) ) % modp;<span class="hljs-keyword">if</span>(qr &gt; mid) res = (res + <span class="hljs-built_in">range_query</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,right,ql,qr) ) % modp;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<span class="hljs-built_in">in_build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,nums);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;    <span class="hljs-built_in">submit_change</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,nums);    &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-built_in">update_add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-built_in">update_mul</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-built_in">update_change</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr);&#125;&#125;;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pl</span>(N),<span class="hljs-built_in">pr</span>(N);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>();pl[r].<span class="hljs-built_in">push_back</span>(l);pr[l].<span class="hljs-built_in">push_back</span>(r);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; ql,qr;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a&lt;b) &#123;ql.<span class="hljs-built_in">push_back</span>(&#123;a,b,i&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&gt;b) &#123;qr.<span class="hljs-built_in">push_back</span>(&#123;a,b,i&#125;);&#125;&#125;<span class="hljs-function">SegmentTree <span class="hljs-title">segl</span><span class="hljs-params">(N)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(N)</span></span>;segl.<span class="hljs-built_in">build</span>(tmp);<span class="hljs-built_in">sort</span>(ql.<span class="hljs-built_in">begin</span>(),ql.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b,id]:ql) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&lt;=a;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:pr[i]) &#123;segl.<span class="hljs-built_in">add</span>(k,k,<span class="hljs-number">1</span>);&#125;segl.<span class="hljs-built_in">add</span>(i,i,-pl[i].<span class="hljs-built_in">size</span>());&#125;pos=a+<span class="hljs-number">1</span>;segl.<span class="hljs-built_in">add</span>(a,a,pl[a].<span class="hljs-built_in">size</span>());ans[id]=segl.<span class="hljs-built_in">query</span>(a,b<span class="hljs-number">-1</span>);segl.<span class="hljs-built_in">add</span>(a,a,-pl[a].<span class="hljs-built_in">size</span>());&#125;<span class="hljs-function">SegmentTree <span class="hljs-title">segr</span><span class="hljs-params">(N)</span></span>;segr.<span class="hljs-built_in">build</span>(tmp);<span class="hljs-built_in">sort</span>(qr.<span class="hljs-built_in">begin</span>(),qr.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(qr.<span class="hljs-built_in">begin</span>(),qr.<span class="hljs-built_in">end</span>());pos=<span class="hljs-number">2e5</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b,id]:qr) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&gt;=a;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:pl[i]) &#123;segr.<span class="hljs-built_in">add</span>(k,k,<span class="hljs-number">1</span>);&#125;segr.<span class="hljs-built_in">add</span>(i,i,-pr[i].<span class="hljs-built_in">size</span>());&#125;pos=a<span class="hljs-number">-1</span>;segr.<span class="hljs-built_in">add</span>(a,a,pr[a].<span class="hljs-built_in">size</span>());ans[id]=segr.<span class="hljs-built_in">query</span>(b+<span class="hljs-number">1</span>,a);segr.<span class="hljs-built_in">add</span>(a,a,-pr[a].<span class="hljs-built_in">size</span>());&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code 树状数组版本    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fenwick</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; tr;<span class="hljs-built_in">Fenwick</span>() &#123;&#125;<span class="hljs-built_in">Fenwick</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-keyword">this</span>-&gt;n = n;tr.<span class="hljs-built_in">assign</span>(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">while</span>(pos&lt;=n)&#123;tr[pos]+=x;pos+=pos&amp;-pos;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(pos)&#123;res+=tr[pos];pos-=pos&amp;-pos;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r)-<span class="hljs-built_in">sum</span>(l<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">// tr[x] count the cnt of x</span><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;res+=(<span class="hljs-number">1</span>&lt;&lt;i);<span class="hljs-keyword">if</span>(res&gt;n || cnt+tr[res]&gt;=k)&#123;res-=(<span class="hljs-number">1</span>&lt;&lt;i);&#125; <span class="hljs-keyword">else</span> &#123;cnt+=tr[res];&#125;&#125;<span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;&#125;&#125;;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pl</span>(N),<span class="hljs-built_in">pr</span>(N);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>();pl[r].<span class="hljs-built_in">push_back</span>(l);pr[l].<span class="hljs-built_in">push_back</span>(r);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; ql,qr;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a&lt;b) &#123;ql.<span class="hljs-built_in">push_back</span>(&#123;a,b,i&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&gt;b) &#123;qr.<span class="hljs-built_in">push_back</span>(&#123;a,b,i&#125;);&#125;&#125;<span class="hljs-function">Fenwick <span class="hljs-title">fenl</span><span class="hljs-params">(N)</span></span>;<span class="hljs-built_in">sort</span>(ql.<span class="hljs-built_in">begin</span>(),ql.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b,id]:ql) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&lt;=a;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:pr[i]) &#123;fenl.<span class="hljs-built_in">add</span>(k,<span class="hljs-number">1</span>);&#125;fenl.<span class="hljs-built_in">add</span>(i,-pl[i].<span class="hljs-built_in">size</span>());&#125;pos=a+<span class="hljs-number">1</span>;fenl.<span class="hljs-built_in">add</span>(a,pl[a].<span class="hljs-built_in">size</span>());ans[id]=fenl.<span class="hljs-built_in">rangeSum</span>(a,b<span class="hljs-number">-1</span>);fenl.<span class="hljs-built_in">add</span>(a,-pl[a].<span class="hljs-built_in">size</span>());&#125;<span class="hljs-function">Fenwick <span class="hljs-title">fenr</span><span class="hljs-params">(N)</span></span>;<span class="hljs-built_in">sort</span>(qr.<span class="hljs-built_in">begin</span>(),qr.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(qr.<span class="hljs-built_in">begin</span>(),qr.<span class="hljs-built_in">end</span>());pos=<span class="hljs-number">2e5</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b,id]:qr) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&gt;=a;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:pl[i]) &#123;fenr.<span class="hljs-built_in">add</span>(k,<span class="hljs-number">1</span>);&#125;fenr.<span class="hljs-built_in">add</span>(i,-pr[i].<span class="hljs-built_in">size</span>());&#125;pos=a<span class="hljs-number">-1</span>;fenr.<span class="hljs-built_in">add</span>(a,pr[a].<span class="hljs-built_in">size</span>());ans[id]=fenr.<span class="hljs-built_in">rangeSum</span>(b+<span class="hljs-number">1</span>,a);fenr.<span class="hljs-built_in">add</span>(a,-pr[a].<span class="hljs-built_in">size</span>());&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】AtCoder Beginner Contest 222 D~G</title>
    <link href="/posts/81df370c.html"/>
    <url>/posts/81df370c.html</url>
    
    <content type="html"><![CDATA[<h2 id="d.-between-two-arrays">D. Between Two Arrays</h2><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_d">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的单调不下降的整数序列 <span class="math inline">\(a,b\)</span>，且满足 <span class="math inline">\(a_i\le b_i\)</span>。求满足 <span class="math inline">\(a_i\le c_i\le b_i\)</span> 的单调不下降的整数序列 <span class="math inline">\(c\)</span> 的数量。</p><p><span class="math inline">\(1\le n\le 3000\)</span>，<span class="math inline">\(0\le a_i\le b_i\le 3000\)</span>。</p>          </div><div class="note note-success">            <p>前缀和优化 dp 经典题。</p><p>令 <span class="math inline">\(dp_{i,j}\)</span> 表示长度为 <span class="math inline">\(i\)</span> 且以 <span class="math inline">\(j\)</span> 结尾的单调不下降序列数量。则： <span class="math display">\[dp_{i,j}=\sum\limits_{k\in [0,j] \text{ }\cap \text{ }[a_{i-1},b_{i-1}]} dp_{i-1,k}\]</span> 那么我们需要枚举 <span class="math inline">\(i,j,k\)</span>，时间复杂度 <span class="math inline">\(O(n\alpha^2)\)</span>，<span class="math inline">\(\alpha\)</span> 为值域。</p><p>利用前缀和优化，令 <span class="math inline">\(s_{i,j}=\sum\limits_{j\in[0,j]}dp_{i,j}\)</span>，<span class="math inline">\(O(\alpha)\)</span> 便能完成转移。</p><p>总时间复杂度 <span class="math inline">\(O(n\alpha)\)</span> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;    <span class="hljs-type">int</span> x;    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == a.x; &#125;;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x != a.x; &#125;;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * y * a.x % mod);&#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(y) / a;&#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="hljs-keyword">return</span> is &gt;&gt; t.x;&#125;    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;            mul *= mul;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (b) &#123;            <span class="hljs-type">int</span> t = a / b;            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);        &#125;        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;        <span class="hljs-keyword">return</span> u;    &#125;    &#125;;<span class="hljs-keyword">using</span> mint = ModInt&lt;modp&gt;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;vector&lt;vector&lt;mint&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;mint&gt;(<span class="hljs-number">3002</span>,<span class="hljs-number">0</span>));vector&lt;vector&lt;mint&gt;&gt; <span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;mint&gt;(<span class="hljs-number">3002</span>,<span class="hljs-number">0</span>));dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3000</span>;++i) &#123;sum[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=a[i];j&lt;=b[i];++j) &#123;<span class="hljs-type">int</span> l=a[i<span class="hljs-number">-1</span>],r=<span class="hljs-built_in">min</span>(j,b[i<span class="hljs-number">-1</span>]);dp[i][j]+=sum[i<span class="hljs-number">-1</span>][r+<span class="hljs-number">1</span>]-sum[i<span class="hljs-number">-1</span>][l];&#125;sum[i][<span class="hljs-number">1</span>]=dp[i][<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">3000</span>;++j) &#123;sum[i][j+<span class="hljs-number">1</span>]=sum[i][j]+dp[i][j];&#125;&#125;mint res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">3000</span>;++i) &#123;res+=dp[n][i];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="e.-red-and-blue-tree">E. Red and Blue Tree</h2><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_e">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定一棵 <span class="math inline">\(n\)</span> 个点的树和一个长为 <span class="math inline">\(m\)</span> 的序列 <span class="math inline">\(a\)</span> 和一个整数 <span class="math inline">\(K\)</span>，你需要给这颗树上的边染蓝色或染红色。合法的染色方案满足从 <span class="math inline">\(a_1\)</span> 开始依次途径 <span class="math inline">\(a_2,a_3,\dots ,a_{n-1}\)</span> 最后到达 <span class="math inline">\(a_n\)</span> 的路径中经过的蓝边数总和 <span class="math inline">\(B\)</span> 和红边数总和 <span class="math inline">\(R\)</span> ，有 <span class="math inline">\(R-B=K\)</span>。求方案数。</p><p><span class="math inline">\(2\le n\le 1000\)</span>，<span class="math inline">\(2\le m\le 100\)</span>。</p>          </div><div class="note note-success">            <p>对每两个相邻的数都跑 <span class="math inline">\(\text{dfs}\)</span> 记录每条边 $i $ 的经过次数 <span class="math inline">\(C_i\)</span>。</p><p>问题转化为：将 <span class="math inline">\(C_1,C_2,...,C_{n-1}\)</span> 分成两个集合使得两个集合里元素的和 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(R-B=K\)</span>。</p><p>令 <span class="math inline">\(C_1+C_2+...+C_{n-1}=S\)</span> , 则</p><p><span class="math display">\[\begin{cases}S=R+B\\R-B=K \end{cases}\rightarrow 2R=S+K\rightarrow R=\frac{S+K}{2}\]</span></p><p>问题转化为从 <span class="math inline">\(C_1,C_2,...,C_{n-1}\)</span> 中选择若干个数使得和为 <span class="math inline">\(\frac{S+K}{2}\)</span>，dp 即可 。</p><p>具体的，令 <span class="math inline">\(dp_x\)</span> 表示使得和为 <span class="math inline">\(x\)</span> 的方案数， <span class="math inline">\(dp_x=\sum dp_{x-C_i}\)</span> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),K=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(&#123;y,i&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x,i&#125;);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath,<span class="hljs-type">int</span> goal) &#123;<span class="hljs-keyword">if</span>(x==goal) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,i]:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fath) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">self</span>(self,y,x,goal)) &#123;cnt[i]++;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i) &#123;<span class="hljs-built_in">dfs</span>(dfs,a[i],<span class="hljs-number">0</span>,a[i+<span class="hljs-number">1</span>]);&#125;<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;S+=cnt[i];&#125;<span class="hljs-keyword">if</span>((S+K)%<span class="hljs-number">2</span> || S+K&lt;<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>)</span></span>;dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1e5</span>;x&gt;=cnt[i];--x) &#123;dp[x]+=dp[x-cnt[i]];dp[x]%=modp;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[(S+K)/<span class="hljs-number">2</span>]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="f.-expensive-expense">F. Expensive Expense</h2><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_f">problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：树上每个点有权值 <span class="math inline">\(a_i\)</span>，边也有边权 <span class="math inline">\(w_i\)</span>。令 <span class="math inline">\(dis_{i,j}\)</span> 表示 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(j\)</span> 的简单路径长度 , 对于每一个 <span class="math inline">\(i\)</span> 求 <span class="math inline">\(\sum\limits_{j=1,j\neq i}^n max(dis_{i,j}+a_j)\)</span>。</p><p><span class="math inline">\(2\le n\le 2\times 10^5\)</span>，<span class="math inline">\(1\le c_i,w_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>方法一：（树的直径的性质）</p><p>一个结论：距离树上任意一点最远的点一定是直径两个端点中的一个。（这也是两次 <span class="math inline">\(\text{dfs}\)</span> 能够求树的直径的依据）</p><p>但这里有点权，那我们可以变通。</p><p>两次 <span class="math inline">\(\text{dfs}\)</span> 求树的直径时，将比较 <span class="math inline">\(dis_i\)</span> 换成比较 <span class="math inline">\(dis_i+a_i\)</span>。这样求出来的 “直径” 就是整颗树 <span class="math inline">\(dis_i+ a_i\)</span> 最大的路径。</p><p>确定了直径的两个端点 <span class="math inline">\(ml,mr\)</span> 后，再次应用 <span class="math inline">\(\text{dfs}\)</span> 求出两个端点到所有点的简单路径距离 <span class="math inline">\(disl\)</span> 和 <span class="math inline">\(disr\)</span>。</p><p>那么对于每个 <span class="math inline">\(i\)</span>，<span class="math inline">\(ans=\max(disl_{i}+a_{ml},disr_{i}+a_{mr})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code 1    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(&#123;y,w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x,w&#125;);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath,vector&lt;<span class="hljs-type">int</span>&gt; &amp;dis) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,z]:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fath) &#123;dis[y]=dis[x]+z;<span class="hljs-built_in">self</span>(self,y,x,dis);&#125;&#125;&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">dis1</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">dis2</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-built_in">dfs</span>(dfs,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,dis);<span class="hljs-type">int</span> ml=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,maxn=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(dis[i]+a[i]&gt;maxn) &#123;maxn=dis[i]+a[i];ml=i;&#125;&#125;<span class="hljs-built_in">dfs</span>(dfs,ml,<span class="hljs-number">0</span>,dis1);<span class="hljs-type">int</span> mr=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,maxn=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(i!=ml &amp;&amp; dis1[i]+a[i]&gt;maxn) &#123;maxn=dis1[i]+a[i];mr=i;&#125;&#125;<span class="hljs-built_in">dfs</span>(dfs,mr,<span class="hljs-number">0</span>,dis2);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(i!=ml) &#123;res=<span class="hljs-built_in">max</span>(res,dis1[i]+a[ml]);&#125;<span class="hljs-keyword">if</span>(i!=mr) &#123;res=<span class="hljs-built_in">max</span>(res,dis2[i]+a[mr]);&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>方法二：（换根dp）</p><p>第一次 <span class="math inline">\(\text{dfs}\)</span>，<span class="math inline">\(dp_{i,0/1}\)</span> 代表 <span class="math inline">\(i\)</span> 的子树内答案的最大值/次大值。那么有： <span class="math display">\[dp_{x}=\max_{y\in son[x]}(dp_{x},dp_{y}+w,a_y+w)\]</span> 第二次 <span class="math inline">\(\text{dfs}\)</span> ，可以画图分析：</p><p><img src="/image/academic/3.png" style="zoom: 60%;" /></p><p>向下 <span class="math inline">\(\text{dfs}\)</span> 时子树内的贡献没有改变，我们只需要分析另一边（绿色部分）多出了哪些贡献。</p><p>假设我们刚刚走过了边 <span class="math inline">\(fa\to y\)</span>，分为两种情况：</p><ol type="1"><li><p>（橙字）<span class="math inline">\(dp_{fa,0}\)</span> 从非 <span class="math inline">\(y\)</span> 子树内转移而来，那么： <span class="math display">\[dp_y=\max(dp_y,dp_{fa,0}+w)\]</span></p></li><li><p>（蓝字）<span class="math inline">\(dp_{fa,0}\)</span> 从 <span class="math inline">\(y\)</span> 的子树内转移而来，非子树部分的最大值实际就是 <span class="math inline">\(fa\)</span> 节点对应的次大值，那么： <span class="math display">\[dp_y=\max(dp_y,dp_{fa,1}+w)\]</span></p></li></ol><p>最后更新答案。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code 2    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(&#123;y,w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x,w&#125;);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">from</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,w]:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">self</span>(self,y,x);<span class="hljs-type">int</span> t=<span class="hljs-built_in">max</span>(a[y],dp[y][<span class="hljs-number">0</span>])+w;<span class="hljs-keyword">if</span>(t&gt;dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>]=dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>]=t;from[x]=y;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>]=t;&#125;&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> w) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">int</span> t=a[fa]+w;<span class="hljs-keyword">if</span>(from[fa]!=x) &#123;t=<span class="hljs-built_in">max</span>(t,dp[fa][<span class="hljs-number">0</span>]+w);&#125; <span class="hljs-keyword">else</span> &#123;t=<span class="hljs-built_in">max</span>(t,dp[fa][<span class="hljs-number">1</span>]+w);&#125;<span class="hljs-keyword">if</span>(t&gt;dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>]=dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>]=t;from[x]=fa;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>]=t;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,w]:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">self</span>(self,y,x,w);&#125;&#125;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,w]:adj[<span class="hljs-number">1</span>]) &#123;<span class="hljs-built_in">dfs2</span>(dfs2,y,<span class="hljs-number">1</span>,w);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[i][<span class="hljs-number">0</span>]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="g.-222">G. 222</h2><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_g">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：幸运数字是由若干个 <span class="math inline">\(2\)</span> 构成的数字（如 <span class="math inline">\(2,22,222,\dots\)</span> ）。给定正整数 <span class="math inline">\(k\)</span>，当 <span class="math inline">\(k\)</span> 的倍数第一次属于某个幸运数字时。输出该倍数由多少个 <span class="math inline">\(2\)</span> 组成。若不存在 <span class="math inline">\(k\)</span> 的倍数是幸运数字，输出 <span class="math inline">\(-1\)</span>。</p>          </div><div class="note note-success">            <p>幸运数字可以表示为 <span class="math inline">\(2\times \dfrac{10^x-1}{9}\)</span>。</p><p>问题转化为寻求最小的 <span class="math inline">\(x\)</span> 使得： <span class="math display">\[\begin{align}2\times \dfrac{10^x-1}{9}&amp;\equiv 0 \pmod{k} \\2\times(10^x-1) &amp;\equiv 0 \pmod{9k} \\10^x-1 &amp;\equiv 0 \pmod{\dfrac{9k}{\gcd(k,2)}} \\10^x &amp;\equiv 1 \pmod{\dfrac{9k}{\gcd(k,2)}}\end{align}\]</span> 转化为了 <span class="math inline">\(a^x\equiv b \pmod{P}\)</span> 的形式，运用 BSGS 算法即可求解。</p><p>还可以运用欧拉函数。</p><p>回忆欧拉定理：对于互质的正整数 <span class="math inline">\(a,n\)</span> 有 <span class="math inline">\(a^{\varphi(n)}\equiv1\pmod{n}\)</span> .</p><p>我们令 <span class="math inline">\(p=\dfrac{9k}{\gcd(k,2)} ,x=\varphi(p)\)</span>，则 <span class="math inline">\(10^{\varphi(p)}\equiv1\pmod{p}\)</span>，可以直接得到一个可行解。</p><p>虽然 <span class="math inline">\(\varphi(p)\)</span> 不一定是满足条件的正整数，但答案一定是其因子，枚举即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-comment">//欧拉函数</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eular</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> ret=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/i;++i) &#123;    <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;        n/=i;        ret*=i<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) &#123;        n/=i;        ret*=i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) &#123;    ret*=n<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k%p) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s=s*k%p;<span class="hljs-keyword">return</span> s;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> K=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> p=<span class="hljs-number">9</span>*K/__gcd(K,<span class="hljs-number">2ll</span>);<span class="hljs-type">int</span> n=<span class="hljs-built_in">eular</span>(p);<span class="hljs-keyword">if</span>(__gcd(<span class="hljs-number">10ll</span>,p)&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> ans=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">sqrtl</span>(n);++i) &#123;<span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">qpow</span>(<span class="hljs-number">10</span>,i,p) == <span class="hljs-number">1</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,i);&#125;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">qpow</span>(<span class="hljs-number">10</span>,n/i,p) == <span class="hljs-number">1</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,n/i);&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Atcoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】Codeforces Round 902 (Div. 2, based on COMPFEST 15 - Final Round) 5 of 7</title>
    <link href="/posts/1537ce5a.html"/>
    <url>/posts/1537ce5a.html</url>
    
    <content type="html"><![CDATA[<h2 id="a.-goals-of-victory">A. Goals of Victory</h2><p><a href="https://codeforces.com/contest/1877/problem/A">Problem</a></p><div class="note note-success">            <p>赢的场次一定和输的场次相等。</p><p>即 <span class="math inline">\(\sum\limits_{i=1}^{n} a_i = 0\)</span>。故 <span class="math inline">\(ans=-\sum\limits_{i=1}^{n-1}a_i\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();sum+=a[i];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-number">-1</span>*sum);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-helmets-in-night-light">B. Helmets in Night Light</h2><p><a href="https://codeforces.com/contest/1877/problem/B">Problem</a></p><div class="note note-info">            <p>题意：须弥除了草神外有 <span class="math inline">\(n\)</span> 个居民。草神要通过虚空终端向所有 <span class="math inline">\(n\)</span> 个人传递公告，其直接向一个居民传递的代价为 <span class="math inline">\(p\)</span>。居民 <span class="math inline">\(i\)</span> 一旦得知，也可以向其它人传递，但最多直接传递给 <span class="math inline">\(a_i\)</span> 个人且每个人的传递代价为 <span class="math inline">\(b_i\)</span>。求最小代价。</p><p><span class="math inline">\(1\le n,a_i,b_i \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>考虑贪心。因为对于向单个人的传递代价，肯定是越小越好。</p><p>一开始，草神必然至少通知一个人，代价为 <span class="math inline">\(p\)</span>。</p><p>之后将代价 <span class="math inline">\(b_i\)</span> 排序后从小到大选择，若 <span class="math inline">\(b_i&gt;p\)</span>，肯定不优，考虑把剩余的通知任务全堆给草神。</p><p>否则累加 <span class="math inline">\(a_i\)</span>，当选择的 <span class="math inline">\(a_i\)</span> 之和超过 <span class="math inline">\(n-1\)</span> 时就代表通知了所有人。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),p=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">order</span><span class="hljs-params">(n)</span></span>;<span class="hljs-built_in">iota</span>(order.<span class="hljs-built_in">begin</span>(),order.<span class="hljs-built_in">end</span>(),<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(order.<span class="hljs-built_in">begin</span>(),order.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> b[i]&lt;b[j];&#125;);<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<span class="hljs-type">bool</span> fir=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:order) &#123;<span class="hljs-keyword">if</span>(b[i]&lt;=p) &#123;<span class="hljs-keyword">if</span>(fir) &#123;fir=<span class="hljs-literal">false</span>;res+=p;sum++;&#125;<span class="hljs-type">int</span> add=<span class="hljs-built_in">min</span>(n-sum,a[i]);sum+=add;res+=b[i]*add;<span class="hljs-keyword">if</span>(sum==n) &#123;<span class="hljs-keyword">break</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;res+=(n-sum)*p;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-joyboard">C. Joyboard</h2><p><a href="https://codeforces.com/contest/1877/problem/C">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n+1\)</span> 的序列 <span class="math inline">\(a\)</span>，一开始全为空。你可以给 <span class="math inline">\(a_{n+1}\)</span> 填上 <span class="math inline">\(0\sim m\)</span> 中的一个，之后从右向左构造 <span class="math inline">\(a_i=a_{i+1} \pmod {i}\)</span>。求最终序列有 <span class="math inline">\(k\)</span> 个不同的数的方案数。</p><p><span class="math inline">\(1\le n\le 10^9\)</span>，<span class="math inline">\(0\le m \le 10^9\)</span>，<span class="math inline">\(1\le k \le n+1\)</span>。</p>          </div><div class="note note-success">            <p>随便列举一下就图穷匕见了。</p><p>当 <span class="math inline">\(n=6\)</span> 时有：</p><p><span class="math display">\[\begin{alignat}{7}a_1 &amp;\quad&amp; a_2 &amp;\quad&amp; a_3 &amp;\quad&amp; a_4 &amp;\quad&amp; a_5 &amp;\quad&amp; a_6 &amp;\quad&amp; a_7\\0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0 \\0   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1 \\0   &amp;\quad&amp; 0   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 2 \\0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 3   &amp;\quad&amp; 3   &amp;\quad&amp; 3   &amp;\quad&amp; 3 \\    &amp;\quad&amp;     &amp;\quad&amp;     &amp;\quad&amp; \vdots    &amp;\quad&amp;     &amp;\quad&amp;     &amp;\quad&amp;   \\0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 6 \\0   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 7 \\0   &amp;\quad&amp; 0   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 8 \\0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 3   &amp;\quad&amp; 3   &amp;\quad&amp; 3   &amp;\quad&amp; 9 \\    &amp;\quad&amp;     &amp;\quad&amp;     &amp;\quad&amp; \vdots    &amp;\quad&amp;     &amp;\quad&amp;     &amp;\quad&amp;   \\0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 0   &amp;\quad&amp; 12 \\0   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 1   &amp;\quad&amp; 13 \\0   &amp;\quad&amp; 0   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 2   &amp;\quad&amp; 14 \\    &amp;\quad&amp;     &amp;\quad&amp;     &amp;\quad&amp; \vdots    &amp;\quad&amp;     &amp;\quad&amp;     &amp;\quad&amp;   \\\end{alignat}\]</span></p><p>生成的序列一定最多经过两次衰减变为 <span class="math inline">\(0\)</span>。</p><p>那么当 <span class="math inline">\(k&gt;3\)</span> 时一定无解。</p><p>令 <span class="math inline">\(a_{n+1}=x\)</span> ：</p><p>当 <span class="math inline">\(k=1\)</span> 时，显然只有 <span class="math inline">\(x=0\)</span> 符合题意。</p><p>当 <span class="math inline">\(k=2\)</span> 时，首先对于 <span class="math inline">\(n\mid x\)</span> 一定符合题意，其次 <span class="math inline">\(x\in[1,n-1]\)</span> 只衰减一次，同样符合题意。</p><p>当 <span class="math inline">\(k=3\)</span> 时，容斥一下就好了。</p><p><span class="math display">\[ans=\begin{cases}1 &amp;,k=1 \\m &amp;,k=2,m\le n \\n+\lfloor \frac{m-n}{n}\rfloor  &amp;,k=2,m &gt; n \\m-n-\lfloor \frac{m-n}{n}\rfloor  &amp;,k=3,m &gt; n \\0 &amp;,others\end{cases}\]</span></p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125; <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> div=k/n,cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(m&lt;=n) &#123;cnt=m;&#125; <span class="hljs-keyword">else</span> &#123;cnt=m/n;cnt+=(n<span class="hljs-number">-1</span>);&#125;<span class="hljs-keyword">if</span>(k==<span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,cnt);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,m-cnt);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-effects-of-anti-pimples">D. Effects of Anti Pimples</h2><p><a href="https://codeforces.com/contest/1877/problem/D">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定长度为 <span class="math inline">\(n\)</span> 的数列，一开始全为白色。你可以任意选一些索引，将对应位置涂黑。然后对于每一个涂黑的位置，将它索引的所有倍数的位置涂绿（不可覆盖黑）。定义该状态的价值为黑色和绿色所有位置上数的最大值。涂黑方案有 <span class="math inline">\(2^n-1\)</span> 种，求所有方案价值总和。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(0\le a_i \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>令 <span class="math inline">\(f_i\)</span> 表示位置 <span class="math inline">\(i\)</span> 的价值。</p><p>因为将 <span class="math inline">\(a_i\)</span> 涂成黑色的同时所有 <span class="math inline">\(i\mid j\)</span> 的 <span class="math inline">\(a_j\)</span> 被涂成了绿色。</p><p>而这段子序列的价值只和最大值有关，故 <span class="math inline">\(f_i=\max\limits_{i\mid j} a_j\)</span>。</p><p>考虑 <span class="math inline">\(f_i\)</span> 对答案的贡献。</p><p>一个结论，<span class="math inline">\(n\)</span> 个数的所有子集中包含某个下标的子集有 <span class="math inline">\(2^{n-1}\)</span> 个。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        为什么？    </div>    <div class='spoiler-content'>        <p><span class="math inline">\(n\)</span> 个数共有 <span class="math inline">\(2^n-1\)</span> 个子集，去掉某个下标后剩下 <span class="math inline">\(n-1\)</span> 个数共有 <span class="math inline">\(2^{n-1}-1\)</span> 个子集。</p><p>这 <span class="math inline">\(2^{n-1}-1\)</span> 个子集都不包含那个下标。故包含那个下标的子集有 <span class="math inline">\(2^n-1-(2^{n-1}-1)=2^{n-1}\)</span> 个。</p>    </div></div><div class="note note-success">            <p>故最大的 <span class="math inline">\(f_i\)</span> 对答案的贡献是 <span class="math inline">\(f_i\times 2^{n-1}\)</span>。</p><p>而次大 <span class="math inline">\(f_i\)</span> 对答案的贡献是 <span class="math inline">\(f_i\times 2^{n-2}\)</span>。因为次大值若有贡献必不能包含最大值，相当于除去最大 <span class="math inline">\(f_i\)</span> 剩下 <span class="math inline">\(n-1\)</span> 个数，被 <span class="math inline">\(2^{n-2}\)</span> 个集合包含。</p><p>以此类推。</p><p>故答案为 <span class="math inline">\(\sum\limits_{i=1}^{n} 2^{i-1} f_i\)</span> 。其中 <span class="math inline">\(f_i\)</span> 从小到大排序。</p><p>时间复杂度 <span class="math inline">\(O(n\ln n)\)</span> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;    <span class="hljs-type">int</span> x;    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == a.x; &#125;;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x != a.x; &#125;;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * y * a.x % mod);&#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(y) / a;&#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="hljs-keyword">return</span> is &gt;&gt; t.x;&#125;    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;            mul *= mul;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (b) &#123;            <span class="hljs-type">int</span> t = a / b;            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);        &#125;        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;        <span class="hljs-keyword">return</span> u;    &#125;    &#125;;<span class="hljs-keyword">using</span> mint = ModInt&lt;modp&gt;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j+=i) &#123;a[i]=<span class="hljs-built_in">max</span>(a[i],a[j]);&#125;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,a.<span class="hljs-built_in">end</span>());mint res=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;sum == <span class="hljs-number">0</span> ? sum=<span class="hljs-number">1</span> : sum=sum*<span class="hljs-number">2</span>;res+=sum*a[i];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p>对于以下代码段，时间复杂度为 <span class="math inline">\(O(n\ln n)\)</span> 。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j+=i) &#123;        <span class="hljs-comment">//do something</span>    &#125;&#125;</code></pre></div><p>因为执行次数 <span class="math inline">\(\frac{n}{1}+\frac{n}{2}+\frac{n}{3}+\dots +\frac{n}{n} = n(1+\frac{1}{2}+\frac{1}{3}+\dots+\frac{1}{n})\)</span>。调和级数的和约为 <span class="math inline">\(\ln n\)</span>。</p>          </div><h2 id="e.-autosynthesis">E. Autosynthesis</h2><p><a href="https://codeforces.com/contest/1877/problem/E">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的正整数序列 <span class="math inline">\(a\)</span>。你要将这个序列划分成两个不交的子序列，满足其中一个子序列的下标构成的集合等于另一个子序列的值构成的集合。输出作为值的那一个子序列。</p><p><span class="math inline">\(1\le a_i\le n \le 2\times 10^5\)</span>。</p>          </div><div class="note note-success">            <p>转换为图论模型，对每个 <span class="math inline">\(i\in[1,n]\)</span> 连边 <span class="math inline">\(i\to a_i\)</span>，会形成一颗基环内向树。</p><p>考虑一个经典模型——置换环。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        那是什么    </div>    <div class='spoiler-content'>        <p>对于一个任意 <span class="math inline">\(1\sim n\)</span> 的排列 <span class="math inline">\(a\)</span> ，连边 <span class="math inline">\(i\to a_i\)</span>，得到的图一定是由一个或多个环组成（一个点看作长度为 <span class="math inline">\(1\)</span> 的环），称作置换环。</p><p>其意义在于，位于一个长度为 <span class="math inline">\(L\)</span> 的置换环内的元素，经历最少 <span class="math inline">\(L-1\)</span> 次元素交换便能使元素在原序列中有序。</p><p>于是对于任意一个排列，两两交换其中元素使其变得单调增的最小交换次数就是 <span class="math inline">\(n-\text{置换环个数}\)</span> 。</p>    </div></div><div class="note note-success">            <p>如果序列 <span class="math inline">\(a\)</span> 是排列，只需要满足 <span class="math inline">\(a\)</span> 的所有置换环长度均为偶数。</p><p>因为可以间隔黑白染色，染成黑色和白色的点的集合正好对应题中的两个序列。</p><p>例如，有排列 <code>4 3 6 5 7 8 1 2</code> ，连边后如下图。</p><figure><img src="/image/academic/2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><p>下标集合 <code>1,2,5,6</code> 或 <code>1,3,5,8</code> 或 <code>3,4,7,8</code> 等均符合题意。</p><p>为什么间隔染色正确？因为对于一条有向边，总是一个索引指向对应的值。</p><p>而挑选出的 <span class="math inline">\(\frac{n}{2}\)</span> 个点的出边指向的 “值的点集” 正好与 “索引点集” 互补！</p><p>那么剩下的 <span class="math inline">\(\frac{n}{2}\)</span> 的 “值的点集” 就必然与 “索引点集” 相同。</p><p>好，但现在 <span class="math inline">\(a\)</span> 并不是排列，但这也说明有一些数不会在 <span class="math inline">\(a\)</span> 中出现：</p><ul><li>若点 <span class="math inline">\(i\)</span> 被选入索引点集，则存在一个没被选的点 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(a_j=i\)</span>。</li><li>若对点 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(\exists\mkern-10mu/ \text{ }j\)</span> 使得 <span class="math inline">\(a_j=i\)</span>，那这个点一定属于值的点集。</li></ul><p>这意味这 <span class="math inline">\(n\)</span> 个数中有一些数的状态是确定的。</p><p>手玩一下样例，模拟一下将索引点集对应的值逐步删掉，只留下值的集合的过程：</p><div class="code-wrapper"><pre><code class="hljs c++">Input：<span class="hljs-number">5</span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>Output：<span class="hljs-number">3</span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre></div><p>首先 <span class="math inline">\(1\)</span> 没在 <span class="math inline">\(a\)</span> 中出现，<span class="math inline">\(1\)</span> 不可能属于索引点集，那么 <span class="math inline">\(a[1]\)</span> 永远不能被删掉。</p><p>同理 <span class="math inline">\(a[5]\)</span> 也永远不能被删掉。</p><p>为保证 <span class="math inline">\(a[1]=3\)</span> 不被删，那么 <span class="math inline">\(a[3]\)</span> 必然被删掉。</p><p>为保证 <span class="math inline">\(a[3]=2\)</span> 必然被删，所以 <span class="math inline">\(a[2]\)</span> 永远不能被删掉？不，不一定。</p><p>因为场上不只有一个 <span class="math inline">\(2\)</span>，<span class="math inline">\(a[4]\)</span> 也是 <span class="math inline">\(2\)</span>，故 <span class="math inline">\(a[2]\)</span> 的状态不确定。</p><p>这个过程可以利用 <code>bfs</code> ，从入度为 <span class="math inline">\(0\)</span> 的点开始搜，直到能确定状态的都被确定。</p><p>那么此时剩下的都是状态不确定的了。</p><p>此时就可以把剩下的数看作一个排列，按照上述方法判断置换环长度的奇偶性，确定答案。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">rd</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();rd[a[i]]++;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">del</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//储存有哪些数的状态被确定</span>queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!rd[i]) &#123;q.<span class="hljs-built_in">push</span>(i);&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();del[x]=<span class="hljs-literal">true</span>;ans.<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">if</span>(!del[a[x]] &amp;&amp; --rd[a[a[x]]]==<span class="hljs-number">0</span>) &#123;q.<span class="hljs-built_in">push</span>(a[a[x]]);&#125;del[a[x]]=<span class="hljs-literal">true</span>;&#125;<span class="hljs-type">bool</span> ok=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(del[i]) &#123;<span class="hljs-keyword">continue</span>;&#125;vector&lt;<span class="hljs-type">int</span>&gt; cycle;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;!del[j];j=a[j]) &#123;cycle.<span class="hljs-built_in">push_back</span>(j);del[j]=<span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span>(cycle.<span class="hljs-built_in">size</span>()%<span class="hljs-number">2</span>) &#123;ok=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cycle.<span class="hljs-built_in">size</span>();j+=<span class="hljs-number">2</span>) &#123;ans.<span class="hljs-built_in">push_back</span>(cycle[j]);&#125;&#125;<span class="hljs-keyword">if</span>(!ok) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans.<span class="hljs-built_in">size</span>());<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,a[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《动手学深度学习》随笔 part1 —— pytorch 基本操作</title>
    <link href="/posts/a3c53bfd.html"/>
    <url>/posts/a3c53bfd.html</url>
    
    <content type="html"><![CDATA[<h2 id="数值操作">数值操作</h2><p>模块导入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch</code></pre></div><p>用 <code>torch.arange()</code> 创建向量：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.arange(<span class="hljs-number">12</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])</code></pre></div><div class="note note-info">            <p>参数列表：<code>torch.arange(start=0, end, step=1, \*, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor</code></p><p><code>start</code> <code>end</code> <code>step</code> ：起始值，结束值和步长。</p><p><code>dtype</code> ：指定数据类型。</p><p><code>out</code> ：输出张量。</p><p><code>layout</code> ：布局方式，一般有以下两种：</p><ul><li><code>torch.strided</code> ：密集布局，张量元素按一定步幅排列在内存中，相邻元素间地址差距连续，但元素不一定连续存储。</li><li><code>torch.sparse_coo</code> ：稀疏布局。只存储非零元素的索引和值，节省内存。访问 <a href="https://runebook.dev/zh/docs/pytorch/sparse#sparse-docs">Link</a> 获取更多信息。</li></ul><p><code>device</code> ：设备。例如可选 <code>cpu</code> 或 <code>cuda</code> 。</p><p><code>requires_grad</code> ：是否为张量启用梯度计算。</p>          </div><p>用 <code>torch.reshape()</code> 改变张量形状：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>],         [ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],         [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>]],        [[ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],         [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],         [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>]]])</code></pre></div><div class="note note-info">            <p>注：可以用 <span class="math inline">\(-1\)</span> 表示自动填充某一个轴的大小。</p><p>如 <code>x = torch.arange(12).reshape((-1, 3, 2))</code> 就和以上语句等价。</p>          </div><p>用 <code>shape</code> 获取沿所有轴的元素个数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.shape</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])</code></pre></div><div class="note note-info">            <p>如果只对张量的第一个维度感兴趣，可以用 <code>len(x)</code> 。</p>          </div><p>用 <code>torch.zeros(),torch.ones()</code> 获得全0 / 全1 张量：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])</code></pre></div><p>用 <code>torch.randn()</code> 随机采样（ 会生成均值为 0，标准差为 1 的正态分布）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[[ <span class="hljs-number">0.2692</span>,  <span class="hljs-number">0.0791</span>,  <span class="hljs-number">0.0039</span>, -<span class="hljs-number">0.1389</span>],         [-<span class="hljs-number">0.1045</span>, -<span class="hljs-number">0.3420</span>,  <span class="hljs-number">0.2542</span>,  <span class="hljs-number">1.4940</span>],         [ <span class="hljs-number">1.5095</span>,  <span class="hljs-number">1.1909</span>, -<span class="hljs-number">0.5695</span>,  <span class="hljs-number">1.4376</span>]],        [[ <span class="hljs-number">0.5032</span>, -<span class="hljs-number">0.1839</span>, -<span class="hljs-number">0.0568</span>,  <span class="hljs-number">0.1740</span>],         [-<span class="hljs-number">0.2951</span>,  <span class="hljs-number">2.4619</span>,  <span class="hljs-number">1.2984</span>,  <span class="hljs-number">0.0647</span>],         [-<span class="hljs-number">0.5046</span>,  <span class="hljs-number">0.9516</span>, -<span class="hljs-number">0.0810</span>, -<span class="hljs-number">0.3269</span>]]])</code></pre></div><div class="note note-success">            <p>更一般地，有库函数 <code>torch.normal(mean, std, size, out=None)</code> 。</p><p><code>mean</code> ：正态分布的均值。</p><p><code>std</code> ：正态分布的标准差。</p><p><code>size</code> ：生成的张量形状。可以是整数（一维向量），也可以是元组或列表（多维张量）。</p><p><code>out</code> ：如果提供了一个输出张量，随机生成的值将存储在这个张量中，而不是创建一个新的张量。</p><p>故 <code>torch.randn(2, 3, 4)</code> 等效于：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.normal(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))</code></pre></div>          </div><p>指定值：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],        [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>],        [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])</code></pre></div><p>用 <code>sum()</code> 求和：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.<span class="hljs-built_in">sum</span>()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">24</span>)</code></pre></div><p>用 <code>axis=0</code> 指定沿列求和：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>])</code></pre></div><p>用 <code>axis=1</code> 指定沿行求和：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>])</code></pre></div><p>用 <code>keepdims=True</code> 非降维求和（保持原有行/列的形状）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">4</span>],        [ <span class="hljs-number">8</span>],        [<span class="hljs-number">12</span>]])</code></pre></div><p>用 <code>numel()</code> 获取总元素个数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.numel()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">12</span></code></pre></div><p>四则运算：形状相同，按元素操作</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.tensor([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>x + y, x - y, x * y, x / y, x ** y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">( tensor([ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">10</span>]),   tensor([-<span class="hljs-number">1</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">6</span>]),   tensor([ <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]),   tensor([<span class="hljs-number">0.5000</span>, <span class="hljs-number">1.0000</span>, <span class="hljs-number">2.0000</span>, <span class="hljs-number">4.0000</span>]),   tensor([ <span class="hljs-number">1</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">64</span>]) )</code></pre></div><p>其中，单纯两个矩阵中每个值按元素相乘，称为 <code>Hadamard积</code> 。</p><p><code>x.exp()</code> <span class="math inline">\(\to\)</span> <span class="math inline">\(e^x\)</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.exp()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">2.7183e+00</span>, <span class="hljs-number">7.3891e+00</span>, <span class="hljs-number">5.4598e+01</span>, <span class="hljs-number">2.9810e+03</span>])</code></pre></div><p>用 <code>dtype</code> 指定元素类型：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>, dtype=torch.float32).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>],        [ <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>]])</code></pre></div><p>用 <code>cat</code> 沿行（轴 0）拼接张量：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.tensor([[<span class="hljs-number">1.0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],        [<span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.cat((x, y), dim=<span class="hljs-number">0</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>],        [ <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>],        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],        [ <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>],        [ <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>]])</code></pre></div><p>用 <code>cat</code> 沿列（轴 1）拼接张量：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.cat((x, y), dim=<span class="hljs-number">1</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>],        [ <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>]])</code></pre></div><p>按元素比较：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x == y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],        [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],        [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>]])</code></pre></div><p>利用广播机制使得不同形状的张量执行按元素操作，<code>tensor</code> 会自动扩充维度。</p><p>两个“可广播的” <code>tensor</code> 满足以下条件：</p><ul><li>每个 <code>tensor</code> 至少一个维度。</li><li>从末尾遍历 <code>tensor</code> 所有维度时，出现以下情况：<ul><li>维度相等。</li><li>维度不等 &amp;&amp; 其中一个维度为 <span class="math inline">\(1\)</span> 。</li><li>维度不等 &amp;&amp; 其中一个维度不存在。</li></ul></li></ul><p>满足规则，将小的扩展成大的 <code>tensor</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">2</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.arange(<span class="hljs-number">4</span>).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x, y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">(tensor([[<span class="hljs-number">0</span>],        [<span class="hljs-number">1</span>]]), tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x + y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])</code></pre></div><p>这时候就体现非降维求和的优势了：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>sum_x = x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>sum_x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">6</span>],        [<span class="hljs-number">22</span>],        [<span class="hljs-number">38</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x / sum_x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1667</span>, <span class="hljs-number">0.3333</span>, <span class="hljs-number">0.5000</span>],        [<span class="hljs-number">0.1818</span>, <span class="hljs-number">0.2273</span>, <span class="hljs-number">0.2727</span>, <span class="hljs-number">0.3182</span>],        [<span class="hljs-number">0.2105</span>, <span class="hljs-number">0.2368</span>, <span class="hljs-number">0.2632</span>, <span class="hljs-number">0.2895</span>]])</code></pre></div><p>可以看到对每一行/列求了平均，而不会因维度对不上而报错。</p><p>与 python 字符串类似地进行索引。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x[-<span class="hljs-number">1</span>]</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</code></pre></div><p>将指定元素写入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>] = <span class="hljs-number">114514</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[     <span class="hljs-number">0</span>,      <span class="hljs-number">1</span>,      <span class="hljs-number">2</span>,      <span class="hljs-number">3</span>],        [     <span class="hljs-number">4</span>,      <span class="hljs-number">5</span>,      <span class="hljs-number">6</span>,      <span class="hljs-number">7</span>],        [     <span class="hljs-number">8</span>,      <span class="hljs-number">9</span>, <span class="hljs-number">114514</span>,     <span class="hljs-number">11</span>]])</code></pre></div><p>多元素赋值，先 0 轴后 1 轴。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-number">3</span>] = <span class="hljs-number">1919810</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1919810</span>, <span class="hljs-number">1919810</span>, <span class="hljs-number">1919810</span>,       <span class="hljs-number">3</span>],        [<span class="hljs-number">1919810</span>, <span class="hljs-number">1919810</span>, <span class="hljs-number">1919810</span>,       <span class="hljs-number">7</span>],        [      <span class="hljs-number">8</span>,       <span class="hljs-number">9</span>,  <span class="hljs-number">114514</span>,      <span class="hljs-number">11</span>]])</code></pre></div><p>以分配新内存的方式分配 <span class="math inline">\(x\)</span> 的副本给 <span class="math inline">\(y\)</span> ：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = x.clone()</code></pre></div><p>用 <code>mean()</code> 求所有均值（注意必须是浮点型）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>, dtype=torch.float32).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>],        [ <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.mean()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">5.5000</span>)</code></pre></div><p><code>x.mean(axis=0)</code> 等价于 <code>x.sum(axis=0) / x.shape[0]</code></p><p>用 <code>cumsum</code> 沿着某个维度计算累计总和：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.cumsum(axis=<span class="hljs-number">0</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">10.</span>],        [<span class="hljs-number">12.</span>, <span class="hljs-number">15.</span>, <span class="hljs-number">18.</span>, <span class="hljs-number">21.</span>]])</code></pre></div><p>用 <code>torch.unsqueeze()</code> 增加数据维度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4</span>)  <span class="hljs-comment"># tensor([0, 1, 2, 3])</span><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.unequeeze(x, <span class="hljs-number">0</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])</code></pre></div><p>可以看到最外层增加了一维。</p><div class="note note-info">            <p>参数列表：<code>new_tensor = torch.unsqueeze(input, dim)</code></p><p><code>input</code>：需要操作的张量。</p><p><code>dim</code>：要在哪个维度上增加一个维度。</p><p>返回值是一个新的张量。</p>          </div><h2 id="线性代数操作">线性代数操作</h2><p>矩阵转置：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>A = torch.arange(<span class="hljs-number">20</span>, dtype=torch.float32).reshape(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>A</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>],        [ <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>],        [<span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>, <span class="hljs-number">12.</span>, <span class="hljs-number">13.</span>, <span class="hljs-number">14.</span>],        [<span class="hljs-number">15.</span>, <span class="hljs-number">16.</span>, <span class="hljs-number">17.</span>, <span class="hljs-number">18.</span>, <span class="hljs-number">19.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>A.T</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">5.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">15.</span>],        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">6.</span>, <span class="hljs-number">11.</span>, <span class="hljs-number">16.</span>],        [ <span class="hljs-number">2.</span>,  <span class="hljs-number">7.</span>, <span class="hljs-number">12.</span>, <span class="hljs-number">17.</span>],        [ <span class="hljs-number">3.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">13.</span>, <span class="hljs-number">18.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">14.</span>, <span class="hljs-number">19.</span>]])</code></pre></div><p>点积（Dot Product） <span class="math inline">\(\textbf{x}^\top \textbf{y} = \sum x_iy_i\)</span> ：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">5</span>, dtype=torch.float32)<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.ones(<span class="hljs-number">5</span>, dtype = torch.float32)<span class="hljs-meta">&gt;&gt;&gt; </span>x, y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">(tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">4.</span>]), tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.dot(x, y)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">10.</span>)</code></pre></div><p>等效表达 <code>torch.sum(x * y)</code> 。</p><p>矩阵-向量积：</p><p>对于一个矩阵 $^{mn} $ ，和向量 <span class="math inline">\(\textbf{x}\in \mathbb{R}^{n}\)</span> 。</p><p><span class="math inline">\(\textbf{Ax} = \begin{bmatrix} a_{11} &amp; a_{12} &amp; \ldots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \ldots &amp; a_{2n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{m1} &amp; a_{m2} &amp; \ldots &amp; a_{mn} \end{bmatrix}\)</span><span class="math inline">\(\begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_m \end{bmatrix}\)</span> <span class="math inline">\(= \begin{bmatrix} \left\langle a_1x\right\rangle \\ \left\langle a_2x\right\rangle \\ \vdots \\ \left\langle a_mx\right\rangle \end{bmatrix}\)</span></p><p><span class="math inline">\(\left\langle a_ix \right\rangle\)</span> 表示矩阵的第 <span class="math inline">\(i\)</span> 行构成的行向量和向量 <span class="math inline">\(x\)</span> 的点积。</p><p>利用 <code>mv(A, x)</code> 进行矩阵-向量积：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>A, x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">(tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>],        [ <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>],        [<span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>, <span class="hljs-number">12.</span>, <span class="hljs-number">13.</span>, <span class="hljs-number">14.</span>],        [<span class="hljs-number">15.</span>, <span class="hljs-number">16.</span>, <span class="hljs-number">17.</span>, <span class="hljs-number">18.</span>, <span class="hljs-number">19.</span>]]), tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">4.</span>]))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.mv(A, x)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([ <span class="hljs-number">30.</span>,  <span class="hljs-number">80.</span>, <span class="hljs-number">130.</span>, <span class="hljs-number">180.</span>])</code></pre></div><p>利用 <code>mm(A, B)</code> 矩阵乘法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>B = torch.ones(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.mm(A, B)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">10.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">10.</span>],        [<span class="hljs-number">35.</span>, <span class="hljs-number">35.</span>, <span class="hljs-number">35.</span>, <span class="hljs-number">35.</span>],        [<span class="hljs-number">60.</span>, <span class="hljs-number">60.</span>, <span class="hljs-number">60.</span>, <span class="hljs-number">60.</span>],        [<span class="hljs-number">85.</span>, <span class="hljs-number">85.</span>, <span class="hljs-number">85.</span>, <span class="hljs-number">85.</span>]])</code></pre></div><div class="note note-success">            <p>更加通用地，有库函数 <code>torch.matmul(input, other, out=None)</code> 执行矩阵相乘。</p><p><code>input</code> ：要进行矩阵相乘的第一个张量（或标量）。</p><p><code>other</code> ：要进行矩阵相乘的第二个张量（或标量）。</p><p><code>out</code> ：如果提供了输出张量，结果将存储在这个张量中，而不是创建一个新的张量。</p><p><code>torch.normal()</code> 的行为取决于输入张量的维度。</p><ol type="1"><li>若两个张量均一维，执行内积（点积）操作，返回一个标量。</li><li>若两个张量均二维，它执行矩阵乘法，返回一个二维矩阵。</li><li>若至少一个张量高维，它执行广义矩阵乘法操作，根据广播规则计算结果。</li></ol>          </div><p>利用 <code>norm(x)</code> 求 <span class="math inline">\(L_2\)</span> 范数：</p><p><span class="math display">\[ \| \mathbf{v} \|_2 = \sqrt{v_1^2 + v_2^2 + \ldots + v_n^2} \]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>v = torch.tensor([<span class="hljs-number">3.0</span>,-<span class="hljs-number">4.0</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>torch.norm(v)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">5.</span>)</code></pre></div><p><span class="math inline">\(L_1\)</span> 范数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.<span class="hljs-built_in">abs</span>(v).<span class="hljs-built_in">sum</span>()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">7.</span>)</code></pre></div><p>矩阵的 <span class="math inline">\(L_2\)</span> 范数：（Frobenius范数）</p><p><span class="math display">\[\|A\|_2=\sqrt{\sum_{i=1}^{m}\sum_{j=1}^{n}|a_{ij}|^2}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.norm(torch.ones((<span class="hljs-number">4</span>, <span class="hljs-number">9</span>)))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">6.</span>)</code></pre></div><h2 id="微分操作">微分操作</h2><p>用 <code>requires_grad = True</code> 为张量启动梯度计算：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad = <span class="hljs-literal">True</span>) <span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>])</code></pre></div><p>另一种写法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.requires_grad_(<span class="hljs-literal">True</span>)</code></pre></div><p>利用 <code>backward()</code> 计算梯度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.dot(x, x)<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward()</code></pre></div><div class="note note-warning">            <p>注意，使用点积而不是乘法，因为 pytorch 只能对标量求梯度。</p><p>不过可以使用 <code>y.sum().backward()</code> 。</p><p>效果和 <code>y.backward(torch.ones_like(y))</code> 等同。</p>          </div><p>利用 <code>.grad</code> 显示梯度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.grad</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">6.</span>])</code></pre></div><p>由 <span class="math inline">\(\nabla \textbf{x}^\top\textbf{x}=2\textbf{x}\)</span> 得知答案正确，也可以利用程序验证。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.grad == <span class="hljs-number">2</span> * x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>])</code></pre></div><p>重置梯度值为 0 ，以便后续计算其它梯度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.grad.zero_()</code></pre></div><p>利用 <code>.detach()</code> 停止梯度传播：对比两个例子：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad = <span class="hljs-literal">True</span>) <span class="hljs-comment"># [0, 1, 2, 3]</span><span class="hljs-meta">&gt;&gt;&gt; </span>y = x * x<span class="hljs-meta">&gt;&gt;&gt; </span>y1 = y * x<span class="hljs-meta">&gt;&gt;&gt; </span>y1.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-meta">&gt;&gt;&gt; </span>x.grad</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">12.</span>, <span class="hljs-number">27.</span>])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad = <span class="hljs-literal">True</span>) <span class="hljs-comment"># [0, 1, 2, 3]</span><span class="hljs-meta">&gt;&gt;&gt; </span>y = x * x<span class="hljs-meta">&gt;&gt;&gt; </span>y2 = y.detach() * x<span class="hljs-meta">&gt;&gt;&gt; </span>y2.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-meta">&gt;&gt;&gt; </span>x.grad</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">9.</span>])</code></pre></div><p>可以看到前者计算的是 <span class="math inline">\(y1=x\times x \times x\)</span> 的偏导数为 <span class="math inline">\(3x^2\)</span> 。</p><p>而后者则是 <span class="math inline">\(y2=u\times x\)</span> （ <span class="math inline">\(u\)</span> 看作常量，数值等于 <span class="math inline">\(y\)</span> ）的偏导数，即为 <span class="math inline">\(u=x^2\)</span> 。</p><div class="note note-info">            <p>此外，还可以用一个上下文管理器 <code>torch.no_grad()</code> 来禁止梯度传播。</p><p>例如以下是第二个例子的等价形式：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad = <span class="hljs-literal">True</span>) <span class="hljs-comment"># [0, 1, 2, 3]</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():        y = x * x;    <span class="hljs-meta">&gt;&gt;&gt; </span>y2 = y * x;<span class="hljs-meta">&gt;&gt;&gt; </span>y2.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-meta">&gt;&gt;&gt; </span>x.grad</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">tensor</span>([<span class="hljs-number">0</span>., <span class="hljs-number">1</span>., <span class="hljs-number">4</span>., <span class="hljs-number">9</span>.])</code></pre></div>          </div><p>利用 <code>retain_graph=True</code> 保留计算图，以便再次 <code>backward()</code> ：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad=<span class="hljs-literal">True</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.dot(x, x)<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward(retain_graph=<span class="hljs-literal">True</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward()</code></pre></div><p>若第三行换成 <code>y.backward()</code> 则会报错。</p><h2 id="线性回归">线性回归</h2><p>模块导入</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn</code></pre></div><p>用 <code>nn.Linear</code> 定义一个线性层：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>model = nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># 输入特征数为2,输出特征数为1(标量)</span></code></pre></div><div class="note note-info">            <p>参数列表：<code>torch.nn.Linear(in_features, out_features, bias=True)</code></p><p><code>in_features</code> ：输入神经元个数，即输入特征数。</p><p><code>out_features</code> ：输出神经元个数，即输出特征数。</p><p><code>bias</code> ：是否包含偏置。</p><p>本质是执行了一个线性变换： <span class="math display">\[\textbf{Y}_{n\times out} = \textbf{X}_{n\times in}\textbf{W}_{in\times out}+\textbf{b}\]</span> 其中 <span class="math inline">\(n\)</span> 是样本数量，或者说 <code>batch_size</code> 。<span class="math inline">\(in,out\)</span> 为输入和输出的特征维度，<span class="math inline">\(\textbf{b}\)</span> 为 <span class="math inline">\(out\)</span> 维的向量偏置，使用了广播机制。</p>          </div><p>用 <code>nn.Sequential</code> 定义神经网络容器：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>net = nn.Sequential(model)</code></pre></div><p>作用是按顺序组织一系列神经网络的层（layer），例如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>model = nn.Sequential(        nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>),        nn.ReLU(),        nn.Conv2d(<span class="hljs-number">20</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>),        nn.ReLU()        )</code></pre></div><p>我们可以通过下标访问元素，如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>net = nn.Sequential(        nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)        <span class="hljs-comment"># other</span>    )<span class="hljs-meta">&gt;&gt;&gt; </span>net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)</code></pre></div><p>通过 <code>net[0]</code> 去访问了 <code>Linear</code> 类中的函数，使模型参数初始化。</p><p>其中 <code>weight</code> 和 <code>bias</code> 指明要访问权值还是偏置数据，<code>normal_</code> 和 <code>fill_</code> 则是 pytorch 的两个张量方法。</p><p><code>tensor.normal_(mean=0, std=1)</code> 指定随机抽样的正态分布均值和标准差。</p><p><code>tensor.fill_(value)</code> 则直接填充 <code>value</code> 值。</p><p>调用损失函数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>nn.MSELoss() <span class="hljs-comment"># 均方误差，或称平方L2范数</span></code></pre></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        常见损失函数    </div>    <div class='spoiler-content'>        <p><code>L1Loss()</code> ：L1 范数损失（MAE）</p><p><code>MSELoss()</code> : 均方误差（MSE）</p><p><code>SmoothL1Loss()</code> ：L1 平滑损失。</p><p><code>CrossEntyopyLoss()</code> ：交叉熵损失</p><p><code>NLLloss()</code> ：负对数似然损失。</p><p><code>BCELoss()</code> ：二元交叉熵损失。</p>    </div></div><p>用 <code>torch.optim.SGD</code> 执行小批量随机梯度下降算法并更新：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>trainer.step()</code></pre></div><p><code>parameters()</code> 用于自动读取参数，<code>lr</code> 为学习率（LearningRate）。</p><p>完整实例（《动手学深度学习》章节3.3）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> torch<span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nntrue_w = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>])true_b = <span class="hljs-number">4.2</span><span class="hljs-comment"># 生成多个噪声数据</span>features, labels = d2l.synthetic_data(true_w, true_b, <span class="hljs-number">1000</span>)<span class="hljs-comment"># 构建PyTorch数据迭代器</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_array</span>(<span class="hljs-params">data_arrays, batch_size, is_train=<span class="hljs-literal">True</span></span>):  <span class="hljs-comment">#@save</span>    dataset = data.TensorDataset(*data_arrays)    <span class="hljs-keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)batch_size = <span class="hljs-number">10</span>data_iter = load_array((features, labels), batch_size)<span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data_iter))<span class="hljs-comment"># 创建神经网络</span>net = nn.Sequential(nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<span class="hljs-comment"># 初始化参数</span>net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)loss = nn.MSELoss()trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)num_epochs = <span class="hljs-number">3</span><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:        l = loss(net(X) ,y)        trainer.zero_grad()        l.backward()        trainer.step()    l = loss(net(features), labels)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span>, loss <span class="hljs-subst">&#123;l:f&#125;</span>&#x27;</span>)w = net[<span class="hljs-number">0</span>].weight.data<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;w的估计误差：&#x27;</span>, true_w - w.reshape(true_w.shape))b = net[<span class="hljs-number">0</span>].bias.data<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b的估计误差：&#x27;</span>, true_b - b)<span class="hljs-comment"># 访问线性回归的梯度</span>w_grad = net[<span class="hljs-number">0</span>].weight.grad<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;w的梯度：&#x27;</span>, w_grad)b_grad = net[<span class="hljs-number">0</span>].bias.grad<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b的梯度：&#x27;</span>, b_grad)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">epoch <span class="hljs-number">1</span>, loss <span class="hljs-number">0.000232</span>epoch <span class="hljs-number">2</span>, loss <span class="hljs-number">0.000101</span>epoch <span class="hljs-number">3</span>, loss <span class="hljs-number">0.000100</span>w的估计误差： tensor([ <span class="hljs-number">0.0002</span>, -<span class="hljs-number">0.0003</span>])b的估计误差： tensor([-<span class="hljs-number">0.0003</span>])w的梯度： tensor([[-<span class="hljs-number">0.0041</span>, -<span class="hljs-number">0.0147</span>]])b的梯度： tensor([<span class="hljs-number">0.0073</span>])</code></pre></div><h2 id="激活函数">激活函数</h2><ol type="1"><li><span class="math inline">\(\text{ReLU}(x)\)</span> 函数</li></ol><p><span class="math display">\[\text{ReLU}(x)=\max(x,0)\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(-<span class="hljs-number">3.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">0.5</span>, requires_grad=<span class="hljs-literal">True</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.relu(x)<span class="hljs-meta">&gt;&gt;&gt; </span>x, y<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward(torch.ones_like(x), retain_graph=<span class="hljs-literal">True</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">(tensor([-<span class="hljs-number">3.0000</span>, -<span class="hljs-number">2.5000</span>, -<span class="hljs-number">2.0000</span>, -<span class="hljs-number">1.5000</span>, -<span class="hljs-number">1.0000</span>, -<span class="hljs-number">0.5000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.5000</span>,          <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.5000</span>,  <span class="hljs-number">2.0000</span>,  <span class="hljs-number">2.5000</span>], requires_grad=<span class="hljs-literal">True</span>), tensor([<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5000</span>, <span class="hljs-number">1.0000</span>,         <span class="hljs-number">1.5000</span>, <span class="hljs-number">2.0000</span>, <span class="hljs-number">2.5000</span>], grad_fn=&lt;ReluBackward0&gt;))</code></pre></div><p><img src="https://zh-v2.d2l.ai/_images/output_mlp_76f463_21_0.svg" style="zoom: 67%;" /></p><p>一个显著的性质是对 <span class="math inline">\(\text{ReLU}(x)\)</span> 求导后非 <span class="math inline">\(0\)</span> 即 <span class="math inline">\(1\)</span> ，即要么让参数消失，要么让参数通过。</p><p><img src="https://zh-v2.d2l.ai/_images/output_mlp_76f463_36_0.svg" style="zoom:67%;" /></p><p>用许多个 <span class="math inline">\(\text{ReLU}(x)\)</span> 函数构成连续的分段线性函数：</p><p><img src="https://datawhalechina.github.io/d2l-ai-solutions-manual/ch04/ch4-4-1-2-relu.png" style="zoom: 33%;" /></p><p>变体：（即使参数是负的，某些信息仍然可以通过） <span class="math display">\[\text{pReLU}(x)=\max(0,x) + \alpha\min(0,x)\]</span></p><ol start="2" type="1"><li><span class="math inline">\(\text{sigmoid}(x)\)</span> 函数（“S”型函数）</li></ol><p><span class="math display">\[\text{sigmoid}(x)=\dfrac{1}{1+e^{-x}}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.sigmoid(x)<span class="hljs-meta">&gt;&gt;&gt; </span>x.grad.zero_()<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward(torch.ones_like(x), retain_graph=<span class="hljs-literal">True</span>)</code></pre></div><p><img src="https://zh-v2.d2l.ai/_images/output_mlp_76f463_51_0.svg" style="zoom: 67%;" /> <span class="math display">\[\dfrac{d}{dx}\text{sigmoid}(x)=\dfrac{e^{-x}}{(1+e^{-x})^2}=\text{sigmoid}(x)(1-\text{sigmoid}(x))\]</span> <img src="https://zh-v2.d2l.ai/_images/output_mlp_76f463_66_0.svg" style="zoom:67%;" /></p><p>易知 <span class="math inline">\(x=0\)</span> 时有导数最大值 <span class="math inline">\(\dfrac{1}{4}\)</span> 。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>pytorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>ML</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】 python3</title>
    <link href="/posts/91245943.html"/>
    <url>/posts/91245943.html</url>
    
    <content type="html"><![CDATA[<p>以下只提及与 C++ 差异较大的定义和语法。</p><p>持续更新。</p><h2 id="语言特色">语言特色</h2><p>python 属于解释型语言：最大的特色莫过于使用 <code>exec()</code> 函数直接解释括号中的字符串并运行。</p><p>python 有很多库：如 NumPy 用于数学运算，Pandas 用于数据处理，Matplotlib 用于画图等。python 不调库就好比 C++ 没有 STL (雾) 。</p><h2 id="关键字">关键字</h2><p>相比 C++，以下字符也属于 python 的保留字。</p><ul><li><p><code>False</code> <code>True</code> <code>None</code>：表示布尔值，空值（注意是大写）。</p></li><li><p><code>def</code> ：用于函数定义。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function_name</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hrdg kawaii!&quot;</span>)</code></pre></div></p></li><li><p><code>assert</code> ：检查条件真假。</p><p><div class="code-wrapper"><pre><code class="hljs python">x = -<span class="hljs-number">1</span><span class="hljs-keyword">assert</span> x &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;靠&quot;</span><span class="hljs-built_in">print</span>(x)</code></pre></div></p><p>运行时会报错 <code>AssertionError: 靠</code> 而不会执行 <code>print</code> 。</p></li><li><p><code>del</code> ：用于删除变量或对象。</p><p><div class="code-wrapper"><pre><code class="hljs python">x = <span class="hljs-number">1</span><span class="hljs-keyword">del</span> x<span class="hljs-built_in">print</span>(x)</code></pre></div></p><p>运行时报错 <code>NameError: name 'x' is not defined</code> 。</p></li><li><p><code>elif</code> ：等同于 C++ 的 <code>else if</code> 。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-1&quot;</span>)<span class="hljs-keyword">elif</span> x == <span class="hljs-number">0</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>)</code></pre></div></p></li><li><p><code>except</code> ：用于异常处理时捕获异常。</p></li><li><p><code>finally</code> ：异常处理中必须执行。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    result = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><span class="hljs-keyword">except</span> ZeroDivisionError:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;除以零错误&quot;</span>)<span class="hljs-keyword">finally</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无论如何都会执行这里的代码&quot;</span>)</code></pre></div> 其中 <code>ZeroDivisionError</code> 是一个内置异常。</p></li></ul><div class='spoiler collapsed'>    <div class='spoiler-title'>        其它内置异常    </div>    <div class='spoiler-content'>        <ol type="1"><li><p><code>SyntaxError</code>：语法错误，通常发生在代码编写时，如拼写错误、缺少冒号等。</p></li><li><p><code>IndentationError</code>：缩进错误，通常发生在代码块的缩进不一致或不正确时。</p></li><li><p><code>NameError</code>：名称错误，通常发生在尝试访问不存在的变量或名称时。</p></li><li><p><code>TypeError</code>：类型错误，通常发生在操作不兼容的数据类型时，如将字符串和数字相加。</p></li><li><p><code>ValueError</code>：值错误，通常发生在操作正确类型的对象，但值无效或不合法时，如尝试将无效的字符串转换为数字。</p></li><li><p><code>ZeroDivisionError</code>：除以零错误，通常发生在除法操作中的除数为零时。</p></li><li><p><code>IndexError</code>：索引错误，通常发生在尝试访问列表、元组或其他序列中不存在的索引时。</p></li><li><p><code>KeyError</code>：键错误，通常发生在尝试访问字典中不存在的键时。</p></li><li><p><code>FileNotFoundError</code>：文件未找到错误，通常发生在尝试打开不存在的文件时。</p></li><li><p><code>IOError</code>：输入/输出错误，通常发生在文件操作失败或无法读取或写入文件时。</p></li><li><p><code>ImportError</code>：导入错误，通常发生在尝试导入不存在的模块或无效的模块时。</p></li><li><p><code>AttributeError</code>：属性错误，通常发生在尝试访问对象上不存在的属性时。</p></li><li><p><code>TypeError</code>：类型错误，通常发生在函数或方法接收到不正确类型的参数时。</p></li><li><p><code>AssertionError</code>：断言错误，通常发生在 <code>assert</code> 语句中的条件不满足时。</p></li><li><p><code>ArithmeticError</code>：算术错误的基类，包括 <code>ZeroDivisionError</code> 和 <code>OverflowError</code> 等。</p></li><li><p><code>EOFError</code>：文件末尾错误，通常发生在尝试从已经读取到文件末尾的文件读取更多数据时。</p></li></ol>    </div></div><ul><li><p><code>from</code> <code>import</code> ：从模块中导入函数，变量或类。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt</code></pre></div></p></li><li><p><code>global</code> ：声明全局变量。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<span class="hljs-keyword">global</span> xx = <span class="hljs-number">10</span>func()<span class="hljs-built_in">print</span>(x)</code></pre></div></p></li><li><p><code>in</code> ：检查一个值是否存在于一个容器中，如列表，元组，字典等。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-number">5</span> <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;5 存在于列表中&quot;</span>)</code></pre></div></p></li><li><p><code>is</code> ：比较两个对象是否是同一个对象。（比较的不是值而是内存地址）</p><p><div class="code-wrapper"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]y = x<span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> y:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x 和 y 是同一个对象&quot;</span>)</code></pre></div></p></li><li><p><code>lambda</code> ：创建匿名函数。</p><ul><li><p>语法：<code>lambda arguments: expression</code> ，依次对应关键字，函数参数和表达式。</p><div class="code-wrapper"><pre><code class="hljs python">add = <span class="hljs-keyword">lambda</span> x, y: x + y * <span class="hljs-number">2</span><span class="hljs-built_in">print</span>(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 输出 8</span></code></pre></div></li></ul></li><li><p><code>nonlocal</code> ：在嵌套函数中声明一个外部（封闭）函数的变量，而不是创建一个新的局部变量。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_function</span>():    x = <span class="hljs-number">10</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner_function</span>():        <span class="hljs-keyword">nonlocal</span> x        x = <span class="hljs-number">20</span>    inner_function()    <span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># 输出 20</span></code></pre></div></p></li><li><p><code>pass</code> ：占位符，表示一个空的代码块或函数体。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():    <span class="hljs-keyword">pass</span></code></pre></div></p></li><li><p><code>with</code> ：用于创建一个上下文管理器，通常用于管理资源，如文件或数据库连接。</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> file:    data = file.read()</code></pre></div></p></li><li><p><code>yield</code> ：允许你编写一种特殊类型的函数，这种函数可以在迭代时逐个产生值，而不是一次性生成所有值。</p><ul><li><p>如以下程序会输出前10个斐波那契数。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_generator</span>(<span class="hljs-params">n</span>):    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>    count = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> count &lt; n:        <span class="hljs-keyword">yield</span> a        a, b = b, a + b        count += <span class="hljs-number">1</span><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> fib_generator(<span class="hljs-number">10</span>):    <span class="hljs-built_in">print</span>(value,end=<span class="hljs-string">&quot; &quot;</span>)  <span class="hljs-comment"># 0 1 1 2 3 5 8 13 21 34</span></code></pre></div><p>可以发现程序遇到 <code>yield</code> 时立即返回对应值。</p></li></ul></li></ul><h2 id="注释">注释</h2><ul><li><p>单行注释：</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 啊?OP?</span></code></pre></div></p></li><li><p>多行注释：</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">原来你也玩原神?</span><span class="hljs-string">原神怎么你了?</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div></p></li></ul><h2 id="多行语句">多行语句</h2><p>运用反斜杠 <code>\</code> 。</p><div class="code-wrapper"><pre><code class="hljs python">a,b,c = <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>t = a + b + \+c<span class="hljs-built_in">print</span>(t)  <span class="hljs-comment"># 3</span></code></pre></div><h2 id="字符串">字符串</h2><ul><li><p>不同于 C++ 中的 "单引号括字符，双引号括字符串" ，python 中单引号与双引号用法<strong>完全相同</strong>。</p></li><li><p>三引号：指定多行字符串。</p><p><div class="code-wrapper"><pre><code class="hljs python">word = <span class="hljs-string">&#x27;&#x27;&#x27;这合</span><span class="hljs-string">理吗&#x27;&#x27;&#x27;</span><span class="hljs-built_in">print</span>(word)</code></pre></div></p><p>输出：</p><p><div class="code-wrapper"><pre><code class="hljs">这合理吗</code></pre></div></p></li><li><p>使用 <code>r</code> 以防止转义。</p><p><div class="code-wrapper"><pre><code class="hljs python">word = <span class="hljs-string">r&#x27;hrdg yyds\n&#x27;</span><span class="hljs-built_in">print</span>(word)  <span class="hljs-comment"># &quot;hrdg yyds\n&quot;</span></code></pre></div></p></li></ul><div class='spoiler collapsed'>    <div class='spoiler-title'>        常见转义符    </div>    <div class='spoiler-content'>        <ol type="1"><li><code>\\</code>：表示一个反斜杠字符。</li><li><code>\'</code>：表示一个单引号字符。</li><li><code>\"</code>：表示一个双引号字符。</li><li><code>\n</code>：表示换行符，用于在字符串中创建新的一行。</li><li><code>\t</code>：表示制表符，用于在字符串中创建水平制表位。</li><li><code>\r</code>：表示回车符，通常与 <code>\n</code> 一起使用，用于在字符串中创建新行并将光标移到行首。</li><li><code>\b</code>：表示退格符，用于在字符串中删除前一个字符。</li><li><code>\f</code>：表示换页符，通常用于在字符串中创建新的一页。</li><li><code>\v</code>：表示垂直制表符，通常用于在字符串中创建垂直制表位。</li><li><code>\ooo</code>：表示一个八进制值，其中 <code>ooo</code> 是三个八进制数字，用于表示特定的字符。</li><li><code>\xhh</code>：表示一个十六进制值，其中 <code>hh</code> 是两个十六进制数字，用于表示特定的字符。</li></ol>    </div></div><ul><li><p>可以用 <code>*</code> 使字符串重复。</p><p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-built_in">print</span>(a * <span class="hljs-number">3</span>) <span class="hljs-comment"># aaa</span></code></pre></div></p></li><li><p>字符串的索引与截取</p><ul><li><p>从左往右索引以 <code>0</code> 开始，从右往左以 <code>-1</code> 开始。</p></li><li><p>截取格式：<code>[Begin:End:Step]</code> ：截取 <code>Begin</code> 到 <code>End-1</code> 的字符，步长为 <code>Step</code> 。</p></li><li><p>以下是一个实例：</p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;123456789&#x27;</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>])     <span class="hljs-comment"># 1</span><span class="hljs-built_in">print</span>(s[-<span class="hljs-number">1</span>])    <span class="hljs-comment"># 9</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>])   <span class="hljs-comment"># 456</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 12345678</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">2</span>:])    <span class="hljs-comment"># 3456789</span><span class="hljs-built_in">print</span>(s[:<span class="hljs-number">2</span>])    <span class="hljs-comment"># 12</span><span class="hljs-built_in">print</span>(s[:-<span class="hljs-number">1</span>])   <span class="hljs-comment"># 12345678</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment"># 24</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">1</span>::<span class="hljs-number">3</span>])  <span class="hljs-comment"># 258</span><span class="hljs-built_in">print</span>(s[:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment"># 1357</span></code></pre></div></li></ul></li><li><p>字符串格式化</p><p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>()greeting = <span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span><span class="hljs-built_in">print</span>(greeting)</code></pre></div></p></li></ul><h2 id="输入输出">输入输出</h2><ul><li><p>使用 <code>input()</code> 输入</p><ul><li><p>基本用法： <code>a = input()</code></p></li><li><p>传递字符串作为输入提示： <code>a = input("a = ")</code></p></li><li><p>类型转换： <code>a = int(input())</code></p></li><li><p>运用 <code>.split()</code> 分隔</p><p><div class="code-wrapper"><pre><code class="hljs python">a,b,c = <span class="hljs-built_in">input</span>().split() <span class="hljs-comment"># 输入“1 2 3”</span><span class="hljs-built_in">print</span>(b) <span class="hljs-comment"># 输出2</span></code></pre></div></p></li></ul></li><li><p>使用 <code>print()</code> 输出</p><ul><li><p>换行： <code>print(x)</code></p></li><li><p>不换行： <code>print(x,end="")</code></p><div class="code-wrapper"><pre><code class="hljs python">a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(a, end=<span class="hljs-string">&quot; &quot;</span>)<span class="hljs-built_in">print</span>(b, end=<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-built_in">print</span>(a) <span class="hljs-comment">#输出 &quot;0 10&quot;</span></code></pre></div></li></ul></li><li><p>其它输出方式</p><ul><li><p>文件输出</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> file:    file.write(<span class="hljs-string">&quot;This is written to a file.&quot;</span>)</code></pre></div></p></li><li><p>格式化字符串输出</p><p><div class="code-wrapper"><pre><code class="hljs python">name = <span class="hljs-string">&quot;学生&quot;</span>age = <span class="hljs-number">24</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;岁,是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(age,name))<span class="hljs-comment"># 24岁,是学生</span></code></pre></div></p><p>或者使用 f-strings 等价：</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;age&#125;</span>岁,是<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<span class="hljs-comment"># 24岁,是学生</span></code></pre></div></p></li><li><p>标准错误输出（一般输出至终端或命令行）</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> syssys.stderr.write(<span class="hljs-string">&quot;寄了,哈哈\n&quot;</span>)</code></pre></div></p></li></ul></li></ul><h2 id="模块导入">模块导入</h2><ul><li><p>只导入模块： <code>import somemodule</code></p><ul><li>后续调用使用 <code>somemodule.func_a</code> 形式</li></ul></li><li><p>导入模块成员： <code>from somemodule import func_a,func_b</code></p><ul><li>后续直接调用 <code>func_a</code> <code>func_b</code></li></ul></li><li><p>导入模块中的全部函数： <code>from somemodule import *</code></p></li><li><p>什么是 <code>if __name__ == "__main__":</code> ?</p><ul><li><p>当你创建了一个模块（比如一个 .py 文件），这个模块就会有一个内置属性 <code>name</code> 生成。当你 import 一个模块时，<code>name</code> 通常是文件名。如果你直接运行该模块，那么 <code>__name__ == "__main__"</code> ，否则不等。</p></li><li><p>例如你创建了两个 .py 文件：</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># test1.py</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a&#x27;</span>,end=<span class="hljs-string">&quot; &quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b&#x27;</span>)</code></pre></div></p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># test2.py</span><span class="hljs-keyword">import</span> test1</code></pre></div></p><p>直接运行 <code>test1.py</code> 输出 <code>a b</code> ;</p><p>而运行 <code>test2.py</code> 则输出 <code>a</code> 。</p></li></ul></li><li><p>模块搜索顺序：</p><ul><li>当前目录</li><li>shell 变量 PYTHONPATH 下的每个目录（PYTHONPATH 由装在一个列表里的许多目录组成）</li><li>查看默认路径（UNIX下，默认路径一般为/usr/local/lib/python/）</li></ul></li><li><p>利用 <code>dir(somemodule)</code> 查看模块中定义的子模块，变量，函数。</p></li><li><p>利用 <code>locals()</code> 访问<strong>局部</strong>命名空间，<code>globals()</code> 访问<strong>全局</strong>命名空间。</p></li><li><p>利用 <code>reload(somemodule)</code> 重新执行顶层导入代码。</p></li></ul><h2 id="数值对象">数值对象</h2><ul><li><p>乘方用 <code>**</code> ，如 <code>2 ** 3 = 8</code></p></li><li><p>数值除法包括：</p><ul><li><code>/</code> 返回一个<strong>浮点数</strong>。<code>3 / 2 = 1.5</code></li><li><code>//</code> 类似 C 整数除法，<strong>下取整</strong>。<code>3 // 2 = 1</code></li></ul></li><li><p>混合计算时，整型会被转化为浮点数。</p></li><li><p>利用 <code>type(object)</code> 获取对象类型</p><p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-number">2.0</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))<span class="hljs-comment"># 输出“&lt;class &#x27;float&#x27;&gt;”</span></code></pre></div></p></li><li><p>利用 <code>isinstance(object, classinfo)</code> 检查一个对象是否是特定类或类型的实例。其返回一个布尔值。</p><ul><li><p>类型判断：</p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-number">2.0</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(a,<span class="hljs-built_in">int</span>)) <span class="hljs-comment"># False</span></code></pre></div></li><li><p>实例判断：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">op</span>:qiye_nana7 = <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(op(),op)) <span class="hljs-comment"># True</span></code></pre></div><p>那如果想判断 <code>qiye_nana7</code> 是否属于 <code>op</code> 怎么办呢？</p><p>其中<code>qiye_nana7</code> 属于类属性，那么使用 <code>hasattr(class_name,attribute_name)</code> 判断：</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">op</span>:qiye_nana7 = <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(op, <span class="hljs-string">&#x27;qiye_nana7&#x27;</span>)) <span class="hljs-comment"># True</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(op, <span class="hljs-string">&#x27;KisuraOP&#x27;</span>)) <span class="hljs-comment"># False</span></code></pre></div></p></li></ul></li></ul><h2 id="列表list">列表（List）</h2><ul><li><p>类似数组，是有序对象集合。</p></li><li><p>中括号定义：<code>list = [123, 1.0, 'str', 'nmsl']</code></p></li><li><p>调用和截取与字符串相同，略。</p></li><li><p>与字符串不同的是，列表中的元素可以改变：</p><p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;cnm&#x27;</span><span class="hljs-comment"># a[0] = &#x27;a&#x27; # 编译错误</span>a = [<span class="hljs-string">&#x27;原神&#x27;</span>, <span class="hljs-string">&#x27;牛批&#x27;</span>]<span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])  <span class="hljs-comment"># 原批</span>a[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;o&#x27;</span>a[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;p&#x27;</span><span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>]+a[<span class="hljs-number">1</span>])  <span class="hljs-comment"># op</span></code></pre></div></p></li></ul><h2 id="元组tuple">元组（Tuple）</h2><ul><li>与列表类似，元组一样可以通过 <code>+</code> 连接，<code>*</code> 重复，不过其<strong>元素不能修改</strong>。</li><li>小括号定义：<code>tup = (123, 1.0, 'str', 'nmsl')</code> 。</li><li>只包含一个元素时，需添加逗号。 <code>tup2 = (114514,)</code></li></ul><h2 id="集合set">集合（Set）</h2><ul><li><p>特点：无序，可变，元素不会重复。</p></li><li><p>大括号定义：<code>setA = &#123;'Codeforces', 'Atcoder', 'Luogu'&#125;</code></p></li><li><p>函数定义：<code>setB = set('AAACMCA')</code> <span class="math inline">\(\to\)</span> <code>setB = &#123;'A', 'C', 'M'&#125;</code></p></li><li><p>集合运算：</p><p><div class="code-wrapper"><pre><code class="hljs python">A = &#123;<span class="hljs-string">&#x27;Codeforces&#x27;</span>, <span class="hljs-string">&#x27;Atcoder&#x27;</span>, <span class="hljs-string">&#x27;Luogu&#x27;</span>, <span class="hljs-string">&#x27;Lutece&#x27;</span>&#125;B = &#123;<span class="hljs-string">&#x27;Lutece&#x27;</span>, <span class="hljs-string">&#x27;TopCoder&#x27;</span>&#125;<span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Atcoder&#x27;</span> <span class="hljs-keyword">in</span> A:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<span class="hljs-comment"># Yes</span><span class="hljs-built_in">print</span>(A - B)  <span class="hljs-comment"># 差集 &#123;&#x27;Luogu&#x27;, &#x27;Codeforces&#x27;, &#x27;Atcoder&#x27;&#125;</span><span class="hljs-built_in">print</span>(B - A)  <span class="hljs-comment"># 差集 &#123;&#x27;TopCoder&#x27;&#125;</span><span class="hljs-built_in">print</span>(A | B)  <span class="hljs-comment"># 并集 &#123;&#x27;Codeforces&#x27;, &#x27;Atcoder&#x27;, &#x27;TopCoder&#x27;, &#x27;Luogu&#x27;, &#x27;Lutece&#x27;&#125;</span><span class="hljs-built_in">print</span>(A &amp; B)  <span class="hljs-comment"># 交集 &#123;&#x27;Lutece&#x27;&#125;</span><span class="hljs-built_in">print</span>(A ^ B)  <span class="hljs-comment"># 异或,不同时出现 &#123;&#x27;Codeforces&#x27;, &#x27;Atcoder&#x27;, &#x27;TopCoder&#x27;, &#x27;Luogu&#x27;&#125;</span></code></pre></div></p></li></ul><h2 id="字典dict">字典（Dict）</h2><ul><li><p>无序对象集合，键值对存储，键必须唯一。类似 STL 中的 <code>map</code> 。</p><p><div class="code-wrapper"><pre><code class="hljs python">  a = &#123;      <span class="hljs-string">&#x27;op&#x27;</span>: <span class="hljs-string">&#x27;我&#x27;</span>,      <span class="hljs-number">55</span>: <span class="hljs-string">&#x27;芙宁娜大人&#x27;</span>,      <span class="hljs-string">&#x27;啊&#x27;</span>: <span class="hljs-number">4</span>  &#125;    <span class="hljs-built_in">print</span>(a[<span class="hljs-string">&#x27;op&#x27;</span>] + <span class="hljs-built_in">str</span>(a[<span class="hljs-string">&#x27;啊&#x27;</span>]) + a[<span class="hljs-number">55</span>] + <span class="hljs-string">&#x27;的狗&#x27;</span>)  <span class="hljs-comment"># 我4芙宁娜大人的狗</span>    <span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># &#123;&#x27;op&#x27;: &#x27;我&#x27;, 55: &#x27;芙宁娜大人&#x27;, &#x27;啊&#x27;: 4&#125;</span>    <span class="hljs-built_in">print</span>(a.keys())  <span class="hljs-comment"># dict_keys([&#x27;op&#x27;, 55, &#x27;啊&#x27;])</span>    <span class="hljs-built_in">print</span>(a.values())  <span class="hljs-comment"># dict_values([&#x27;我&#x27;, &#x27;芙宁娜大人&#x27;, 4])</span>      a[<span class="hljs-string">&#x27;op&#x27;</span>] = <span class="hljs-string">&#x27;芙宁娜&#x27;</span>  <span class="hljs-comment"># 更改键值对</span>  a[<span class="hljs-number">44</span>] = <span class="hljs-string">&#x27;我&#x27;</span>  <span class="hljs-comment"># 增添键值对</span>    <span class="hljs-built_in">print</span>(a[<span class="hljs-string">&#x27;op&#x27;</span>] + <span class="hljs-built_in">str</span>(a[<span class="hljs-string">&#x27;啊&#x27;</span>]) + a[<span class="hljs-number">44</span>] + <span class="hljs-string">&#x27;的狗&#x27;</span>)  <span class="hljs-comment"># 芙宁娜4我的狗</span>    <span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># &#123;&#x27;op&#x27;: &#x27;芙宁娜&#x27;, 55: &#x27;芙宁娜大人&#x27;, &#x27;啊&#x27;: 4, 44: &#x27;我&#x27;&#125;</span>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:      <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment"># op55啊44</span>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> a.items():      <span class="hljs-built_in">print</span>(i, j, end=<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment"># op 芙宁娜55 芙宁娜大人啊 444 我</span>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(a))  <span class="hljs-comment"># 4</span>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;我&#x27;</span> <span class="hljs-keyword">in</span> a:      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;oh yeah&quot;</span>)  <span class="hljs-keyword">else</span>:      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<span class="hljs-comment"># No</span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;op&#x27;</span> <span class="hljs-keyword">in</span> a:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;oh yeah&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<span class="hljs-comment"># oh yeah</span>a.clear()  <span class="hljs-comment"># 清空字典</span><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># &#123;&#125;</span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;op&#x27;</span> <span class="hljs-keyword">in</span> a:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这河里吗&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;op似光辣&quot;</span>)<span class="hljs-comment"># op似光辣</span></code></pre></div></p></li></ul><h2 id="数据类型转换">数据类型转换</h2><ol type="1"><li><p><code>int(x[,base])</code> ：将 <code>x</code> 作为 <code>base</code> 进制转换。</p><ul><li><code>int('101') = 101</code> , <code>int('101',2) = 5</code> 。</li></ul></li><li><p><code>float(x)</code> ：转换为浮点数</p></li><li><p><code>str(x)</code> <code>repr(x)</code> ：转换为字符串/字符串字面量。</p><ul><li><p>有什么区别？</p><p><div class="code-wrapper"><pre><code class="hljs python">s=<span class="hljs-string">&quot;校区 \t清水河\t沙河\n提档线\t629 \t631&quot;</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(s))<span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(s))</code></pre></div></p><p>将会输出：</p><p><div class="code-wrapper"><pre><code class="hljs taggerscript">校区 清水河沙河提档线629   631&#x27;校区 <span class="hljs-symbol">\t</span>清水河<span class="hljs-symbol">\t</span>沙河<span class="hljs-symbol">\n</span>提档线<span class="hljs-symbol">\t</span>629 <span class="hljs-symbol">\t</span>631&#x27;</code></pre></div></p></li></ul></li><li><p><code>complex(real[,imag])</code> ：创建一个复数（实虚部）</p></li><li><p><code>tuple(x)</code> <code>list(x)</code> <code>set(x)</code> <code>dict(x)</code> ：转换为元组/列表/集合/字典</p></li><li><p><code>chr(x)</code> <code>ord(x)</code> <code>hex(x)</code> <code>oct(x)</code> ：整数转字符/字符转整数/转十六进制/转八进制</p></li><li><p><code>eval(x)</code> ：表达式计算</p><p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;2 ** 5&quot;</span>)<span class="hljs-built_in">print</span>(a) <span class="hljs-comment"># 32</span></code></pre></div></p><p>和 <code>exec()</code> 的区别在于 <code>eval()</code> <strong>只能执行表达式而不能执行代码块</strong>。</p></li></ol><h2 id="对象的可更改性">对象的可更改性</h2><ul><li><p>可变：类似 C++ 引用传递，如列表，字典。</p></li><li><p>不可变：类似 C++ 值传递，如数字，字符串，元组。</p></li><li><p>区别：</p><p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_num</span>(<span class="hljs-params">x</span>):x = x + <span class="hljs-number">1</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_list</span>(<span class="hljs-params">x</span>):x.append([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])A = <span class="hljs-number">3</span>;change_num(A)<span class="hljs-built_in">print</span>(A)   <span class="hljs-comment"># 3</span>B = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]change_list(B)<span class="hljs-built_in">print</span>(B)   <span class="hljs-comment"># [1, 2, 3, 4, [1, 2]]</span></code></pre></div></p></li></ul><h2 id="python包">python包</h2><p>包是一个分层次文件目录结构，基础构成如下：</p><div class="code-wrapper"><pre><code class="hljs vim">test.<span class="hljs-keyword">py</span>packageA|-- __init__.<span class="hljs-keyword">py</span>|-- A.<span class="hljs-keyword">py</span>|-- B.<span class="hljs-keyword">py</span>packageB|-- __init__.<span class="hljs-keyword">py</span>|-- A.<span class="hljs-keyword">py</span>|-- B.<span class="hljs-keyword">py</span></code></pre></div><p>可以通过以下方法调用模块：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># test.py</span><span class="hljs-keyword">from</span> packageB.A <span class="hljs-keyword">import</span> funcion_name<span class="hljs-keyword">from</span> packageA.B <span class="hljs-keyword">import</span> funcion_name</code></pre></div><p>其中 <code>__init__.py</code> 是必须的，目的是标识当前目录是一个包。</p><h2 id="内置函数">内置函数</h2><ul><li><p><code>enumerate(sequence, [start = 0])</code></p><ul><li><p><code>sequence</code> ：一个序列，迭代器等支持迭代的对象。</p></li><li><p><code>start</code> ：下标起始位置的值。</p></li><li><p>将一个可迭代对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和数据下标。</p></li></ul><div class="code-wrapper"><pre><code class="hljs python">a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):    <span class="hljs-built_in">print</span>(i)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">(0, &#x27;a&#x27;)</span><span class="hljs-string">(1, &#x27;b&#x27;)</span><span class="hljs-string">(2, &#x27;d&#x27;)</span><span class="hljs-string">(3, &#x27;c&#x27;)</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):    <span class="hljs-built_in">print</span>(i, j)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">0 a</span><span class="hljs-string">1 b</span><span class="hljs-string">2 d</span><span class="hljs-string">3 c</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div></li></ul><p>​</p><ul><li><p><code>map(function, iterable, ...)</code></p><ul><li><p><code>function</code> ：要应用于每个元素的函数。</p></li><li><p><code>iterable</code> ：输入到 <code>function</code> 的可迭代对象，可以是一个或多个。</p></li><li><p>将一个函数应用于可迭代对象（如列表、元组或字符串）的所有元素，返回一个迭代器。</p></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]squared_numbers = <span class="hljs-built_in">map</span>(square, numbers)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(squared_numbers)) <span class="hljs-comment"># 1, 4, 9, 16, 25</span></code></pre></div><ul><li>一个应用是求出一个数 <span class="math inline">\(x\)</span> 的各数位之和（将 <code>int</code> 作为 <code>function</code> 应用到 <span class="math inline">\(x\)</span> 每一位）</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">digit_sum</span>(<span class="hljs-params">n</span>):    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>(n)))</code></pre></div></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LGR-162-Div.3] 洛谷基础赛 5 &amp; QFOI Round 1</title>
    <link href="/posts/31577138.html"/>
    <url>/posts/31577138.html</url>
    
    <content type="html"><![CDATA[<h2 id="a.-qfoi-r1贴贴">A. 「QFOI R1」贴贴</h2><p><a href="https://www.luogu.com.cn/problem/P9712">Problem</a></p><div class="note note-success">            <p>可以使用 <code>std::isupper()</code> 和 <code>std::tolower()</code> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;string s;cin&gt;&gt;s;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;_&#x27;</span>) &#123;s[i]=<span class="hljs-string">&#x27;-&#x27;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(s[i])) &#123;s[i]=<span class="hljs-built_in">tolower</span>(s[i]);&#125;&#125;s=<span class="hljs-string">&quot;solution-&quot;</span>+s;cout&lt;&lt;s&lt;&lt;endl;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-qfoi-r1抱抱">B. 「QFOI R1」抱抱</h2><p><a href="https://www.luogu.com.cn/problem/P9713">Problem</a></p><div class="note note-success">            <p>可以想象，无论怎么切，最后剩下的一定是完整的一个长方体。</p><p>分别记录当前切出去的最大 <span class="math inline">\(x_m,y_m,z_m\)</span>，答案即 <span class="math inline">\((a-x_m)(b-y_m)(c-z_m)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(m)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>(),c=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> xmax=<span class="hljs-number">0</span>,ymax=<span class="hljs-number">0</span>,zmax=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> opt=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>) &#123;xmax=<span class="hljs-built_in">max</span>(xmax,k);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>) &#123;ymax=<span class="hljs-built_in">max</span>(ymax,k);&#125; <span class="hljs-keyword">else</span> &#123;zmax=<span class="hljs-built_in">max</span>(zmax,k);&#125;<span class="hljs-type">int</span> res=(a-xmax)*(b-ymax)*(c-zmax);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-qfoi-r1摸摸">C. 「QFOI R1」摸摸</h2><p><a href="https://www.luogu.com.cn/problem/P9714">Problem</a></p><div class="note note-info">            <p>题意：给出长度为 <span class="math inline">\(n\)</span> 的数列 <span class="math inline">\(b,t\)</span>，每次操作可以将 <span class="math inline">\(t\)</span> 与其翻转数列相加得到新 <span class="math inline">\(t\)</span>，或将 <span class="math inline">\(t\)</span> 累加到一开始为空的数列 <span class="math inline">\(a\)</span> 上，问若干次操作后是否能将 <span class="math inline">\(a\rightarrow b\)</span>。</p><p><span class="math inline">\(1\le n,b_i,t_i \le 2\times 10^3\)</span>。</p>          </div><div class="note note-success">            <p>对于一个初始数列我们考虑它经过若干次翻转相加操作后变成什么样。</p><p>初始 <span class="math inline">\([a_1,a_2,\dots,a_{n-1},a_n]\)</span>。</p><p>第一次 <span class="math inline">\([a_1+a_n,a_2+a_{n-1},\dots,a_{n-1}+a_2,a_n+a_1]\)</span>。（设为数列 <span class="math inline">\(s\)</span>）</p><p>第二次 <span class="math inline">\([2(a_1+a_n),2(a_2+a_{n-1}),\dots,2(a_{n-1}+a_2),2(a_n+a_1)]\)</span>。</p><p>第三次 <span class="math inline">\([4(a_1+a_n),4(a_2+a_{n-1}),\dots,4(a_{n-1}+a_2),4(a_n+a_1)]\)</span>。</p><p>第 <span class="math inline">\(m\)</span> 次 <span class="math inline">\([2^{m-1}(a_1+a_n),2^{m-1}(a_2+a_{n-1}),\dots,2^{m-1}(a_{n-1}+a_2),2^{m-1}(a_n+a_1)]\)</span>。</p><p>由此发现，后续无论将多少个经历几次迭代的 <span class="math inline">\(t\)</span> 加到 <span class="math inline">\(a\)</span> 上，一定等价于将若干个 <span class="math inline">\(s\)</span> 乘以一定倍数再累加到 <span class="math inline">\(a\)</span> 上。</p><p>令 <span class="math inline">\(t_0\)</span> 为初始 <span class="math inline">\(t\)</span> 数列。于是我们可以枚举 <span class="math inline">\(k_1,k_2\)</span>，判断 <span class="math inline">\(k_1\cdot t_{0i}+k_2\cdot s_i\)</span> 是否与 <span class="math inline">\(b_i\)</span> 相等。</p><p>时间复杂度为 <span class="math inline">\(O(nw)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p>          </div><div class="note note-warning">            <p>涉及整个数列/区间操作的问题可以试着手推操作过程，尝试发现性质。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t1</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">t2</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> max1=inf,max2=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;t1[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;t2[i]=t1[n-i+<span class="hljs-number">1</span>]+t1[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();max1=<span class="hljs-built_in">min</span>(max1,b[i]/t1[i]);max2=<span class="hljs-built_in">min</span>(max2,b[i]/t2[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=max1;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=max2;++j) &#123;<span class="hljs-type">bool</span> ok=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) &#123;<span class="hljs-keyword">if</span>(t1[k]*i+t2[k]*j!=b[k]) &#123;ok=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(ok) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-qfoi-r1头">D. 「QFOI R1」头</h2><p><a href="https://www.luogu.com.cn/problem/P9715">Problem</a></p><span class="label label-primary">好题，系NOI春测T1加强版</span><div class="note note-info">            <p>题意：初始一个没有颜色的 <span class="math inline">\(n\times m\)</span> 网格，现有 <span class="math inline">\(k\)</span> 种颜色编号 <span class="math inline">\(1\sim k\)</span>，以及 <span class="math inline">\(q\)</span> 次操作。</p><p>每次操作给定 <span class="math inline">\(op,l,r,c,t\)</span> 五个参数：</p><ul><li><span class="math inline">\(op=1/2\)</span> 代表将第 <span class="math inline">\(l\sim r\)</span> 行<span class="math inline">\(/\)</span>列 的所有格子涂成颜色 <span class="math inline">\(c\)</span>。</li><li><span class="math inline">\(t=0/1\)</span> 代表若遇到已被染色的格子，不再染色<span class="math inline">\(/\)</span>覆盖染色。</li></ul><p>最后输出 <span class="math inline">\(k\)</span> 个整数，每个整数 <span class="math inline">\(x\)</span> 代表被染成颜色 <span class="math inline">\(x\)</span> 的格子数量。</p><p><span class="math inline">\(1\le n,m,q,\le 2\times 10^6\)</span>，<span class="math inline">\(1\le k \le 5\times 10^5\)</span>。</p>          </div><div class="note note-success">            <p>考虑将操作离线。</p><p>对于 <span class="math inline">\(t=0\)</span> 的操作，越排在前面优先级越大。</p><p>对于 <span class="math inline">\(t=1\)</span> 的操作，越排在后面优先级越大。</p><p>并且先执行完所有 <span class="math inline">\(t=1\)</span> 的操作对 <span class="math inline">\(t=0\)</span> 的操作没有任何影响，因为要被覆盖的早晚被覆盖。</p><p>因此可以安排一个操作顺序（先从后往前执行 <span class="math inline">\(t=1\)</span> 操作，再从前往后执行 <span class="math inline">\(t=0\)</span> 操作），使得后面的操作不影响前面的操作。</p><p>接着，我们可以维护每一行是否全被染色（记为 <span class="math inline">\(R_i\)</span>）和每一列是否全被染色（记为 <span class="math inline">\(C_i\)</span>）。</p><p>以染色第 <span class="math inline">\([l,r]\)</span> 行为例，贡献是 <span class="math inline">\([(r-l+1)-\sum\limits_{i=l}^{r}R_i](m-\sum\limits_{i=1}^{m}C_i)\)</span>。列染色同理。</p><p>每次计算完贡献后，对于 <span class="math inline">\(i\in[l,r]\)</span>，<span class="math inline">\(R_i\leftarrow 1\)</span>。</p><p>如此一来，转化为区间赋值和区间求和问题。</p><p>但线段树的对数时间还是不足以通过，我们可以用链表模拟这个过程。</p><p>用两个单向链表维护行列，修改时变更 <span class="math inline">\(nxt\)</span>，询问时暴跳 <span class="math inline">\(nxt\)</span>，均摊时间复杂度是线性的。</p><p>透过代码可能更好理解。</p><p>总时间复杂度 <span class="math inline">\(O(n+m+q)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chain</span> &#123;<span class="hljs-type">int</span> covered;vector&lt;<span class="hljs-type">int</span>&gt; a,nxt; <span class="hljs-built_in">Chain</span>() &#123;&#125;<span class="hljs-built_in">Chain</span>(<span class="hljs-type">int</span> n) &#123;a.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>);nxt.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>);<span class="hljs-built_in">iota</span>(nxt.<span class="hljs-built_in">begin</span>(),nxt.<span class="hljs-built_in">end</span>(),<span class="hljs-number">1</span>);covered=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,lst=<span class="hljs-number">0</span>;i&lt;=r;i=nxt[i]) &#123;<span class="hljs-keyword">if</span>(!a[i]) &#123;covered++;a[i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(lst) &#123;nxt[lst]=nxt[r];&#125;lst=i;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-comment">//[l,r]内有多少已被占用</span><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i=nxt[i]) &#123;res+=(a[i]==<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">return</span> (r-l+<span class="hljs-number">1</span>)-res;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();vector&lt;array&lt;<span class="hljs-type">int</span>,5&gt;&gt; <span class="hljs-built_in">qry</span>(q+<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;qry[i]=&#123;<span class="hljs-built_in">read</span>(),<span class="hljs-built_in">read</span>(),<span class="hljs-built_in">read</span>(),<span class="hljs-built_in">read</span>(),<span class="hljs-built_in">read</span>()&#125;;&#125;<span class="hljs-function">Chain <span class="hljs-title">tr</span><span class="hljs-params">(n)</span>,<span class="hljs-title">tc</span><span class="hljs-params">(m)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(k+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> work = [&amp;](<span class="hljs-type">int</span> id) &#123;<span class="hljs-keyword">auto</span> [opt,l,r,c,t]=qry[id];<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>) &#123;ans[c]+=(r-l+<span class="hljs-number">1</span>-tr.<span class="hljs-built_in">query</span>(l,r))*(m-tc.covered);tr.<span class="hljs-built_in">update</span>(l,r);&#125; <span class="hljs-keyword">else</span> &#123;ans[c]+=(r-l+<span class="hljs-number">1</span>-tc.<span class="hljs-built_in">query</span>(l,r))*(n-tr.covered);tc.<span class="hljs-built_in">update</span>(l,r);&#125;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=q;i&gt;=<span class="hljs-number">1</span>;--i) &#123;<span class="hljs-keyword">if</span>(qry[i][<span class="hljs-number">4</span>]) &#123;<span class="hljs-built_in">work</span>(i);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-keyword">if</span>(!qry[i][<span class="hljs-number">4</span>]) &#123;<span class="hljs-built_in">work</span>(i);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Luogu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>Luogu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LGR-161-Div.3] 洛谷基础赛 4</title>
    <link href="/posts/26a0ed02.html"/>
    <url>/posts/26a0ed02.html</url>
    
    <content type="html"><![CDATA[<h2 id="a.-judg.">A. Judg.</h2><p><a href="https://www.luogu.com.cn/problem/P9686?contestId=133572">Problem</a></p><div class="note note-success">            <p>逐个判断即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;string s;cin&gt;&gt;s;<span class="hljs-keyword">if</span>(s!=<span class="hljs-string">&quot;AC&quot;</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,i);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-maps.">B. Maps.</h2><p><a href="https://www.luogu.com.cn/problem/P9687?contestId=133572">Problem</a></p><div class="note note-success">            <p>要让字典序最小，答案必然是一段前缀 <span class="math inline">\(0\)</span> <span class="math inline">\(+\)</span> 一段 <span class="math inline">\(01\)</span> 交替的序列。</p><p>满状态是 <span class="math inline">\(1010\dots0101\)</span>，所以 <span class="math inline">\(2p+1&gt; n\)</span> 时无解。</p><p>后续直接从后往前模拟。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> s[<span class="hljs-number">100000</span>+<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),p=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&gt;n) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,tot=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(s));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;--i) &#123;<span class="hljs-keyword">if</span>((++tot)&amp;<span class="hljs-number">1</span>) &#123;s[i]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(++cnt==p) &#123;s[i<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,s[i]);&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-colo.">C. Colo.</h2><p><a href="https://www.luogu.com.cn/problem/P9688?contestId=133572">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a,b\)</span> 分别代表颜色和价值，你可以挑一些不同的颜色 <span class="math inline">\(a_i\)</span> 进集合 <span class="math inline">\(S\)</span> 中，获得 <span class="math inline">\(b_{a_i}\)</span> 价值，但需要使所有 <span class="math inline">\(x\in S\)</span> 从 <span class="math inline">\(a\)</span> 中按顺序取出后形成的序列单调不降。 求 <span class="math inline">\(|S|=k\)</span> 时能获得的最大价值。</p><p><span class="math inline">\(1\le n,k \le 500\)</span>，<span class="math inline">\(1\le a_i\le n\)</span>，<span class="math inline">\(1\le b_i\le10^9\)</span>。</p>          </div><div class="note note-success">            <p>把每种不同的颜色看成一个线段 <span class="math inline">\([\text{fir}_{a[i]},\text{end}_{a[i]}]\)</span>，其中 <span class="math inline">\(\text{fir}_{a[i]}\)</span> 和 <span class="math inline">\(\text{end}_{a[i]}\)</span> 分别是颜色 <span class="math inline">\(a[i]\)</span> 第一次出现的地方和最后一次出现的地方。不难发现如果当前保留了两种及以上的颜色，那么所有线段都应该是互相隔离的（即既不包含也不相交），这样才能确保最终序列的单调性。</p><p>现在相当于确定了一种 <span class="math inline">\(a[i]\)</span>，我们可以去区间 <span class="math inline">\([1,\text{fir}_{a[i]})\)</span> 去寻找一个 <span class="math inline">\(\text{end}_{a[j]}\)</span>，这样 <span class="math inline">\(a[i]\)</span> 就可以从 <span class="math inline">\(a[j]\)</span> 那转移过来。</p><p>这样就转化为了一个类背包问题，用 dp 求解。</p><p>令 <span class="math inline">\(dp[\text{end}_{i}][len]\)</span> 表示目前选择到了颜色 <span class="math inline">\(i\)</span> ，已经选了 <span class="math inline">\(len\)</span> 种颜色。</p><p>转移方程如下：</p><p><span class="math display">\[\normalsize{dp[\text{end}_i][len]=\max\limits_{j=\text{end}_{a[j]}\text{ },\text{ }j\in [1,\text{fir}_i)}(dp[j][len-1]+b[i])}\]</span></p><p>答案即为 <span class="math inline">\(\max\limits_{i\in [1,n]}dp[i][k]\)</span>。</p><p>有点抽象，看代码可能更直观。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fir</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">end</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!vis[a[i]]) &#123;vis[a[i]]=<span class="hljs-literal">true</span>;fir[a[i]]=i;&#125;end[a[i]]=i;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k+<span class="hljs-number">1</span>,-inf));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123; <span class="hljs-comment">//表示当前枚举到颜色i </span><span class="hljs-keyword">if</span>(vis[i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;fir[i];++j) &#123;<span class="hljs-keyword">if</span>(j==end[a[j]]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=k;++len) &#123;<span class="hljs-keyword">if</span>(dp[j][len<span class="hljs-number">-1</span>]!=-inf) &#123;dp[end[i]][len]=<span class="hljs-built_in">max</span>(dp[end[i]][len],dp[j][len<span class="hljs-number">-1</span>]+b[i]);&#125;&#125;&#125;&#125;dp[end[i]][<span class="hljs-number">1</span>]=b[i]; <span class="hljs-comment">//只选它自身</span>&#125;&#125;<span class="hljs-type">int</span> res=-inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;res=<span class="hljs-built_in">max</span>(res,dp[i][k]);&#125;<span class="hljs-keyword">if</span>(res==-inf) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>这和一般的 dp 有点不一样，所以看起来很奇怪。</p><p>我们分析它的正确性是如何保证的：</p><ol type="1"><li>外层从小到大枚举颜色 <span class="math inline">\(i\)</span>，保证不会从比它大的颜色转移过来，使序列单调不降。</li><li>用右端点 <span class="math inline">\(\text{end}_{i}\)</span> 代表该种颜色，只保留有用的部分，符合最优子结构性质。</li></ol><p>时间复杂度 <span class="math inline">\(O(n^2k)\)</span>。</p>          </div><h2 id="d.-bina.">D. Bina.</h2><p><a href="https://www.luogu.com.cn/problem/P9689?contestId=133572">Problem</a></p><span class="label label-danger">毒瘤</span><div class="note note-info">            <p>题意：给定正整数 <span class="math inline">\(n,m\)</span>，依照给定代码建一棵构建参数为 <span class="math inline">\(n\)</span> 二叉树。你可以从二叉树底部开始往上砍节点（或不砍），一次砍一层，至少砍 <span class="math inline">\(m\)</span> 个点。令美丽值 <span class="math inline">\(=\)</span> 所有节点编号之和 <span class="math inline">\(\div\)</span> 这棵树的深度（向下取整），求最大美丽值。</p>          </div><div class="note note-success">            <p>很难下手，但你可以把 <span class="math inline">\(n=1\sim 16\)</span> 的图都手玩出来，找到一些性质。</p><p>这是 <span class="math inline">\(n=13\)</span> 的图。</p><figure><img src="/image/academic/1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>最明显的是这颗树除去最后一层必然是满二叉树，而且最后一层的叶子节点必然成对出现。</p><p>再进一步，<span class="math inline">\(n\leftarrow n+1\)</span> 时就会多出两个节点，所以总节点数量 <span class="math inline">\(2n-1\)</span> 是已知的，进而树的深度 <span class="math inline">\(d\)</span> 也能推出。</p><p>其次一颗 <span class="math inline">\(d\)</span> 层的满二叉树，其美丽值为 <span class="math inline">\(\frac{(1+2^{n}-1)(2^n-1)}{2}\times \frac{1}{d}=\frac{2^{n-1}(2^n-1)}{d}\)</span>，单调增。</p><p>意味着尽可能保留满二叉树层数是最优的。</p><p>故 <span class="math inline">\(m&gt;0\)</span> 时，最后一层必砍，在此基础上砍够 <span class="math inline">\(m\)</span> 就马上停手，答案最优。</p><p>麻烦的是 <span class="math inline">\(m=0\)</span>，这意味着答案是从砍最后一层和一点不砍之间取较大者。</p><p>前者可以预处理，后者我们需要知晓最后一层的节点编号和。</p><p>找规律。</p><p>打印出 <span class="math inline">\(n=2^3\sim 2^4\)</span> 时是哪些编号（设为 <span class="math inline">\(x\)</span>）的节点下挂了两个新节点。</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n=\)</span></th><th style="text-align: center;"><span class="math inline">\(8\)</span></th><th style="text-align: center;"><span class="math inline">\(9\)</span></th><th style="text-align: center;"><span class="math inline">\(10\)</span></th><th style="text-align: center;"><span class="math inline">\(11\)</span></th><th style="text-align: center;"><span class="math inline">\(12\)</span></th><th style="text-align: center;"><span class="math inline">\(13\)</span></th><th style="text-align: center;"><span class="math inline">\(14\)</span></th><th style="text-align: center;"><span class="math inline">\(15\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x=\)</span></td><td style="text-align: center;">8</td><td style="text-align: center;">12</td><td style="text-align: center;">10</td><td style="text-align: center;">14</td><td style="text-align: center;">9</td><td style="text-align: center;">13</td><td style="text-align: center;">11</td><td style="text-align: center;">15</td></tr></tbody></table><p>都减去 <span class="math inline">\(2^3\)</span> 有：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n=\)</span></th><th style="text-align: center;"><span class="math inline">\(0\)</span></th><th style="text-align: center;"><span class="math inline">\(1\)</span></th><th style="text-align: center;"><span class="math inline">\(2\)</span></th><th style="text-align: center;"><span class="math inline">\(3\)</span></th><th style="text-align: center;"><span class="math inline">\(4\)</span></th><th style="text-align: center;"><span class="math inline">\(5\)</span></th><th style="text-align: center;"><span class="math inline">\(6\)</span></th><th style="text-align: center;"><span class="math inline">\(7\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x=\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">6</td><td style="text-align: center;">1</td><td style="text-align: center;">5</td><td style="text-align: center;">3</td><td style="text-align: center;">7</td></tr></tbody></table><p>此时我们发现 <span class="math inline">\(x\)</span> 是对应 <span class="math inline">\(n\)</span> 的二进制翻转。</p><p>设 <span class="math inline">\(k=n-2^p-1\)</span>，<span class="math inline">\(rev(i)\)</span> 为 <span class="math inline">\(i\)</span> 的二进制翻转。</p><p>又由于 <span class="math inline">\(x\)</span> 下挂的两个节点编号为 <span class="math inline">\(2x\)</span> 和 <span class="math inline">\(2x+1\)</span>，最后一层的总编号和即为： <span class="math display">\[\begin{align}&amp;\text{ }\text{ }\text{ }\sum\limits_{i=0}^{k}(((2^p+rev(i))\times 2)+(2^p+rev(i))\times2 +1)\\&amp;=(k+1)(2^{p+2}+1)+4\sum_{i=0}^k rev(i)\end{align}\]</span> 由表推出 <span class="math inline">\(p=d-1\)</span>。那么如何求 <span class="math inline">\(\sum\limits_{i=0}^k rev(i)\)</span> ？</p><p>拆位考虑，考虑 <span class="math inline">\(0\sim k\)</span> 中每个数的第 <span class="math inline">\(x\in[0,p)\)</span> 位为 <span class="math inline">\(1\)</span> 的个数 <span class="math inline">\(cnt\)</span>，对翻转后的贡献即 <span class="math inline">\(cnt\times 2^{p-x-1}\)</span> 。</p><p>单组总时间复杂度 <span class="math inline">\(O(\log n)\)</span>。</p>          </div><div class="note note-warning">            <p>利用二进制下第 <span class="math inline">\(x\)</span> 位每隔 <span class="math inline">\(2^x\)</span> 个就改变一次的特性，统计循环节，可以 <span class="math inline">\(O(1)\)</span> 统计每一位的 <span class="math inline">\(cnt\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> all=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>,depth=<span class="hljs-number">0</span>;  <span class="hljs-comment">//all:总节点数,depth:总深度</span><span class="hljs-keyword">while</span>((<span class="hljs-number">1ll</span>&lt;&lt;depth)&lt;all) &#123;depth++;&#125;<span class="hljs-keyword">if</span>(m&gt;all) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> lastnum=all-((<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>))<span class="hljs-number">-1</span>); <span class="hljs-comment">//最后一层节点数</span><span class="hljs-keyword">if</span>(m&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> tmp=depth,cut=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(tmp==depth) &#123;cut+=lastnum;&#125; <span class="hljs-keyword">else</span> &#123;cut+=(<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>));&#125;depth--;<span class="hljs-keyword">if</span>(cut&gt;=m) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(!depth) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> res=(<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>))*((<span class="hljs-number">1ll</span>&lt;&lt;depth)<span class="hljs-number">-1</span>)/depth;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125; <span class="hljs-keyword">else</span> &#123;depth--;  <span class="hljs-comment">//此时depth是满二叉树层数</span><span class="hljs-type">int</span> res=(<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>))*((<span class="hljs-number">1ll</span>&lt;&lt;depth)<span class="hljs-number">-1</span>)/depth;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,tmp_n=n-(<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;depth<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> cnt=tmp_n/(<span class="hljs-number">1ll</span>&lt;&lt;i);<span class="hljs-type">int</span> left=tmp_n%(<span class="hljs-number">1ll</span>&lt;&lt;i);<span class="hljs-type">int</span> ano_cnt=cnt;<span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) &#123;ano_cnt--;&#125;ano_cnt/=<span class="hljs-number">2</span>;ano_cnt*=(<span class="hljs-number">1ll</span>&lt;&lt;i);<span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) &#123;ano_cnt+=left;&#125;sum+=ano_cnt*(<span class="hljs-number">1ll</span>&lt;&lt;(depth-i<span class="hljs-number">-2</span>));&#125;sum=tmp_n*((<span class="hljs-number">1ll</span>&lt;&lt;(depth+<span class="hljs-number">1</span>))+<span class="hljs-number">1</span>)+<span class="hljs-number">4</span>*sum; <span class="hljs-comment">//操作后sum为最后一层节点编号和</span><span class="hljs-type">int</span> res2=((<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>))*((<span class="hljs-number">1ll</span>&lt;&lt;depth)<span class="hljs-number">-1</span>)+sum)/(depth+<span class="hljs-number">1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">max</span>(res,res2));&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Luogu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>Luogu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】2023 NOI 春季测试 3 of 4</title>
    <link href="/posts/a073199c.html"/>
    <url>/posts/a073199c.html</url>
    
    <content type="html"><![CDATA[<h2 id="a.-涂色游戏">A. 涂色游戏</h2><p><a href="https://www.luogu.com.cn/problem/P9117">Problem</a></p><div class="note note-info">            <p>题意：<span class="math inline">\(n\times m\)</span> 的网格，<span class="math inline">\(q\)</span> 次询问，每次涂一行或一列，新颜色会覆盖旧颜色，输出最终形态。</p><p><span class="math inline">\(1\le \sum nm\)</span>，<span class="math inline">\(\sum q\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>考虑倒序执行这 <span class="math inline">\(q\)</span> 个操作。</p><p>对每一行和每一列用 <code>std::unordered_map</code> 存当前还有哪一些方格未被涂色。</p><p>因为反着执行涂色时旧颜色一定不会被覆盖，故对于一个操作遍历该行/列对应的容器，未涂色的涂色，再将该方格编号从容器中删掉即可。</p><p>时间复杂度 <span class="math inline">\(O(mn)\)</span>。</p>          </div><div class="note note-warning">            <p><code>std::unordered_map</code> 插值和删值的均摊时间复杂度是 <span class="math inline">\(O(1)\)</span> 的。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; <span class="hljs-built_in">query</span>(q);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q;++i) &#123;<span class="hljs-type">int</span> opt=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>(),c=<span class="hljs-built_in">read</span>();query[i]=&#123;opt,x,c&#125;;&#125;vector&lt;unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">line</span>(n+<span class="hljs-number">1</span>),<span class="hljs-built_in">col</span>(m+<span class="hljs-number">1</span>);vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;line[i][j]=j;col[j][i]=i;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=q<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-keyword">auto</span> [opt,x,c]=query[i];<span class="hljs-keyword">if</span>(!opt) &#123;vector&lt;<span class="hljs-type">int</span>&gt; id;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [fir,sec]:line[x]) &#123;id.<span class="hljs-built_in">push_back</span>(sec);col[sec].<span class="hljs-built_in">erase</span>(x);ans[x][sec]=c;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:id) &#123;line[x].<span class="hljs-built_in">erase</span>(k);&#125;&#125; <span class="hljs-keyword">else</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; id;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [fir,sec]:col[x]) &#123;id.<span class="hljs-built_in">push_back</span>(sec);line[sec].<span class="hljs-built_in">erase</span>(x);ans[sec][x]=c;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:id) &#123;col[x].<span class="hljs-built_in">erase</span>(k);&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i][j]);&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-幂次">B. 幂次</h2><p><a href="https://www.luogu.com.cn/problem/P9118">Problem</a></p><div class="note note-info">            <p>题意：给定正整数 <span class="math inline">\(n,k\)</span>，求 <span class="math inline">\(1\sim n\)</span> 中有多少正整数 <span class="math inline">\(x\)</span> 可以表示为 <span class="math inline">\(x=a^b\)</span> 的形式，其中 <span class="math inline">\(a,b\in \mathbb N^+\)</span> 且 <span class="math inline">\(b\ge k\)</span> 。</p><p><span class="math inline">\(1\le n \le 10^{18}\)</span>，<span class="math inline">\(1\le k \le 100\)</span>。</p>          </div><div class="note note-success">            <p>按照 <span class="math inline">\(k\)</span> 范围分治。</p><p>首先，当 <span class="math inline">\(k=1\)</span> 时，<span class="math inline">\(ans=n\)</span>。因为所有 <span class="math inline">\(x\)</span> 都能表示为 <span class="math inline">\(x^1\)</span>。</p><p>其次，当 <span class="math inline">\(k\ge 3\)</span> 时，可以暴力枚举底数 <span class="math inline">\(a\)</span>，因为 <span class="math inline">\((10^6)^3=10^{18}\)</span>，底数十分有限。</p><p>最后，<span class="math inline">\(k=2\)</span> 时，一个结论是小于等于 <span class="math inline">\(x\)</span> 的完全平方数有 <span class="math inline">\(sqrt(x)\)</span> 个，但其中有一些和指数大于 <span class="math inline">\(2\)</span> 时的计算结果重复，考虑容斥。在统计 <span class="math inline">\(k\ge 3\)</span> 的过程中顺便记录哪些计入答案的数属于完全平方数，令 <span class="math inline">\(k\ge 3\)</span> 时的答案为 <span class="math inline">\(cnt\)</span>，有 <span class="math inline">\(num\)</span> 个完全平方数，则 <span class="math inline">\(ans=cnt+sqrt(x)-num\)</span>。</p><p>容易爆 <code>long long</code> ，可以开 <code>__int128</code> 。</p>          </div><div class="note note-warning">            <p>小心精度问题，用 <code>std::sqrtl()</code> 而不是 <code>std::sqrt()</code> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int __int128</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k*=k) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s*=k;<span class="hljs-keyword">return</span> s;&#125;map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt; mp;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">write</span>(n);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,sqrt_num=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i*i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;;++j) &#123;x*=i;<span class="hljs-keyword">if</span>(x&gt;n) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(j&gt;=k &amp;&amp; !mp[x]) &#123;<span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrtl</span>(x)*(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrtl</span>(x)==x) &#123;sqrt_num++;&#125;mp[x]=<span class="hljs-number">1</span>;cnt++;&#125;&#125;&#125;<span class="hljs-keyword">if</span>(k==<span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">write</span>(cnt+<span class="hljs-built_in">sqrtl</span>(n)-sqrt_num);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">write</span>(cnt+<span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-圣诞树">C. 圣诞树</h2><p><a href="https://www.luogu.com.cn/problem/P9119">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定二维坐标系上 <span class="math inline">\(n\)</span> 个点构成的凸多边形，求从 <span class="math inline">\(y\)</span> 轴最高点出发的一条最短路径，要求经过 <span class="math inline">\(n\)</span> 个点且每个点仅能经过一次，依次输出编号。</p><p><span class="math inline">\(3\le n\le 1000\)</span>，<span class="math inline">\(|x_i|,|y_i|\le 10^7\)</span>。</p>          </div><div class="note note-success">            <p>正解是区间dp，不是很会。</p><p>只会 <span class="math inline">\(3\le n\le18\)</span>，不过加上两个特殊性质一共能拿到 80pts。</p><p>套路题，最短哈密顿路径，考虑状压dp。</p><p>令起点为 <span class="math inline">\(s\)</span>，则 <span class="math inline">\(dp[i][j]\)</span> 代表从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(j\)</span> ，且经过 <span class="math inline">\(i\)</span> 的二进制为 <span class="math inline">\(1\)</span> 的位数对应编号的点的最短路径长度。</p><p>则 <span class="math inline">\(dp[i][j]=\mathop\min\limits_{k\in[1,n]}(dp[i\oplus2^j][k]+dis[k][j])\)</span>。</p><p>答案为 <span class="math inline">\(\min\limits_{i\in[1,n]}(dp[2^n-1][i])\)</span>。</p><p>接下来考虑如何记录路径。</p><p>令 <span class="math inline">\(pre[mask][j]=k\)</span> 表示状态为 <span class="math inline">\(mask\)</span>，当前点 <span class="math inline">\(j\)</span> 从点 <span class="math inline">\(k\)</span> 转移过来最优。</p><p>状态转移时 <span class="math inline">\(pre\)</span> 与 <span class="math inline">\(dp\)</span> 同步。</p><p>统计答案时，<span class="math inline">\(mask\)</span> 对应为 <span class="math inline">\(1\)</span> 的位异或变成 <span class="math inline">\(0\)</span>，即可回溯到上一状态。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dis</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(n));<span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">X</span><span class="hljs-params">(n)</span>,<span class="hljs-title">Y</span><span class="hljs-params">(n)</span></span>;<span class="hljs-type">int</span> top=<span class="hljs-number">0</span>;<span class="hljs-type">double</span> maxn=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;cin&gt;&gt;X[i]&gt;&gt;Y[i];<span class="hljs-keyword">if</span>(Y[i]&gt;maxn) &#123;maxn=Y[i];top=i;&#125;&#125; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) &#123;dis[i][j]=<span class="hljs-built_in">sqrtl</span>((X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j]));&#125;&#125;vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>&lt;&lt;n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(n,<span class="hljs-number">1.0</span>*inf));vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pre</span>(<span class="hljs-number">1</span>&lt;&lt;n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">-1</span>));dp[<span class="hljs-number">1</span>&lt;&lt;top][top]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) &#123;<span class="hljs-keyword">if</span>(i&gt;&gt;j&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k) &#123;<span class="hljs-keyword">if</span>(i&gt;&gt;k&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)][k]+dis[k][j]&lt;dp[i][j]) &#123;dp[i][j]=dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)][k]+dis[k][j];pre[i][j]=k;&#125;&#125;&#125;&#125;&#125;&#125;<span class="hljs-type">double</span> res=<span class="hljs-number">1.0</span>*inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(i!=top) &#123;res=<span class="hljs-built_in">min</span>(res,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]);&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]-res)&lt;<span class="hljs-number">1e-14</span>) &#123;path.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-type">int</span> mask=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>,j=i;<span class="hljs-keyword">while</span>(pre[mask][j]!=<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> tmp=j;j=pre[mask][j];mask^=(<span class="hljs-number">1</span>&lt;&lt;tmp);path.<span class="hljs-built_in">push_back</span>(j);&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(),path.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:path) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,i+<span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】Codeforces Round 901 (Div.2) 4 of 7</title>
    <link href="/posts/80b55541.html"/>
    <url>/posts/80b55541.html</url>
    
    <content type="html"><![CDATA[<h2 id="a.-jellyfish-and-undertale">A. Jellyfish and Undertale</h2><p><a href="https://codeforces.com/contest/1875/problem/A">Problem</a></p><div class="note note-success">            <p>显然每当倒计时仅剩 <span class="math inline">\(1\)</span> 时依次使用工具会最优。</p><p>则第 <span class="math inline">\(i\)</span> 个工具对时间的贡献就是 <span class="math inline">\(min(a-1,x_i)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>(),n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;x[i]=<span class="hljs-built_in">read</span>();sum+=<span class="hljs-built_in">min</span>(x[i],a<span class="hljs-number">-1</span>);&#125;<span class="hljs-type">int</span> res=b+sum;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-jellyfish-and-game">B. Jellyfish and Game</h2><p><a href="https://codeforces.com/contest/1874/problem/A">Problem</a></p><div class="note note-info">            <p>题意：<span class="math inline">\(A\)</span> 有 <span class="math inline">\(n\)</span> 个物品，<span class="math inline">\(B\)</span> 有 <span class="math inline">\(m\)</span> 个，每个物品有价值。游戏进行 <span class="math inline">\(k\)</span> 轮，奇数轮 <span class="math inline">\(A\)</span> 可以选择与 <span class="math inline">\(B\)</span> 的一个物品交换(或不交换)，偶数轮 <span class="math inline">\(B\)</span> 可以选择与 <span class="math inline">\(A\)</span> 的一个物品交换(或不交换)，问最终 <span class="math inline">\(A\)</span> 拥有物品的总价值。<span class="math inline">\(1\le n,m\le 50\)</span>，<span class="math inline">\(1\le k \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>一开始，<span class="math inline">\(A\)</span> 显然会拿自己的最小价值的和 <span class="math inline">\(B\)</span> 的最大价值进行交换，而 <span class="math inline">\(B\)</span> 的回合会拿 <span class="math inline">\(min(自己原本的最小价值,A 给的物品价值)\)</span> 和 <span class="math inline">\(max(A 原本最大价值,A 从 B 这拿走的物品价值)\)</span> 进行交换。一个直觉是当游戏进行两轮以上后，双方的决策(即拿的物品的价值)都达到最优，因此游戏最终结果仅和 <span class="math inline">\(k\)</span> 的奇偶性相关。我们只需要暴力模拟 <span class="math inline">\(k=1,2\)</span> 时的结果。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();vector&lt;<span class="hljs-type">int</span>&gt; a,b;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();a.<span class="hljs-built_in">push_back</span>(x);sum+=x;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();b.<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-type">int</span> res=sum;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=(k&amp;<span class="hljs-number">1</span>?<span class="hljs-number">1</span>:<span class="hljs-number">2</span>);++i) &#123;<span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> posa=<span class="hljs-built_in">min_element</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">auto</span> posb=<span class="hljs-built_in">max_element</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> mina=a[posa-a.<span class="hljs-built_in">begin</span>()];<span class="hljs-type">int</span> maxb=b[posb-b.<span class="hljs-built_in">begin</span>()];<span class="hljs-keyword">if</span>(mina&gt;maxb) &#123;<span class="hljs-keyword">continue</span>;&#125;res-=mina;res+=maxb;a.<span class="hljs-built_in">erase</span>(posa);b.<span class="hljs-built_in">erase</span>(posb);a.<span class="hljs-built_in">push_back</span>(maxb);b.<span class="hljs-built_in">push_back</span>(mina);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">auto</span> posa=<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">auto</span> posb=<span class="hljs-built_in">min_element</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> maxa=a[posa-a.<span class="hljs-built_in">begin</span>()];<span class="hljs-type">int</span> minb=b[posb-b.<span class="hljs-built_in">begin</span>()];<span class="hljs-keyword">if</span>(maxa&lt;minb) &#123;<span class="hljs-keyword">continue</span>;&#125;res-=maxa;res+=minb;a.<span class="hljs-built_in">erase</span>(posa);b.<span class="hljs-built_in">erase</span>(posb);a.<span class="hljs-built_in">push_back</span>(minb);b.<span class="hljs-built_in">push_back</span>(maxa);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-jellyfish-and-green-apple">C. Jellyfish and Green Apple</h2><p><a href="https://codeforces.com/contest/1875/problem/C">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：<span class="math inline">\(n\)</span> 个苹果分给 <span class="math inline">\(m\)</span> 个人，每个苹果 <span class="math inline">\(1kg\)</span>，每切一刀会均分成重量相同的两瓣，问最少切几刀能使每个人分到的苹果重量都相等，若无法均分输出 <span class="math inline">\(-1\)</span>。</p><p><span class="math inline">\(1\le n,m\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>当 <span class="math inline">\(n\ge m\)</span> 时，可以把 <span class="math inline">\(n\)</span> 个中的若干个 <span class="math inline">\(m\)</span> 分出去，剩下 <span class="math inline">\(n\%m\)</span> 个。而剩下不足 <span class="math inline">\(m\)</span> 个的为了能均分必然选择每个切一刀进行加倍，因此可以用递归进行模拟。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> &amp;res,<span class="hljs-type">int</span> times)</span> </span>&#123;<span class="hljs-keyword">if</span>(times&gt;<span class="hljs-number">1000</span>) &#123;res=<span class="hljs-number">-1</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">while</span>(n&lt;m) &#123;res+=n;n*=<span class="hljs-number">2</span>;&#125;<span class="hljs-type">int</span> div=n%m;<span class="hljs-keyword">if</span>(!div) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">divide</span>(div,m,res,times+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-built_in">divide</span>(n,m,res,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>但这样无解条件并不明显，借用官方题解进行形式化的思考。由于苹果 <span class="math inline">\(1kg\)</span>，以下用数量指代重量，完全等价。</p><p>若能均分，那么必有 <span class="math inline">\(n\times 2^k\equiv0\pmod{m}\)</span>，因为只考虑什么时候无解时"先分再加倍"和"先加倍再分"是等价的。接着推出 <span class="math inline">\(n\times 2^k\equiv0\pmod{m} \rightarrow 2^k\equiv 0 \pmod{\frac{m}{gcd(n,m)}}\)</span> .</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Why?    </div>    <div class='spoiler-content'>        <p>定理：若 <span class="math inline">\(ac\equiv bc\pmod{m},c\neq 0\)</span> ，则 <span class="math inline">\(a\equiv b \pmod{\frac{m}{gcd(c,m)}}\)</span></p><p>证明：</p><ul><li><p>当 <span class="math inline">\(gcd(c,m)=1\)</span> 时：</p><p>​ 由定理 "整数 <span class="math inline">\(a,b\)</span> 对模 <span class="math inline">\(m\)</span> 同余的充要条件是 <span class="math inline">\(m\mid (a-b)\)</span>" (比较显然，证明略)</p><p>​ <span class="math inline">\(\begin{align}\textbf{那么}&amp;\text{ }ac\equiv bc\pmod{m}\\&amp;\rightarrow m\mid(ac-bc)\\&amp;\rightarrow m\mid (a-b)c \\&amp;\rightarrow m\mid (a-b) \\&amp;\rightarrow a\equiv b\pmod{m}\end{align}\)</span></p><p>​ 又此时 <span class="math inline">\(gcd(c,m)=1\)</span> ，故相当于 <span class="math inline">\(a\equiv b\pmod{\frac{m}{gcd(c,m)}}\)</span> .</p></li><li><p>当 <span class="math inline">\(gcd(c,m)\neq 1\)</span> 时：</p><p>​ 设 <span class="math inline">\(gcd(c,m)=d &gt; 1\)</span> ，令 <span class="math inline">\(c=c&#39;d\)</span> 和 <span class="math inline">\(m=m&#39;d\)</span> ，则 <span class="math inline">\(gcd(c&#39;,m&#39;)=1\)</span> .</p><p>​ <span class="math inline">\(\begin{align}\textbf{那么}&amp;\text{ }ac\equiv bc \pmod{m} \\&amp;\rightarrow ac&#39;\equiv bc&#39; \pmod{m&#39;} \\&amp;\rightarrow a\equiv b \pmod{m&#39;}(由上文另一点的证明)\\&amp;\rightarrow a\equiv b \pmod{\frac{m}{d}}\\&amp;\rightarrow a\equiv b\pmod{\frac{m}{gcd(c,m)}}\end{align}\)</span></p></li></ul>    </div></div><div class="note note-success">            <p>也就是说，当 <span class="math inline">\(\frac{m}{gcd(n,m)}\)</span> 不是 <span class="math inline">\(2\)</span> 的整数幂时无解，可以用 <span class="math inline">\(\text{std::}\)</span><span class="math inline">\(\underline{}\underline{}\text{builtin}\)</span><span class="math inline">\(\underline{}\text{popcount()}\)</span> 快速验证。</p><p>接着，若有解，那么每个人分到的苹果数量应该是实数 <span class="math inline">\(\frac{n}{m}\)</span>，而具体的，每次一个人得到的苹果数量应该是 <span class="math inline">\(2\)</span> 的整数幂，即存在集合 <span class="math inline">\(S\)</span> 使 <span class="math inline">\(\frac{n}{m}=\sum_{i\in S} \frac{1}{2^i}\)</span>。而 <span class="math inline">\(|S|\)</span> 即每个人得到的苹果数量，答案即为 <span class="math inline">\(m\times |S|-n\)</span>。</p><p>减去 <span class="math inline">\(n\)</span> 是因为苹果总数量 <span class="math inline">\(-\)</span> 原有数量 <span class="math inline">\(=\)</span> 切的刀数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m); n %= m;<span class="hljs-type">int</span> a = n / __gcd(n, m), b = m / __gcd(n, m);<span class="hljs-keyword">if</span>(__builtin_popcount(b) &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-number">1ll</span> * __builtin_popcount(a) * m - n);&#125;<span class="hljs-type">int</span> T = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; T ; i ++) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-jellyfish-and-mex">D. Jellyfish and Mex</h2><p><a href="https://codeforces.com/contest/1875/problem/D">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：一个有 <span class="math inline">\(n\)</span> 个数的非负数组，<span class="math inline">\(n\)</span> 次操作每次选一个数删掉后计算 <span class="math inline">\(\text{MEX}\)</span> 并累加，问能达到的最小价值。</p><p><span class="math inline">\(1\le n \le 5000\)</span>，<span class="math inline">\(1\le a_i\le10^9\)</span>。</p>          </div><div class="note note-success">            <p>根据样例就能看明白，让总价值最小就是以最小的价值让 <span class="math inline">\(\text{MEX}\)</span> 变为 <span class="math inline">\(0\)</span>，并且我们只关心小于一开始 <span class="math inline">\(\text{MEX}\)</span> 的数的出现次数。</p><p>一开始我想假了，认为最优解一定是从小于 <span class="math inline">\(\text{MEX}\)</span> 的某个数开始删一路删到 <span class="math inline">\(0\)</span>，喜提 2WA。</p><p>耽误了很多时间，直到拍到一组样例：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">9</span><span class="hljs-attribute">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span><span class="hljs-attribute">Wrong</span> Answer: <span class="hljs-number">8</span><span class="hljs-attribute">Correct</span> Answer: <span class="hljs-number">6</span></code></pre></div><p>删法是先删掉 <span class="math inline">\(2\)</span>，然后删 <span class="math inline">\(0\)</span>，答案并不连续，所以考虑dp。</p><p><span class="math inline">\(dp[i]\)</span> 表示目前从 <span class="math inline">\(\text{MEX}\)</span> 开始删到 <span class="math inline">\(i\)</span> 的最小价值，则 <span class="math inline">\(dp[i]=\mathop\min\limits_{j\in[i+1,\text{MEX}]}(dp[i],dp[j]+cnt[i]\times j)\)</span>.</p><p>因为一开始有一个数是没有贡献的，所以答案是 <span class="math inline">\(dp[0]-\text{MEX}\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">cnt</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]&lt;=n) &#123;cnt[a[i]]++;&#125;&#125;<span class="hljs-type">int</span> mex=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(cnt[mex]) &#123;mex++;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,inf)</span></span>;dp[mex]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mex;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=mex;++j) &#123;dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[j]+cnt[i]*j);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[<span class="hljs-number">0</span>]-mex);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关一道数列高考题求和表达式的思考</title>
    <link href="/posts/97008555.html"/>
    <url>/posts/97008555.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>【467】（2020 · 新课标Ⅰ卷 · 文 · 16）</p><p>​ 数列 <span class="math inline">\(\{a_n\}\)</span> 满足 <span class="math inline">\(a_{n+2}+(-1)^na_n=3n-1\)</span>，前 <span class="math inline">\(16\)</span> 项和为 <span class="math inline">\(540\)</span>，则 <span class="math inline">\(a_1=\underline{\qquad\qquad}\)</span>.</p>          </div><p>这是刷题时碰到的一道有意思的题目。</p><p>因为该题数据范围小，故在现行参考答案中都是清一色的分奇偶讨论然后枚举相加。</p><p>但实际上，其求和表达式是可求的：</p><p>当 <span class="math inline">\(n\)</span> 为奇数时，运用累加法 <span class="math display">\[\begin{align}a_{n+2}-a_n&amp;=3n-1 \\a_n-a_{n-2}&amp;=3(n-2)-1 \\a_{n-2}-a_{n-4}&amp;=3(n-4)-1 \\&amp;\dots \\a_5-a_3&amp;=3\times3-1=8 \\a_3-a_1&amp;=3\times1-1=2 \\\end{align}\]</span> 则 <span class="math display">\[\begin{align}a_{n+2}&amp;=(3n-1)+(3n-7)+\dots+8+2+a_{1} \\&amp;= \dfrac{(2+3n-1)\dfrac{n+1}{2}}{2}+a_1 \\&amp;= \dfrac{(n+1)(3n+1)}{4}+a_1\end{align}\]</span> 令 <span class="math inline">\(b_n=\dfrac{(n+1)(3n+1)}{4}\)</span>. 因为只研究奇数项，</p><p>令 <span class="math inline">\(c_n=b_{2n-1}=\dfrac{2n(6n-2)}{4}=n(3n-1)=3n-n^2\)</span>.</p><p>对于两个等差数列相乘的形式，展开分别求和，于是有 <span class="math display">\[\begin{align}S_{c_n}&amp;=3\times\dfrac{n(n+1)(2n+1)}{6}-\dfrac{n(n+1)}{2} \\ &amp;=\dfrac{n(n+1)\times 2n}{2} \\&amp;=n^2(n+1)\end{align}\]</span> 注意到 <span class="math display">\[\begin{align}a_{n+2}=b_n&amp;+a_1 \\a_{2n+1}=b_{2n-1}+&amp;a_1=c_n+a_1 \\a_1+a_3+a_5+\dots+a_{2n-1}&amp;=S_{c_n}+(n+1)a_1 \\&amp;=n^2(n+1)+(n+1)a_1\end{align}\]</span> 令 <span class="math inline">\(T_1\)</span> 为奇数项前 <span class="math inline">\(n\)</span> 项和，因此 <span class="math display">\[\begin{align}T_1 &amp;= a_1+a_3+a_5+\dots+a_{2n-1} \\&amp;= (n-1)^2n + na_1 \\&amp;= n[(n-1)^2+a_1]\end{align}\]</span> 当 <span class="math inline">\(n\)</span> 为偶数时，有 <span class="math inline">\(a_{n+2}+a_n=3n-1\)</span>.</p><p>令 <span class="math inline">\(d_n=a_n+a_{n+2}\)</span>，又只取偶数项，可列出大概示意 <span class="math display">\[\begin{align}a_{16}\quad a_{14} \to d_{14} \to \ &amp;e_4 \\a_{12}\quad a_{10} \to d_{10} \to \ &amp;e_3 \\a_{8}\quad a_{6} \to d_{6} \to \ &amp;e_2 \\a_{4}\quad a_{2} \to d_{2} \to \ &amp;e_1 \\\end{align}\]</span> 箭头左边即为所需 <span class="math inline">\(a_n\)</span> 的和</p><p>故可令 <span class="math inline">\(e_n=d_{4n-2}=3(4n-2)-1=12n-7\)</span>. <span class="math display">\[\begin{align}S_{e_n}&amp;=12\times\dfrac{n(n+1)}{2}-7n \\&amp;=n(6n-1)\end{align}\]</span> 由示意图看出 <span class="math inline">\(e_n\)</span> 即对应 <span class="math inline">\(a_{4n}\)</span>，令 <span class="math inline">\(T_2\)</span> 为偶数项前 <span class="math inline">\(n\)</span> 项和，则 <span class="math display">\[\begin{align}T_2 &amp;= a_2+a_4+a_6+\dots+a_{2n} \\&amp;= \dfrac{n}{2}(6\times \dfrac{n}{2}-1) \\&amp;= \dfrac{n(3n-1)}{2}\end{align}\]</span> 综上，令 <span class="math inline">\(T_n\)</span> 表示 <span class="math inline">\(a_n\)</span> 的前 <span class="math inline">\(2n\)</span> 项和 <span class="math display">\[T_n=T_1+T_2=\dfrac{1}{2}n(2n^2-n+2a_1+1)\]</span> 对于本题，将 <span class="math inline">\(n=8\)</span> 和 <span class="math inline">\(T_n=540\)</span> 代入即得答案 <span class="math inline">\(a_1=7\)</span>.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Sundry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】 背包问题</title>
    <link href="/posts/184d7496.html"/>
    <url>/posts/184d7496.html</url>
    
    <content type="html"><![CDATA[<h1 id="背包">1. <span class="math inline">\(01\)</span> 背包</h1><div class="note note-info">            <p>Q：有 <span class="math inline">\(N\)</span> 件物品和一个容量为 <span class="math inline">\(V\)</span> 的背包。第 <span class="math inline">\(i\)</span> 件物品的体积是 <span class="math inline">\(v_i\)</span>，价值是 <span class="math inline">\(w_i\)</span>。求解将哪些物品装入背包可使价值总和最大。</p>          </div><div class="note note-success">            <p>规定：<span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 件物品放入容量为 <span class="math inline">\(j\)</span> 的背包可以获得的最大价值，所以</p><p><span class="math display">\[\large{f_{i,j}=\max_{i\in [1,N],j\in [v_i,V]}(f_{i-1,j},f_{i-1,j-v_i}+w_i)}\]</span></p><p>在此基础上，还可以降维打击，考虑将 <span class="math inline">\(f\)</span> 第一维去掉，此时 <span class="math inline">\(f_j=\max(f_j,f_{j-v_i}+w_i)\)</span>，但此时我们需要将内层循环 <span class="math inline">\(j\)</span> 逆序循环。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.NFor j=V..v[i]f[j]=max&#123;f[j],f[j-v[i]]+w[i]&#125;;result: f[V]</code></pre></div>          </div><div class="note note-warning">            <p><strong>为什么逆序 ？</strong></p><p>对比上面的递推式， <span class="math inline">\(f_j\)</span> 为第 <span class="math inline">\(i\)</span> 时刻的 <span class="math inline">\(f_j\)</span>，<span class="math inline">\(f_{j-v_i}\)</span> 为第 <span class="math inline">\(i-1\)</span> 时刻的 <span class="math inline">\(f_{j-v_i}\)</span>。</p><p>当外层循环执行到 <span class="math inline">\(i\)</span>，内层循环还没开始执行时， <span class="math inline">\(f_{j-v_i}\)</span> 为 <span class="math inline">\(i-1\)</span> 时刻的。</p><p>我们要保留这个 <span class="math inline">\(i-1\)</span> 时刻的 <span class="math inline">\(f_{j-v_i}\)</span>，就要 <span class="math inline">\(i-1\)</span> 时刻的 <span class="math inline">\(f_j\)</span> 在 <span class="math inline">\(f_{j-v_i}\)</span> 更新前率先更新为 <span class="math inline">\(i\)</span> 时刻的 <span class="math inline">\(f_j\)</span> ，即在 <span class="math inline">\(j-v_i\)</span> 前更新 <span class="math inline">\(j\)</span>，所以逆序循环。</p>          </div><h1 id="完全背包">2. 完全背包</h1><div class="note note-info">            <p>Q：在 01 背包的基础上规定每个物品可用无限次，求最大价值。</p>          </div><div class="note note-success">            <p>一个朴素的方法是用多一重循环 <span class="math inline">\(k\)</span> 记录每个物品所用的数量，状态转移：</p><p><span class="math display">\[\large{f_{i,j}=\max_{k\times v_i\in [0,j]}(f_{i-1,j},f_{i-1,j-k\times v_i}+k\times w_i)}\]</span></p><p>不过时间复杂度较大，于是就诞生了一个巧妙的方法：把完全背包转化为 01 背包求解。</p><p>首先我们要知道，任何一个数都可以通过 2 的幂次方数表示，如 <span class="math inline">\(11=2^3+2^1+2^0\)</span>，并且每一个幂次方数都能够仅出现一次。</p><p>然后我们发现，一个体积为 <span class="math inline">\(V\)</span> 的背包中最多能装下 <span class="math inline">\(\left \lfloor \dfrac {V}{v_i}\right \rfloor\)</span> 个体积为 <span class="math inline">\(v_i\)</span> 的物品。每一种物品数量是有限的，这意味着我们可以把每一种物品拆分。</p><p>具体的说，可以把第 <span class="math inline">\(i\)</span> 种物品拆成体积为 <span class="math inline">\(v_i\times 2^k\)</span>，价值为 <span class="math inline">\(w_i\times 2^k\)</span> 的若干件物品，其中 <span class="math inline">\(v_i\times 2^k\leq V,k\in Z\)</span>。</p><p>如此时间复杂度降为 <span class="math inline">\(O(N\times \sum log \dfrac {V}{v_i})\)</span>。</p><p>但我们还是不想扩大时间复杂度，所以仍然有一个 <span class="math inline">\(O(NV)\)</span> 的解决方法：将 01 背包中的内层循环由逆序再改回正序。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.NFor j=v[i]..Vf[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);result: f[V]</code></pre></div>          </div><div class="note note-warning">            <p><strong>为什么正序可以满足题意 ？</strong></p><p>反过来想 01 背包为什么要逆序？因为 <span class="math inline">\(i\)</span> 时刻的 <span class="math inline">\(f_j\)</span> 需要 <span class="math inline">\(i-1\)</span> 时刻的 <span class="math inline">\(f_{j-v_i}\)</span> 更新，所以在第 <span class="math inline">\(i\)</span> 时刻时 <span class="math inline">\(f_j\)</span> 要率先被遍历到。</p><p>换句话说，这是为了保证递推唯一，即每件物品只选一次。</p><p>而完全背包恰好相反，或许确实需要那个可能选入第 <span class="math inline">\(i\)</span> 件物品的结果，即第 <span class="math inline">\(i\)</span> 时刻的 <span class="math inline">\(f_{j-v_i}\)</span>，因此采用顺序循环便是最简单的解决方式。</p>          </div><h1 id="多重背包">3.多重背包</h1><div class="note note-info">            <p>Q：在 01 背包的基础上规定第 <span class="math inline">\(i\)</span> 件物品最多有 <span class="math inline">\(s_i\)</span> 件，求最大价值。</p>          </div><div class="note note-success">            <p>很容易想到把 <span class="math inline">\(s_i\)</span> 件物品全部拆分，转化为 01 背包问题，但如果每种物品限定数量很多，时间复杂度就过大。</p><p>于是我们想到了上面完全背包用2的幂次方数拆分的二进制拆分法，但要稍加改动：</p><p>假设 <span class="math inline">\(s=13\)</span> ，在 <span class="math inline">\(0\sim13\)</span> 中选一个数，例如 <span class="math inline">\(11\)</span>，我们需要拆分出 <span class="math inline">\(2^0,2^1,2^2,2^3\)</span>，然后选出 <span class="math inline">\(2^0,2^1,2^3\)</span> 来组成。</p><p>但程序可以组出 <span class="math inline">\(2^0+2^1+2^2+2^3=15\)</span> 这样大于 <span class="math inline">\(s=13\)</span> 的数，不符合限制。</p><p>所以正确的做法是：保证拆分出的 <span class="math inline">\(2\)</span> 的幂次方数之和始终不大于 <span class="math inline">\(s\)</span>，余下部分通过相减来补齐。</p><p><span class="math inline">\(e.g.\text{ } 13\)</span> 可以拆分出 <span class="math inline">\(2^0,2^1,2^2\)</span> 和 <span class="math inline">\(13-2^0-2^1-2^2=6\)</span>，即 <span class="math inline">\(1,2,4,6\)</span>。</p><p>代码：（vector Q 存储拆分出物品的体积和价值）</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.N&#123;k=<span class="hljs-number">1</span>;While k&lt;=s[i] <span class="hljs-keyword">do</span>&#123;s[i]-=k;Q.<span class="hljs-built_in">pushback</span>(&#123;v[i]*k,w[i]*k&#125;);k&lt;&lt;=<span class="hljs-number">1</span>; <span class="hljs-comment">//指数+1</span>&#125;<span class="hljs-built_in">If</span>(s&gt;<span class="hljs-number">0</span>) Q.<span class="hljs-built_in">pushback</span>(&#123;v[i]*s,w[i]*s&#125;);&#125;For <span class="hljs-keyword">auto</span> QFor j=V..Q.vf[j]=<span class="hljs-built_in">max</span>(f[j],f[j-Q.v]+Q.w);result: f[V]</code></pre></div>          </div><div class="note note-danger">            <p><strong>单调队列优化 <span class="math inline">\(O(NV)\)</span></strong></p><p>试写出多重背包的朴素转移：</p><p><span class="math display">\[\large{f_{i,j}=\max(f_{i-1,j},f_{i-1,j-k\times v_i}+k\times w_i)}\]</span></p><p>其中 <span class="math inline">\(k\in[ 1,min(\left \lfloor \dfrac {V}{v_i} \right \rfloor,s_i) ]\)</span>，仿照 01 背包的想法，考虑 <span class="math inline">\(f_{i,j}\)</span> 对其它状态的影响：</p><p>我们发现如果往体积为 <span class="math inline">\(j-(k+1)\times v_i\)</span> 的背包中填充体积为 <span class="math inline">\(v_i\)</span> 的物品，体积变化为 <span class="math inline">\(j-k\times v_i\)</span>。</p><p>归纳来看，<span class="math inline">\(f_{i,j}\)</span> 会影响 <span class="math inline">\(f_{i,j+k\times v_i}\)</span>（<span class="math inline">\(j+k\times v_i \leq V\)</span>。</p><p>那么，<span class="math inline">\(j+k\times v_i\)</span> 能联想到什么？是等差数列，并且公差就是 <span class="math inline">\(v_i\)</span> ，举个例子：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rgd8liiq.png" /></p><p>图中每一种颜色构成的数列均为公差为 <span class="math inline">\(v_i=4\)</span> 的等差数列，意味着同一种颜色的格子对 <span class="math inline">\(v_i\)</span> 取模得到的余数相同。</p><p>即通项公式为 <span class="math inline">\(j=k\times v_i+取模得到的余数\)</span>，所以我们可以通过取模得到的余数分出 <span class="math inline">\(0,1,2,..,v_i-1\)</span> 共 <span class="math inline">\(v_i\)</span> 组，</p><p>令公差为 <span class="math inline">\(d=v_i\)</span>，全选状态下物品个数 <span class="math inline">\(a=\left \lfloor \dfrac {j}{v_i} \right \rfloor\)</span>，余数 <span class="math inline">\(b=j \% v_i\)</span>，所以写成 <span class="math inline">\(j=a\times d+b\)</span>，带回得：</p><p><span class="math display">\[\normalsize{j-k\times d=a\times d+b-k\times d=(a-k)\times d+b}\]</span></p><p>回想转移方程中 <span class="math inline">\(f_{i,j-k\times v_i}+k\times w_i\)</span> 代表选择 <span class="math inline">\(k\)</span> 件第 <span class="math inline">\(i\)</span> 种物品，全选是 <span class="math inline">\(a\)</span>，所以不选择 <span class="math inline">\(a-k\)</span> 件物品。</p><p>如果令 <span class="math inline">\(a-k=k&#39;\)</span>，则状态变成：</p><p><span class="math display">\[\large{f_{i,j}=max(f_{i-1,k&#39;\times d+b}+a\times w_i-k&#39;\times w_i )}\]</span></p><p>其中 <span class="math inline">\(a\times w_i\)</span> 为常量，将其从 <span class="math inline">\(max\)</span> 中移出。则：</p><p><span class="math display">\[\large{f_{i,j}=max(f_{i-1,k&#39;\times d+b}-k&#39;\times w_i )+a\times w_i}\]</span></p><p>如果把 <span class="math inline">\(f_{i,j}\)</span> 之前所有的 $f_{i-1,k'd+b}-k'w_i $ 放入一个队列，答案转化为求这个最长为 <span class="math inline">\(min(\left \lfloor \dfrac {V}{v_i} \right \rfloor,s_i)+1\)</span> 的队列的最大值+ <span class="math inline">\(a\times w_i\)</span>。</p><p>所以考虑单调队列优化。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000010</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mylist</span> &#123;<span class="hljs-type">int</span> val,pos;&#125;que[N];<span class="hljs-type">int</span> n,V,head,tail,f[N],c[N],w[N],num[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;V);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;w[i],&amp;c[i],&amp;num[i]); <span class="hljs-comment">//c[i]代表体积，w[i]代表价值，num[i]代表数量 </span><span class="hljs-keyword">if</span>(V/c[i]&lt;num[i]) &#123;num[i]=V/c[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> mo=<span class="hljs-number">0</span>;mo&lt;c[i];mo++) &#123;head=tail=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=(V-mo)/c[i];k++) &#123;<span class="hljs-type">int</span> x=k;<span class="hljs-type">int</span> y=f[k*c[i]+mo]-k*w[i];<span class="hljs-keyword">while</span>(head&lt;tail &amp;&amp; que[head].pos&lt;k-num[i]) head++;<span class="hljs-keyword">while</span>(head&lt;tail &amp;&amp; que[tail<span class="hljs-number">-1</span>].val&lt;=y)tail--;que[tail].pos=x;que[tail].val=y;tail++; f[k*c[i]+mo]=que[head].val+k*w[i];&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[V]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>          </div><h1 id="混合背包">4.混合背包</h1><div class="note note-info">            <p>Q：有些物品只能放一次，有些物品可以放无限次，有些物品可以放 <span class="math inline">\(s_i\)</span> 次，求最大价值。</p>          </div><div class="note note-success">            <p>其实就是上面三中背包合在一起。</p><p>把可以放 <span class="math inline">\(s_i\)</span> 次的二进制拆分，当作 01 背包，和只能放一次的倒序循环处理。</p><p>然后把可以放无限次的正序循环处理就行了。</p>          </div><h1 id="二维费用背包">5.二维费用背包</h1><div class="note note-info">            <p>Q：在 01 背包基础上，每件物品都有一个重量 <span class="math inline">\(m_i\)</span>，要求所选物品还要满足总重量不超过背包核载 <span class="math inline">\(M\)</span>，求最大价值。</p>          </div><div class="note note-success">            <p>其实感觉就像两个 01 背包，一个限制体积，一个限制重量，事实上也差不多（多定义一维）。</p><p><span class="math inline">\(f_{i,j}\)</span> 表示背包体积为 <span class="math inline">\(i\)</span>，重量为 <span class="math inline">\(j\)</span> 时的最大价值。相同地：</p><p><span class="math display">\[\large{f_{j,k}=max(f_{j,k},f_{j-v_i,k-m_i}+w_i)}\]</span></p><p>所以内层两个循环都是逆序循环。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.NFor j=V..v[i]For k=M..m[i]f[j][k]=<span class="hljs-built_in">max</span>(f[j][k],f[j-v[i]][k-m[i]]+w[i]);result: f[V][M]</code></pre></div>          </div><h1 id="分组背包">6.分组背包</h1><div class="note note-info">            <p>Q：有 <span class="math inline">\(N\)</span> 组物品和容量为 <span class="math inline">\(V\)</span> 的背包，每一组内最多只能选一个物品，求最大价值。</p>          </div><div class="note note-success">            <p>和多重背包问题很像，多重背包是考虑选多少个物品，分组背包是考虑每一组选哪个物品。</p><p>对每一组的 <span class="math inline">\(n\)</span> 个物品有 <span class="math inline">\(n+1\)</span> 种方案，即不选，选第一个，选第二个...以此类推。多一重循环枚举即可。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.N&#123;read n;For j=<span class="hljs-number">1.</span>.n read v[j],w[j];For j=V.<span class="hljs-number">.0</span>For k=<span class="hljs-number">0.</span>.n<span class="hljs-keyword">if</span>(j&gt;=v[k]) f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[k]]+w[k]);&#125;result: f[V];</code></pre></div>          </div><h1 id="树形依赖背包">7.树形依赖背包</h1><div class="note note-info">            <p>Q：有 <span class="math inline">\(N\)</span> 件物品和容量为 <span class="math inline">\(V\)</span> 的背包。物品间形成依赖关系，且依赖关系组成一棵树。如果选择一个物品，则必须选择它的父节点。 其中每个物品有体积 <span class="math inline">\(v_i\)</span>，价值 <span class="math inline">\(w_i\)</span>，和所依赖的父节点编号 <span class="math inline">\(p_i\)</span>，求最大价值。</p>          </div><div class="note note-success">            <p>对于一棵树，如何去表示状态？普通的背包用 <span class="math inline">\(f_i\)</span> 表示体积为 <span class="math inline">\(i\)</span> 时的最大价值，但放到一棵树中，为了定位到我们需要选的一个子树，还需要记录根节点。</p><p>定义 <span class="math inline">\(f_{i,j}\)</span> 表示以 <span class="math inline">\(i\)</span> 为根节点并包含 <span class="math inline">\(i\)</span> 的一棵子树，当体积为 <span class="math inline">\(j\)</span> 时的最大价值。试着写出状态转移：</p><p><span class="math display">\[\large{f_{x,j}=\max(f_{x,j},f_{x,j-k}+f_{son,k})_{(x为当前节点，son为儿子节点)}}\]</span></p><p>整个过程是递归到叶子节点再自下向上的。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    f[x][<span class="hljs-number">1</span>]=a[x];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=nxt[i])    &#123;        <span class="hljs-type">int</span> y=ver[i];        <span class="hljs-built_in">dfs</span>(y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m+<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">1</span>;--j)            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;j;++k)                f[x][j]=<span class="hljs-built_in">max</span>(f[x][j],f[x][j-k]+f[y][k]);    &#125;&#125;</code></pre></div><p>看上去很不错，但还可以上下界优化，优化之后被严格证明为 <span class="math inline">\(O(NV)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    siz[x]=<span class="hljs-number">1</span>;    f[x][<span class="hljs-number">1</span>]=a[x];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=nxt[i])    &#123;        <span class="hljs-type">int</span> y=ver[i];        <span class="hljs-built_in">dfs</span>(y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-built_in">min</span>(m+<span class="hljs-number">1</span>,siz[x]+siz[y]);j&gt;=<span class="hljs-number">1</span>;--j)            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,j-siz[x]);k&lt;=<span class="hljs-built_in">min</span>(siz[y],j);++k)                f[x][j]=<span class="hljs-built_in">max</span>(f[x][j],f[x][j-k]+f[y][k]);        siz[x]+=siz[y];    &#125;&#125;</code></pre></div><p>相比自下向上的 dp，可以转变思路：对于一个节点，分为选和不选。假定选这个节点，往下递归，最后和不选的进行比较。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> fa)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//当前节点编号，背包剩余体积，父节点编号 </span><span class="hljs-keyword">if</span>(m&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=next[i])&#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(y==fa)<span class="hljs-keyword">continue</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=m;++k)        f[y][k]=f[x][k]+v[y];<span class="hljs-comment">//选 </span><span class="hljs-built_in">dp</span>(y,m-p[y],x);<span class="hljs-comment">//由上至下 </span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p[y];k&lt;=m;++k)            f[x][k]=<span class="hljs-built_in">max</span>(f[x][k],f[y][k-p[y]]);<span class="hljs-comment">//和不选的比较，留取最大值 </span>&#125;&#125;</code></pre></div><p>复杂度为 <span class="math inline">\(O(NV)\)</span>。</p>          </div><h1 id="泛化物品背包">8.泛化物品背包</h1><h1 id="背包最优方案总数">9-1.背包最优方案总数</h1><div class="note note-success">            <p>一个可行的方案是：用 <span class="math inline">\(g_i\)</span> 表示背包容量为 <span class="math inline">\(i\)</span> 时的方案数，然后常规背包得出最优解，遍历<span class="math inline">\(f_i\)</span>，若和最优解相同，答案就加上 <span class="math inline">\(g_i\)</span>。</p><p>那么如何预处理出 <span class="math inline">\(g_i\)</span> ？只要确定状态转移时来自哪一种决策即可。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">g[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">1.</span>.V]=-INF;<span class="hljs-comment">//当背包容量为0时只有“不选”这1种方案</span>For i=<span class="hljs-number">1.</span>.NFor j=V..v[i]&#123;<span class="hljs-type">int</span> tmp_f,tmp_g;tmp_f=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);tmp_f==f[j] ? tmp+=g[j] : tmp+=g[j-v[i]] ;<span class="hljs-comment">//判断来自哪一种决策，注意方案数不需要加w[i];</span>f[j]=tmp_f;g[j]=tmp_g;&#125;<span class="hljs-type">int</span> maxw=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;For i=<span class="hljs-number">0.</span>.V  maxw=<span class="hljs-built_in">max</span>(maxw,f[i]);For i=<span class="hljs-number">0.</span>.V<span class="hljs-keyword">if</span>(maxw==f[i])ans+=g[i];result: ans</code></pre></div>          </div><div class="note note-warning">            <p><strong>为什么 <span class="math inline">\(f_{1..V}\)</span> 要预处理成极小值？为什么最优解不是 <span class="math inline">\(f[m]\)</span> 了 ？</strong></p><p>因为要统计 <span class="math inline">\(g_i\)</span>，这里的 <span class="math inline">\(f_i\)</span> 的意义并不是背包容量为 <span class="math inline">\(i\)</span> 时的最大价值，而是背包容量恰好为 <span class="math inline">\(i\)</span> 时的最大价值，因此最优解并不是 <span class="math inline">\(f[m]\)</span>。</p><p>为了达成恰好为 <span class="math inline">\(i\)</span> 的目的，<span class="math inline">\(f_{1..V}\)</span> 应赋值为极小值，原因见下文。</p>          </div><h1 id="背包具体方案">9-2.背包具体方案</h1><div class="note note-success">            <p>和求方案总数一样，需要确定状态转移时来自哪一种决策，在此用 <span class="math inline">\(g_{i,j}\)</span> 记录。</p><p>由于 <span class="math inline">\(f_{i,j}=f_{i-1,j}\)</span> 表示不选第 <span class="math inline">\(i\)</span> 件物品，令 <span class="math inline">\(g_{i,j}=0\)</span>。反之，若 <span class="math inline">\(f_{i,j}=f_{i-1,j-v_i}+w_i\)</span>，则令 <span class="math inline">\(g_{i,j}=1\)</span>。</p><p>最后从后往前用 <span class="math inline">\(g_{i,j}\)</span> 来判断是否选择了该物品即可。</p><p>不过既然需要记录物品和容量，<span class="math inline">\(g\)</span> 数组只能是二维，但 <span class="math inline">\(f\)</span> 数组仍可保留一维。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.NFor j=V..v[i]&#123;f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<span class="hljs-keyword">if</span>(f[j]==f[j-v[i]]+w[i])g[i][j]=<span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> i=N,lf=V;<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(g[i][lf])<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i),lf-=v[i];i--;&#125;</code></pre></div><p>注：此时输出的物品选择方案是降序的。</p>          </div><h1 id="背包k优解">9-3.背包k优解</h1><h1 id="背包状态与初始化">10.背包状态与初始化</h1><div class="note note-success">            <p>背包恰好装满：<span class="math inline">\(f[0]=0\)</span>，<span class="math inline">\(f[1\sim V]=-inf\)</span>。</p><p>背包不要求恰好装满：<span class="math inline">\(f[0\sim V]=0\)</span>。</p>          </div><div class="note note-warning">            <p><strong>为什么 ？</strong></p><p>初始化的 <span class="math inline">\(f\)</span> 数组实际就是在没有任何物品可以放入背包时的合法状态，或者说初始化 <span class="math inline">\(f[i]=0\)</span> 代表最后还剩 <span class="math inline">\(i\)</span> 的体积是合法的。</p>          </div><div class="note note-primary">            <p>参考链接：</p><p>https://www.cnblogs.com/jbelial/articles/2116074.html <code>《dd大牛的背包九讲》</code></p><p>https://www.bilibili.com/video/BV1qt411Z7nE <code>闫学灿'背包九讲专题'</code></p><p>https://www.luogu.com.cn/blog/RPdreamer/bei-bao-wen-ti <code>洛谷日报#61 背包问题</code></p><p>https://oi-wiki.org/dp/knapsack/ <code>OIwiki 背包dp</code></p>          </div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】AtCoder Regular Contest 124 (4 of 6)</title>
    <link href="/posts/79e649ee.html"/>
    <url>/posts/79e649ee.html</url>
    
    <content type="html"><![CDATA[<h2 id="a.-lr-constraints">A. LR Constraints</h2><p><a href="https://atcoder.jp/contests/arc124/tasks/arc124_a">Problem</a></p><div class="note note-info">            <p>题意：从左到右 <span class="math inline">\(n\)</span> 个空卡片，需要在每个卡片上写一个 <span class="math inline">\(x\in[1,k]\)</span>，且满足 <span class="math inline">\(k\)</span> 个限制条件。第 <span class="math inline">\(i\)</span> 个条件限定第 <span class="math inline">\(k_i\)</span> 个卡片必须是最左/最右边的写有 <span class="math inline">\(i\)</span> 的卡片。问填写方案数。</p><p><span class="math inline">\(1\le n,k \le 1000\)</span>。</p>          </div><div class="note note-success">            <p>直接模拟。开一个桶 <span class="math inline">\(a\)</span> 统计每个卡片能填的数字数量，初始化全为 <span class="math inline">\(a_i=k\)</span>。</p><p>对于一个限制条件，若限制第 <span class="math inline">\(k_i\)</span> 个卡片是最左边的写有 <span class="math inline">\(i\)</span> 的卡片，则 <span class="math inline">\(a_{j\in[1,k_i-1]}--\)</span>。</p><p>若限制第 <span class="math inline">\(k_i\)</span> 个卡片是最右边的写有 <span class="math inline">\(i\)</span> 的卡片，则 <span class="math inline">\(a_{j\in[k_i+1,n]}--\)</span>。</p><p>最后 <span class="math inline">\(ans = \prod a_i\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=k;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-type">char</span> opt[<span class="hljs-number">3</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;opt);<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(opt[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;L&#x27;</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;x;++j) &#123;<span class="hljs-keyword">if</span>(a[j]!=<span class="hljs-number">1</span>) &#123;a[j]--;&#125;&#125;a[x]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=x+<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(a[j]!=<span class="hljs-number">1</span>) &#123;a[j]--;&#125;&#125;a[x]=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans*=a[i];ans%=modp;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-xor-matching-2">B. XOR Matching 2</h2><p><a href="https://atcoder.jp/contests/arc124/tasks/arc124_b">Problem</a></p><div class="note note-info">            <p>题意：给定两个长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a,b\)</span>。找到所有的 <span class="math inline">\(x\)</span> 使得能使 <span class="math inline">\(b\)</span> 按一定顺序重排后对于所有 <span class="math inline">\(1\le i\le n\)</span> 都有 <span class="math inline">\(a_i\oplus b_i = x\)</span>。</p><p><span class="math inline">\(1\le n\le 2000\)</span>，<span class="math inline">\(0\le a_i,b_i\le 2^{30}\)</span>。</p>          </div><div class="note note-success">            <p>略加思考，如果要对所有 <span class="math inline">\(i\)</span> 都满足 <span class="math inline">\(a_i \oplus b_i=x\)</span>，那么 <span class="math inline">\(x\)</span> 的可能值最多就 <span class="math inline">\(n\)</span> 个，且一定是 <span class="math inline">\(a_1\oplus b_1,a_1\oplus b_2,\dots ,a_1\oplus b_n\)</span> 中的若干。逐个去试即可。</p><p>最方便的方法是对 <span class="math inline">\(b\)</span> 排序，用 <span class="math inline">\(a\)</span> 的每一项去异或可能的 <span class="math inline">\(x\)</span> 得到 <span class="math inline">\(c\)</span> ，再将 <span class="math inline">\(c\)</span> 排序后和 <span class="math inline">\(b\)</span> 比较。</p><p>一个坑点是答案需要去重。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">c</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,b.<span class="hljs-built_in">end</span>());vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=a[<span class="hljs-number">1</span>]^b[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;c[j]=a[j]^x;&#125;<span class="hljs-built_in">sort</span>(c.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,c.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span>(c==b) &#123;ans.<span class="hljs-built_in">push_back</span>(x);&#125;&#125;ans.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>()),ans.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans.<span class="hljs-built_in">size</span>());<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,i);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p><code>std::vector</code> 去重方法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());res.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>()),res.<span class="hljs-built_in">end</span>());</code></pre></div>          </div><h2 id="c.-lcm-of-gcds">C. LCM of GCDs</h2><p><a href="https://atcoder.jp/contests/arc124/tasks/arc124_c">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定 <span class="math inline">\(n\le 50\)</span> 对数。对于每一对数，选一个放入集合 <span class="math inline">\(A\)</span> ，另一个则放入集合 <span class="math inline">\(B\)</span>，最后对两个集合里所有数求 <span class="math inline">\(\gcd\)</span> 得到 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，求最大的 <span class="math inline">\(\text{lcm}(a,b)\)</span>。</p>          </div><div class="note note-success">            <p>经典 trick 。</p><p>如果直接暴力搜索，复杂度将会是 <span class="math inline">\(O(2^n)\)</span>。</p><p>但这里最后是拿两个集合的 <span class="math inline">\(\gcd\)</span> 做 <span class="math inline">\(\text{lcm}\)</span>，而实际上这 <span class="math inline">\(50\)</span> 对数的 <span class="math inline">\(\gcd\)</span> 个数并没有那么多。</p><p>所以还是暴搜，用一个 <code>std::set</code> 记录选到当前位置的集合里是否有与当前相同的 <span class="math inline">\(\gcd\)</span>，有就跳过，否则把当前两个集合里的 <span class="math inline">\(\gcd\)</span> 用一个 <code>std::pair</code> 记录到 <code>std::set</code> 里。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q[<span class="hljs-number">55</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span>(p==n+<span class="hljs-number">1</span>) &#123;res=<span class="hljs-built_in">max</span>(res,x/__gcd(x,y)*y);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span>(q[p].<span class="hljs-built_in">count</span>(&#123;x,y&#125;)) &#123;<span class="hljs-keyword">return</span> ;&#125;q[p].<span class="hljs-built_in">insert</span>(&#123;x,y&#125;);<span class="hljs-built_in">self</span>(self,p+<span class="hljs-number">1</span>,__gcd(x,a[p]),__gcd(y,b[p]));<span class="hljs-built_in">self</span>(self,p+<span class="hljs-number">1</span>,__gcd(x,b[p]),__gcd(y,a[p]));&#125;;<span class="hljs-built_in">dfs</span>(dfs,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-yet-another-sorting-problem">D. Yet Another Sorting Problem</h2><p><a href="https://atcoder.jp/contests/arc124/tasks/arc124_d">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：给定一个长 <span class="math inline">\(n+m\)</span> 的排列，每次可以从前边 <span class="math inline">\(n\)</span> 个数和后边 <span class="math inline">\(m\)</span> 个数里挑一个出来交换，问至少交换多少次能使整个序列呈升序。</p><p><span class="math inline">\(1\le n,m\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>挺新颖的思路。先考虑如果没有左边 <span class="math inline">\(n\)</span> 个和右边 <span class="math inline">\(m\)</span> 个的限制，从整个序列里挑两个数交换的最少方案数。</p><p>我们将每个数和它对应的下标连边，那么最终升序的状态是每个点和自己连边，即一共 <span class="math inline">\(n+m\)</span> 个连通块。我们再考虑交换两个数会发生什么。</p><ol type="1"><li><p>如果 <span class="math inline">\(i,a_i\)</span> 和 <span class="math inline">\(j,a_j\)</span> 位于两个连通块，那么交换会让它们合并成一个连通块。</p></li><li><p>如果 <span class="math inline">\(i,a_i\)</span> 和 <span class="math inline">\(j,a_j\)</span> 位于同一连通块，交换之后仍为一个连通块。</p></li><li><p>如果 <span class="math inline">\(i,j,a_i,a_j\)</span> 中有两个数相等，那这四个数一定位于一个连通块，交换之后会把相等的那个数移出该连通块，连通块数 <span class="math inline">\(+1\)</span>。比如 <span class="math inline">\(i=a_j\)</span>，则连边情况为 <span class="math inline">\(a_i -a_j/i-j\)</span>，交换后 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(i\)</span> 连边，<span class="math inline">\(a_j\)</span> 和 <span class="math inline">\(j\)</span> 连边，变成两个连通块。</p></li><li><p>如果 <span class="math inline">\(i=a_j,j=a_i\)</span>，交换后分离，变成两个连通块，连通块数目 <span class="math inline">\(+1\)</span>。</p></li></ol><p>因为最终目标是 <span class="math inline">\(n+m\)</span> 个连通块，所以只需要用后两个操作不断增加连通块即可。</p><p>再考虑有限制怎么做 ：因为我们只能对前 <span class="math inline">\(n\)</span> 个数和后 <span class="math inline">\(m\)</span> 个数成对操作，所以将前 <span class="math inline">\(n\)</span> 个点染成红色，后 <span class="math inline">\(m\)</span> 个点染成蓝色，每次只能对红色点和蓝色点执行交换操作。</p><p>那么对于只有红色或蓝色的纯色且大小大于 <span class="math inline">\(1\)</span> 的连通块，只能执行操作 <span class="math inline">\(1\)</span> 合并在一起变成杂色连通块，再用后两个操作分开。</p><p>假设大小大于1的纯红色连通块有 <span class="math inline">\(a\)</span> 个，纯蓝色连通块有 <span class="math inline">\(b\)</span> 个，总连通块个数为 <span class="math inline">\(cnt\)</span>，那么 ：</p><p><span class="math display">\[ans=n+m-cnt+2\times max(a,b)\]</span></p><p>假设 <span class="math inline">\(a&lt;b\)</span>，因为把红色连通块与蓝色连通块合并的需要 <span class="math inline">\(a\)</span> 步，把剩下的蓝色连通块合并到杂色连通块要 <span class="math inline">\(b-a\)</span> 步，一共少了 <span class="math inline">\(a+(b-a)=b\)</span> 个连通块，所以还需要 <span class="math inline">\(b\)</span> 次分离操作，那么现在一共 <span class="math inline">\(2\times b\)</span> 次操作。 <span class="math inline">\(a&gt;b\)</span> 同理。</p><p>前面的 <span class="math inline">\(n+m-cnt\)</span> 即本来需要分离的连通块数量。</p><p>整个过程都可以用并查集维护。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f,siza,sizb;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;f.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);siza.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);sizb.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;++i)f[i]=i,siza[i]=sizb[i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(x==f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;x=<span class="hljs-built_in">find</span>(x);y=<span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;siza[x]+=siza[y];sizb[x]+=sizb[y];f[y]=x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sizea</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> siza[<span class="hljs-built_in">find</span>(x)];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sizeb</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> sizb[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n+m)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) &#123;i&lt;=n ? dsu.siza[i]++ : dsu.sizb[i]++;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();dsu.<span class="hljs-built_in">merge</span>(x,i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+m+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,cnta=<span class="hljs-number">0</span>,cntb=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) &#123;<span class="hljs-type">int</span> x = dsu.<span class="hljs-built_in">find</span>(i);<span class="hljs-keyword">if</span>(!vis[x]) &#123;vis[x]=<span class="hljs-literal">true</span>;cnt++;cnta+=(dsu.<span class="hljs-built_in">sizea</span>(x)&gt;=<span class="hljs-number">2</span> &amp;&amp; !dsu.<span class="hljs-built_in">sizeb</span>(x));cntb+=(dsu.<span class="hljs-built_in">sizeb</span>(x)&gt;=<span class="hljs-number">2</span> &amp;&amp; !dsu.<span class="hljs-built_in">sizea</span>(x));&#125;&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n+m-cnt+<span class="hljs-number">2</span>*<span class="hljs-built_in">max</span>(cnta,cntb));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Atcoder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】Codeforces Round 729 (Div.2) 4 of 6</title>
    <link href="/posts/49b078d6.html"/>
    <url>/posts/49b078d6.html</url>
    
    <content type="html"><![CDATA[<h2 id="a.-odd-set">A. Odd Set</h2><p><a href="https://codeforces.com/contest/1542/problem/A">Problem</a></p><div class="note note-info">            <p>题意：给出长为 <span class="math inline">\(2n\)</span> 的数组，问是否能分成 <span class="math inline">\(n\)</span> 个长度为 <span class="math inline">\(2\)</span> 的组使每组内两数之和均为奇数。</p>          </div><div class="note note-success">            <p>若和为奇数，则两数一奇一偶，即判断原数列中奇数个数是否等于偶数个数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> re register int</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)     &#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(re i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();cnt+=(x%<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">if</span>(cnt==n) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-plus-and-multiply">B. Plus and Multiply</h2><p><a href="https://codeforces.com/contest/1542/problem/B">Problem</a></p><span class="label label-primary">好题</span><div class="note note-info">            <p>题意：<span class="math inline">\(T\le 10^5\)</span> 组数据，给定正整数 <span class="math inline">\(n,a,b\)</span> ，每次能将一个数 <span class="math inline">\(\times a\)</span> 或 <span class="math inline">\(+b\)</span>，问是否能将 <span class="math inline">\(1\)</span> 经过若干次操作得到 <span class="math inline">\(n\)</span> 。</p><p><span class="math inline">\(1\le n,a,b\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>若得到了某个数 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\((n-x)\% b=0\)</span> 那么显然符合要求。</p><p>对于 <span class="math inline">\(+b\)</span> 操作，<span class="math inline">\(\%b\)</span> 后余数不变。</p><p>意味着只有 <span class="math inline">\(\times a\)</span> 操作会使 <span class="math inline">\(\%b\)</span> 的余数改变。</p><p>枚举不超过 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(a\)</span> 的次方数 <span class="math inline">\(x\)</span> 判断是否满足 <span class="math inline">\((n-x)\%b=0\)</span> 即可。</p><p>特判 <span class="math inline">\(a=1\)</span> 的情况。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> re register int</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> tmp=a,flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>((x<span class="hljs-number">-1</span>)%b==<span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);            &#125;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(tmp&gt;x) &#123;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">if</span>((x-tmp)%b==<span class="hljs-number">0</span>) &#123;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;tmp*=a;&#125;<span class="hljs-keyword">if</span>(flag || (x<span class="hljs-number">-1</span>)%b==<span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);        &#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-strange-function">C. Strange Function</h2><p><a href="https://codeforces.com/contest/1542/problem/C">Problem</a></p><div class="note note-info">            <p>题意：求 <span class="math inline">\(\sum\limits_{i=1}^n f_i\)</span>，<span class="math inline">\(f_i\)</span> 为满足 <span class="math inline">\(x\nmid i\)</span> 的最小正整数 <span class="math inline">\(x\)</span>。</p><p><span class="math inline">\(1\le T\le 10^4\)</span>，<span class="math inline">\(1\le n\le 10^{16}\)</span>。</p>          </div><div class="note note-success">            <p>没什么思路，打表得到 <span class="math inline">\(2,3,2,3,2,4,2,3,2,3,2,5,2,\dots\)</span> 。</p><p>令 <span class="math inline">\(p_i\)</span> 为第一次出现 <span class="math inline">\(i\)</span> 的位置，观察有 <span class="math inline">\(p_3=2,p_4=6,p_5=12\)</span> ，类比得 <span class="math inline">\(p_i=\text{lcm} (1\sim i-1)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Why?    </div>    <div class='spoiler-content'>        <p>因为对于 <span class="math inline">\(f_x\)</span>，<span class="math inline">\(1\sim (f_x-1)\)</span> 必然是 <span class="math inline">\(p_{f_x}\)</span> 的因子，故最优选择就是它们的最小公倍数。</p>    </div></div><div class="note note-success">            <p>其中每个位置贡献至少为 <span class="math inline">\(2\)</span>，故初始化 <span class="math inline">\(ans=2n\)</span>。</p><p>又若 <span class="math inline">\(i\)</span> 在位置 <span class="math inline">\(pos\)</span> 有贡献，则在 <span class="math inline">\(pos\)</span> 的倍数处也必有贡献，且每次贡献为 <span class="math inline">\(1\)</span>。</p><p>而每个 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(1\sim n\)</span> 中出现 <span class="math inline">\(\left\lfloor\dfrac{n}{p_i}\right\rfloor\)</span> 次，故 <span class="math inline">\(ans=2n+\sum\limits_{i=3}^{p_i\le n}\left\lfloor\dfrac{n}{p_i}\right\rfloor\)</span> .</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> re register int</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e16</span>+<span class="hljs-number">10</span>,modp=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> !y?x:<span class="hljs-built_in">gcd</span>(y,x%y);&#125;<span class="hljs-type">int</span> Lcm[<span class="hljs-number">50</span>];<span class="hljs-comment">//lcm[i]表示1~i-1的最小公倍数 </span><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> tmp=<span class="hljs-number">1</span>,x=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;Lcm[tmp]=x;x=x*tmp/<span class="hljs-built_in">gcd</span>(x,tmp);<span class="hljs-keyword">if</span>(x&gt;maxn)<span class="hljs-keyword">break</span>;tmp++;    &#125;<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),ans=<span class="hljs-number">2</span>*n%modp;<span class="hljs-keyword">for</span>(re i=<span class="hljs-number">3</span>;i&lt;=tmp;++i)ans=(ans+n/Lcm[i])%modp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-priority-queue">D. Priority Queue</h2><p><a href="https://codeforces.com/contest/1542/problem/D">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的操作序列 <span class="math inline">\(A\)</span> ，定义操作序列 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 的一个子序列，并维护一个可重集 <span class="math inline">\(T\)</span>。若操作形如 <code>+ x</code> 则将 <span class="math inline">\(x\)</span> 插入 <span class="math inline">\(T\)</span>，若操作形如 <code>-</code> 则将 <span class="math inline">\(T\)</span> 中最小元素删去(若为空则忽略)。令 <span class="math inline">\(f(B)\)</span> 为经过 <span class="math inline">\(B\)</span> 的操作后 <span class="math inline">\(T\)</span> 中剩余元素的和，求 <span class="math inline">\(\sum f(B)\)</span>。</p><p><span class="math inline">\(1\le n \le 500\)</span>。</p>          </div><div class="note note-success">            <p>类计数dp，因为我们对于每一个<code>+ x</code> 操作只关心数 <span class="math inline">\(x\)</span> 最终出现在多少个 <span class="math inline">\(B\)</span> 中。因为最多有 <span class="math inline">\(n\)</span> 个 <code>+ x</code>，所以可以最多进行 <span class="math inline">\(n\)</span> 次 dp 得到结果，每次 <span class="math inline">\(O(n^2)\)</span>，一共 <span class="math inline">\(O(n^3)\)</span>。</p><p>令 <span class="math inline">\(f_{i,j}\)</span> 为前 <span class="math inline">\(i\)</span> 个数中有 <span class="math inline">\(j\)</span> 个数比 <span class="math inline">\(x\)</span> 小的方案数，设当前第 <span class="math inline">\(i\)</span> 位读到 <code>-</code>，比 <span class="math inline">\(x\)</span> 大的数和比 <span class="math inline">\(x\)</span> 小的数，由该位选或不选分类讨论写出转移方程。若 <span class="math inline">\(A[k]=x\)</span> :</p><p><span class="math display">\[f_{i,j}=\begin{cases}f_{i-1,j}+f_{i-1,j+1}&amp;,A[i]= \text{&#39;-&#39;}\\f_{i-1,j}+f_{i-1,j}&amp;,A[i]&gt;x \text{   or }A[i]=x,i&gt;k \\f_{i-1,j}+f_{i-1,j-1}&amp;,A[i]&lt;x,j\neq0 \text{ or }A[i]=x,i&lt;k\\f_{i-1,j}&amp;,A[i]&lt;x,j=0 \text{ or }A[i]=x,i&lt;k\end{cases}\]</span></p><p>特别注意第一种情况当 <span class="math inline">\(i&lt;k\)</span> 且 <span class="math inline">\(j=0\)</span> 时需要加上 <span class="math inline">\(f_{i-1,0}\)</span>，因为此时选上 <code>-</code> 不会使 <span class="math inline">\(j\)</span> 变小。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> re register int</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp=<span class="hljs-number">998244353</span>; <span class="hljs-type">int</span> A[<span class="hljs-number">500</span>+<span class="hljs-number">10</span>],f[<span class="hljs-number">500</span>+<span class="hljs-number">10</span>][<span class="hljs-number">500</span>+<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(re i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<span class="hljs-type">char</span> x[<span class="hljs-number">3</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;x);<span class="hljs-keyword">if</span>(x[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;+&#x27;</span>) A[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">else</span> A[i]=<span class="hljs-number">-1</span>;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(re k=<span class="hljs-number">1</span>;k&lt;=n;++k)&#123;<span class="hljs-keyword">if</span>(A[k]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> f);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(re i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<span class="hljs-keyword">if</span>(i==k)&#123;<span class="hljs-built_in">memcpy</span>(f[i],f[i<span class="hljs-number">-1</span>],<span class="hljs-keyword">sizeof</span> f[i]);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span>(re j=<span class="hljs-number">0</span>;j&lt;=n;++j)&#123;<span class="hljs-keyword">if</span>(A[i]==<span class="hljs-number">-1</span>)&#123;f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>])%modp;<span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> &amp;&amp; i&lt;k) f[i][j]=(f[i][j]+f[i<span class="hljs-number">-1</span>][j])%modp;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A[i]&lt;A[k] || (A[i]==A[k] &amp;&amp; i&lt;k))&#123;<span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)f[i][j]=f[i<span class="hljs-number">-1</span>][j];<span class="hljs-keyword">else</span> f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%modp;&#125;<span class="hljs-keyword">else</span> f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j])%modp;&#125;&#125;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(re j=<span class="hljs-number">0</span>;j&lt;=n;++j)sum=(sum+f[n][j])%modp;ans=(ans+sum*A[k]%modp)%modp;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>Codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ICPC</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摩尔投票法及其扩展</title>
    <link href="/posts/be35d7b0.html"/>
    <url>/posts/be35d7b0.html</url>
    
    <content type="html"><![CDATA[<p>摩尔投票法是用来解决以下问题的一类方法。</p><h3 id="q-在一个长度为-n-的数组中找出出现次数大于一半的元素">Q : 在一个长度为 <span class="math inline">\(n\)</span> 的数组中找出出现次数大于一半的元素。</h3><p>很明显，利用<strong>开桶</strong>，<strong>排序找中位数</strong>等多种多样的方法都可以轻松解决，但摩尔投票法厉害之处在于它的<strong>空间复杂度</strong>仅为 <span class="math inline">\(O(1)\)</span>，意味着数组都不用开。</p><p>摩尔投票法的核心如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!cnt) ans = <span class="hljs-built_in">read</span>(), cnt = <span class="hljs-number">1</span>;   <span class="hljs-keyword">else</span> cnt += <span class="hljs-built_in">read</span>() == ans ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;&#125;</code></pre></div><p>我们可以借助文字来帮助理解上面这段话：</p><p>摩尔投票法本质上是<strong>每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。</strong></p><p>所以，<span class="math inline">\(cnt\)</span> 存储的是<strong>当前暂时无法删除的数字的个数</strong>，表现为和上一个记录的数字相等，所以当 <span class="math inline">\(ans=read()\)</span> 时 <span class="math inline">\(cnt\)</span> 自增，反之自减，而 <span class="math inline">\(cnt=0\)</span> 的意思就是"没有数字无法删除了"，即能删的都删完了，或者说没有数可以用来抵消了，只能拿当前的数放到 <span class="math inline">\(ans\)</span> 中和后面的数抵消了。</p><p>所以我们要做的仅仅就是每次拿读入的数字和 <span class="math inline">\(ans\)</span> 去抵消而已。</p><hr /><h3 id="扩展相关">扩展相关</h3><h3 id="q-在一个长度为n的数组中找出出现次数大于-left-lfloordfrac-nk-right-rfloor-的元素">Q : 在一个长度为n的数组中找出出现次数大于 <span class="math inline">\(\left \lfloor\dfrac nk \right \rfloor\)</span> 的元素。</h3><p>为方便理解，先讨论 <span class="math inline">\(k=3\)</span> 时的情况：</p><p>如果理解了上面 <span class="math inline">\(k=2\)</span> 的那一段话，那么我们发现摩尔投票法是基于这样一个原理：如果一个数组里有一元素超过 <span class="math inline">\(\frac {\ 1\ }{2}\)</span>，那么同时删除 <span class="math inline">\(2\)</span> 个不同的数，数量超过 <span class="math inline">\(\frac {\ 1\ }{2}\)</span> 的数仍然超过 <span class="math inline">\(\frac {\ 1\ }{2}\)</span>。</p><p>稍加修改我们可以猜想：如果一个数组里有一元素超过 <span class="math inline">\(\frac {\ 1\ }{3}\)</span>，那么同时删除 <span class="math inline">\(3\)</span> 个不同的数，数量超过 <span class="math inline">\(\frac {\ 1\ }{3}\)</span> 的数仍然超过 <span class="math inline">\(\frac {\ 1\ }{3}\)</span>。</p><p>我们可以尝试证明它的正确性：</p><ul><li><p>如果删除的 <span class="math inline">\(3\)</span> 个不同的数都不是超过 <span class="math inline">\(\frac {\ 1\ }{3}\)</span> 的元素，显然成立。</p></li><li><p>如果删除的 <span class="math inline">\(3\)</span> 个不同的数有一个是超过 <span class="math inline">\(\frac {\ 1\ }{3}\)</span> 的元素，设该元素有 <span class="math inline">\(m&gt; \frac {\ 1\ }{3}\)</span> 个，即需要证：</p></li></ul><p><span class="math display">\[\dfrac {m-1}{n-3}&gt; \dfrac {n}{3}\Longrightarrow m&gt; \dfrac {n(n-3)}{3}+1\]</span></p><p>而：</p><p><span class="math display">\[\dfrac {n(n-3)}{3}+1 \ge \dfrac {n}{3} \Longrightarrow (n-2)^2-1\ge 0\quad\{n\ge 3\}\]</span></p><p>故命题成立。</p><p>同样的证明方法可以推广到 <span class="math inline">\(k\)</span>，得出：若一个数组里有一元素超过 <span class="math inline">\(\frac {\ 1\ }{k}\)</span>，那么同时删除 <span class="math inline">\(k\)</span> 个不同的数，数量超过 <span class="math inline">\(\frac {\ 1\ }{k}\)</span> 的数仍然超过 <span class="math inline">\(\frac {\ 1\ }{k}\)</span>。</p><p>不过很遗憾，如果 <span class="math inline">\(k\)</span> 很大，只能用数组去存 <span class="math inline">\(cnt_i\)</span>，但其内核仍然值得我们思考。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>等差数列与二阶前缀和</title>
    <link href="/posts/854283fe.html"/>
    <url>/posts/854283fe.html</url>
    
    <content type="html"><![CDATA[<p>设 <span class="math inline">\(a\)</span> 是原数组，<span class="math inline">\(b\)</span> 是一阶差分数组，<span class="math inline">\(c\)</span> 是二阶差分数组。</p><p>首先，公差 <span class="math inline">\(d=(t-s)/(R-L)\)</span>。</p><p>考虑给一个区间 <span class="math inline">\([L,R]\)</span> 加上首项为 <span class="math inline">\(s\)</span>，末项为 <span class="math inline">\(t=s+(R-L)\times d\)</span> 的等差数列对 <span class="math inline">\(a\)</span> 的影响。</p><p><span class="math display">\[a_x=a_x+s+(x-L)\times d\]</span></p><p>由于 <span class="math inline">\(b_i=a_i-a_{i-1}\)</span> ，那么：</p><p><span class="math display">\[\begin{align}&amp;\text{} \\b_L&amp;=(a_L+s)-a_{L-1}\\&amp;=b_L+s \\&amp;\text{}\\b_x&amp;=[a_x+(x-L)\times d]-[a_{x-1}+(x-1-L)\times d]\\&amp;=b_x+d\quad(x\in[L+1,R]) \\&amp;\text{}\\b_{R+1}&amp;=a_{R+1}-(a_R+t)\\&amp;=b_{R+1}-t\end{align}\]</span></p><p>又 <span class="math inline">\(c_i=b_i-b_{i-1}\)</span> ：</p><p><span class="math display">\[\begin{align}&amp;\text{} \\c_L&amp;=(b_L+s)-b_{L-1}\\&amp;=c_L+s \\&amp;\text{}\\c_{L+1}&amp;=(b_{L+1}+d)-(b_L+s)\\&amp;=c_{L+1}+d-s \\&amp;\text{}\\c_x&amp;=(b_x+d)-(b_{x-1}+d)\\&amp;=c_x\quad(x\in [L+2,R]) \\&amp;\text{}\\c_{R+1}&amp;=(b_{R+1}-t)-(b_R+d)\\&amp;=c_{R+1}-d-t \\&amp;\text{}\\c_{R+2}&amp;=b_{R+2}-(b_{R+1}-t)\\&amp;=c_{R+2}+t \\\end{align}\]</span></p><p>所以，相当于改变 <span class="math inline">\(L,L+1,R+1,R+2\)</span> 四个位置的数值再求两遍前缀和。</p><p>注意：差分数组需要开大。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】NOIP 2007 提高组</title>
    <link href="/posts/7f934b5.html"/>
    <url>/posts/7f934b5.html</url>
    
    <content type="html"><![CDATA[<h2 id="a.-统计数字">A. 统计数字</h2><p><a href="https://www.luogu.com.cn/problem/P1097">Problem</a></p><div class="note note-success">            <p>按照题意模拟即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125; <span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> a[N],n;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        a[i]=<span class="hljs-built_in">read</span>();    &#125;<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;++i) &#123;<span class="hljs-keyword">if</span>(a[i]==a[i<span class="hljs-number">-1</span>]) &#123;            tot++;        &#125;<span class="hljs-keyword">if</span>(a[i]!=a[i<span class="hljs-number">-1</span>] &amp;&amp; i!=<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,a[i<span class="hljs-number">-1</span>],tot);tot=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-字符串的展开">B. 字符串的展开</h2><p><a href="https://www.luogu.com.cn/problem/P1098">Problem</a></p><div class="note note-success">            <p>按照题意模拟即可。</p><p>注意一些特判：</p><ul><li>开头字符也可能为 '<span class="math inline">\(-\)</span> '。</li><li>可能有连续的 ‘ <span class="math inline">\(-\)</span> ’。</li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">int</span> p1,p2,p3;string s;stack&lt;<span class="hljs-type">char</span>&gt; q;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;-&#x27;</span> || s[i]!=<span class="hljs-string">&#x27;-&#x27;</span> || (s[i]==<span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; i==<span class="hljs-number">0</span>) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((s[i]==<span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; ((<span class="hljs-type">int</span>)s[i<span class="hljs-number">-1</span>]&gt;=(<span class="hljs-type">int</span>)s[i+<span class="hljs-number">1</span>])) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//&#x27;-&#x27;之后的字符ascll比前面大 </span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-string">&#x27;z&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//&#x27;-&#x27;前后同为数字或字母 </span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;p1=<span class="hljs-built_in">read</span>(),p2=<span class="hljs-built_in">read</span>(),p3=<span class="hljs-built_in">read</span>();cin&gt;&gt;s;<span class="hljs-type">int</span> lst;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-type">char</span> x=s[i];<span class="hljs-keyword">if</span>(x!=<span class="hljs-string">&#x27;-&#x27;</span> ||(x==<span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; i==<span class="hljs-number">0</span>)|| <span class="hljs-built_in">check</span>(i)) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,x),lst=x;        &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;lst++;x=s[++i];<span class="hljs-keyword">while</span>(lst&lt;(<span class="hljs-type">int</span>)x) &#123;<span class="hljs-keyword">if</span>(p1==<span class="hljs-number">1</span> || (p1==<span class="hljs-number">2</span>&amp;&amp;(<span class="hljs-type">char</span>)lst&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;(<span class="hljs-type">char</span>)lst&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p2;++i) &#123;    <span class="hljs-keyword">if</span>(p3==<span class="hljs-number">1</span>) &#123;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,(<span class="hljs-type">char</span>)lst);                        &#125; <span class="hljs-keyword">else</span> &#123;                            q.<span class="hljs-built_in">push</span>(lst);                        &#125;                    &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p1==<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p2;++i) &#123;    <span class="hljs-keyword">if</span>(p3==<span class="hljs-number">1</span>) &#123;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,(<span class="hljs-type">char</span>)(lst<span class="hljs-number">-32</span>));                        &#125; <span class="hljs-keyword">else</span> &#123;                            q.<span class="hljs-built_in">push</span>(lst<span class="hljs-number">-32</span>);                        &#125;                    &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p1==<span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p2;++i) &#123;                       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*&quot;</span>);                   &#125;lst++;                &#125;&#125;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,(<span class="hljs-type">char</span>)q.<span class="hljs-built_in">top</span>());                q.<span class="hljs-built_in">pop</span>();            &#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,x);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-矩阵取数游戏">C. 矩阵取数游戏</h2><p><a href="https://www.luogu.com.cn/problem/P1005">Problem</a></p><div class="note note-info">            <p>题意：在 <span class="math inline">\(n\times m\)</span> 的非负矩阵中取数，需要满足以下条件：</p><ul><li>每次从每一行取走一个元素，共 <span class="math inline">\(n\)</span> 个。经过 <span class="math inline">\(m\)</span> 次后取完矩阵内所有元素。</li><li>每次只能在一行的行首或行尾取数。</li><li>每行取数的得分 = 被取走的元素<span class="math inline">\(\times 2^i\)</span>，其中 <span class="math inline">\(i\)</span> 表示第 <span class="math inline">\(i\)</span> 次取数。最后的总得分为各行得分之和。</li></ul><p>求最大总得分。</p><p><span class="math inline">\(1\le n,m\le 80\)</span>，<span class="math inline">\(0\le a_{ij}\le1000\)</span>。</p>          </div><div class="note note-success">            <p>不妨先观察样例： <div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span></code></pre></div></p><div class="code-wrapper"><pre><code class="hljs">82</code></pre></div><p>其中 <span class="math inline">\(82=2^1\times(1+2)+2^2\times(2+3)+2^3\times(3+4)\)</span></p><p>即 <span class="math inline">\(82=(2^1\times1+2^2\times2+2^3\times3)+(2^1\times2+2^2\times3+2^3\times4)\)</span></p><p>发现每行之间取数都互不干扰，即可以一行一行dp，最后对每行答案求和。</p><p>容易想到令 <span class="math inline">\(f[i][j]\)</span> 为左边取 <span class="math inline">\(i\)</span> 个数，右边取 <span class="math inline">\(j\)</span> 个数的最大得分。</p><p>故 <span class="math inline">\(f[i][j]=\max(f[i-1][j]+2^{i+j}\times a[i],f[i][j-1]+2^{i+j}\times a[m-j+1])\)</span>。</p><p>答案为 <span class="math inline">\(\max(f[i][m-i]),i\in[1,m]\)</span>。</p>          </div><div class="note note-warning">            <p>爆 <code>long long</code> ，记得用 <code>__int128</code> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int __int128</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);<span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k)<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)s*=k;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<span class="hljs-type">int</span> n,m,a[N][N],f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> q[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>*q[<span class="hljs-number">1</span>],f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>*q[m];<span class="hljs-comment">//第一次取数 </span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;i+j&lt;=m;++j) &#123;        f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j]+<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,i+j)*q[i],f[i][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,i+j)*q[m-j+<span class="hljs-number">1</span>]);        &#125;    &#125;<span class="hljs-type">int</span> maxf=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;    maxf=<span class="hljs-built_in">max</span>(maxf,f[i][m-i]);    &#125;<span class="hljs-keyword">return</span> maxf;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;    a[i][j]=<span class="hljs-built_in">read</span>();        &#125;    &#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        ans+=<span class="hljs-built_in">dp</span>(a[i]);    &#125;<span class="hljs-built_in">write</span>(ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-树网的核">D. 树网的核</h2><p><a href="https://www.luogu.com.cn/problem/P1099">Problem</a></p><div class="note note-info">            <p>题意：给出一颗 <span class="math inline">\(n\)</span> 个节点的无根树，有如下定义。</p><p><strong>偏心距(ECC)</strong>：路径 <span class="math inline">\(F\)</span> 的 ECC 指树网中距路径 <span class="math inline">\(F\)</span> 最远的点到路径 <span class="math inline">\(F\)</span> 的距离。</p><p><strong>树网的核</strong>：在直径上找一段路径 <span class="math inline">\(F\)</span> 使长度不超过 <span class="math inline">\(s\)</span> 且 ECC 最小，必要时可以为一个节点。</p><p>求满足上述条件的最小 ECC 。</p><p><span class="math inline">\(2\le n \le 300\)</span>，<span class="math inline">\(0\le s \le 10^3\)</span>，<span class="math inline">\(1\le u,v\le n\)</span>，<span class="math inline">\(0\le w \le 10^3\)</span>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7luiueve.png" /></p><p>图中直径为：<span class="math inline">\(A\sim B,A\sim C\)</span>。</p><p>若 <span class="math inline">\(s=11\)</span>，树网的核为 <span class="math inline">\(DEFG\)</span>，偏心距为 <span class="math inline">\(8\)</span> 。</p><p>若 <span class="math inline">\(s=0~2\)</span>，树网的核为 <span class="math inline">\(F\)</span>，偏心距为 <span class="math inline">\(12\)</span> 。</p>          </div><div class="note note-success">            <p>首先，可以看到 <span class="math inline">\(n\)</span> 究极小，所以考虑暴力：</p><p>考虑找到树的直径，记录两个端点，枚举每一段长度不超过<span class="math inline">\(s\)</span>的路径，逐一比较<span class="math inline">\(ECC\)</span>。</p><p>那么如何求一段路径的偏心距？</p><p>我们以图中 <span class="math inline">\(s=11\)</span> 时的情况为例，树网的核为 <span class="math inline">\(DEFG\)</span>，偏心距为路径 <span class="math inline">\(BF(4+2+2=8)\)</span>。</p><p>看图容易推出 $dis(B,F)=( dis(B,D)+dis(G,B)-dis(D,G) ) $。</p><p>于是我们得到：<span class="math inline">\(ECC(i,j)=( dis(i,k)+dis(j,k)-dis(i,j))\div2\)</span>。</p><p>其中 <span class="math inline">\(k\in[1,n]\)</span>，可以用一层循环枚举 <span class="math inline">\(k\)</span>，求出最小 <span class="math inline">\(ECC\)</span>。</p><p>至于 <span class="math inline">\(dis(i,k)\)</span>，<span class="math inline">\(dis(j,k)\)</span>，<span class="math inline">\(dis(i,j)\)</span>，我们只需跑 <span class="math inline">\(floyd\)</span> 即可。</p><p>但由于 <span class="math inline">\(floyd\)</span> 用邻接矩阵，所以我们只能 <span class="math inline">\(O(n^2)\)</span> 求直径，整个算法复杂度为 <span class="math inline">\(O(n^3)\)</span>。</p>          </div><div class="note note-warning">            <p>细节：容易得到一个点 <span class="math inline">\(k\)</span> 在直径 <span class="math inline">\(i\)</span>~<span class="math inline">\(j\)</span> 上，那么 <span class="math inline">\(dis[i][k]+dis[k][j]=dis[i][j]\)</span>，否则 continue。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125; <span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">300</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">0x7fffffff</span>;<span class="hljs-type">int</span> n,s,dis[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)    <span class="hljs-keyword">if</span>(i!=j) dis[i][j]=inf;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)     <span class="hljs-keyword">if</span>(dis[i][j]&gt;dis[i][k]+dis[k][j])        dis[i][j]=dis[i][k]+dis[k][j];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;n=<span class="hljs-built_in">read</span>(),s=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> u=<span class="hljs-built_in">read</span>(),v=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();dis[u][v]=dis[v][u]=w;&#125;<span class="hljs-built_in">floyd</span>();<span class="hljs-type">int</span> pl,pr,len=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;      <span class="hljs-keyword">if</span>(dis[i][j]&gt;=inf || dis[i][j]&lt;=len) &#123;                <span class="hljs-keyword">continue</span>;            &#125;      len=dis[i][j],pl=i,pr=j;<span class="hljs-comment">//求树的直径，记录两个端点 </span>    &#125;&#125;  <span class="hljs-type">int</span> ecc,ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(dis[pl][i]+dis[i][pr]!=len) &#123;            <span class="hljs-keyword">continue</span>;        &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(dis[pl][j]+dis[j][pr]!=len) &#123;                <span class="hljs-keyword">continue</span>;            &#125;<span class="hljs-keyword">if</span>(dis[i][j]&gt;s) &#123;                <span class="hljs-keyword">continue</span>;            &#125;ecc=-inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) &#123;ecc=<span class="hljs-built_in">max</span>(ecc,(dis[i][k]+dis[j][k]-dis[i][j])/<span class="hljs-number">2</span>);&#125;ans=<span class="hljs-built_in">min</span>(ans,ecc);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
