<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【题解】2025 赛季 XCPC 金牌题鉴赏</title>
      <link href="/posts/1fbf08d.html"/>
      <url>/posts/1fbf08d.html</url>
      
        <content type="html"><![CDATA[<p>这赛季又摄金失败了，写点题解来麻痹一下自己。</p><p>我自身还是比较迷茫的，不知道明年是否还需投入今年以来这么多精力。</p><p>很对不起队友，这赛季我没能有很亮眼的发挥。</p><p>原本这里应该有很多内容，但被我鉴定为批话就删掉了。</p><p>作为选手参与了 IC 西安，IC 武汉，CC哈尔滨三个赛站，就线下体验来说哈尔滨 &gt; 武汉 &gt; 西安。</p><p>武汉的主要问题是食堂离赛场太远，校内没有任何供校外人员使用的交通工具，去一趟就走近半小时。西安的主要问题是学校周围都是荒地，酒店还没抢到校内，走路去赛场单程50min，不幸中的万幸是外卖还能送到酒店门口。哈尔滨体验十分好，如果不是去年nefu 闹的大瓜外加天寒地冻，应该会有很多强队来旅游罢。</p><p>下面大部分是金牌题，也混有少部分在我看来较为困难的银牌题。如果屏幕前的你对其中某一题有更为深刻的想法，欢迎QQ 与我交流，我将不胜感激。</p><h2 id="icpc-西安"><a href="https://qoj.ac/contest/2562">ICPC西安</a></h2><h3 id="m.-mystique-as-iris"><ahref="https://qoj.ac/contest/2562/problem/14693">M. Mystique asIris</a></h3><p><a href="https://qoj.ac/submission/1767293">Code</a></p><p>结论题。若 <span class="math inline">\(\{a\}\)</span> 中存在值在<span class="math inline">\([2,n-1]\)</span> 中的元素，<spanclass="math inline">\(\{a\}\)</span> 必然是神秘的。</p><p>证明使用归纳法，若存在 <span class="math inline">\(a_i\ge3\)</span>，则可以将 <span class="math inline">\(a_i\)</span>减一，序列长度减一。故只用证 <span class="math inline">\(n\ge 3\)</span>且序列中存在 <span class="math inline">\(a_i=2\)</span> 的情况。若 <spanclass="math inline">\(n=3\)</span>，显然是神秘的。对于 <spanclass="math inline">\(n&gt;3\)</span>，可以狗咬狗转化为 <spanclass="math inline">\(n=3\)</span> 或 <spanclass="math inline">\(n=4\)</span>（注意序列中始终保留一个 <spanclass="math inline">\(2\)</span>）。<spanclass="math inline">\(n=4\)</span>手玩一下发现也是必定神秘，就得证了。</p><p>将 <span class="math inline">\(\ge n\)</span> 的元素看作 <spanclass="math inline">\(\infty\)</span>，现在只剩 “序列由 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(\infty\)</span> 构成” 的情况。首先若 <spanclass="math inline">\(a_1=1\)</span> 或 <spanclass="math inline">\(a_n=1\)</span>，<spanclass="math inline">\(\{a\}\)</span>也必定神秘，因为可以另一侧狗咬狗只剩 <spanclass="math inline">\(\{1,x\}\)</span>。一种特殊情况是序列全为 <spanclass="math inline">\(1\)</span>，且 <spanclass="math inline">\(n\)</span> 为奇数，要特判掉。</p><p>接着，如果序列中有连续两个 <spanclass="math inline">\(1\)</span>，可以在这两个 <spanclass="math inline">\(1\)</span>中间划一刀分成两个序列，两个序列要么头有 <spanclass="math inline">\(1\)</span> 要么尾有 <spanclass="math inline">\(1\)</span>，规约到上一段的情况，是神秘的。</p><p>容斥，对不神秘的序列计数，问题转化为：对每个 <spanclass="math inline">\(-1\)</span>，填 <spanclass="math inline">\(1\)</span> 有一种情况，填 <spanclass="math inline">\(\infty\)</span> 有 <spanclass="math inline">\(\max(m-n+1,0)\)</span>种情况，问有多少个序列头尾为 <span class="math inline">\(\infty\)</span>且没有两个相邻的 <span class="math inline">\(1\)</span>。</p><p>令 <span class="math inline">\(dp[i][0/1]\)</span> 表示填完前 <spanclass="math inline">\(i\)</span> 个数，最后一个数为 <spanclass="math inline">\(1/\infty\)</span> 的方案数，容易转移。时间复杂度<span class="math inline">\(O(n)\)</span>。</p><h3 id="c.-catch-the-monster"><ahref="https://qoj.ac/contest/2562/problem/14683">C. Catch theMonster</a></h3><p><a href="https://qoj.ac/submission/1769665">Code</a></p><p>手玩一下发现，怪物能逃脱当且仅当出现一个 “一个点挂三条长为 <spanclass="math inline">\(2\)</span> 的链”的结构，并且这个结构是极小的。而不含该结构的图一定是毛毛虫（存在一条链，图上的点到链的距离都<span class="math inline">\(\le 1\)</span>）。</p><p>令 <span class="math inline">\(f[x]=\sum\limits_{x\toy}[\text{deg}(y)\ge 2]\)</span>，一张图是毛毛虫的充要条件是 <spanclass="math inline">\(\forall x\)</span>，<spanclass="math inline">\(f[x]&lt; 3\)</span>。</p><p>同时，对于固定的 <spanclass="math inline">\(r\)</span>，一定存在一个分界点 <spanclass="math inline">\(\text{mnL}[r]\)</span>，满足当 <spanclass="math inline">\(l\ge \text{mnL}[r]\)</span> 时，<spanclass="math inline">\([l, r]\)</span>的导出子图是毛毛虫；否则不是。于是，只用对每个 <spanclass="math inline">\(r\)</span> 求出 <spanclass="math inline">\(\text{mnL}[r]\)</span>，就能 <spanclass="math inline">\(O(1)\)</span> 回答询问。因为 <spanclass="math inline">\(\text{mnL}[i]\)</span> 单调增，尝试双指针。</p><p>考虑朴素的插入/删除一个点的过程，以插入点 <spanclass="math inline">\(x\)</span> 为例。设当前双指针为 <spanclass="math inline">\(L,R\)</span>，遍历 <spanclass="math inline">\(x\)</span> 的每一个在 <spanclass="math inline">\([L,R]\)</span> 里的邻居 <spanclass="math inline">\(y\)</span>，将 <spanclass="math inline">\(\text{deg}(x)\)</span> 和 <spanclass="math inline">\(\text{deg}(y)\)</span> 自增，若 <spanclass="math inline">\(\text{deg}(x)/\text{deg}(y)\)</span> 自增后为<span class="math inline">\(2\)</span>，则将 <spanclass="math inline">\(x/y\)</span> 所有 <spanclass="math inline">\([L,R]\)</span> 内的邻居 <spanclass="math inline">\(z\)</span> 的 <spanclass="math inline">\(f[z]\)</span> 自增。容易遗漏的是：若 <spanclass="math inline">\(\text{deg}(y)\)</span> 自增后 <spanclass="math inline">\(&gt;2\)</span>，<spanclass="math inline">\(f[x]\)</span> 也要自增。</p><p>由于每个点只会插入一次、删除一次，遍历 <spanclass="math inline">\(y\)</span> 的过程为均摊线性。整个双指针过程，每个<span class="math inline">\(x\)</span> 的 <spanclass="math inline">\(\text{deg}(x)\)</span> 先增后减最多两次会恰好<span class="math inline">\(\text{deg}(x)=2\)</span>，故遍历 <spanclass="math inline">\(z\)</span> 的过程也均摊线性。总时间复杂度 <spanclass="math inline">\(O(n+q)\)</span>。</p><h3 id="k.-killing-bits"><ahref="https://qoj.ac/contest/2562/problem/14691">K. KillingBits</a></h3><p><a href="https://qoj.ac/submission/1770302">Code</a></p><p>必要条件是 <span class="math inline">\(\forall i\)</span>，<spanclass="math inline">\(a_i\)</span> 是 <spanclass="math inline">\(b_i\)</span> 的超集，且存在一个 <spanclass="math inline">\(0\sim n-1\)</span> 的排列 <spanclass="math inline">\(p\)</span> 使得 <spanclass="math inline">\(\forall i\)</span>，<spanclass="math inline">\(p_i\)</span> 是 <spanclass="math inline">\(b_i\)</span> 的超集。</p><p>并且这个条件是充分的，感性上可以通过一些交换论证来证明。其中第一个条件可以直接判断，至于第二个条件，一个naive 的想法是网络流，如果 <span class="math inline">\(x\)</span> 是<span class="math inline">\(y\)</span> 的超集，就连一条 <spanclass="math inline">\(x\to y\)</span>，容量为 <spanclass="math inline">\(1\)</span> 的边，最后看是否满流。</p><p>一个明显的优化是对每个 <spanclass="math inline">\(x\)</span>，只连一条 <spanclass="math inline">\(x\to x\text{\\}\{2^i\}\)</span>，容量为 <spanclass="math inline">\(\infty\)</span> 的边。</p><p>这样就能过了，时间复杂度并不会分析。</p><h2 id="icpc-成都"><a href="https://qoj.ac/contest/2567">ICPC成都</a></h2><h3 id="m.-meeting-for-meals"><ahref="https://qoj.ac/contest/2567/problem/14718">M. Meeting forMeals</a></h3><p><a href="https://qoj.ac/submission/1772173">Code</a></p><p>先考虑在树上的情况，两个人分别在 <spanclass="math inline">\(i,j\)</span>，最大陪伴时间显然是 <spanclass="math inline">\(t_\text{meet}-\dfrac{\text{dis}(i,j)}{2}\)</span>，即在路径中点会合。放到图上也是类似的，我们从给定的<span class="math inline">\(k\)</span>个关键点出发跑多源最短路，并为每个点 <spanclass="math inline">\(i\)</span> 记录离它最近的关键点编号 <spanclass="math inline">\(c[i]\)</span>，这样对于一条边 <spanclass="math inline">\((u,v,w)\)</span>，如果 <spanclass="math inline">\(c[u]\neqc[v]\)</span>，那这条边上才有可能存在路径中点。</p><p>设多源最短路跑出来的距离是 <spanclass="math inline">\(d[i]\)</span>，枚举边 <spanclass="math inline">\((u,v,w)\)</span> 为路径中点，答案就是 <spanclass="math inline">\(t_\text{meet}-\dfrac{d[u]+d[v]+w}{2}\)</span>。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log m)\)</span>。</p><h3 id="i.-inside-triangle"><ahref="https://qoj.ac/contest/2567/problem/14714">I. InsideTriangle</a></h3><p><a href="https://qoj.ac/submission/1774603">Code</a></p><p>对大凸包上的每个点 <spanclass="math inline">\(i\)</span>，求出顺时针方向最远的点 <spanclass="math inline">\(p\)</span> 满足 <spanclass="math inline">\(\overrightarrow{ip}\)</span> 在小凸包左侧，设为<span class="math inline">\(l[i]\)</span>；以及逆时针方向最远的点 <spanclass="math inline">\(p\)</span> 满足 <spanclass="math inline">\(\overrightarrow{ip}\)</span> 在小凸包右侧，设为<spanclass="math inline">\(r[i]\)</span>。这一步可以用双指针线性求。</p><p>设三角形逆时针按顺序编号 <spanclass="math inline">\(i,j,k\)</span>，那么 <spanclass="math inline">\(j\in [i+1,r[i]]\)</span>，<spanclass="math inline">\(k\in [l[i],i-1]\)</span> 且 <spanclass="math inline">\(k\in [j+1,r[j]]\)</span>。也就是说 <spanclass="math display">\[\text{ans}=\frac{1}{3}\sum_{i=0}^{n-1}\sum_{j=i+1}^{r[i]}\{k\mid\max(l[i],j+1)\le k\le r[j]\}\]</span> 至于优化，只用考虑 <span class="math inline">\(i\toi+1\)</span> 的过程，算一下答案变化量。具体的，设当前 <spanclass="math inline">\(j\)</span> 可选集合为 <spanclass="math inline">\(B=[B_l,B_r]\)</span>，<spanclass="math inline">\(k\)</span> 可选集合为 <spanclass="math inline">\(A=[A_l,A_r]\)</span>。当 <spanclass="math inline">\(B_r\)</span> 向前走一步，变化量是 <spanclass="math inline">\([B_r+1,r[B_r]]\)</span> 与 <spanclass="math inline">\(A\)</span> 的交集；当 <spanclass="math inline">\(A_r\)</span> 向前走一步，变化量是 <spanclass="math inline">\([l[A_r], A_r-1]\)</span> 与 <spanclass="math inline">\(B\)</span> 的交集。<spanclass="math inline">\(B_l,A_l\)</span>向前走一步同理，只不过变化量是负的。</p><p>写代码的时候要十分小心。时间复杂度 <spanclass="math inline">\(O(n+m)\)</span>。</p><h2 id="icpc-武汉"><a href="https://qoj.ac/contest/2609">ICPC武汉</a></h2><h3 id="b.-77g-network"><ahref="https://qoj.ac/contest/2609/problem/14720">B. 77G Network</a></h3><p><a href="https://qoj.ac/submission/1778921">Code</a></p><p>很裸的题。“线段树优化建图 + 2SAT” 几乎被出烂了，不再赘述。</p><p>唯一的难点是，如何建线段树使得 “<spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(k\)</span> 级儿子” 是一段连续的区间？</p><p>bfs 序是很好的选择，那给定 <spanclass="math inline">\(x,k\)</span>，如何定位到对应的区间？记录同一深度下所有点的bfs 时间戳，那我们要找的就是深度 <spanclass="math inline">\(\text{dep}[x]+k\)</span> 下，dfs 序在 <spanclass="math inline">\([\text{dfn}[x],\text{dfn}[x]+\text{sz}[x]-1]\)</span>的点对应的区间，二分即可。</p><p>时间复杂度 <span class="math inline">\(O(n+m\log n)\)</span>。</p><h3 id="a.-planting-trees"><ahref="https://qoj.ac/contest/2609/problem/14719">A. PlantingTrees</a></h3><p><a href="https://qoj.ac/submission/1779064">Code</a></p><p>题目等价于求 <span class="math display">\[\sum_{i=0}^{n-1}[(f\cdot i+x)\bmod m&lt; (g\cdot i+y)\bmod m]\]</span> 然后题解就给出了一个神奇的公式（不清楚是否是 well-known 的trick） <span class="math display">\[[u &lt; v] = 1 + \left\lfloor \frac{v-u-1}{m} \right\rfloor\ \ (0\leu,v&lt;m)\]</span> 将该公式代入，用 <span class="math inline">\(x\bmod y=x-y\cdot\left\lfloor\dfrac{x}{y}\right\rfloor\)</span> 展开，得到 <spanclass="math display">\[\text{ans}=\sum_{i=0}^{n-1}1+\sum_{i=0}^{n-1}\left\lfloor\frac{(g-f)\cdoti+(y-x-1)}{m}\right\rfloor+\sum_{i=0}^{n-1}\left\lfloor\frac{f\cdoti+x}{m}\right\rfloor-\sum_{i=0}^{n-1}\left\lfloor\frac{g\cdoti+y}{m}\right\rfloor\]</span> 后三项为 floor_sum 结构，套个<ahref="https://github.com/KisuraOP/XCPC-Templates/blob/main/templates/数学/floor_sum.cpp">板子</a>就好。时间复杂度<span class="math inline">\(O(T\log m)\)</span>。</p><h2 id="icpc-南京"><a href="https://qoj.ac/contest/2581">ICPC南京</a></h2><h3 id="h.-pen-pineapple-apple-pen"><ahref="https://qoj.ac/contest/2581/problem/14808">H. Pen Pineapple ApplePen</a></h3><p><a href="https://qoj.ac/submission/1784325">Code</a></p><p>令 <span class="math inline">\(f[l][r]\)</span> 表示第一个子串以<span class="math inline">\(l\)</span> 结尾，第四个子串以 <spanclass="math inline">\(r\)</span> 开头的方案数，<spanclass="math inline">\(g[l][r]\)</span> 表示 <spanclass="math inline">\([l,r]\)</span>里存在第二个子串和第三个子串的方案数。 <span class="math display">\[\text{ans}=\sum_{i=1}^{n}\sum_{j=i+1}^{n}f[i-1][j+1]\cdot g[i][j]\]</span> 再令 <span class="math inline">\(h[l][r]\)</span>表示第三个子串以 <span class="math inline">\(r\)</span>结尾，且与第三个子串相同的第二个子串的后缀以 <spanclass="math inline">\(l\)</span> 开头的方案数。</p><p><span class="math display">\[g[l][r]=\sum_{i=l}^{r}\sum_{j=i+1}^{r}(i-l)\cdot h[i][j]\]</span> 这个式子可以用前缀和优化，现在的任务是求出 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(h\)</span>。</p><p>枚举 <span class="math inline">\(r\)</span>，对 <spanclass="math inline">\(S[r,n]\)</span> 用 KMP 求出 <spanclass="math inline">\(\text{nxt}\)</span> 数组，再对 <spanclass="math inline">\(S[1,r-1]\)</span> 进行匹配。匹配到 <spanclass="math inline">\(i\)</span> 时，指针 <spanclass="math inline">\(p\)</span> 表示当前以 <spanclass="math inline">\(i\)</span> 结尾的后缀完全匹配了 <spanclass="math inline">\(S[r,p]\)</span>。至此，<spanclass="math inline">\(S[r,p]\)</span> 的 border 个数即为 <spanclass="math inline">\(f[i][r]\)</span>。</p><p>至于 <span class="math inline">\(h[i][j]\)</span>，等价于 <spanclass="math inline">\([i,j]\)</span> 里长度不超过一半的 border个数。对于一个长为 <span class="math inline">\(L\)</span>的串来说，长度大于 <span class="math inline">\(\frac{L}{2}\)</span> 的border 呈等差数列，且公差为最小周期 <spanclass="math inline">\(L-\text{nxt}[L]\)</span>。由此我们枚举 <spanclass="math inline">\(l\)</span>，对 <spanclass="math inline">\(S[l,n]\)</span> 求出 <spanclass="math inline">\(\text{nxt}\)</span> 数组。再枚举 <spanclass="math inline">\(r\)</span>，利用等差数列的性质可以一步跳到 border小于长度一半的位置，也就求出了 <spanclass="math inline">\(h\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h3 id="e.-cyan-white-tree"><ahref="https://qoj.ac/contest/2581/problem/14805">E. Cyan WhiteTree</a></h3><p><a href="https://qoj.ac/submission/1799822">Code</a></p><p>先处理 <span class="math inline">\(c\ge w\)</span> 的情况，<spanclass="math inline">\(c\le w\)</span>只用把每个点颜色取反再跑一遍就行。</p><p>当 <span class="math inline">\(c\ge w\)</span> 时，路径价值是 <spanclass="math inline">\(3w-c\)</span>。令 <spanclass="math inline">\(a[x]\)</span> 表示路径 <spanclass="math inline">\(1\sim x\)</span> 的 <spanclass="math inline">\(c-w\)</span>，<spanclass="math inline">\(b[x]\)</span> 表示路径 <spanclass="math inline">\(1\sim x\)</span> 的 <spanclass="math inline">\(3w-c\)</span>。对每个点 <spanclass="math inline">\(x\)</span>，维护一个<code>set&lt;array&lt;int, 2&gt;&gt;</code>，里面每一个元素 <spanclass="math inline">\((a[u],b[u])\)</span> 表示当前从 <spanclass="math inline">\(x\)</span> 向下位于另一头的最优路径端点 <spanclass="math inline">\(u\)</span> 的集合。</p><p>考虑自底向上 small-to-large 的过程。现在有两条链，<spanclass="math inline">\(x\leftrightarrow u\)</span> 和 <spanclass="math inline">\(x\leftrightarrowv\)</span>，合并为一条路径后价值为 <spanclass="math inline">\((b[u]-b[x])+(b[v]-b[x])+(b[x]-b[fa])=b[u]+b[v]-b[x]-b[fa]\quad(*)\)</span>。当然前提是合并后的路径满足<span class="math inline">\(c - w\ge 0\)</span>，也就是 <spanclass="math inline">\(a[u]+a[v]-a[x]-a[fa]\ge 0\quad(**)\)</span>。</p><p>如果我们将这个 <code>set</code>维护成第一维递增，第二维递减（像单调栈一样），那么对于当前 large 集合<span class="math inline">\(A\)</span> 和 small 集合 <spanclass="math inline">\(B\)</span>，遍历 <spanclass="math inline">\(B\)</span> 中每一个元素 <spanclass="math inline">\((a[v],b[v])\)</span>，我们就能再 <spanclass="math inline">\(A\)</span> 中 lower_bound 第一个大于等于 <spanclass="math inline">\((a[x]+a[fa]-a[v],-\infty)\)</span> 的元素 <spanclass="math inline">\((a[u],b[u])\)</span>，此时在满足 <spanclass="math inline">\((*)\)</span> 的情况下做到了让 <spanclass="math inline">\(b[u]\)</span> 最大，也就是 <spanclass="math inline">\((**)\)</span> 最大。</p><p>时间复杂度 <spanclass="math inline">\(O(n\log^2n)\)</span>，实际跑得飞快。</p><h3 id="j.-trajan-algorithm"><ahref="https://qoj.ac/contest/2581/problem/14810">J. TrajanAlgorithm</a></h3><p><a href="https://qoj.ac/submission/1785811">Code</a></p><p>小清新图论题。首先对于一个点 <spanclass="math inline">\(x\)</span>，一定有 <spanclass="math inline">\(\text{low}[x]\le\text{dfn}[x]\)</span>。所以假算法只会把 <spanclass="math inline">\(\text{low}[x]\)</span> 变小。</p><p>接着对于一个点 <span class="math inline">\(x\)</span>，是割点当且仅当<span class="math inline">\(\text{low}[y]\ge\text{dfn}[x]\)</span>，假算法更难满足，所以割点只会被判漏。被判漏说明<spanclass="math inline">\(\text{low}[y]&lt;\text{dfn}[x]\)</span>，而错误的<span class="math inline">\(\text{low}[y]\)</span> 是从 <spanclass="math inline">\(\text{low}[x]\)</span> 传递过来的。说明满足条件的<span class="math inline">\(x\)</span> 满足 <spanclass="math inline">\(\text{low}[x]&lt;\text{dfn}[x]\)</span>，这说明<span class="math inline">\(x\)</span> 存在返祖边。</p><p>于是，<span class="math inline">\(x\)</span>被判漏当且仅当有返祖边指向 <spanclass="math inline">\(x\)</span>，且也有从 <spanclass="math inline">\(x\)</span> 离开的返祖边。换句话说如果 <spanclass="math inline">\(x\)</span>至少在两个点双中，且这两个点双各有至少两条边连向 <spanclass="math inline">\(x\)</span>，且不存在 <spanclass="math inline">\(x\)</span> 属于一个点双 <spanclass="math inline">\(v\)</span> 但 <spanclass="math inline">\(v\)</span> 只有一条边连向 <spanclass="math inline">\(x\)</span>，那么 <spanclass="math inline">\(x\)</span> 就是一个答案。</p><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>。</p><h2 id="ccpc-哈尔滨"><a href="https://qoj.ac/contest/2575">CCPC哈尔滨</a></h2><h3 id="m.-连通的正三角形"><ahref="https://qoj.ac/contest/2575/problem/14826">M.连通的正三角形</a></h3><p><a href="https://qoj.ac/submission/1798877">Code</a></p><p>条件刻画题。不难发现题目等价于计数同时满足如下条件的三元组 <spanclass="math inline">\((i,j,k)\)</span> 的数量。</p><ul><li><span class="math inline">\(a_i=b_j=c_k\)</span></li><li><span class="math inline">\(i+j\ge n,\ j+k\ge n,\ i+k\gen\)</span></li><li><span class="math inline">\(i+j+k\neq 2n\)</span></li></ul><p>记这三个条件分别为 <spanclass="math inline">\(A,B,C\)</span>。对于条件 <spanclass="math inline">\(A\)</span>，可以分为 <spanclass="math inline">\(a_i=b_j=c_k=0\)</span> 和 <spanclass="math inline">\(a_i=b_j=c_k=1\)</span>，两种情况互斥，答案可以相加。以下将<span class="math inline">\(A\)</span> 改写成 <spanclass="math inline">\(a_i=b_j=c_k=0\)</span> 为例。</p><p>经过观察，满足 <span class="math inline">\(\lnot C\)</span>的三元组一定满足 <spanclass="math inline">\(B\)</span>。于是答案可以表示为 <spanclass="math inline">\(\text{cnt}(A\cap B)-\text{cnt}(A\cap \lnotC)\)</span>。对于 <span class="math inline">\(\text{cnt}(A\cap \lnotC)\)</span>，是一个经典的 ntt 问题，记数组 <spanclass="math inline">\(d_i=[b_i=0]\)</span>，<spanclass="math inline">\(e_i=[c_i=0]\)</span>，答案就是 <spanclass="math inline">\(\sum\limits_{a_i=0}\sum\limits_{j+k=2n-i}d_j\cdote_k\)</span>。</p><p>对于 <span class="math inline">\(\text{cnt}(A\capB)\)</span>，可以使用后缀和线性算。枚举 <spanclass="math inline">\(i\)</span>，当 <span class="math inline">\(n-i\lej\le i\)</span> 时，<spanclass="math inline">\(\max(n-i,n-j)=n-j\)</span>，贡献是 <spanclass="math inline">\(c_{\ge n-j}\)</span>；当 <spanclass="math inline">\(j&gt;i\)</span> 时，<spanclass="math inline">\(\max(n-i,n-j)=n-i\)</span>，贡献是 <spanclass="math inline">\(c_{\ge n-i}\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h3 id="h.-匹配"><a href="https://qoj.ac/contest/2575/problem/14821">H.匹配</a></h3><p><a href="https://qoj.ac/submission/1797167">Code</a></p><p>坏消息，题解完全不说人话。好消息，似乎是一道命题作文。</p><p>前置：<a href="https://www.luogu.com.cn/article/l3dfir8x">IntoTheDusk- 鞅的停时定理 - 洛谷专栏</a>，<ahref="https://zhuanlan.zhihu.com/p/721900819">GhostLX - 鞅与停时定理 -知乎</a>。</p><p>以下表述可能有不妥之处。</p><p>设当前局面为 <spanclass="math inline">\(S=\{a_1,a_2,\ldots,a_n\}\)</span>，我们希望定义一个<span class="math inline">\(f(x)\)</span>，使得系统总势能 <spanclass="math inline">\(\Phi(S)=\sum\limits_{i=1}^{n}f(a_i)\)</span>满足：在每一步操作中，总势能期望减少 <spanclass="math inline">\(1\)</span>。也就是 <span class="math display">\[E[\Phi(S_{t+1})-\Phi(S_t) | S_t]=-1\]</span> 我们希望 <span class="math inline">\(n\)</span>个集合平均分配势能下降的任务，于是 <span class="math display">\[E[f(i&#39;)]-f(i)=-\frac{i}{2m}\]</span> 其中 <span class="math inline">\(E[f(i&#39;)]\)</span>是下一时刻势能的加权平均，即 <span class="math display">\[\left(\sum_{i&#39;}P(i\to i&#39;)f(i&#39;)\right)-f(i)=-\frac{i}{2m}\]</span> 已经明显看出高斯消元的形式了，现在的任务只剩下求 <spanclass="math inline">\(P(i\to i&#39;)\)</span>。</p><p>每一轮操作，等价于：选定 <span class="math inline">\(2m\)</span>个元素中的 <span class="math inline">\(m\)</span> 个，删去没选中的 <spanclass="math inline">\(m\)</span> 个，再将选中的 <spanclass="math inline">\(m\)</span> 个原地复制一份。对于大小为 <spanclass="math inline">\(i\)</span> 的集合，假设有 <spanclass="math inline">\(j\)</span> 个元素被选中，那操作后集合大小变为<span class="math inline">\(2j\)</span>，因此 <spanclass="math display">\[P(i\to 2j)=\frac{\dbinom{i}{j}\dbinom{2m-i}{m-j}}{\dbinom{2m}{m}}\]</span> 高斯消元对 <spanclass="math inline">\(i=1,2,\ldots,2m-1\)</span> 求出 <spanclass="math inline">\(f(i)\)</span>，根据停时定理 <spanclass="math display">\[\text{ans}=E(t)=E(\Phi(S_0))-\Phi(S_t)=\sum_{i=1}^{n}f(a_i)-0\]</span> 需要注意 <spanclass="math inline">\(f(0)=f(2m)=0\)</span>。时间复杂度 <spanclass="math inline">\(O(m^3)\)</span>。</p><h2 id="icpc-沈阳"><a href="https://qoj.ac/contest/2641">ICPC沈阳</a></h2><h3 id="f.-the-bond-beyond-time"><ahref="https://qoj.ac/contest/2641/problem/14945">F. The Bond BeyondTime</a></h3><p><a href="https://qoj.ac/submission/1766636">Code</a></p><p>若 <span class="math inline">\(x, y\)</span> 不是邻居，可以直接将与<span class="math inline">\(x\)</span> 相邻的边都指向 <spanclass="math inline">\(x\)</span>，与 <spanclass="math inline">\(y\)</span> 相邻的边都指向 <spanclass="math inline">\(y\)</span>。</p><p>若 <span class="math inline">\(x,y\)</span> 是邻居，分两种情况：</p><ul><li><span class="math inline">\(x,y\)</span> 同处一个环中，此时 bfs找一个包含 <span class="math inline">\(x,y\)</span>的最小环，将所有非环点指向环，这样 <spanclass="math inline">\(x,y\)</span>只能一直绕圈圈。而不与环接触的边可以任意定向。</li><li>否则，若图中有环，我们也可以找一个离 <spanclass="math inline">\(x,y\)</span>最近的环。先将环上的点标记，再从环出发多源 bfs，标记环到 <spanclass="math inline">\(x,y\)</span>最短路径上的点。此时将所有非标记点指向标记点，<spanclass="math inline">\(x,y\)</span> 沿着预定路径追逐到我们找的环中，亦是Yes。</li></ul><p>最后只剩下图中无环的情况，显然是 No。</p><p>如何找离 <span class="math inline">\(x,y\)</span> 最近的环？从 <spanclass="math inline">\(x,y\)</span> 出发 bfs，设走到的第一条非割边是<span class="math inline">\((u, v)\)</span>，再次 bfs 找包含 <spanclass="math inline">\(u,v\)</span> 的最小环就行。时间复杂度依实现方式<span class="math inline">\(O(n^2)/O(n)\)</span>，码量略大。</p><h3 id="d.-led-display-renovation"><ahref="https://qoj.ac/contest/2641/problem/14943">D. LED DisplayRenovation</a></h3><p><a href="https://qoj.ac/submission/1777085">Code</a></p><p>令 <span class="math inline">\(f[i][j][l=0/1]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个位置，翻新了 <spanclass="math inline">\(j\)</span> 个段，最多能表示的数字数量。其中 <spanclass="math inline">\(l=1\)</span> 代表允许前 <spanclass="math inline">\(i\)</span> 个位置全是空，<spanclass="math inline">\(l=0\)</span> 则是不允许。</p><p>转移的时候 <span class="math inline">\(2^7\)</span> 枚举当前位置的<span class="math inline">\(7\)</span> 个段是否翻新。对于每个状态 <spanclass="math inline">\(t\)</span>，算出当前状态下（即对应翻新后）能展示的数字个数<spanclass="math inline">\(\text{cnt}\)</span>，以及能作为最高位展示的数字个数<span class="math inline">\(\text{high}\)</span>。转移就是 <spanclass="math display">\[f[i+1][j+\text{popc}(t)][nl]\ \longleftarrow \ f[i][j][l]\cdot\text{cnt}+(l&gt;0)\cdot \text{high}\]</span> 其中 <span class="math inline">\(nl=1\)</span> 当且仅当 <spanclass="math inline">\(l=1\)</span> 且当前位置的所有常亮段均被翻新。</p><p>同样定义 <span class="math inline">\(g[i][j][l]\)</span> 用于 <spanclass="math inline">\(f\)</span>取到最大值时的方案数。要注意对于当前位置一个数字都显示不了，但能显示空的情况，新的<span class="math inline">\(g\)</span> 值应该为 “前 <spanclass="math inline">\(i\)</span> 个位置，翻新了 <spanclass="math inline">\(j\)</span> 个段且前 <spanclass="math inline">\(i\)</span> 个位置均为空” 的方案数。我们将其记作<spanclass="math inline">\(h[i][j][l]\)</span>，这样又能愉快的转移了！</p><p>时间复杂度 <span class="math inline">\(O(nk\cdot 2^7\cdot10)\)</span>。</p><h2 id="ccpc-济南"><a href="https://qoj.ac/contest/2693?v=1">CCPC济南</a></h2><p>真的好难，兄弟。真的好难…</p><h3 id="a.-cipher"><ahref="https://qoj.ac/contest/2693/problem/15032?v=1">A. Cipher</a></h3><p><a href="https://qoj.ac/submission/1902158">Code</a></p><p>以下做法来自伟大的 lyc。</p><p>当 <span class="math inline">\(a\)</span> 为偶数时，令 <spanclass="math inline">\(a=2\cdot c\)</span>，则 <spanclass="math inline">\(2^x\cdot c^x\equiv b\pmod{2^{64}}\)</span>，当<span class="math inline">\(x\ge 64\)</span> 时左侧模 <spanclass="math inline">\(2^{64}\)</span> 恒等为 <spanclass="math inline">\(0\)</span>，于是只用依次尝试 <spanclass="math inline">\(x\in [0,64)\)</span>。而当 <spanclass="math inline">\(a\)</span> 为奇数时，<spanclass="math inline">\(a\)</span> 的幂也一定是奇数，接下来我们只用讨论<span class="math inline">\(a,b\)</span> 均为奇数的情况。</p><p><em>Conclution.</em> 在模 <span class="math inline">\(2^k\)</span>乘法群中，任何元素的阶都是 <span class="math inline">\(2\)</span>的幂。</p><p><em>Prove.</em> 由群论中拉格朗日定理的推论，有限群 <spanclass="math inline">\(G\)</span> 中每个元素的阶都整除群 <spanclass="math inline">\(G\)</span> 的阶。因此对于任意 <spanclass="math inline">\(a\in (\mathbb{Z}/2^k)\)</span>，其阶 <spanclass="math inline">\(d\)</span> 一定有 <spanclass="math inline">\(d\mid \varphi(2^k)\)</span>，也就是 <spanclass="math inline">\(d\mid 2^{k-1}\)</span>。此时 <spanclass="math inline">\(d\)</span> 一定是 <spanclass="math inline">\(2\)</span> 的幂。</p><p><em>Conclution.</em> 令 <span class="math inline">\(x\)</span> 为模<span class="math inline">\(2^k\)</span> 下 <spanclass="math inline">\(a\)</span> 的阶，<spanclass="math inline">\(y\)</span> 为模 <spanclass="math inline">\(2^{k+1}\)</span> 下 <spanclass="math inline">\(a\)</span> 的阶，那么 <spanclass="math inline">\(y\)</span> 只可能是 <spanclass="math inline">\(x\)</span> 或 <spanclass="math inline">\(2x\)</span>。</p><p><em>Prove.</em> 由 <span class="math inline">\(a^y\equiv1\pmod{2^{k+1}}\)</span>，则一定有 <span class="math inline">\(a^y\equiv1\pmod {2^k}\)</span>，又 <span class="math inline">\(x\)</span>是最小的满足 <span class="math inline">\(a^x\equiv 1\pmod{2^k}\)</span>的正整数，于是 <span class="math inline">\(x\mid y\)</span>。令 <spanclass="math inline">\(a^x=1+2^kt\)</span>，那么 <spanclass="math display">\[a^{2x}=(1+2^kt)^2=1+2^{k+1}t+2^{2k}t^2\]</span> 当 <span class="math inline">\(k\ge 1\)</span> 时，<spanclass="math inline">\(2k\ge k+1\)</span>，因此 <spanclass="math inline">\(2^{2k}t^2\)</span> 能被 <spanclass="math inline">\(2^{k+1}\)</span> 整除，故 <spanclass="math inline">\(a^{2x}\equiv 1\pmod{2^{k+1}}\)</span>。</p><p>因此 <span class="math inline">\(y\mid 2x\)</span>，结合 <spanclass="math inline">\(x\mid y\)</span>，可得 <spanclass="math inline">\(y=x\)</span> 或 <spanclass="math inline">\(y=2x\)</span>。</p><p>考虑 <span class="math inline">\(a^{x_k}\equiv b\pmod{2^k}\)</span>，其中 <span class="math inline">\(k=1,2,3,\ldots\)</span>一直递增到 <span class="math inline">\(64\)</span>，该过程中 <spanclass="math inline">\(x_k\)</span> 一定是 <spanclass="math inline">\(x_{k-1}\)</span> 或 <spanclass="math inline">\(2\cdot x_{k-1}\)</span>，分别尝试即可。若到某个<span class="math inline">\(k\)</span>时两种情况都不能满足，那对于更大的 <spanclass="math inline">\(k\)</span> 也必然不能满足，直接无解。时间复杂度<span class="math inline">\(O(T\cdot 64)\)</span>。</p><h3 id="e.-tree-and-subgraph-problem"><ahref="https://qoj.ac/contest/2693/problem/15036">E. Tree and SubgraphProblem</a></h3><p><a href="https://qoj.ac/submission/1908163">Code</a></p><p><span class="math inline">\(\text{sub}(S)\)</span> 和 <spanclass="math inline">\(\text{sub}(T)\)</span> 不交，等价于存在一条连接<span class="math inline">\(\text{sub}(S)\)</span> 和 <spanclass="math inline">\(\text{sub}(T)\)</span>的最短路径，该路径上的内部点（不包括端点）和边均不属于二者。把贡献摊到点和边上，由该路径上“边数 = 点数 + 1” 的巧妙性质，答案可以写成 <span class="math display">\[\text{ans} = \sum_{e\in E}g_e-\sum_{v\in V} f_v\]</span> 其中 <span class="math inline">\(g_e\)</span> 表示删除边 <spanclass="math inline">\(e\)</span> 后，两个连通块中分别选 <spanclass="math inline">\(S,T\)</span> 的方案数；<spanclass="math inline">\(f_v\)</span> 表示删除点 <spanclass="math inline">\(v\)</span> 后，在不同连通块中分别选 <spanclass="math inline">\(S,T\)</span> 的方案数。</p><p>令 <span class="math inline">\(\text{in}_{x}\)</span> 和 <spanclass="math inline">\(\text{out}_{x}\)</span> 分别表示以 <spanclass="math inline">\(x\)</span>为根的子树内/子树外，选一个颜色相同的非空点集的方案数之和。于是 <spanclass="math inline">\(g_{(x, y)} = 2\cdot \text{in}_{y} \cdot\text{out}_{y}\)</span>，乘 <span class="math inline">\(2\)</span>是因为计有序对。至于 <span class="math inline">\(f_v\)</span>，设删去<span class="math inline">\(v\)</span> 后分成的若干连通块的 <spanclass="math inline">\(\text{in}\)</span> 值分别为 <spanclass="math inline">\(p_1,p_2,\ldots,p_m\)</span>，那么 <spanclass="math display">\[f_v=\sum_{i\neq j}p_ip_j=\left(\sum_{i}p_i\right)^2-\sum_{i}p_i^2\]</span> 问题转化为了对每个 <span class="math inline">\(x\)</span> 求出<span class="math inline">\(\text{in}_x\)</span> 和 <spanclass="math inline">\(\text{out}_x\)</span>。利用 dsu_on_tree维护当前子树内各颜色 <span class="math inline">\(c\)</span> 出现的次数<span class="math inline">\(\text{cnt}_c\)</span>，于是 <spanclass="math display">\[\text{in}_x = \sum_{c}(2^{\text{cnt}_c}-1)\qquad\text{out}_x=\sum_{c}(2^{\text{all}_c-\text{cnt}_c}-1)\]</span> 其中 <span class="math inline">\(\text{all}_c\)</span> 为颜色<span class="math inline">\(c\)</span> 在整棵树中的出现次数。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="icpc-上海">ICPC 上海</h2><p>还没 VP。</p><h2 id="ccpc-郑州"><a href="https://qoj.ac/contest/2661">CCPC郑州</a></h2><h3 id="i.-dumb-problem-ii"><ahref="https://qoj.ac/contest/2661/problem/15309">I. Dumb ProblemII</a></h3><p><a href="https://qoj.ac/submission/1796740">Code</a></p><p>对于某个特定的前缀最大值集合 <spanclass="math inline">\(S=\{g(p)\}\)</span>，设它在一个排列中出现的概率是<span class="math inline">\(P(S)\)</span>。</p><p>在 <span class="math inline">\(k\)</span> 个随机排列中，<spanclass="math inline">\(P(S \textbf{ 至少出现一次})=1-P(S \textbf{从未出现})=1-(1-P(S))^k\)</span>。</p><p>列出答案式子，用二项式定理展开 <span class="math display">\[\begin{align}\text{ans}&amp;=\sum_S\left[1-(1-P(S))^k\right]\\&amp;=\sum_S\left[1-\sum_{j=0}^{k}\binom{k}{j}(-1)^jP(S)^j\right]\\&amp;=\sum_{j=1}^{k}\binom{k}{j}(-1)^{j-1}\sum_{S}P(S)^j\end{align}\]</span> 我们的任务是对所有 <span class="math inline">\(1\le i\lek\)</span> 求出 <spanclass="math inline">\(g_i=\sum\limits_SP(S)^i\)</span>。从式子来看，<spanclass="math inline">\(g_i\)</span> 就是这 <spanclass="math inline">\(i\)</span> 个排列前缀最大值集合都相同的概率。</p><p>不同数字是否成为前缀最大值，是完全独立的事件。考虑从大到小依次插入<span class="math inline">\(n,n-1,\ldots,1\)</span>构成排列的过程，一个数字 <span class="math inline">\(x\)</span> 有 <spanclass="math inline">\(1\)</span>种方案成为前缀最大值（插到最前面），以及 <spanclass="math inline">\(n-x\)</span>种方案不成为。根据乘法分配律，所有可能的集合 <spanclass="math inline">\(S\)</span> 的方案数之和，等于每个数字 <spanclass="math inline">\(x\)</span> 所有可能贡献之和的乘积。 <spanclass="math display">\[g_i=\frac{\prod\limits_{x=1}^{n}(1^i+(n-x)^i)}{(n!)^i}=\frac{\prod\limits_{j=0}^{n-1}(1+j^i)}{(n!)^i}\]</span> 时间复杂度 <span class="math inline">\(O(nk)\)</span>。</p><h3 id="d.-diameter-of-a-tree"><ahref="https://qoj.ac/contest/2661/problem/15304">D. Diameter of aTree</a></h3><p><a href="https://qoj.ac/submission/1795646">Code</a></p><p>先任意找一条直径，端点设为 <spanclass="math inline">\(L,R\)</span>。对于一个点 <spanclass="math inline">\(i\)</span>，若 <spanclass="math inline">\(\max(\text{dis}(i,L),\text{dis}(i,R))=\text{dis}(L,R)\)</span>，那么<span class="math inline">\(i\)</span>就是某一条直径的端点，这样的点我们称为关键点。</p><p>设共有 <span class="math inline">\(t\)</span> 个关键点，显然标号<span class="math inline">\(1\sim t\)</span>，并考虑从标号为 <spanclass="math inline">\(t\)</span> 的关键点开始向直径中点标号 <spanclass="math inline">\(t+1,t+2,\ldots\)</span>。因为所有直径的中点（或者说中边，如果直径长度为奇数）都是相同的，所以我们没必要真的一路标过来。也就是说，如果直径长度为<span class="math inline">\(L\)</span>，答案的前缀一定是 <spanclass="math inline">\(t,t+1,t+1,\ldots,t+\lceil\frac{L}{2}\rceil\)</span>。</p><p>设直径中点为 <spanclass="math inline">\(x_0\)</span>（若两个中点，推荐在两个中点之间建一个虚点作为中点），中点的标号为<span class="math inline">\(t_x\)</span>，后半段直径为 <spanclass="math inline">\(x_0\to x_1\to x_2\to \ldots\)</span>，那么 <spanclass="math inline">\(x_i\ (i\ge 1)\)</span> 的标号应该是 <spanclass="math inline">\(t_x+\text{deg}(x_0)+\text{deg}(x_1)+\ldots+\text{deg}(x_{i-1})\)</span>。其中<span class="math inline">\(\text{deg}(x)\)</span> 表示在以 <spanclass="math inline">\(x_0\)</span> 为根的情况下，满足 <spanclass="math inline">\(x\to y\)</span> 且 <spanclass="math inline">\(y\)</span>子树中存在关键点的出边数量。由此可见选择一个 <spanclass="math inline">\(\{\text{deg}(x_1),\text{deg}(x_2),\ldots\}\)</span>字典序最小的 <span class="math inline">\(\{x_i\}\)</span>链是最优的。方法是从 <span class="math inline">\(x_0\)</span> 开始逐层bfs。</p><p>注意直径末尾（也就是答案最后一项）需要特殊判。当只有一个中点时 <spanclass="math inline">\(\text{deg}(x_0)\)</span>也要排除来时的出边。时间复杂度 <span class="math inline">\(O(n\logn)\)</span>，细节略多。</p><h3 id="k.-parentheses-and-swapping"><ahref="https://qoj.ac/contest/2661/problem/15311">K. Parentheses andSwapping</a></h3><p><a href="https://qoj.ac/submission/1907296">Code</a></p><p>题面很绕，等价于对 <span class="math inline">\(\{b\}\)</span>中每一对匹配的 <span class="math inline">\((i,j)\)</span>，交换 <spanclass="math inline">\(a[i]\)</span> 和 <spanclass="math inline">\(a[j]\)</span>，要让 <spanclass="math inline">\(\{a\}\)</span> 字典序最小。</p><p>在合法括号序列中，匹配的两个位置 <spanclass="math inline">\((i,j)\)</span> 间的元素数量必须是偶数，因此 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 的奇偶性必然不同。</p><p>从左往右考虑每个位置 <span class="math inline">\(i\)</span>，逐个判断<span class="math inline">\(b[i]\)</span> 填 <code>(</code> 还是<code>)</code>。我们用一个栈维护 <span class="math inline">\(i\)</span>之前已经确定的 <code>(</code>，设当前栈顶为 <spanclass="math inline">\(u\)</span>，接着断言 <spanclass="math inline">\(b[i]\)</span> 填 <code>)</code>，也就是和 <spanclass="math inline">\(b[u]\)</span> 匹配，当且仅当：</p><ul><li><span class="math inline">\(a[i]\)</span> 是到 <spanclass="math inline">\(u\)</span> 时 <spanclass="math inline">\(a[u+1\sim n]\)</span> 中未被匹配的最小值。要不然选<span class="math inline">\(i\)</span> 后面更小的交换到 <spanclass="math inline">\(u\)</span> 肯定更优。</li><li>在此基础上，若存在 <span class="math inline">\(j&gt;i\)</span> 满足<span class="math inline">\(a[j]=a[i]\)</span>，则需满足 <spanclass="math inline">\(a[u]\le t\)</span>，其中 <spanclass="math inline">\(t\)</span> 是 <spanclass="math inline">\(i\)</span> 未来能匹配上的最优值。若不满足，说明<span class="math inline">\(a[u]\)</span> 较大，交换到 <spanclass="math inline">\(i\)</span> 的位置肯定更劣。</li></ul><p>用两个 ST 表分别维护奇数下标和偶数下标的 “元素+下标” 二元组。对于每个<span class="math inline">\(i\)</span>，我们先找到它未来能匹配到最优<span class="math inline">\(j\)</span>的二元组，这样上面两个条件都是好判断的。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="icpc-香港">ICPC 香港</h2><p>Wait for ucup end.</p><h2 id="ccpc-重庆">CCPC 重庆</h2><p>Wait for ucup end.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> XCPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】龟速更新的加训日记</title>
      <link href="/posts/2fc406e4.html"/>
      <url>/posts/2fc406e4.html</url>
      
        <content type="html"><![CDATA[<p>vp 多一点还是有好处的。</p><p>计划将区域赛前的训练都写在这里。</p><p>与以往不同，这篇博客说是题解，实际上只会记录简要的解题思路，用于我日后进行回忆。</p><h2 id="nwerc-2023"><a href="https://qoj.ac/contest/1446">【8.21】NWERC2023</a></h2><h3 id="h.-higher-arithmetic">H. Higher Arithmetic</h3><div class="note note-primary">            <p>将一个数拆分成若干正整数，要使得乘积最大，应当先尽可能多地拆成 <spanclass="math inline">\(3\)</span>，再尽可能多地拆成 <spanclass="math inline">\(2\)</span>。如果最后剩下 <spanclass="math inline">\(1\)</span>，就把之前组合出的一个 <spanclass="math inline">\(3\)</span> 拆掉，拼成两个 <spanclass="math inline">\(2\)</span>。</p><p>注：实际上拆分成 <span class="math inline">\(e\)</span> 最好，只不过<span class="math inline">\(3\)</span> 是最接近 <spanclass="math inline">\(e\)</span> 的正整数，其次是 <spanclass="math inline">\(2\)</span>。</p>          </div><p>回到这道题，<span class="math inline">\(\ge 3\)</span>的肯定直接乘起来，否则想办法凑出多的 <spanclass="math inline">\(3\)</span>，其次凑出多的 <spanclass="math inline">\(2\)</span>。</p><h3 id="j.-jogging-tour">J. Jogging Tour</h3><p>枚举 <span class="math inline">\(n\)</span> 个点两两之间的 <spanclass="math inline">\(n^2\)</span>条边，最优策略中坐标轴肯定与其中一条边平行。</p><div class="note note-primary">            <p>坐标轴旋转公式（逆时针旋转 <spanclass="math inline">\(\theta\)</span>），原坐标 <spanclass="math inline">\((x,y)\)</span>，新坐标 <spanclass="math inline">\((x&#39;,y&#39;)\)</span>。 <spanclass="math display">\[\begin{align}\pmatrix{x&#39; \\ y&#39;}=\pmatrix{\cos\theta &amp;\sin\theta\\ -\sin\theta &amp; \cos \theta}\pmatrix{x\\ y}\end{align}\]</span></p>          </div><p>之后跑最短哈密顿路径即可。</p><h3 id="i.-isolated-island">I. Isolated Island</h3><p>比较蠢的方法是先建出平面图，再用最小左转法转成对偶图，再从无限面开始bfs。</p><p>这当然是能做的，<ahref="https://qoj.ac/submission/1251741">Link</a>，<spanclass="math inline">\(O(n^2\log n)\)</span>，缺点是一大坨。</p><p>注意到答案是 <span class="math inline">\(\texttt{No}\)</span>当且仅当对偶图是二分图（相邻点到海边的距离最多相差 <spanclass="math inline">\(1\)</span>，按到海边的距离的奇偶性建二分图，这个条件是充要的）。二分图意味着没有奇环，因为“奇 + 偶 =奇”，如果对偶图有奇环，那么一定存在一个极小的奇环，环内的点度数为奇数。</p><p>于是判断输入的 <span class="math inline">\(n\)</span>条线段是否有某一个端点只出现了奇数次即可。</p><h3 id="g.-galaxy-quest">G. Galaxy Quest</h3><p>设在第 <span class="math inline">\(i\)</span> 条边上我们用了 <spanclass="math inline">\(x_i\)</span>秒来加速。如果我们知道最终走了哪些边，就能转化为线性规划问题 <spanclass="math display">\[\begin{align}&amp;\min \ 2\sum x_i\\&amp;\sum x_i + \dfrac{d_i}{x_i}\le t\end{align}\]</span> 拉格朗日乘数法，最终得到 <span class="math display">\[2\sum x_i=t-\sqrt{t^2-4(\sum \sqrt{d_i})}\]</span> 所以答案越小等同于让 <span class="math inline">\(\sum\sqrt{d_i}\)</span> 越小。</p><p>给每条边赋权 <span class="math inline">\(\sqrt{d_i}\)</span> 跑dijkstra 即可，单次 <span class="math inline">\(O(1)\)</span>回答询问。</p><h2 id="icpc-jinan-regional"><ahref="https://qoj.ac/contest/1997">【8.25】2021 ICPC JinanRegional</a></h2><h3 id="c.-optimal-strategy">C. Optimal Strategy</h3><p>先考虑所有数出现次数只有偶数的情况，如果一个人拿了最大的，另一个人必须跟着拿，因此可以两两配对。</p><p>从小到大考虑每个数，如果新加进一个数 <spanclass="math inline">\(x\)</span>，导致 <spanclass="math inline">\(x\)</span> 的出现次数变成奇数，先手肯定将 <spanclass="math inline">\(x\)</span> 拿走一个，回到刚刚的情况。</p><p>对操作序列计数，设 <span class="math inline">\(f[i]\)</span>为当前最大的数为 <span class="math inline">\(i\)</span>的答案，用隔板法试图将 <span class="math inline">\(i\)</span> 插进序列<span class="math display">\[f[i]=f[i-1]\cdot \binom{cnt[i]/2+\sum_{j=1}^{i-1}cnt[j] }{cnt[i] /2}\cdot cnt[i]!\]</span> 最后乘阶乘表示分配这 <spanclass="math inline">\(cnt[i]\)</span> 个 <spanclass="math inline">\(i\)</span> 的次序。</p><h3 id="l.-strange-series">L. Strange Series</h3><p><span class="math display">\[\begin{align}p&amp;=\dfrac{S}{e}\\&amp;=\dfrac{1}{e}\sum_{m=0}^{\infty}\dfrac{\sum_{i=0}^{n}a_im^i}{m!}\\&amp;=\sum_{i=0}^{n}a_i\cdot\dfrac{1}{e}\sum_{m=0}^{\infty}\frac{m^i}{m!}\end{align}\]</span></p><p>令 <spanclass="math inline">\(T_i=\dfrac{1}{e}\sum\limits_{m=0}^{\infty}\dfrac{m^i}{m!}\)</span>，我们要对<span class="math inline">\(i\in [0,n]\)</span> 求出 <spanclass="math inline">\(T_i\)</span>。</p><p>对 <span class="math inline">\(T_i\)</span> 建立 EGF，设 <spanclass="math inline">\(F(x)=\sum\limits_{i=0}^{\infty}T_i\dfrac{x^i}{i!}\)</span>。那么<span class="math display">\[\begin{align}F(x)&amp;=\sum_{i=0}^{\infty}\left(\dfrac{1}{e}\sum_{m=0}^{\infty}\frac{m^i}{m!}\right)\dfrac{x^i}{i!}\\&amp;=\dfrac{1}{e}\sum_{m=0}^{\infty}\frac{1}{m!}\sum_{i=0}^{\infty}\dfrac{(mx)^i}{i!}\\&amp;=\dfrac{1}{e}\sum_{m=0}^{\infty}\dfrac{(e^x)^m}{m!}\\&amp;=e^{e^x-1}\end{align}\]</span> 令 <spanclass="math inline">\(G(x)=e^x-1=\sum\limits_{i=1}^{\infty}\dfrac{x^i}{i!}\)</span>。那么<span class="math inline">\(T_i=i!\cdot [x^i]e^{G(x)}\)</span>，多项式<span class="math inline">\(\text{exp}\)</span> 即可。</p><h3 id="b.-monitored-area">B. Monitored Area</h3><p>对于一个多边形内的监控 <spanclass="math inline">\(O\)</span>，以它为原点向多边形的每个顶点做射线，每条射线取极长的在多边形内的部分。极角序相邻的射线与多边形的一条边构成三角形，得到<span class="math inline">\(n\)</span>个三角形，每个监控都这么做，再把所有三角形求并就是答案。</p><p>难点是如何正确识别三角形的顶点。我们对每一组极角序相邻的射线考虑，枚举多边形的每条边，对于一条边，如果某一条射线和它没有交点，就排除，否则设交点坐标分别为<span class="math inline">\(A,B\)</span>，只用判断线段 <spanclass="math inline">\(OA\)</span> 和线段 <spanclass="math inline">\(OB\)</span> 是否完全在多边形内部就行。</p><p>时间复杂度 <span class="math inline">\(O(n^4)\)</span>。</p><h3 id="m.-coloring-rectangles">M. Coloring Rectangles</h3><p>每个矩形以其两条对角线为分隔，分出上下左右四个三角形。上和下恰好一个涂黑。左和有恰好一个涂黑，对应了题中的四种情况。用一个变量表示上黑还是下黑，另一个变量表示左黑还是右黑，一种染色情况就能用<span class="math inline">\(2n\)</span>个二元变量来描述。两个三角形如果严格相交，就表示二者不能同时涂黑，2-SAT即可。</p><p>因为要字典序最大，我们可以依次钦定每一个矩形是 <spanclass="math inline">\(3,2,1\)</span> 或 <spanclass="math inline">\(0\)</span>，最多跑 <spanclass="math inline">\(4n\)</span> 遍 2-SAT，最终 <spanclass="math inline">\(O(n^3)\)</span>。</p><div class="note note-primary">            <p>两个三角形 <span class="math inline">\(A,B\)</span>严格相交（公共面积 <spanclass="math inline">\(&gt;0\)</span>），等价于</p><ul><li><span class="math inline">\(A\)</span> 中一条边和 <spanclass="math inline">\(B\)</span> 中一条边在非三角形端点处规范相交。</li><li>或者，其中一个三角形的重心严格在另一个三角形内部。</li></ul>          </div><h3 id="ucup3-39.-tokyo"><ahref="https://qoj.ac/contest/2071">【8.28】Ucup3-39. Tokyo</a></h3><h3 id="k.-k-rep-array">K. K-rep Array</h3><p>数组可以是 <span class="math inline">\(K\)</span>-rep 当且仅当不存在<span class="math inline">\(i,j\)</span> 使得 <spanclass="math inline">\(a_i\neq -1, a_j\neq -1,a_i\neq a_j\)</span> 且<span class="math inline">\(|i-j|\bmod K=0\)</span>。</p><p>令 <spanclass="math inline">\(f_d=\sum\limits_{i-j=d}(a_i+1)(a_j+1)(a_i-a_j)^2\)</span>，那么<span class="math inline">\(K=i\)</span> 时答案为 <spanclass="math inline">\(1\)</span> 当且仅当 <spanclass="math inline">\(\forall j,\ i\mid j\)</span>，<spanclass="math inline">\(f_j=0\)</span>。</p><p>将 <span class="math inline">\(f_d\)</span> 拆开 <spanclass="math display">\[\begin{align}f_d&amp;=\sum_{i-j=d}a_i(a_i+1)\cdot(a_j+1)\\&amp;-2\sum_{i-j=d}a_i(a_i+1)\cdota_j(a_j+1)\\&amp;+\sum_{i-j=d}(a_i+1)\cdot a_j(a_j+1)\end{align}\]</span> 每一项分别计算，差卷积化为和卷积后，用 NTT 求解。</p><div class="note note-primary">            <p>差卷积化和卷积（0-index）： <span class="math display">\[\sum_{i-j=d}f(i)g(j)=\sum_{i+(n-j-1)=d+n-1}f(i)g(j)\]</span> 令 <spanclass="math inline">\(g_{\text{rev}}(i)=g(n-i-1)\)</span>，化为 <spanclass="math inline">\(\sum\limits_{i+j=d+n-1}f(i)g_{\text{rev}}(j)\)</span>。</p>          </div><h3 id="n.-nice-bouquets">N. Nice Bouquets</h3><p>转化题意：找到最小的 <span class="math inline">\(c\)</span>，通过对树<span class="math inline">\(1\sim c\)</span> 操作，使得在所有 <spanclass="math inline">\(k\)</span> 天里，每一天三种颜色的花的数量（<spanclass="math inline">\(n_R,n_G,n_B\)</span>）都满足 <spanclass="math inline">\(n_R\equiv n_G\equiv n_B\pmod {3}\)</span>。</p><p>一棵树用长为 <span class="math inline">\(2k\)</span> 的向量描述：第<span class="math inline">\(2i\)</span> 个值表示第 <spanclass="math inline">\(i\)</span> 天这棵树对 <spanclass="math inline">\(n_R-n_G\pmod {3}\)</span> 的贡献，第 <spanclass="math inline">\(2i+1\)</span> 个值表示第 <spanclass="math inline">\(i\)</span> 天这棵树对 <spanclass="math inline">\(n_G-n_B\pmod {3}\)</span> 的贡献。如此得到 <spanclass="math inline">\(n\)</span> 个长为 <spanclass="math inline">\(2k\)</span> 的向量构成的向量组 <spanclass="math inline">\(\{v_i\}\)</span>。</p><p>对第 <span class="math inline">\(i\)</span> 棵树操作，默认状态 <spanclass="math inline">\(1\cdot v_i\)</span>，砍掉即 <spanclass="math inline">\(0\cdot v_i\)</span>，加速即 <spanclass="math inline">\(2\cdot v_i\)</span>。令 <spanclass="math inline">\(V_{\text{init}}=\sum_{i=1}^{n}v_i\pmod{3}\)</span>，目标是选取一组<span class="math inline">\(\{a_i\}\)</span> 使得 <spanclass="math display">\[V_{\text{init}}+\sum_{i=1}^{c} a_iv_i \equiv 0 \pmod{3} \ \ (a_i\in\{0,1,2\})\]</span> 即向量 <span class="math inline">\(-V_{\text{init}}\)</span>是否能被向量组 <spanclass="math inline">\(\{v_1,v_2,\ldots,v_c\}\)</span>线性表出，用线性基求解。</p><div class="note note-primary">            <p><span class="math inline">\(GF(3)\)</span>下的线性基：核心仍然是高斯消元。</p><p>基的每一维都是一个向量（当然也可以是三进制数）</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        GF(3) basis    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Basis</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; p;<span class="hljs-built_in">Basis</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">p</span>(n) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; v)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (v[i] == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (p[i].<span class="hljs-built_in">empty</span>()) &#123;p[i] = v;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> fac = v[i] * p[i][i] % <span class="hljs-number">3</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;v[j] = (v[j] - fac * p[i][j] % <span class="hljs-number">3</span> + <span class="hljs-number">3</span>) % <span class="hljs-number">3</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; v)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (v[i] == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (p[i].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-type">int</span> fac = v[i] * p[i][i] % <span class="hljs-number">3</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;v[j] = (v[j] - fac * p[i][j] % <span class="hljs-number">3</span> + <span class="hljs-number">3</span>) % <span class="hljs-number">3</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;;</code></pre></div>    </div></div><h3 id="g.-guarding-plan">G. Guarding Plan</h3><p>如果一个哨位已被监视，就可以删去。没被删的哨位构成一条随着 <spanclass="math inline">\(x\)</span> 递增，<spanclass="math inline">\(y\)</span>递减的折线（红线），单调栈求出。我们再作出这些哨位的上凸壳（绿线），凸壳内的任意一点均能搞出一个哨位。</p><p><img src="/image/academic/10976.png" /></p><p>现在，你可以选择在绿线上新建若干点，覆盖掉红线上的一些点，让总点数变少。每段绿线分别考虑，<spanclass="math inline">\(dp(i)=(a,b)\)</span>表示这段绿线对应的红色折线上的前 <span class="math inline">\(i\)</span>个点至少能分成 <span class="math inline">\(a\)</span> 段，且分成 <spanclass="math inline">\(a\)</span> 段的前提下至少添加 <spanclass="math inline">\(b\)</span> 个新点。</p><ul><li>当前点选择保留：<span class="math inline">\(dp(i)=(a,b)\todp(i+1)=(a+1,b)\)</span>。</li><li>当前点选择被一个新点覆盖：<spanclass="math inline">\(dp(l-1)=(a,b)\todp(r)=(a+1,b+1)\)</span>。这需要凸包上的一个点完全覆盖 <spanclass="math inline">\([l,r]\)</span> 这一段，也就是 <spanclass="math inline">\((x_r,y_l)\)</span> 在凸包内。</li></ul><p>dp 值是单调的，相同的 <span class="math inline">\(r\)</span> 转移小的<span class="math inline">\(l\)</span> 更优，因此可以单调队列优化。</p><h2 id="ccpc-2023-harbin"><ahref="https://qoj.ac/contest/1412">【8.30】CCPC 2023 Harbin</a></h2><h3 id="e.-revenge-on-my-boss">E. Revenge on My Boss</h3><p>二分答案，设为 <span class="math inline">\(T\)</span>。<spanclass="math inline">\(T\)</span> 可行 <spanclass="math inline">\(\Leftrightarrow\)</span> 重排三元组 <spanclass="math inline">\(\{a_i,b_i,c_i\}\)</span> 使得 <spanclass="math inline">\(\forall m\in [1,n]\)</span>，<spanclass="math inline">\((\sum\limits_{i=1}^{m}a_i+\sum\limits_{i=m}^{n}b_i)\cdot c_m \le T\)</span>。</p><p>令 <span class="math inline">\(d_i=a_i-b_i\)</span>，<spanclass="math inline">\(B=\sum\limits_{i=1}^{n}b_i\)</span>，推一下式子，等价的条件是<span class="math display">\[\sum\limits_{i=1}^{m-1} d_i\le T / c_m-B-a_m\]</span> 不等号右侧均和放置顺序无关，记为 <spanclass="math inline">\(e_m\)</span>。现在要重排 <spanclass="math inline">\(\{d_i,e_i\}\)</span> 使得 <spanclass="math inline">\(\forall m\in [1,n]\)</span>，<spanclass="math inline">\(\sum\limits_{i=1}^{m-1}d_i \le e_i\)</span>。</p><p>最优策略下，显然先放置 <span class="math inline">\(d_i\le 0\)</span>的项，再放置 <span class="math inline">\(d_i&gt;0\)</span>的项（其实并不显然，但可以感性理解？）。对于 <spanclass="math inline">\(d_i\le 0\)</span> 的项，应当先放 <spanclass="math inline">\(e_i\)</span>较大的，让不等号右侧尽快增大，条件会更宽松；对于 <spanclass="math inline">\(d_i&gt;0\)</span> 的项，引入 <spanclass="math inline">\(D_i\)</span> 表示 <spanclass="math inline">\(d_i\)</span> 的前缀和，条件变成 <spanclass="math inline">\(D_i\le d_i+e_i\)</span>，其中 <spanclass="math inline">\(d_i+e_i\)</span>可以看成天花板，我们要想不顶过天花板，策略应当是先放 <spanclass="math inline">\(d_i+e_i\)</span> 较小的。</p><h3 id="h.-energy-distribution">H. Energy Distribution</h3><p>先忽略 <span class="math inline">\(e_i\ge 0\)</span>的条件，拉格朗日乘数法，<span class="math inline">\(\dfrac{\partialL}{\partial e_k}=0\Longrightarrow \sum\limits_{i\neq k}w_{ik}e_i=\lambda\)</span>，是定值。</p><p>枚举子集 <span class="math inline">\(S\)</span>，钦定子集内的 <spanclass="math inline">\(i\)</span> 都满足 <spanclass="math inline">\(e_i&gt;0\)</span>，能列出 <spanclass="math inline">\(|S|-1\)</span> 个方程，再加上 <spanclass="math inline">\(\sum e_i=1\)</span>，就是 <spanclass="math inline">\(|S|\)</span> 个，未知数也是 <spanclass="math inline">\(|S|\)</span>个，高斯消元，如果有负数解就舍去。答案对所有子集取 <spanclass="math inline">\(\max\)</span>。时间复杂度 <spanclass="math inline">\(O(2^nn^3)\)</span>。</p><h3 id="c.-karshilovs-matching-problem-ii">C. Karshilov’s MatchingProblem II</h3><p>拆贡献，式子可以写成 <spanclass="math inline">\(\sum\limits_{i=l}^{r}Sw[\min(r-i+1,z[i])]\)</span>，其中<span class="math inline">\(Sw\)</span> 是 <spanclass="math inline">\(w\)</span> 的前缀和，<spanclass="math inline">\(z[i]\)</span> 是 <spanclass="math inline">\(\text{LCP}(T[i,n],S[1,n])\)</span>，可以通过把<span class="math inline">\(S\)</span> 和 <spanclass="math inline">\(T\)</span> 拼起来跑 Z 函数求得。</p><p>找到 <span class="math inline">\([l,r]\)</span> 里最小的 <spanclass="math inline">\(mid\)</span> 满足 <spanclass="math inline">\(T[mid,r]\)</span> 是 <spanclass="math inline">\(S\)</span> 的一个前缀。<spanclass="math inline">\(i&lt;mid\)</span> 的部分 <spanclass="math inline">\(\min\)</span> 那项一定取到 <spanclass="math inline">\(z[i]\)</span>，因此只用预处理 <spanclass="math inline">\(Sw[z[i]]\)</span> 的前缀和；比较困难的是 <spanclass="math inline">\(i\ge mid\)</span> 的部分，<spanclass="math inline">\(\min\)</span>那项仍旧有两个可能取值。换一个视角，我们可以对 <spanclass="math inline">\(S\)</span> 的每个前缀 <spanclass="math inline">\(1\sim k\)</span> 都预处理出 <spanclass="math inline">\(f(S[1,k])\)</span>，这样两部分都能 <spanclass="math inline">\(O(1)\)</span> 回答。具体的 <spanclass="math display">\[\begin{align}f(S[1,k])&amp;=\sum_{i=1}^{k}\left(\sum_{S[i-j+1,i] \textbf{是 } S\textbf{ 的一个前缀}} w_j\right)\\&amp;=\sum_{i=1}^{k}\left(\sum_{j \textbf{ 在 fail 树上是 } i \textbf{的祖先} } w_j\right)\\\end{align}\]</span> 令 <span class="math inline">\(h[i]=\left(\sum_{j \textbf{ 在fail 树上是 } i \textbf{ 的祖先} } w_j\right)\)</span>，因为 <spanclass="math inline">\(i\)</span> 的祖先集合 <spanclass="math inline">\(=\{i\}\cup \text{link}[i]\)</span>的祖先集合，所以 <span class="math display">\[h[i]=w_i+h[\text{link}[i]]\]</span> 至于求 <spanclass="math inline">\(mid\)</span>，可以在线段树上二分，找 <spanclass="math inline">\([l, r]\)</span> 里第一个 <spanclass="math inline">\(i+z[i]&gt;r\)</span> 的位置。</p><h2 id="ccpc-final-2020"><ahref="https://qoj.ac/contest/845">【8.31】CCPC Final 2020</a></h2><h3 id="e.-game-theory">E. Game Theory</h3><p>打表，令 <span class="math inline">\(k\)</span> 表示 <spanclass="math inline">\(1\)</span> 的个数，答案是 <spanclass="math display">\[\left(\sum_{s_i=1}2i-1\right)-k(k-1)\]</span> 两部分都可以用线段树维护。</p><h3 id="j.-permutation-pattern">J. Permutation Pattern</h3><p>区间 dp，令 <span class="math inline">\(f[l][r][i][j]\)</span>表示只考虑区间 <span class="math inline">\([l,r]\)</span>，选出的子序列最小值为 <spanclass="math inline">\(i\)</span>，最大值为 <spanclass="math inline">\(j\)</span>的答案。对于一个区间，枚举最大值出现的位置 <spanclass="math inline">\(m\in [l,r]\)</span>，设 <spanclass="math inline">\(\{L\},\{R\}\)</span> 分别表示 <spanclass="math inline">\([l,m-1]\)</span> 和 <spanclass="math inline">\([m+1,r]\)</span>选出的符合条件的子序列，那么子序列 <spanclass="math inline">\([\{L\},m,\{R\}]\)</span> 满足条件等价于 <spanclass="math inline">\(\max\limits_{x\in \{L\}} x&lt;\min\limits_{y\in\{R\}} y\)</span>。</p><p>分 <code>() m ..</code>，<code>.. m ()</code> 和 <code>.. m ..</code>转移，前两种表示最大值位于区间端点，第三种可以后缀和加速，总时间复杂度<span class="math inline">\(O(n^4)\)</span>。</p><h3 id="k.-stringology">K. Stringology</h3><p>如下图。</p><p><img src="/image/academic/28371.png" /></p><h3 id="m.-3d-geometry">M. 3D Geometry</h3><p>将四面体的直角顶点平移到原点，三个维度进行缩放，变成标准四面体（<spanclass="math inline">\(x,y,z\ge 0,\ x+y+z\le1\)</span>），变换后的立方体只保留第一卦限的部分，最后计算出的体积交乘一个缩放系数就是答案。</p><p>设 <span class="math inline">\(V(x,y,z)\)</span> 表示区域 <spanclass="math inline">\(\{(x&#39;,y&#39;,z&#39;)\mid x&#39;\ge x,\y&#39;\ge y,\ z&#39;\ge z\}\)</span>与四面体的体积交，那么总体积交可以拆分成 <span class="math display">\[\begin{align}&amp;+V(x_a,y_a,z_a)\\&amp;-(V(x_b,y_a,z_a)+V(x_a,y_b,z_a)+V(x_a,y_a,z_b))\\&amp;+(V(x_b,y_b,z_a)+V(x_b,y_a,z_b)+V(x_a,y_b,z_b))\\&amp;-V(x_b,y_b,z_b)\end{align}\]</span> 其中 <span class="math inline">\((x_a,y_a,z_a)\)</span> 和<span class="math inline">\((x_b,y_b,z_b)\)</span>为立方体的对角顶点，<spanclass="math inline">\(x/y/z_a&lt;x/y/z_b\)</span>。</p><h2 id="zjcpc-2025"><a href="https://qoj.ac/contest/2021">【9.2】ZJCPC2025</a></h2><h3 id="c.-rddccd">C. RDDCCD</h3><p>任取 <span class="math inline">\(x=a_{1,1}\)</span>，答案一定是 <spanclass="math inline">\(x\)</span> 或 <spanclass="math inline">\(\text{rev}(x)\)</span> 的质因数幂的组合。考虑怎么check 某一个质因数幂 <span class="math inline">\(p\)</span>。</p><p>对每一个矩阵中的 <span class="math inline">\(y\)</span>，如果 <spanclass="math inline">\(y\)</span> 和 <spanclass="math inline">\(\text{rev}(y)\)</span> 都不是 <spanclass="math inline">\(p\)</span> 的倍数，那 <spanclass="math inline">\(p\)</span>肯定不合法；如果都是，翻不翻无所谓；如果恰有一个是，我们就给这个位置随机赋一个<span class="math inline">\(v\)</span>，接着将 <spanclass="math inline">\(y\)</span> 所处的两条对角线异或上 <spanclass="math inline">\(v\)</span>。如此，每次更改一条对角线，我们就能快速计算当前相比初始状态被翻的格子对应<span class="math inline">\(v\)</span> 的异或和 <spanclass="math inline">\(\text{cur}\)</span>。再令 <spanclass="math inline">\(\text{need}\)</span> 表示使 <spanclass="math inline">\(p\)</span> 合法应该翻的格子对应的 <spanclass="math inline">\(v\)</span> 的异或和，比较 <spanclass="math inline">\(\text{need}\)</span> 是否等于 <spanclass="math inline">\(\text{cur}\)</span> 即可。单次 check <spanclass="math inline">\(O(n^2+q)\)</span>。</p><h3 id="m.-master-of-both-vii">M. Master of Both VII</h3><p>问所有 <span class="math inline">\(i\in [3,m-1]\)</span> 的 <spanclass="math inline">\((1,i)\)</span>，记为 <spanclass="math inline">\(d_i\)</span>。如果 <spanclass="math inline">\(d_i=0\)</span>，直接计入答案。</p><p>一条边 <span class="math inline">\((x,y)\)</span> 与 <spanclass="math inline">\((1,i)\)</span> 在非端点处相交的充要条件是 <spanclass="math inline">\(1&lt;x&lt;i&lt;y\le n\)</span>。考虑 <spanclass="math inline">\(d_i-d_{i-1}\)</span> 的意义，是 “以 <spanclass="math inline">\(i-1\)</span> 为起点的边数 <spanclass="math inline">\(-\)</span> 以 <spanclass="math inline">\(i\)</span>为终点的边数”。又因为任何一个三角剖分中形如 <spanclass="math inline">\((i-1,y),y&gt;i\)</span> 的边和形如 <spanclass="math inline">\((x,i),x&lt;i-1\)</span>的边不可能同时存在，所以上述差值中的两项必有一个为 <spanclass="math inline">\(0\)</span>。</p><ul><li>若 <span class="math inline">\(d_i-d_{i-1}&gt;0\)</span>，说明有<span class="math inline">\(d_i-d_{i-1}\)</span> 条边以 <spanclass="math inline">\(i - 1\)</span> 为起点。</li><li>若 <span class="math inline">\(d_{i}-d_{i-1}&lt;0\)</span>，说明有<span class="math inline">\(d_{i-1}-d_i\)</span> 条边以 <spanclass="math inline">\(i\)</span> 为终点。</li></ul><p>用一个栈存储还没配对的边的起点，遇到一个终点时就弹栈配对。</p><h2 id="ucup3-24.-poland"><ahref="https://qoj.ac/contest/1890">【9.4】Ucup3-24. Poland</a></h2><h3 id="l.-looping-rps">L. Looping RPS</h3><p>将 <span class="math inline">\(s_i^{\infty}\)</span> 插入trie，三个人有贡献当且仅当它们在同一个点的三个不同子树内。考虑枚举每个点作为LCA 计算贡献，当然我们不用真的建出 trie，只用从根开始dfs，维护当前路径是多少个不同串的前缀。</p><p>实践证明，只要将所有 <span class="math inline">\(s_i\)</span>保留最小整周期并去重，就能跑得很快，复杂度我也不会证。</p><h3 id="d.-diminishing-fractions">D. Diminishing Fractions</h3><p>分母不超过 <spanclass="math inline">\(M=\text{lcm}\{1,2,\ldots,n\}\)</span>，答案下界是<span class="math inline">\(\dfrac{1}{M}\)</span>，尝试构造。因为 <spanclass="math inline">\(M=\prod p^{k_p}\)</span>，其中 <spanclass="math inline">\(k_p\)</span> 是最大的满足 <spanclass="math inline">\(p^{k_p}\le n\)</span>的幂次，我们可以直接选择这些不超过 <spanclass="math inline">\(n\)</span> 的最高质数次幂作为分母，记为 <spanclass="math inline">\(\{d_1,d_2,\ldots,d_m\}\)</span>。现在需要寻找对应的分子<span class="math inline">\(\{a_1,a_2,\ldots,a_m\}\)</span>，使得：<span class="math display">\[\sum_{i=1}^{m}\dfrac{a_i}{d_i}=\dfrac{1}{M}\]</span> 这个不好构造，但题目允许我们最后减去一个形如 <spanclass="math inline">\(K/1\)</span> 的整数 <spanclass="math inline">\(K\)</span>，所以可以写成 <spanclass="math display">\[\sum_{i=1}^{m}\dfrac{a_i}{d_i}=K+\dfrac{1}{M}\ \longrightarrow\\sum_{i=1}^{m}a_i\cdot \dfrac{M}{d_i}\equiv 1\pmod{M}\]</span> 这个式子可以拆成 <span class="math inline">\(m\)</span> 个<span class="math inline">\(\bmod d_i\)</span> 的同余式，且 <spanclass="math inline">\(\gcd(M/d_i,d_i)=1\)</span>，存在逆元，因此直接能exgcd 求出 <span class="math inline">\(a_i\)</span>。那么 <spanclass="math inline">\(K\)</span> 是多少？直接 double加起来取整数部分。</p><p>对于多组数据，离线，按 <span class="math inline">\(n\)</span>从小到大回答询问，想办法更新贡献就行，有点复杂但总能改出来。时间复杂度<span class="math inline">\(O(n\pi (n)+\pi(n)\log n)\)</span>。</p><h2 id="ec-final-2024"><a href="https://qoj.ac/contest/1894">【9.5】ECFinal 2024</a></h2><h3 id="k.-exploration-boundary">K. Exploration Boundary</h3><p>一个点集成为边界时，整张图被划分成三个部分，因为 Dijkstra按最短路递增的顺序访问，边界上和边界外点的距离必然不小于和边界内点的距离。因此将边界看成一堵墙，从起点bfs，若某个时刻没有点可遍历，且已遍历的点包含了一个题目给出的边界，这个边界就是合法的。</p><p>现在题目给出多个边界，这些边界包含的内部的点必然是包含关系，访问顺序唯一。我们可以初始把所有边界都看成墙，每遍历完一个边界，就将这个边界拆掉并加进队列继续bfs，以此类推（匹配边界可以直接<code>std::set</code>）。注意一个点可能是多个边界的一部分，所以要按拓扑排序减入度的方法处理。考虑赋边权，设<span class="math inline">\(x\)</span> 在我们得到的拓扑序中排第 <spanclass="math inline">\(h_x\)</span> 个，那么一条边赋 <spanclass="math inline">\(|h_x-h_y|\)</span>是理想的，既能保证出队顺序，也能满足从起点出发最短路互不相同的限制。</p><h3 id="l.-shiori">L. Shiori</h3><p>操作一和三都是线段树标准操作。操作二分两步：先找到mex，再区间加。我们主要看怎么找 mex。线段树维护区间最小值 <spanclass="math inline">\(mn\)</span>，对于一次询问，只有完全被 <spanclass="math inline">\([l,r]\)</span> 包含的区间的 <spanclass="math inline">\(mn\)</span> 有用。我们先找到一个极小的不交区间集合<span class="math inline">\(\{S\}\)</span>，区间并恰好是 <spanclass="math inline">\([l,r]\)</span>，事实上这就是线段树查询时访问的区间，递归一遍即可找出。接着将<span class="math inline">\(\{S\}\)</span> 塞进优先队列，规则是 <spanclass="math inline">\(mn\)</span> 小的靠前。现在，我们尝试逐步找到 <spanclass="math inline">\(x=0,1,2,\ldots\)</span>，第一个找不到的就是mex。</p><p>首先，取出优先队列顶的 <spanclass="math inline">\([u,v]\)</span>，如果对应的 <spanclass="math inline">\(mn&gt;x\)</span>，就找到了；否则 <spanclass="math inline">\(x\leftarrow x+1\)</span>，并递归遍历 <spanclass="math inline">\([u,v]\)</span> 的子树，将 <spanclass="math inline">\(mn&gt;x\)</span>的次一级子区间塞进优先队列。单次操作，这样的子区间有 <spanclass="math inline">\(\log\)</span> 个，时间复杂度均摊 <spanclass="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="ucup3-40.-potyczki"><ahref="https://qoj.ac/contest/2135">【9.6】Ucup3-40. Potyczki</a></h2><p>打完一看怎么是波兰语题解，开了翻译都艰难看不懂，白兰了。</p><p>以后 VP 前真要注意一下题解是什么语言的。</p><h2 id="asia-ec-online-2025-i"><ahref="https://qoj.ac/contest/2513">【9.7】Asia EC Online 2025(I)</a></h2><h3 id="c.-canvas-painting">C. Canvas Painting</h3><p>贪心，把线段按右端点从小到大排序，右端点相同按左端点从小到大排序。然后找到<span class="math inline">\([l,r-1]\)</span> 里第一个未被染色的 <spanclass="math inline">\(p\)</span>，让 <spanclass="math inline">\(a_p=a_r\)</span>，并将 <spanclass="math inline">\(p\)</span> 标记为已经染色。实际上每次只用把 <spanclass="math inline">\(\text{ans}\)</span> 减一，而找 <spanclass="math inline">\(p\)</span> 的过程可以动态开点权值线段树或者 set维护区间并再 lower_bound。</p><h3 id="j.-moving-on-the-plane">J. Moving on the Plane</h3><p>将曼哈顿距离转成切比雪夫距离，那么 “任意两点曼哈顿距离 <spanclass="math inline">\(\le k\)</span>” 等价于 “<spanclass="math inline">\(x\)</span> 轴和 <spanclass="math inline">\(y\)</span> 轴的极差都 <spanclass="math inline">\(\le k\)</span>”，且每一步在切氏距离下等同于 <spanclass="math inline">\(x\)</span> 方向 <span class="math inline">\(\pm1\)</span>，或 <span class="math inline">\(y\)</span> 方向 <spanclass="math inline">\(\pm1\)</span>，两个轴的答案可以乘起来，我们只用研究一维的情况。</p><p>即，数轴上 <span class="math inline">\(n\)</span>个点，每次走一格，最后极差 <span class="math inline">\(\le k\)</span>的方案数。枚举区间左端点 <spanclass="math inline">\(L\)</span>，点只能在 <spanclass="math inline">\([L,L+k]\)</span>移动，再枚举每个点在哪停下，组合数算方案数（向 <spanclass="math inline">\(x\)</span> 轴正方向走看成 <spanclass="math inline">\(1\)</span>，负方向走看成 <spanclass="math inline">\(0\)</span>，插板法），每个点的答案可以乘起来。</p><p>为避免算重，要钦定最后 <span class="math inline">\(L\)</span>上有一个点，故容斥减去 <span class="math inline">\([L+1,L+k]\)</span>的方案数。时间复杂度 <span class="math inline">\(O(nmk)\)</span>。</p><h3 id="h.-walk">H. Walk</h3><p>网络流，建模如下。对于一个矩形，左下指向右上的边容量为 <spanclass="math inline">\(a\)</span>，右上指向左下的边容量为 <spanclass="math inline">\(b\)</span>。</p><p><img src="/image/academic/14308f.png" /></p><h2 id="ccpc-2024-zhengzhou"><ahref="https://qoj.ac/contest/1873">【9.9】CCPC 2024 Zhengzhou</a></h2><h3 id="d.-guessing-game">D. Guessing Game</h3><p>对每一组 <span class="math inline">\((a_i,b_i)\)</span>，连 <spanclass="math inline">\((L_{a_i},R_{b_i})\)</span>，建立二分图。题目可以转化为，从左部点中取走所有度数为<span class="math inline">\(1\)</span> 的点，加进 Alice的答案；再从右部点中取走所有度数为 <spanclass="math inline">\(1\)</span> 的点，加进 Bob的答案。点被取走后，相连的边一并消失，重复上述流程直到图中没有点度数为<span class="math inline">\(1\)</span>。对每个连通分量考虑：</p><ul><li>如果是树，那么可以一直取点直到剩一个孤点，容易说明这个孤点就是树的中心。知道树的直径的奇偶性以及端点的颜色，分情况可以讨论出树的中心的颜色。（“颜色”即位于左部点还是右部点）</li><li>如果有环，环上的点度数一定不会是 <spanclass="math inline">\(1\)</span>，给个标记。环外被分为多个以被标记的点为根的有根树，除了根外的所有点都能被取走。注意两个环中间的链也要被标记。</li></ul><p>考虑加边的过程。对于新加的边 <spanclass="math inline">\((x,y)\)</span>，设 <spanclass="math inline">\(u,v\)</span> 分别表示 <spanclass="math inline">\(x,y\)</span> 所在的连通块。</p><ul><li><span class="math inline">\(u=v\)</span>。若 <spanclass="math inline">\(u\)</span>是树，离线按加边顺序建出生成树，那么相当于减去 <spanclass="math inline">\(x\to y\)</span> 这一段树上路径的贡献，然后标记<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的 LCA。若 <spanclass="math inline">\(u\)</span> 是环，则从第一次成环标记的 LCA（设为<span class="math inline">\(p\)</span>） 开始，减去 <spanclass="math inline">\(p,x,y\)</span> 三点间路径的贡献，并更新 <spanclass="math inline">\(p\)</span> 为 <spanclass="math inline">\(p,x,y\)</span> 三点的LCA。每次我们可以暴跳，只要打个标记，每个点至多遍历一次。</li><li><span class="math inline">\(u\neq v\)</span>。若 <spanclass="math inline">\(u,v\)</span> 都是树，合并后维护新连通块的直径，从<span class="math inline">\(u,v\)</span> 两条直径的四个点中选出；若<span class="math inline">\(u,v\)</span>一环一树，把树的中心的贡献加回来；若 <spanclass="math inline">\(u,v\)</span>都是环，离线后依然变成减去一段路径的贡献。</li></ul><h2 id="icpc-kunming-regional"><ahref="https://qoj.ac/contest/1871">【9.12】2024 ICPC KunmingRegional</a></h2><h3 id="i.-items">I. Items</h3><p>生成函数列出来，相当于求 <spanclass="math inline">\([x^m]f(x)^n&gt;0\)</span>。令 <spanclass="math inline">\(B=\left\lfloor\frac{m}{n}\right\rfloor\)</span>，<spanclass="math inline">\(w_i\leftarrow w_i-B\)</span>，<spanclass="math inline">\(m\leftarrow m-nB\)</span>，这一步将 <spanclass="math inline">\(m\)</span> 的值域调整到了 <spanclass="math inline">\([0,n]\)</span>。但此时，直接多项式快速幂行不通。</p><p>一个相当强的观察：如果存在一个方案使得能取到 <spanclass="math inline">\(m\)</span>，那么就一定可以调整取物品的顺序，让背包的大小一直保持在<spanclass="math inline">\([0,n]\)</span>。这意味着，多项式每乘一次，只截取<span class="math inline">\(x^{-n}\sim x^n\)</span>就足够。利用类似整数快速幂的方式倍增，<spanclass="math inline">\(O(n\log^2 n)\)</span>。</p><h3 id="b.-brackets">B. Brackets</h3><p>对每个区间来说，将其化简后必须是一段左括号或者一段右括号，这样才有可能匹配。于是，我们只要想办法高效地化简所有区间，并给每个剩下左括号的区间一个哈希值。至于剩下右括号的区间，将序列翻转再做一遍就好。</p><p>从左向右扫，维护一个括号栈，以及栈内元素的哈希值，以及一个标记<code>ok[i]</code>，表示 <span class="math inline">\(i\)</span>可以成为一个合法括号序列的左端点。遇到左括号，标记合法并入栈；遇到右括号，如果匹配，弹栈，注意到与之匹配的左括号右侧不会有新的合法左端点，于是取消这一段的合法标记。如果不匹配，直接将栈清空，并将之前给的合法标记全部撤销。每扫到一个区间的右端点，如果左端点合法，就记录哈希值。</p><p>注意一个区间化简后为空集的情况，设有 <spanclass="math inline">\(x\)</span> 个这样的区间，贡献就是 <spanclass="math inline">\(\left\lfloor\frac{x}{2}\right\rfloor\)</span>。</p><h3 id="d.-dolls">D. Dolls</h3><p>如果一段区间可以合成一个套娃，其任意一个子区间也可以。如果一段区间不能合成一个套娃，那所有包含该区间的区间都不行。即，固定左端点时，右端点能二分。对于一段要check的区间，先离散化。在最优策略下，若有两个相邻套娃可以紧密合并，就合并它们。模拟这个过程，检查一段长为<span class="math inline">\(m\)</span> 的区间是 <spanclass="math inline">\(O(m\log m)\)</span>，反推二分初始区间长度的和是<span class="math inline">\(k\)</span> 的情况下，是 <spanclass="math inline">\(O(k\log^2 k)\)</span>。要让 <spanclass="math inline">\(k=O(n)\)</span>，每次二分的右端点不应选取 <spanclass="math inline">\(n\)</span>，而是通过倍增来确定。</p><h2 id="icpc-shenyang-regional"><ahref="https://qoj.ac/contest/1865">【9.13】2024 ICPC ShenyangRegional</a></h2><h3 id="d.-dot-product-game">D. Dot Product Game</h3><p>下标 <span class="math inline">\(i,j\)</span> 能操作当且仅当 <spanclass="math inline">\((a_i-a_j)(b_i-b_j)&lt;0\)</span>，令 <spanclass="math inline">\(\{c\}\)</span> 表示按 <spanclass="math inline">\(\{a\}\)</span> 顺序排列的 <spanclass="math inline">\(\{b\}\)</span> 数组，那么每次操作定会让 <spanclass="math inline">\(\{c\}\)</span> 的逆序对数减少。</p><div class="note note-primary">            <p>对于任意 <span class="math inline">\(1\sim n\)</span>的排列，交换任意下标不同的两个数，逆序对数的奇偶性一定会改变。</p>          </div><p>游戏结束时逆序对数为 <spanclass="math inline">\(0\)</span>，于是答案取决于 <spanclass="math inline">\(\{c\}\)</span>的逆序对数的奇偶性。对于一次修改，将 <spanclass="math inline">\([l,r]\)</span> 循环左移一次等价于进行了 <spanclass="math inline">\(r-l\)</span> 次交换，检查 <spanclass="math inline">\(d(r-l)\)</span> 的奇偶性即可，和操作 <spanclass="math inline">\(\{a\}\)</span> 还是 <spanclass="math inline">\(\{b\}\)</span> 一点关系都没有。</p><h3 id="i.-growing-tree">I. Growing Tree</h3><p>比较考验实现方式的题目。从底向上考虑，如果存在一个节点往下延伸的两条链权值相同，马上砍掉其中一条是最优的。也不可能两条全砍掉，因为这样不如把其中一条放到父亲节点决策。因为最多修改<span class="math inline">\(n\)</span> 条边，递归次数是 <spanclass="math inline">\(2^n\)</span>级别，只要实现的不是特别差，爆搜都能过，细节不赘述了。</p><h3 id="h.-guide-map">H. Guide Map</h3><p>这题真的只有 median 吗？等 C12AK 教我。</p><h2 id="北京市赛-2025"><ahref="https://qoj.ac/contest/1986">【9.15】北京市赛 2025</a></h2><h3 id="i.-最小lcm">I. 最小LCM</h3><p>令 <span class="math inline">\(d=\gcd(a+x,b+y)\)</span>，那么 <spanclass="math inline">\(\text{lcm}(a+x,b+y)=\dfrac{(a+x)(b+y)}{d}\)</span>。当<span class="math inline">\(d\)</span> 确定时，<spanclass="math inline">\(a+x\)</span> 肯定是取到最小的 <spanclass="math inline">\(\ge a\)</span> 的 <spanclass="math inline">\(d\)</span> 的倍数最优，<spanclass="math inline">\(b+y\)</span> 同理，于是 <spanclass="math display">\[\begin{cases}x=d \times \left(\left\lfloor \frac{a-1}{d} \right\rfloor + 1\right)-a\\y=d \times \left(\left\lfloor \frac{b-1}{d} \right\rfloor + 1\right)-b\end{cases}\]</span> 当且仅当 <span class="math inline">\(0\le x,y\le k\)</span>时计入答案。注意到当 <span class="math inline">\(d\)</span> 在一个区间<span class="math inline">\([l, r]\)</span> 连续取值时，<spanclass="math inline">\(\left\lfloor \frac{a-1}{d} \right\rfloor\)</span>不变，且取 <span class="math inline">\(d=l\)</span>最优，数论分块即可。corner case 是 <spanclass="math inline">\(d=a\)</span> 以及 <spanclass="math inline">\(d=b\)</span>。时间复杂度 <spanclass="math inline">\(O(\sqrt{a}+\sqrt{b})\)</span>。</p><h3 id="j.-四舍五入">J. 四舍五入</h3><p>满足 <span class="math inline">\(f(x,k)=y\)</span> 的 <spanclass="math inline">\(x\)</span>，位于闭区间 <spanclass="math inline">\(\left[y-\left\lfloor\frac{k}{2}\right\rfloor,y+\left\lfloor\frac{k-1}{2}\right\rfloor\right]\)</span> 之内。首先，<spanclass="math inline">\(y\)</span> 一定是 <spanclass="math inline">\(k\)</span> 的倍数。对于一个 <spanclass="math inline">\(y\)</span> 来说，每个 <spanclass="math inline">\(k\)</span> 都对应一个区间，这 <spanclass="math inline">\(m\)</span> 个区间的并表示了一步之内能达 <spanclass="math inline">\(y\)</span> 的 <spanclass="math inline">\(x\)</span> 的取值范围，设为 <spanclass="math inline">\([l_{y,0},r_{y,0}]\)</span>。</p><p>进一步，将 <span class="math inline">\([l_{y,i},r_{y,i}]\)</span>定义成在 <span class="math inline">\(2^i\)</span> 步之内能达 <spanclass="math inline">\(y\)</span> 的 <spanclass="math inline">\(x\)</span> 的取值范围，有</p><ul><li><span class="math inline">\(\large l_{y,i}=\min_{u\in[l_{y,i-1},r_{y,i-1}]}l_{u,i-1}\)</span>。</li><li><span class="math inline">\(\large r_{y,i}=\max_{u\in[l_{y,i-1},r_{y,i-1}]}r_{u,i-1}\)</span>。</li></ul><p>利用 ST 表维护 <span class="math inline">\(l_{y,i}\)</span> 和 <spanclass="math inline">\(r_{y,i}\)</span>，查询时只需要对第一维进行倍增，时间复杂度<span class="math inline">\(O(n\log^2 n+q\log n)\)</span>。</p><h3 id="k.-最小生成树">K. 最小生成树</h3><div class="note note-primary">            <p>一条边 <span class="math inline">\((x,y,w)\)</span>在图上的至少一棵最小生成树中 <spanclass="math inline">\(\Longleftrightarrow\)</span> 只考虑边权 <spanclass="math inline">\(&lt;w\)</span> 的边时，<spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 在不同的连通分量。</p>          </div><p>意味着，按边权从小到大加边，当添加一条边权为 <spanclass="math inline">\(w\)</span>的边时，两个端点只能从不同的连通块中寻找。</p><p>令 <span class="math inline">\(f_{k,n}\)</span> 表示边权 <spanclass="math inline">\(\in[1,k]\)</span>，点数为 <spanclass="math inline">\(n\)</span> 的连通图数量。<spanclass="math inline">\(g_{k,n}\)</span>则表示不一定连通。一个很好的性质是如果令 <spanclass="math inline">\(F_k\)</span> 表示 <spanclass="math inline">\(f_k\)</span> 的 EGF，<spanclass="math inline">\(G_k\)</span> 表示 <spanclass="math inline">\(g_k\)</span> 的 EGF，那么 <spanclass="math inline">\(G_k=\text{exp}(F_k)\)</span>。求出 <spanclass="math inline">\(G_k\)</span> 后只需要一次多项式 <spanclass="math inline">\(\ln\)</span> 就能求出 <spanclass="math inline">\(F_k\)</span>。</p><p>设 <span class="math inline">\(1\)</span> 所在的连通块为 <spanclass="math inline">\(A\)</span>，其余点（不一定连通）为 <spanclass="math inline">\(B\)</span>。枚举 <spanclass="math inline">\(A\)</span> 的大小，列出式子： <spanclass="math display">\[\large g_{k,n} = \sum_{i=1}^{n}\underbrace{\binom{n-1}{i-1}}_{\text{选出 A 除了 1 之外的 i - 1 个点}}\cdot \underbrace{f_{k-1,i}}_{\text{ A要连通}} \cdot\underbrace{g_{k,n-i}}_{\text{B不一定连通}} \cdot\underbrace{2^{i(n-i)}}_{\text{连接 A, B 的边}}\]</span>这和半在线卷积的式子很像，尝试往半在线卷积的标准形式进行修改。</p><div class="note note-primary">            <p><span class="math display">\[i\cdot (n-i)=\binom{n}{2}-\binom{i}{2}-\binom{n-i}{2}\]</span></p>          </div><p>代入，整理 <span class="math display">\[\large \underbrace{\frac{g_n}{2^{\binom{n}{2}}n!}}_{H_n}=\frac{1}{n}\sum\underbrace{\frac{f_i}{2^\binom{i}{2}(i-1)!}}_{I_{i}}\underbrace{\frac{g_{n-i}}{2^{\binom{n-i}{2}}(n-i)!}}_{H_{n-i}}\]</span> 也就是 <spanclass="math inline">\(nH_n=I_iH_{n-i}\)</span>，相比标准形式多了个 <spanclass="math inline">\(n\)</span>，联想到 <spanclass="math inline">\((x^n)&#39;=nx^{n-1}\)</span>，故取生成函数 <spanclass="math display">\[\sum_{n\ge 1}nH_n x^n=x\cdot\sum_{n\ge 1}nH_n x^{n-1}=\sum_{n\ge1}\sum_{i=1}^{n}I_iH_{n-i} x^n\]</span> 即 <spanclass="math inline">\(xH&#39;(x)=I(x)H(x)\)</span>，进一步 <spanclass="math display">\[\begin{align}\frac{H&#39;(x)}{H(x)}&amp;=\frac{I(x)}{x}\\\int\frac{H&#39;(x)}{H(x)}&amp;=\ln H(x)=\int \frac{I(x)}{x}\\H(x)&amp;=\text{exp} \left(\int \frac{I(x)}{x}\right)\end{align}\]</span> 这样就跑通了整个 <span class="math inline">\(f_{k-1,n}\tog_{k,n}\to f_{k,n}\)</span> 的流程，重复 <spanclass="math inline">\(k\)</span> 次，时间复杂度 <spanclass="math inline">\(O(kn\log n)\)</span>。</p><h2 id="icpc-shenyang-regional-1"><ahref="https://qoj.ac/contest/1251">【9.16】2020 ICPC ShenyangRegional</a></h2><h3 id="i.-rise-of-shadows">I. Rise of Shadows</h3><p>一天分为 <span class="math inline">\(HM\)</span> 个单位。分针速度<span class="math inline">\(H\)</span> 单位每分钟；时针速度 <spanclass="math inline">\(1\)</span> 单位每分钟。相对速度 <spanclass="math inline">\(H-1\)</span>，相当于求有多少个 <spanclass="math inline">\(t\in [0,HM-1]\)</span> 满足 <spanclass="math display">\[\begin{align}(H-1)t\ \bmod{(HM)}\le A \quad\textbf{ 或 }\quad (H-1)t\ \bmod{(HM)}\geHM-A\end{align}\]</span> <div class="note note-primary">            <p>对于 <span class="math inline">\(f(x)=ax\bmod b\)</span>，令 <spanclass="math inline">\(g=\gcd(a,b)\)</span>，那么 <spanclass="math inline">\(f(x)\)</span> 有 <spanclass="math inline">\(\frac{b}{g}\)</span> 个可能取值，分别为 <spanclass="math inline">\(\{0,g,2g,3g,\ldots,(\frac{b}{g}-1)g\}\)</span>。同时，<spanclass="math inline">\(\frac{b}{g}\)</span> 也是 <spanclass="math inline">\(f(x)\)</span> 的最小正周期。</p>          </div></p><p>令 <span class="math inline">\(G=\gcd(H-1,HM)\)</span>，<spanclass="math inline">\(t&#39;\in [0,\frac{HM}{G}]\)</span>，式子改写成<span class="math display">\[\begin{align}\frac{(H-1)t&#39;}{G}\ \bmod{\frac{HM}{G}}\le \frac{A}{G} \quad\textbf{或 }\quad \frac{(H-1)t&#39;}{G}\ \bmod{\frac{HM}{G}}\ge \frac{HM-A}{G}\end{align}\]</span> 令 <spanclass="math inline">\(k&#39;=\frac{H-1}{G}\)</span>，<spanclass="math inline">\(n&#39;=\frac{HM}{G}\)</span>，<spanclass="math inline">\(\gcd(k&#39;,n&#39;)=1\)</span>，<spanclass="math inline">\(g(t&#39;)=k&#39;t&#39;\bmod n&#39;\)</span>构成双射（且是置换），答案就是 <spanclass="math inline">\([0,n&#39;-1]\)</span> 中满足 <spanclass="math inline">\(x\le \frac{A}{G}\)</span> 或 <spanclass="math inline">\(x\ge \frac{HM-A}{G}\)</span> 的 <spanclass="math inline">\(x\)</span> 的数量，即 <spanclass="math inline">\(2\left\lfloor\frac{A}{G}\right\rfloor+1\)</span>，再乘上周期数<span class="math inline">\(G\)</span> 就是答案。</p><h3 id="c.-mean-streets-of-gadgetzan">C. Mean Streets of Gadgetzan</h3><p>每个子句中至多一个正文字的 SAT 问题称为Horn-SAT，是能线性解决的。对于蕴含式 <spanclass="math inline">\(x_1,x_2,\cdots,x_k\to y\)</span>，从 <spanclass="math inline">\(x_1,x_2,\cdots,x_k\)</span> 向 <spanclass="math inline">\(y\)</span> 连边，对于非蕴含式，直接扔进 queue里，拓扑排序。维护 <spanclass="math inline">\(\text{ans}[x]=0/1/{-1}\)</span> 表示 <spanclass="math inline">\(x\)</span>尚不确定，确定为正，确定为负，看看有没有冲突就行。</p><h3 id="e.-knights-of-the-frozen-throne">E. Knights of the FrozenThrone</h3><p>令 <span class="math inline">\(t_i^{(j)}\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个玩家的第 <spanclass="math inline">\(j\)</span> 发请求。合法的 <spanclass="math inline">\(X\)</span> 取值只有 <span class="math display">\[\{t_i^{(j)}-t_{i}^{(j-1)}+1\mid 1\le i\le m,\ 2\le j\le k_i\}\]</span> 扫描线，按 <span class="math inline">\(X\)</span>从小到大维护贡献。CPU 部分，只需要 map 维护所有需要 load的时刻；内存部分，当 <span class="math inline">\(X\)</span>逐步增大的时候，有些区间的贡献从 <span class="math inline">\(X\)</span>变为 <spanclass="math inline">\(t_i^{(j)}-t_i^{(j-1)}\)</span>，变了的部分直接累加，再维护仍是<span class="math inline">\(X\)</span> 的区间的个数即可。</p><h3 id="l.-forged-in-the-barrens">L. Forged in the Barrens</h3><p>考虑朴素的 dp，令 <spanclass="math inline">\(f[i][k][s=0/1/2]\)</span> 表示考虑前 <spanclass="math inline">\(i\)</span> 个数，已经分成了完整的 <spanclass="math inline">\(k\)</span> 段，当前段什么都没选 <spanclass="math inline">\((s=0)\)</span>，只选了最小值 <spanclass="math inline">\((s=1)\)</span>，只选了最大值 <spanclass="math inline">\((s=2)\)</span> 的答案，枚举当前 <spanclass="math inline">\(a_i\)</span> 作为当前段的极值进行转移。</p><p>注意到以 <span class="math inline">\(k\)</span> 为自变量，<spanclass="math inline">\(f[i][k]\)</span> 具有凸性，可以利用分治配合 <spanclass="math inline">\((\max,+)\)</span> 卷积进行合并。具体的，令 <spanclass="math inline">\(g[p][l=0/1/2][r=0/1/2][k]\)</span>表示线段树上节点 <span class="math inline">\(p\)</span>对应的区间，已经分成了完整的 <span class="math inline">\(k\)</span>段，左端点/右端点作为新段非极值/最小值/最大值的答案，那么 <spanclass="math display">\[g[p][l][r][k]=\max\begin{cases}g[2 \cdot p][l][r][k]\\g[2\cdot p+1][l][r][k]\\\max\limits_{s_1,s_2\in[0,2]}\left(\max\limits_{k=i+j} (g[2\cdotp][s_1][0][i]+g[2\cdot p+1][0][s_2][j])\right)\\\max\limits_{s_1,s_2\in[0,2]}\left(\max\limits_{k=i+j+1} (g[2\cdotp][s_1][1][i]+g[2\cdot p+1][2][s_2][j])\right)\\\max\limits_{s_1,s_2\in[0,2]}\left(\max\limits_{k=i+j+1} (g[2\cdotp][s_1][2][i]+g[2\cdot p+1][1][s_2][j])\right)\end{cases}\]</span> 对于凸序列 <span class="math inline">\(a,b\)</span>，单次<span class="math inline">\((\max,+)\)</span> 卷积的复杂度是 <spanclass="math inline">\(O(|a|+|b|)\)</span>，故复杂度为 <spanclass="math inline">\(O(n\log^2n)\)</span>。</p><h2 id="ucup2-2.-spb"><ahref="https://qoj.ac/contest/1356">【9.18】Ucup2-2. Spb</a></h2><h3 id="d.-bishops">D. Bishops</h3><p>显然棋盘可以分成两部分，两部分答案可加，互不干扰。将主对角线看成左部点，副对角线看成右部点，构建二分图，我们需要求出一个最大匹配。注意到每个左部点<span class="math inline">\(i\)</span> 向右部点的连边都是一段区间 <spanclass="math inline">\([L_i,R_i]\)</span>，考虑贪心：将三元组 <spanclass="math inline">\((i,L_i,R_i)\)</span> 按 <spanclass="math inline">\(R_i\)</span> 升序排序，每次二分出第一个 <spanclass="math inline">\(\ge L_i\)</span> 的未被匹配的右部点进行匹配。</p><p>一个技巧是将左部点编号为 <span class="math inline">\(s=i +j\)</span>，右部点编号为 <spanclass="math inline">\(t=i-j\)</span>，这样构造方案的时候容易还原。</p><h3 id="g.-graph-cuts">G. Graph Cuts</h3><p>没什么好说的，记录一个坑。</p><div class="note note-warning">            <div class="code-wrapper"><pre><code class="hljs c++">bitset&lt;5&gt; a;a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;a[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> b = a.<span class="hljs-built_in">flip</span>();cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;cout &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</code></pre></div><p>第五行，输出的是 <code>11010</code> 而不是<code>00101</code>。<code>a.flip()</code> 调用的时候直接改变了 <spanclass="math inline">\(a\)</span> 本身，而并非创建了一个副本。</p>          </div><h3 id="c.-many-many-cycles">C. Many Many Cycles</h3><p><em>conclusion.</em>任意求出一棵生成森林，只用考虑至多包含两条非树边的环。</p><p>我们将仅含一条非树边的环称作基本环，先累计基本环答案，再 <spanclass="math inline">\(O(m^2)\)</span>枚举两条非树边，设各自形成的两个基本环分别为 <spanclass="math inline">\(a,b\)</span>，容斥一下，新环长 <spanclass="math inline">\(|c|=|a\oplus b|=|a|+|b|-2|a\cap b|\)</span>，又<span class="math inline">\(\gcd(|a|,|b|,|c|)=\gcd(|a|,|b|,2|a\capb|)\)</span>，我们只用求 <span class="math inline">\(a,b\)</span>在生成树上的交集长度，见<ahref="https://github.com/KisuraOP/XCPC-Templates/blob/main/templates/树论/PathUnion.cpp">树链求交</a>。</p><p>同样的，图上任意一个环 <span class="math inline">\(p\)</span>都能表示成多个基本环的异或。观察 <span class="math inline">\(p=a\oplusb\oplus c\)</span>，推一下有 <spanclass="math inline">\(|p|=|a|+|b|+|c|-2|b\cap c|-2|a\cap(b\oplusc)|\)</span>。最后一项能拆成 <span class="math inline">\((a\cap b)\oplus(a\cap c)\)</span>，即两个基本环交集的线性组合。进一步，任意 <spanclass="math inline">\(|p|\)</span>都能用基本环和两个基本环的交集线性表出，得证。</p><p>出于神秘的原因，使用随机的生成树相比使用 dfs树会让程序效率大幅下降。</p><h2 id="ccpc-online-2025"><ahref="https://qoj.ac/contest/2534">【9.20】CCPC Online 2025</a></h2><p>找不到题解，剩下的题等题解出了再补。</p><h3 id="c.-造桥与砍树">C. 造桥与砍树</h3><p>令生成树点集为 <span class="math inline">\(S\)</span>，初始 <spanclass="math inline">\(S=\{1\}\)</span>，之后尝试不断扩大 <spanclass="math inline">\(S\)</span>。对一个点 <spanclass="math inline">\(u\)</span>，优先找 <spanclass="math inline">\((a_u+a_v)\bmod k\)</span> 最小的 <spanclass="math inline">\(v\)</span>。对 <spanclass="math inline">\(S\)</span> 里的每个点 <spanclass="math inline">\(u\)</span> 都维护一个 <spanclass="math inline">\(v\)</span>，放进优先队列中，每次取最小的加进 <spanclass="math inline">\(S\)</span>，并更新 <spanclass="math inline">\(v\)</span> 的候选值。本质上就是以 <spanclass="math inline">\((a_u+a_v)\bmod k\)</span> 作为权值跑了一遍prim，并用 set 或其它数据结构加速这个过程。</p><h2 id="xvi-open-cup.-moscow"><ahref="https://qoj.ac/contest/2528">【9.22】XVI Open Cup. Moscow</a></h2><h3 id="e.-super-backpack">E. Super Backpack</h3><p>题意可以转化为给定 <span class="math inline">\(n\)</span>个长度不超过 <span class="math inline">\(5\)</span> 的序列，求它们的<span class="math inline">\((\max,+)\)</span> 卷积。如果是凸序列，容易在<span class="math inline">\(O(n\log n)\)</span>内分治合并，可惜并不凸。</p><p><em>conclusion.</em> 设最终答案序列为 <spanclass="math inline">\(d\)</span>，按下标 <spanclass="math inline">\(\bmod 12\)</span> 分组，分出的 <spanclass="math inline">\(12\)</span> 个新子序列都是凸的。</p><p><em>prove.</em> 即证 <span class="math inline">\(2\cdot d[i+12]\ged[i]+d[i+24]\)</span> 对任意 <span class="math inline">\(i\)</span>成立。假设我们有下标和分别为 <span class="math inline">\(i\)</span> 和<span class="math inline">\(i+24\)</span> 的最优方案 <spanclass="math inline">\(S_k=\{c_1,c_2,\ldots,c_n\}\)</span> 和 <spanclass="math inline">\(S_{k+24}=\{c_1&#39;,c_2&#39;,\ldots,c_n&#39;\}\)</span>，其中<span class="math inline">\(\sum(c_i&#39;-c_i)=24\)</span>。值域为 <spanclass="math inline">\([1,5]\)</span>，即 <spanclass="math inline">\((c_i&#39;-c_i)\in[-4,4]\)</span>。注意到（根本注意不到），任何一个由<span class="math inline">\(\{-4,-3,\ldots,3,4\}\)</span>中的整数构成的、总和为 <span class="math inline">\(24\)</span>的多重集，都可以被划分成两个子集，每个子集的和均为 <spanclass="math inline">\(12\)</span>。因此，我们一定能构造出两个总价值之和为<span class="math inline">\(d[i]+d[i+24]\)</span>，下标和均为 <spanclass="math inline">\(i+12\)</span>的可行解（注意不一定最优解）。假设这两个子集的价值分别为 <spanclass="math inline">\(v_a,v_b\)</span>，因为最优解一定不小于任何一个可行解，有<span class="math inline">\(d[i+12]\ge v_a\)</span> 和 <spanclass="math inline">\(d[i+12]\ge v_b\)</span>，两式相加，<spanclass="math inline">\(2\cdot d[i+12]\gev_a+v_b=d[i]+d[i+24]\)</span>，得证。</p><p>分治合并时，下标 <span class="math inline">\(\bmod 12=k\)</span>的组，答案是所有 <span class="math inline">\(k=i+j\)</span> 的组的 <spanclass="math inline">\((\max,+)\)</span> 卷积的 <spanclass="math inline">\(\max\)</span>。虽然两个上凸序列的 <spanclass="math inline">\(\max\)</span>不一定上凸，但合并完一定是凸的。时间复杂度 <spanclass="math inline">\(O(12^2\cdot n\log n)\)</span>。</p><h2 id="ec-final-2023"><a href="https://qoj.ac/contest/1522">【9.23】ECFinal 2023</a></h2><h3 id="i.-balance">I. Balance</h3><p>首先，同一边双内 <span class="math inline">\(a_i\)</span>必须相同，否则一个环会贡献两倍极差。缩边双，得到一棵树，所有 <spanclass="math inline">\(a_i\)</span>相同的连通块，也必定是从小到大像一条链一样排列。设 <spanclass="math inline">\(a_i\)</span> 有 <spanclass="math inline">\(k\)</span> 种取值，分别记为 <spanclass="math inline">\(c_1,c_2,\ldots,c_k\)</span>，我们要找一条路径，路径上按次序有<span class="math inline">\(k-1\)</span> 条特殊边，第 <spanclass="math inline">\(i\)</span> 条边分隔了 <spanclass="math inline">\(c_i\)</span> 和 <spanclass="math inline">\(c_{i+1}\)</span>。</p><p>显然，对于一条特殊边 <spanclass="math inline">\((u,v)\)</span>，其中一侧的连通块大小必定是 <spanclass="math inline">\(c_i\)</span>的一个前缀。要注意，特殊边是有方向的，例如钦定边 <spanclass="math inline">\((u,v)\)</span> 表示 <spanclass="math inline">\(v\)</span>所在连通块的大小，一条合法路径顺次经过的特殊边方向必须相同。一个巧妙的转化是：我们只用找同方向特殊边最多的路径，因为上界就是<span class="math inline">\(k-1\)</span>。换根 dp 即可，时间复杂度 <spanclass="math inline">\(O(n)\)</span>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> QOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】2025 UESTC 暑假集训（div.1）</title>
      <link href="/posts/80517353.html"/>
      <url>/posts/80517353.html</url>
      
        <content type="html"><![CDATA[<p>如梦似幻。</p><h2 id="上海市赛">【7.9】 2025 上海市赛</h2><p><a href="https://qoj.ac/contest/2238">Contest Link</a></p><p>用了 1h 意识到树形背包是 <span class="math inline">\(O(n^2)\)</span>的，太神奇了树形背包。</p><h3 id="c.-饺子">C. 饺子</h3><p><a href="https://qoj.ac/submission/1147422">Code</a></p><p>令 <span class="math inline">\(f(x)\)</span> 表示恰好吃 <spanclass="math inline">\(x\)</span>个饺子，能得到的最大愉悦值（忽略额外愉悦值 <spanclass="math inline">\(val\)</span>）。</p><p>容易看出，<span class="math inline">\(f(x)\)</span>是一个上凸函数，答案只能取在 <span class="math inline">\(0,m\)</span>和极值点三者之一。</p><p>对于某个取值点，可以使用 WQS 二分。二分斜率，对于一根固定斜率 <spanclass="math inline">\(k\)</span>的直线，找到与凸包的切点等价于最大化直线的截距，即 <spanclass="math inline">\(f(x)-kx\)</span>。</p><p>而 <span class="math inline">\(f(x)=v_1+v_2+\cdots+v_x\)</span>，其中<span class="math inline">\(v_i\)</span>为某个饺子带来的愉悦值，那么最大化 <spanclass="math inline">\(f(x)-kx=(v_1-k)+(v_2-k)+\cdots+(v_x-k)\)</span>也就等价于只取 <span class="math inline">\((v_i-k)\ge 0\to v_i\gek\)</span> 的饺子。</p><p>计算所有愉悦值 <span class="math inline">\(\ge k\)</span>的饺子带来的愉悦值之和，即为切点的纵坐标。</p><p>再考虑额外愉悦值 <spanclass="math inline">\(val\)</span>，这等价于将这个上凸函数的其中一段拉高，此时答案的取值点只可能增加了<span class="math inline">\(l, r\)</span> 两个点，同上求解。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p><h3 id="e.-djangle-的数据结构">E. Djangle 的数据结构</h3><p><a href="https://qoj.ac/submission/1147725">Code</a></p><p>线段树维护：区间和，区间 <spanclass="math inline">\(\text{lcm}\)</span>，以及一个懒标记用于区间赋值。</p><p>可以说明，<span class="math inline">\(\gcd\)</span>操作时经过以下两个剪枝，复杂度就是对的：</p><ul><li>如果 <span class="math inline">\(x\)</span> 是当前区间 <spanclass="math inline">\(\text{lcm}\)</span>的倍数，此时直接返回区间和。因为 <spanclass="math inline">\(\gcd(a_i,x)=a_i\)</span>。</li><li>如果区间所有数全相等（为 <spanclass="math inline">\(d\)</span>），转换为区间赋值 <spanclass="math inline">\(\gcd(d,x)\)</span>。</li></ul><p>这是因为每次 <span class="math inline">\(\gcd\)</span> 操作，<spanclass="math inline">\(a_i\)</span>的值至少减半，所以全局上看区间覆盖操作成功执行的次数的上界是 <spanclass="math inline">\(O(n\log w)\)</span>。</p><p>而算上求 <span class="math inline">\(\gcd\)</span>，单次修改的成本是<span class="math inline">\(O(\log n\log w)\)</span>，所以一共就 <spanclass="math inline">\(O(n\log n\log^2 w)\)</span>。</p><p>要更加严谨的话需要势能分析。</p><h2 id="icpc-jinan-regional">【7.10】2020 ICPC Jinan Regional</h2><p><a href="https://qoj.ac/contest/2181">Contest Link</a></p><p>只会 ez。</p><h2 id="icpc-nac">【7.11】2025 ICPC NAC</h2><p><a href="https://qoj.ac/contest/2041">Contest Link</a></p><h3 id="j.-popping-balloons">J. Popping Balloons</h3><p><a href="https://qoj.ac/submission/1151853">Code</a></p><p>蓝色看成 <span class="math inline">\(0\)</span>，黄色看成 <spanclass="math inline">\(1\)</span>，红色看成 <spanclass="math inline">\(2\)</span>，问题变为每秒从序列中随机移除一个值，让序列变得有序的期望时间。</p><p>设随机变量 <span class="math inline">\(X\)</span>表示序列有序后剩下来的长度，则 <span class="math display">\[P(X\ge k)=\dfrac{f(k)}{\binom{n}{k}}\]</span> 其中 <span class="math inline">\(f(k)\)</span> 表示序列中长为<span class="math inline">\(k\)</span> 的非降子序列数量。</p><p>进一步 <span class="math display">\[E[X]=\sum_{k=1}^{n}P(x\ge k)\]</span> 最终题目的答案就是 <span class="math inline">\(n -E[X]\)</span>。</p><p>现在，问题只剩如何对 <span class="math inline">\(k\in [1,n]\)</span>求出 <span class="math inline">\(f(k)\)</span>。</p><p>尝试用多项式描述信息。定义多项式 <spanclass="math inline">\(F_{L,R,i,j}(x)\)</span>，它 <spanclass="math inline">\(x^k\)</span> 项的系数表示 “区间 <spanclass="math inline">\([L,R]\)</span> 中，以 <spanclass="math inline">\(i\)</span> 开头，<spanclass="math inline">\(j\)</span> 结尾 <span class="math inline">\((0\lei\le j\le 2)\)</span>，长为 <span class="math inline">\(k\)</span>的非降子序列数量”。</p><p>这么定义的好处是，两个多项式相乘，<spanclass="math inline">\(x^i\)</span> 的系数和 <spanclass="math inline">\(x^j\)</span> 的系数会累加到新多项式 <spanclass="math inline">\(x^{i+j}\)</span>的系数上，意义就是两个区间合并，长为 <spanclass="math inline">\(i\)</span> 的非降子序列和长为 <spanclass="math inline">\(j\)</span> 的非降子序列会拼接成长为 <spanclass="math inline">\(i + j\)</span> 的非降子序列。</p><p>先考虑基态。对于 <span class="math inline">\(a_i=x\ (x\in\{0,1,2\})\)</span>，<spanclass="math inline">\([x^1]F_{i,i,x,x}=1\)</span>，其它项均为 <spanclass="math inline">\(0\)</span>。</p><p>再考虑合并。假设我们已经知道了区间 <spanclass="math inline">\([l,m]\)</span> 的答案 <spanclass="math inline">\(F_{l,m,i,j}\)</span> 和区间 <spanclass="math inline">\([m+1,r]\)</span> 的答案 <spanclass="math inline">\(F_{m+1,r,i,j}\)</span>（我们得到的是所有 <spanclass="math inline">\(i,j\)</span> 的答案，换句话说，是一个 <spanclass="math inline">\(3\times 3\)</span> 的多项式矩阵），那么 <spanclass="math display">\[\large F_{l,r,i,j}=\sum_{i\le p_1\le p_2\le j}F_{l,m,i,p_1}F_{m+1,r,p_2,j}+F_{l,m,i,j}+F_{m+1,r,i,j}\]</span> 第一项表示拼接，后两项表示继承两侧区间的非降子序列数量。</p><p>分治 NTT 即可，最终 <spanclass="math inline">\(f(k)=\sum\limits_{i=0}^{2}\sum\limits_{j=0}^{2}[x^k]F_{1,n,i,j}\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="毒瘤场-1">【7.12】毒瘤场 1</h2><p>难炸了。</p><h2 id="牛客多校-1">【7.15】牛客多校 1</h2><h2 id="毒瘤场-2">【7.16】毒瘤场 2</h2><p>难炸了。</p><h2 id="牛客多校-2">【7.17】牛客多校 2</h2><h2 id="杭电多校-1">【7.18】杭电多校 1</h2><h3 id="b.-夜世界">B. 夜世界</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1172&amp;rid=26547">Code</a></p><p>有回溯操作，考虑可持久化线段树。</p><p>区间维护三个值：</p><ul><li><span class="math inline">\(sum\)</span>：这一段的净收益（<spanclass="math inline">\(a_i-b_i\)</span>）。</li><li><span class="math inline">\(mn\)</span>：净收益（<spanclass="math inline">\(sum\)</span>）的前缀最小值。</li><li><spanclass="math inline">\(add\)</span>：从金矿获得的收益之和（<spanclass="math inline">\(a_i\)</span>）。</li></ul><p>操作一和操作二就是普通的单点修改，操作三回溯，主要是操作四。</p><p>给出的 <span class="math inline">\(k\)</span> 座金矿将 <spanclass="math inline">\([1,n]\)</span> 划分成了 <spanclass="math inline">\(k + 1\)</span> 段。</p><p>对一段区间 <spanclass="math inline">\([l,r]\)</span>，我们要解决：给一个初始金币数 <spanclass="math inline">\(x\)</span>，问从 <spanclass="math inline">\(l\)</span> 走到 <spanclass="math inline">\(r\)</span>，手上的金币数变成了多少。</p><p>分两种情况：</p><ul><li><span class="math inline">\(x+mn\ge0\)</span>。说明走在这段区间里手里一直有钱，走完后 <spanclass="math inline">\(x\)</span> 变成 <spanclass="math inline">\(x+sum\)</span>。</li><li><spanclass="math inline">\(x+mn&lt;0\)</span>。说明存在某个时刻手里没钱归零了，设此时在第<span class="math inline">\(p\)</span> 座金矿，最后手上的金币数就是<span class="math inline">\(p\)</span> 和 <spanclass="math inline">\(r\)</span> 之间的净收益，数值上等价于 <spanclass="math inline">\(sum-mn\)</span>。</li></ul><p>解决了段内金币数怎么变，端点处金币数减半可以暴力修改。</p><p>最后，交给哥布林的金币数，就是当前版本下金矿的收益之和减去手上剩下的金币数。</p><p>时间复杂度 <span class="math inline">\(O((n+m+k)\logn)\)</span>。</p><h2 id="ucup2-20-ōokayama">【7.19】Ucup2-20 Ōokayama</h2><p><a href="https://qoj.ac/contest/1499">Contest Link</a></p><p>再也不想打小日子的场了。</p><h2 id="杭电多校-2">【7.21】杭电多校 2</h2><h3 id="k.-10010">K. 10010</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1173&amp;rid=22770">Code</a></p><p>题面给的非常抽象。转化之后等价于：设当前询问区间为 <spanclass="math inline">\([l,r]\)</span>，区间内从右到左 <spanclass="math inline">\(1\)</span> 的位置分别为 <spanclass="math inline">\(p_1,p_2,p_3,\ldots\)</span>，令 <spanclass="math inline">\(g_1=r-p_1\)</span>，<spanclass="math inline">\(g_2=p_1-p_2-1\)</span>，<spanclass="math inline">\(g_3=p_2-p_3-1\)</span>，<spanclass="math inline">\(\ldots\)</span>，则这段区间的得分为 <spanclass="math display">\[\large f([l, r])=g_1+\max_{g_1,g_2,\ldots,g_i\ \textbf{形成等差数列} }\3\cdot (i-1)\]</span> 线段树，每个区间维护如下值。</p><ul><li><span class="math inline">\(l\)</span>：左起第一个 <spanclass="math inline">\(1\)</span> 的绝对坐标。</li><li><span class="math inline">\(r\)</span>：右起第一个 <spanclass="math inline">\(1\)</span> 的绝对坐标。</li><li><span class="math inline">\(g\)</span>：右起第一个 <spanclass="math inline">\(1\)</span> 和右起第二个 <spanclass="math inline">\(1\)</span> 之间的间隔。</li><li><span class="math inline">\(ans\)</span>：右起构成等差数列的 <spanclass="math inline">\(1\)</span> 的个数。</li><li><span class="math inline">\(cont\)</span>：区间里所有的 <spanclass="math inline">\(1\)</span> 是否都属于右起的那个等差数列。</li></ul><p>转移的时候，对于 <span class="math inline">\([l_1,r_1]\)</span> 和<span class="math inline">\([l_2,r_2]\)</span>，看 <spanclass="math inline">\(l_2-r_1-1\)</span>是否能作为一个间隔连接两段等差数列。</p><p>细节非常多，我写完之后对拍了很久才过。</p><p>ps：如果你维护了 “<span class="math inline">\(r\)</span> 右侧 <spanclass="math inline">\(0\)</span> 的个数”，那么大概率逻辑是不对的（</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="牛客多校-3">【7.22】牛客多校 3</h2><h3 id="p4389.-付公主的背包">P4389. 付公主的背包</h3><p><a href="https://www.luogu.com.cn/record/226206057">Code</a></p><p>考虑生成函数。其中 <span class="math inline">\(x^k\)</span>项的系数代表 “凑出体积为 <span class="math inline">\(k\)</span>的方案数”。</p><p>对于一个体积为 <span class="math inline">\(V\)</span>的物品，它能凑出的体积是 <spanclass="math inline">\(0,V,2V,3V,\cdots\)</span>，用多项式表示就是 <spanclass="math display">\[f_V(x)=x^0+x^V+x^{2V}+x^{3V}+\cdots\]</span> 写成封闭形式（利用等比数列求和），就是 <spanclass="math inline">\(f_V(x)=\dfrac{1}{1-x^{V}}\)</span>。</p><p>现在有 <span class="math inline">\(n\)</span> 种体积为 <spanclass="math inline">\(v_1,v_2,\ldots,v_n\)</span>的物品，每种无限个，它们任意组合，凑出体积为 <spanclass="math inline">\(k\)</span> 的方案数就是 <spanclass="math display">\[[x^k]\prod_{i=1}^{n}\frac{1}{1-x^{v_i}}\]</span> 令 <spanclass="math inline">\(F(x)=\prod\limits_{i=1}^{n}\dfrac{1}{1-x^{v_i}}\)</span>，要算出<span class="math inline">\(F(x)\)</span> 前 <spanclass="math inline">\(m\)</span> 项的系数，暴力把 个多项式乘起来是 <spanclass="math inline">\(O(nm\log m)\)</span> 的。需要更快的方法。</p><p>令 <span class="math inline">\(G(x)=\ln F(x)\)</span>，也就是 <spanclass="math display">\[G(x)=\ln\prod\limits_{i=1}^{n}\dfrac{1}{1-x^{v_i}}=\sum_{i=1}^{n}\ln\left(\dfrac{1}{1-x^{v_i}}\right)=-\sum_{i=1}^{n}\ln(1-x^{v_i})\]</span> 但如果把 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(1-x^{v_i}\)</span> 做多项式 <spanclass="math inline">\(\ln\)</span>，还是 <spanclass="math inline">\(O(nm\log m)\)</span> 的。</p><p>这么转换的优势在，可以运用泰勒公式 <spanclass="math inline">\(\ln(1-u)=-(u+\frac{u^2}{2}+\frac{u^3}{3}+\cdots)=-\sum\limits_{i=1}^{\infty}\dfrac{u^i}{i}\)</span>。</p><p>令 <span class="math inline">\(u=x^{v_i}\)</span>，有 <spanclass="math display">\[G(x)=-\sum_{i=1}^{n}\left(-\sum_{j=1}^{\infty}\frac{x^{j\cdotv_i}}{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{\infty}\dfrac{x^{j\cdotv_i}}{j}\]</span> 对于一个体积为 <span class="math inline">\(v_i\)</span>的物品，它给 <span class="math inline">\(x^{v_i}\)</span> 的系数贡献了<span class="math inline">\(1\)</span>，给 <spanclass="math inline">\(x^{2v_i}\)</span> 的系数贡献了 <spanclass="math inline">\(\dfrac{1}{2}\)</span>，给 <spanclass="math inline">\(x^{3v_i}\)</span> 的系数贡献了 <spanclass="math inline">\(\dfrac{1}{3}\)</span>，以此类推。</p><p>我们记录有几种物品的体积为 <spanclass="math inline">\(v_i\)</span>，设为 <spanclass="math inline">\(p[v_i]\)</span>。枚举 <spanclass="math inline">\([1,m]\)</span> 内的每一种体积 <spanclass="math inline">\(i\)</span>，枚举 <spanclass="math inline">\(i\)</span> 的倍数 <spanclass="math inline">\(j\)</span>，<spanclass="math inline">\(x^j\)</span> 的系数就加上 <spanclass="math inline">\(p[i]\cdoti\)</span>。这样一来，我们就在调和级数复杂度下计算出了 <spanclass="math inline">\(G(x)\)</span> 前 <spanclass="math inline">\(m\)</span> 项的所有系数。</p><p>利用多项式 <span class="math inline">\(\text{exp}\)</span> 即可在<span class="math inline">\(O(m\log m)\)</span> 内还原出 <spanclass="math inline">\(F(x)\)</span>。</p><h3 id="i.-infinity">I. Infinity</h3><p><ahref="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78426715">Code</a></p><p><span class="math inline">\(\nu(\sigma)\)</span> 表示和 <spanclass="math inline">\(\sigma\)</span> 共轭的置换的数量。</p><p>两个置换共轭，当且仅当它们拥有相同的轮换结构。</p><p>记 <span class="math inline">\(\lambda_i\)</span> 表示 <spanclass="math inline">\(\sigma\)</span> 长度为 <spanclass="math inline">\(i\)</span> 的轮换个数，<spanclass="math inline">\(\sum\limits_{i=1}^{n}i\cdot\lambda_i=n\)</span>。那么 <span class="math display">\[\nu(\sigma)=\frac{n!}{\prod\limits_{i=1}^{n}i^{\lambda_i}\cdot\lambda_i!}\]</span> 其中 <span class="math inline">\(n!\)</span> 是全集。对于<span class="math inline">\(\lambda_i\)</span> 个长度为 <spanclass="math inline">\(i\)</span> 的轮换，每种轮换都有 <spanclass="math inline">\(i\)</span> 种写法，比如 <spanclass="math inline">\((1\  2\  3)\)</span>，<spanclass="math inline">\((2\ 3\ 1)\)</span>，<spanclass="math inline">\((3\ 1\ 2)\)</span> 实际上是相同的轮换，所以要除掉<span class="math inline">\(i^{\lambda_i}\)</span>。又因为这 <spanclass="math inline">\(\lambda_i\)</span>种轮换本身是不可区分的，所以还要除个 <spanclass="math inline">\(\lambda_i!\)</span>。</p><p>那么，对于所有 <span class="math inline">\(n\)</span>阶置换构成的集合 <spanclass="math inline">\(S_n\)</span>，我们枚举每一种轮换结构 <spanclass="math inline">\(\{\lambda_i\}\)</span>，设这个轮换结构对应的置换是<span class="math inline">\(\sigma_1,\sigma_2,\ldots\sigma_{\nu(\sigma)}\)</span>，其中 <spanclass="math inline">\(\nu(\sigma_1)=\nu(\sigma_2)=\ldots=\nu(\sigma_{\nu(\sigma)})\)</span>，取一个代表元<span class="math inline">\(\sigma_1\)</span>，该轮换结构下所有置换的<span class="math inline">\(\nu(\sigma_i)^k\)</span> 之和，就是 <spanclass="math inline">\(\nu(\sigma_1)^{k+1}\)</span>。</p><p>于是，答案为 <span class="math display">\[\sum_{\sum\limits_{i=1}^{n} i\cdot \lambda_i=n,\ 0\le \lambda_i\len}\left(\dfrac{n!}{\prod\limits_{i=1}^{n}i^{\lambda_i}\cdot\lambda_i!}\right)^{k+1}\]</span> 进一步，类似生成函数的组合意义，我们可以转换为多个幂级数相乘。<span class="math display">\[(n!)^{k+1}[x^n]\prod_{i=1}^{n}\left(\sum_{j=0}^\infty\frac{x^{ij}}{(i^jj!)^{k+1}}\right)\]</span> 相当于将所有 <span class="math inline">\(i\cdot j=n\)</span>的项取出来进行组合。</p><p>注意到 <span class="math display">\[\sum_{j=0}^\infty \frac{x^{ij}}{(i^jj!)^{k+1}}=\sum_{j=0}^\infty \frac{\left(\dfrac{x^i}{i^{k+1}}\right)^j}{(j!)^{k+1}}\]</span> 故令 <span class="math display">\[F(x)=\sum_{j=0}^\infty \frac{x^j}{(j!)^{k+1}}\]</span> 那么，答案是 <span class="math display">\[(n!)^{k+1}[x^n]\prod_{i=1}^{n}F\left(\dfrac{x^i}{i^{k+1}}\right)\]</span> 现在，<span class="math inline">\(k\)</span> 是固定的，有<span class="math inline">\(t\)</span> 次询问，每次问一个 <spanclass="math inline">\(1\le n\le 2\cdot 10^5\)</span>。以下直接令 <spanclass="math inline">\(n=2\cdot 10^5\)</span>。</p><p>令 <span class="math display">\[H(x)=\prod_{i=1}^{n}F\left(\dfrac{x^i}{i^{k+1}}\right)\]</span> 我们肯定是想把 <span class="math inline">\(H(x)\)</span>构造出来，然后 <span class="math inline">\(O(1)\)</span> 取它前 <spanclass="math inline">\(n\)</span> 项的系数。</p><p>观察 <span class="math inline">\(H(x)\)</span>，是 <spanclass="math inline">\(n\)</span> 个多项式相乘，就算每个多项式截断到<span class="math inline">\(x^n\)</span>，乘起来也是 <spanclass="math inline">\(O(n^2\log n)\)</span> 的。</p><p>类似付公主的背包，我们取 <span class="math inline">\(L(x)=\lnH(x)\)</span>，<span class="math inline">\(G(x)=\ln F(x)\)</span>，那么<span class="math display">\[L(x) =\ln\prod_{i=1}^{n}F\left(\dfrac{x^i}{i^{k+1}}\right)=\sum_{i=1}^{n}\lnF\left(\dfrac{x^i}{i^{k+1}}\right)=\sum_{i=1}^{n}G\left(\dfrac{x^i}{i^{k+1}}\right)\]</span> 其中，<spanclass="math inline">\(G(x)=\sum\limits_{i=0}^{n}g_ix^i\)</span>，有<span class="math display">\[L(x)=\sum_{i=1}^{n}\sum_{j=0}^{n}g_j\left(\frac{x^{i}}{i^{k+1}}\right)^j=\sum_{i=1}^{n}\sum_{j=0}^{n}g_j\frac{x^{ij}}{i^{(k+1)\cdot j}}\]</span> 到这里，我们就可以算出 <spanclass="math inline">\(L(x)\)</span> 的前 <spanclass="math inline">\(n\)</span> 项系数了。</p><p>对于每一对 <span class="math inline">\(i\cdot j = n\)</span>，为<span class="math inline">\(x^{ij}\)</span> 的系数贡献了 <spanclass="math inline">\(g_j \cdot i^{-j(k+1)}\)</span>。而枚举每一对 <spanclass="math inline">\(i,j\)</span> 的过程，是调和级数复杂度。</p><p>多项式 <span class="math inline">\(\text{exp}\)</span> 即可求出 <spanclass="math inline">\(H(x)\)</span> 的前 <spanclass="math inline">\(n\)</span> 项系数。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="毒瘤场-3">【7.23】毒瘤场 3</h2><p>终于可以看别人受苦了。</p><h2 id="牛客多校-4">【7.24】牛客多校 4</h2><p>烂完了。</p><h3 id="i.-i-box">I. I, Box</h3><p><ahref="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78455039">Code</a></p><p>先判有无解。对于每一个连通块，如果 <code>@</code> 的数目不等于<code>*</code> 的数目，就无解，否则肯定有解。</p><p>策略是：每次选择一个 <code>@</code>，BFS 找到离它最近的<code>*</code>。把这条路径拿出来，路径上可能还包括了多个 <code>@</code>和 <code>!</code>，这些箱子按先后顺序编号为 <spanclass="math inline">\(a_1,a_2,\ldots,a_l\)</span>。我们只需要将 <spanclass="math inline">\(a_{l-1}\)</span> 移动到 <spanclass="math inline">\(a_l\)</span>，<spanclass="math inline">\(a_{l-2}\)</span> 移动到 <spanclass="math inline">\(a_{l-1}\)</span>，<spanclass="math inline">\(\ldots\)</span>，<spanclass="math inline">\(a_{1}\)</span> 移动到 <spanclass="math inline">\(a_2\)</span>。</p><p>每次操作，推到位的箱子数都会多一个。不断这么操作，直到所有箱子都到位，时间复杂度显然不会超过<span class="math inline">\(O(n^2m^2)\)</span>。</p><h2 id="杭电多校-3">【7.25】杭电多校 3</h2><h3 id="d.-三带一">D. 三带一</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1174&amp;rid=22676">Code</a></p><p>二分答案，设二分出的答案是 <spanclass="math inline">\(mid\)</span>。</p><p>设第 <span class="math inline">\(i\)</span> 堆有 <spanclass="math inline">\(b_i\)</span> 个形如 “XXX” 被使用，剩下 <spanclass="math inline">\(c_i=a_i-3b_i\)</span> 个 “X”。</p><p>令 <span class="math inline">\(A=\sum a_i\)</span>，<spanclass="math inline">\(B=\sum b_i=mid\)</span>，<spanclass="math inline">\(C=\sum c_i=A-3\cdot mid\)</span>。</p><p>首先，显然有</p><ul><li><span class="math inline">\(\forall i\in [1,n]\)</span>，<spanclass="math inline">\(b_i\le\left\lfloor\dfrac{a_i}{3}\right\rfloor\)</span>。</li></ul><p>进一步，每个 “XXX” 都要匹配一个 “Y”（“X” <spanclass="math inline">\(\neq\)</span> “Y”），那么</p><ul><li><span class="math inline">\(\forall i\in [1,n]\)</span>，<spanclass="math inline">\(b_i\le \sum\limits_{j=1,j\neqi}^{n}c_j=C-c_i\)</span>。</li></ul><p>代入 <span class="math inline">\(c_i=a_i-3\cdot b_i\)</span>，得<span class="math inline">\(b_i\ge \left\lceil\dfrac{a_i-(A-3\cdotmid)}{2}\right\rceil\)</span>。</p><p>并且，还需要满足 <span class="math inline">\(B\le C\)</span>，即<span class="math inline">\(mid\le A-3\cdot mid\)</span>，得 <spanclass="math inline">\(mid\le\left\lfloor\dfrac{A}{4}\right\rfloor\)</span>。</p><p>综合一下，有 <span class="math display">\[\left[mid\le \left\lfloor\dfrac{A}{4}\right\rfloor\right]\land\left[\forall i\in [1,n],\ \left\lceil\dfrac{a_i-(A-3\cdotmid)}{2}\right\rceil\le b_i\le\left\lfloor\dfrac{a_i}{3}\right\rfloor\right]\]</span> 对每一个 <span class="math inline">\(b_i\)</span> 都能求出下界<span class="math inline">\(l_i\)</span> 和上界 <spanclass="math inline">\(r_i\)</span>。</p><p>若 <span class="math inline">\(\exists i\)</span>，<spanclass="math inline">\(l_i&gt;r_i\)</span>，或 <spanclass="math inline">\(mid&lt;\sum l_i\)</span>，或 <spanclass="math inline">\(mid&gt;\sumr_i\)</span>，就判定失败；否则判定成功。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p><h2 id="ucup-3-3.-ukraine">【7.26】Ucup 3-3. Ukraine</h2><p><a href="https://qoj.ac/contest/1714">Contest Link</a></p><h3 id="h.-highway-hoax">H. Highway Hoax</h3><p><a href="https://qoj.ac/submission/1183581">Code</a></p><p>任选一个点为根。</p><p>注意到对于一个点 <span class="math inline">\(u\)</span>，<spanclass="math inline">\(u\)</span> 子树内 <spanclass="math inline">\(S\)</span> 的个数当且仅当边 <spanclass="math inline">\((fa[u],u)\)</span> 反转时会发生变化。</p><p>令 <span class="math inline">\(dp[u][0/1]\)</span> 表示，在以 <spanclass="math inline">\(u\)</span>为根的子树中，有多少种合法的标号方案，使得边 <spanclass="math inline">\((fa[u],u)\)</span> 保持初始方向 <spanclass="math inline">\(/\)</span> 反转。</p><p>设 <span class="math inline">\(u\)</span> 的儿子为 <spanclass="math inline">\(v_1,v_2,v_3,\ldots,v_m\)</span>，转移时，我们关注以所有 <spanclass="math inline">\(v_i\)</span> 为根的子树中 <spanclass="math inline">\(S\)</span> 的和。</p><p>假设我们已经求出了 <spanclass="math inline">\(dp[v][0/1]\)</span>，直接树形背包的时间复杂度显然无力应对，考虑生成函数。</p><p>尝试将 <span class="math inline">\(x^k\ (k\in \{-1,0,1\})\)</span>的系数表示为子树中 <span class="math inline">\(S\)</span> 变化 <spanclass="math inline">\(k\)</span> 个的方案数。举个具体的例子：</p><ul><li>如果初始边 <span class="math inline">\((u,v_i)\)</span> 的方向为<span class="math inline">\(u\to v_i\)</span>，不反转 <spanclass="math inline">\(S\)</span> 变化 <spanclass="math inline">\(0\)</span> 个，反转后 <spanclass="math inline">\(S\)</span> 变化 <spanclass="math inline">\(+1\)</span> 个。</li><li>如果初始边 <span class="math inline">\((u,v_i)\)</span> 的方向为<span class="math inline">\(v_i\to u\)</span>，不反转 <spanclass="math inline">\(S\)</span> 变化 <spanclass="math inline">\(0\)</span> 个，反转后 <spanclass="math inline">\(S\)</span> 变化 <spanclass="math inline">\(-1\)</span> 个。</li></ul><p>那么对于 <span class="math inline">\(u\to v_i\)</span>的情况，生成函数为 <spanclass="math inline">\(G_i(x)=dp[v_i][0]+dp[v_i][1]\cdot x\)</span>。</p><p>对于 <span class="math inline">\(v_i\to u\)</span> 的情况，生成函数为<span class="math inline">\(G_i(x)=dp[v_i][0]+dp[v_i][1]\cdotx^{-1}\)</span>。</p><p>这里有妙手，我们提一个 <span class="math inline">\(x^{-1}\)</span>出来，就变成 <spanclass="math inline">\(G_i(x)=x^{-1}(dp[v_i][1]+dp[v_i][0]\cdotx)\)</span>，这样两种情况形式就统一了。即，只需记一下乘了多少个 <spanclass="math inline">\(x^{-1}\)</span>（或者说有多少条边方向是 <spanclass="math inline">\(v_i\to u\)</span>，记为 <spanclass="math inline">\(cnt\)</span>），后面乘的时候就不用带上 <spanclass="math inline">\(x^{-1}\)</span> 了。</p><p>令 <spanclass="math inline">\(F(x)=\prod\limits_{i=1}^{m}G_i(x)\)</span>，<spanclass="math inline">\(x^k\)</span> 的系数就表示所有 <spanclass="math inline">\(v_i\)</span> 的子树一共增加了 <spanclass="math inline">\(k+cnt\)</span> 个 <spanclass="math inline">\(S\)</span> 的方案数。这一步用分治 NTT容易求出。</p><p>现在考虑状态转移。依靠的是 “<span class="math inline">\(u\)</span>的子树中 <span class="math inline">\(S\)</span> 的变化量 <spanclass="math inline">\(=\)</span> 节点 <spanclass="math inline">\(u\)</span> 自身 <spanclass="math inline">\(S\)</span> 的变化量（根据 <spanclass="math inline">\((fa[u],u)\)</span> 是否反转可以是 <spanclass="math inline">\(-1,\ 0,\ 1\)</span>）<spanclass="math inline">\(+\)</span> 所有 <spanclass="math inline">\(v_i\)</span> 的子树中 <spanclass="math inline">\(S\)</span> 的变化量之和”。</p><p>后者就是 <span class="math inline">\(F(x)\)</span> 中的对应系数，分“<span class="math inline">\(fa[u]\)</span> 原本是 <spanclass="math inline">\(S\)</span> 还是 <spanclass="math inline">\(F\)</span>” 和 “<spanclass="math inline">\((fa[u],u)\)</span> 是否反转” 进行转移即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="杭电多校-4">【7.28】杭电多校 4</h2><h3 id="hdu7503.-rikka-与子集-iv">HDU7503. Rikka 与子集 IV</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7503">ProblemLink</a></p><p>任选一个点为根，比如 <span class="math inline">\(1\)</span>。</p><p>令 <span class="math inline">\(dp[x][i]\)</span> 表示以 <spanclass="math inline">\(x\)</span> 为根的子树内，包含 <spanclass="math inline">\(x\)</span> 且大小为 <spanclass="math inline">\(i\)</span> 的连通子图个数，那么 <spanclass="math display">\[dp[x][i]=\sum_{i=j+k} dp[x][j]\cdot dp[y][k]\]</span> 树形背包大多都能用生成函数优化。尝试将 <spanclass="math inline">\([x^j]F_i(x)\)</span> 刻画为以 <spanclass="math inline">\(i\)</span> 为根的子树中，包含 <spanclass="math inline">\(i\)</span> 且大小为 <spanclass="math inline">\(j\)</span> 的连通子图个数。那么 <spanclass="math display">\[F_i(x)=1+x\prod_{j\in \text{son}(i)}F_j(x)\]</span> 开头加的 <span class="math inline">\(1\)</span> 对应 <spanclass="math inline">\(dp[x][0]=1\)</span>，表示不选。</p><p>再令 <span class="math inline">\(S_i(x)=\sum\limits_{j\in\text{subtree}(i),\ j\neq i}F_j(x)\)</span>，答案就是 <spanclass="math inline">\([x^k](F_1(x)+S_1(x))\)</span>。</p><p>直接算仍旧是 <span class="math inline">\(O(n^2\logn)\)</span>，考虑重链剖分。</p><p>令 <span class="math inline">\(s_i\)</span> 表示点 <spanclass="math inline">\(i\)</span> 的重儿子，我们的目标是找到 <spanclass="math inline">\(\{F_i(x),S_i(x)\}\)</span> 和 <spanclass="math inline">\(\{F_{s_i}(x),S_{s_i}(x)\}\)</span>之间的递推关系。</p><p>令 <span class="math inline">\(G_i(x)=\prod\limits_{j\in\text{light}(i)}F_j(x)\)</span>，<spanclass="math inline">\(T_i(x)=\sum\limits_{j\in\text{light}(i)}(F_j(x)+S_j(x))\)</span>，那么 <spanclass="math display">\[\begin{align}F_i(x)&amp;=1+x G_i(x) F_{s_i}(x)\\S_i(x)&amp;=T_i(x)+F_{s_i}(x)+S_{s_i}(x)\end{align}\]</span> 写成矩阵形式，有 <span class="math display">\[\pmatrix{F_i(x) \\ 1\\ S_i(x)}=\pmatrix{xG_i(x) &amp; 1 &amp; 0 \\ 0&amp; 1 &amp; 0 \\ 1 &amp; T_i(x) &amp; 1}\pmatrix{F_{s_i}(x) \\ 1 \\S_{s_i}(x)}\]</span> 边界情况是 <spanclass="math inline">\(F_{\text{leaf}}(x)=1+x\)</span>，<spanclass="math inline">\(S_{\text{leaf}}(x)=0\)</span>。</p><p>于是，我们的策略是：</p><ul><li>从根开始 dfs，一直走轻边，走到底回溯，首先叶子的 <spanclass="math inline">\(F\)</span> 和 <spanclass="math inline">\(S\)</span> 是知道的。</li><li>回溯的时候，对每个点 <span class="math inline">\(i\)</span>，分治NTT 合并它所有轻儿子的 <span class="math inline">\(F\)</span>，得 <spanclass="math inline">\(G_i(x)\)</span>。而 <spanclass="math inline">\(T_i(x)\)</span>也能通过普通的多项式加减得到。</li><li>如此一来，对于一条重链，我们知道了其上所有点的 <spanclass="math inline">\(G_i(x)\)</span> 和 <spanclass="math inline">\(T_i(x)\)</span>。换句话说，知道了重链上每个点的转移矩阵。</li><li>两个矩阵相乘相当于若干次多项式乘法。再次用分治 NTT将这条重链上的所有矩阵合并。这一步基于矩阵具有结合律。</li></ul><p>这样就求得了每条重链链顶的 <span class="math inline">\(F\)</span> 和<span class="math inline">\(S\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><p>HDU 的 submission 貌似只能看自己的，代码就贴下面好了。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> G = <span class="hljs-number">3</span>; <span class="hljs-comment">// 原根</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % mod) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % mod;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">// ---------- 多项式乘法 (NTT) ---------- </span>vector&lt;<span class="hljs-type">int</span>&gt; rev;vector&lt;<span class="hljs-type">int</span>&gt; rt&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)rev.<span class="hljs-built_in">size</span>() != n) &#123;<span class="hljs-type">int</span> k = __builtin_ctz(n) - <span class="hljs-number">1</span>;rev.<span class="hljs-built_in">resize</span>(n);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;rev[i] = rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span> | (i &amp; <span class="hljs-number">1</span>) &lt;&lt; k;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (rev[i] &lt; i) &#123;<span class="hljs-built_in">swap</span>(a[i], a[rev[i]]);&#125;&#125;<span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)rt.<span class="hljs-built_in">size</span>() &lt; n) &#123;<span class="hljs-type">int</span> k = __builtin_ctz(rt.<span class="hljs-built_in">size</span>());rt.<span class="hljs-built_in">resize</span>(n);<span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; k) &lt; n) &#123;<span class="hljs-type">int</span> e = <span class="hljs-built_in">qpow</span>(G, (mod - <span class="hljs-number">1</span>) &gt;&gt; (k + <span class="hljs-number">1</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>); i &lt; (<span class="hljs-number">1</span> &lt;&lt; k); i++) &#123;rt[<span class="hljs-number">2</span> * i] = rt[i];rt[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = rt[i] * e % mod;&#125;k++;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; n; k *= <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span> * k) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<span class="hljs-type">int</span> u = a[i + j];<span class="hljs-type">int</span> v = a[i + j + k] * rt[k + j] % mod;a[i + j] = (u + v) % mod;a[i + j + k] = (u - v + mod) % mod;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">dft</span>(a);<span class="hljs-type">int</span> inv = <span class="hljs-built_in">qpow</span>(n, mod - <span class="hljs-number">2</span>);inv = (inv + mod) % mod;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;a[i] *= inv;a[i] %= mod;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">operator</span>*(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>() || b.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>&#125;;&#125;<span class="hljs-type">int</span> sz = <span class="hljs-number">1</span>, tot = a.<span class="hljs-built_in">size</span>() + b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (sz &lt; tot) &#123;sz &lt;&lt;= <span class="hljs-number">1</span>;&#125;a.<span class="hljs-built_in">resize</span>(sz);b.<span class="hljs-built_in">resize</span>(sz);<span class="hljs-built_in">dft</span>(a);<span class="hljs-built_in">dft</span>(b);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;a[i] *= b[i];a[i] %= mod;&#125;<span class="hljs-built_in">idft</span>(a);a.<span class="hljs-built_in">resize</span>(tot);<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-comment">// ---------- 多项式加减、求导、积分 ----------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shrink</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-keyword">while</span> (a.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; a.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;a.<span class="hljs-built_in">pop_back</span>();&#125;<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) &#123;a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">operator</span>+(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;a.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">size</span>(), b.<span class="hljs-built_in">size</span>()));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); i++) &#123;a[i] += b[i];a[i] %= mod;&#125;<span class="hljs-built_in">shrink</span>(a);<span class="hljs-keyword">return</span> a;&#125;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">operator</span>-(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;a.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">size</span>(), b.<span class="hljs-built_in">size</span>()));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); i++) &#123;a[i] -= b[i];a[i] = (a[i] + mod) % mod;&#125;<span class="hljs-built_in">shrink</span>(a);<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_deriv</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a)</span> </span>&#123;<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">return</span> &#123;&#125;;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;a[i] = a[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;&#125;a.<span class="hljs-built_in">pop_back</span>();<span class="hljs-built_in">shrink</span>(a);<span class="hljs-keyword">return</span> a;&#125;vector&lt;<span class="hljs-type">int</span>&gt; invt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_inv</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (invt.<span class="hljs-built_in">empty</span>()) &#123;        invt.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);        invt[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">int</span> sz = invt.<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">if</span> (n &lt;= sz) &#123;    <span class="hljs-keyword">return</span>;    &#125;    invt.<span class="hljs-built_in">resize</span>(n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sz; i &lt; n; i++) &#123;        invt[i] = (mod - invt[mod % i] * (mod / i) % mod) % mod;    &#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_integral</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a)</span> </span>&#123;<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">return</span> &#123;&#125;;&#125;    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();    <span class="hljs-built_in">pre_inv</span>(n + <span class="hljs-number">1</span>);a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i--) &#123;a[i] = a[i - <span class="hljs-number">1</span>] * invt[i] % mod;&#125;a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-built_in">shrink</span>(a);<span class="hljs-keyword">return</span> a;&#125;<span class="hljs-comment">// ---------- 多项式求逆 (牛顿迭代法) ----------</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_inv</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> &#123;&#125;;&#125;vector&lt;<span class="hljs-type">int</span>&gt; b = &#123;<span class="hljs-built_in">qpow</span>(a[<span class="hljs-number">0</span>], mod - <span class="hljs-number">2</span>)&#125;;<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (k &lt; n) &#123;k &lt;&lt;= <span class="hljs-number">1</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(a.begin(), a.begin() + min((<span class="hljs-type">int</span>)a.size(), k))</span></span>;c = c * b;c.<span class="hljs-built_in">resize</span>(k);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : c) &#123;x = mod - x;&#125;c[<span class="hljs-number">0</span>] = (c[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>) % mod;b = b * c;b.<span class="hljs-built_in">resize</span>(k);&#125;b.<span class="hljs-built_in">resize</span>(n);<span class="hljs-keyword">return</span> b;&#125;<span class="hljs-comment">// ---------- 多项式除法、取模、单点求值 ----------</span>pair&lt;vector&lt;<span class="hljs-type">int</span>&gt;, vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">poly_div</span>(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<span class="hljs-built_in">shrink</span>(a);<span class="hljs-built_in">shrink</span>(b);<span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<span class="hljs-type">int</span> m = b.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span> (n &lt; m) &#123;<span class="hljs-keyword">return</span> &#123;&#123;<span class="hljs-number">0</span>&#125;, a&#125;;&#125;<span class="hljs-keyword">auto</span> ar = a, br = b;<span class="hljs-built_in">reverse</span>(ar.<span class="hljs-built_in">begin</span>(), ar.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(br.<span class="hljs-built_in">begin</span>(), br.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> len = n - m + <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> br_inv = <span class="hljs-built_in">poly_inv</span>(br, len);<span class="hljs-keyword">auto</span> qr = ar * br_inv;qr.<span class="hljs-built_in">resize</span>(len);<span class="hljs-built_in">reverse</span>(qr.<span class="hljs-built_in">begin</span>(), qr.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">auto</span> qb = qr * b;<span class="hljs-keyword">auto</span> r = a - qb;<span class="hljs-built_in">shrink</span>(qr);<span class="hljs-built_in">shrink</span>(r);<span class="hljs-keyword">return</span> &#123;qr, r&#125;;&#125;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">operator</span>%(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">poly_div</span>(a, b).second;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;F, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = F.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;res = (res * x + F[i]) % mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// ---------- 多项式对数函数 O(NlogN) ----------</span><span class="hljs-comment">// 要求: a[0] == 1</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_log</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-built_in">assert</span>(!a.<span class="hljs-built_in">empty</span>() &amp;&amp; a[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>);a.<span class="hljs-built_in">resize</span>(n);<span class="hljs-keyword">auto</span> deriv_a = <span class="hljs-built_in">poly_deriv</span>(a);<span class="hljs-keyword">auto</span> inv_a = <span class="hljs-built_in">poly_inv</span>(a, n);<span class="hljs-keyword">auto</span> res = deriv_a * inv_a;res.<span class="hljs-built_in">resize</span>(n);res = <span class="hljs-built_in">poly_integral</span>(res);res.<span class="hljs-built_in">resize</span>(n);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// ---------- 多项式指数函数 O(NlogN) ----------</span><span class="hljs-comment">// 要求: a[0] == 0</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_exp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-built_in">assert</span>(a.<span class="hljs-built_in">empty</span>() || a[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> &#123;&#125;;&#125;vector&lt;<span class="hljs-type">int</span>&gt; b = &#123;<span class="hljs-number">1</span>&#125;;a.<span class="hljs-built_in">resize</span>(n);<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (k &lt; n) &#123;k &lt;&lt;= <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> log_b = <span class="hljs-built_in">poly_log</span>(b, k);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(a.begin(), a.begin() + min((<span class="hljs-type">int</span>)a.size(), k))</span></span>;c.<span class="hljs-built_in">resize</span>(k, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;c[i] = (c[i] - log_b[i] + mod) % mod;&#125;c[<span class="hljs-number">0</span>] = (c[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) % mod;b = b * c;b.<span class="hljs-built_in">resize</span>(k);&#125;b.<span class="hljs-built_in">resize</span>(n);<span class="hljs-keyword">return</span> b;&#125;<span class="hljs-comment">// ---------- 多项式快速幂 O(NlogN) ----------</span><span class="hljs-comment">// 计算 A(x)^k mod x^n</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_pow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-built_in">shrink</span>(a);    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>() || a.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; a[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);    &#125;<span class="hljs-type">int</span> d = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-keyword">if</span> (a[i] != <span class="hljs-number">0</span>) &#123;d = i;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (d == <span class="hljs-number">-1</span> || d * k &gt;= n) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);&#125;<span class="hljs-type">int</span> c = a[d];<span class="hljs-type">int</span> c_inv = <span class="hljs-built_in">qpow</span>(c, mod - <span class="hljs-number">2</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ap</span><span class="hljs-params">(a.size() - d)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ap.<span class="hljs-built_in">size</span>(); i++) &#123;ap[i] = a[i + d] * c_inv % mod;&#125;ap = <span class="hljs-built_in">poly_log</span>(ap, n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x : ap) &#123;x = x * k % mod;&#125;ap = <span class="hljs-built_in">poly_exp</span>(ap, n);<span class="hljs-type">int</span> ck = <span class="hljs-built_in">qpow</span>(c, k);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + d * k &lt; n &amp;&amp; i &lt; ap.<span class="hljs-built_in">size</span>(); i++) &#123;res[i + d * k] = ap[i] * ck % mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// ---------- 多项式多点求值 O(Mlog^2M) ----------</span>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ptr;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_ptr</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;ptr[p] = &#123;(mod - A[l]) % mod, <span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build_ptr</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, A);<span class="hljs-built_in">build_ptr</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, A);ptr[p] = ptr[p &lt;&lt; <span class="hljs-number">1</span>] * ptr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc_ptr</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; F, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span> </span>&#123;<span class="hljs-keyword">if</span> (r - l &lt; <span class="hljs-number">64</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;res[i] = <span class="hljs-built_in">eval</span>(F, A[i]);&#125;<span class="hljs-keyword">return</span> ;&#125;F = F % ptr[p];<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">calc_ptr</span>(F, p &lt;&lt; <span class="hljs-number">1</span>, l, mid, A, res);<span class="hljs-built_in">calc_ptr</span>(F, p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, A, res);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">multi_eval</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;F, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A)</span> </span>&#123;<span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">return</span> &#123;&#125;;&#125;<span class="hljs-type">int</span> m = A.<span class="hljs-built_in">size</span>();ptr.<span class="hljs-built_in">assign</span>(<span class="hljs-number">4</span> * m, &#123;&#125;);<span class="hljs-built_in">build_ptr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, A);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m)</span></span>;<span class="hljs-built_in">calc_ptr</span>(F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, A, res);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span> &#123;<span class="hljs-type">int</span> n, m;vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; a;<span class="hljs-built_in">matrix</span>() &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>(m, vector&lt;<span class="hljs-type">int</span>&gt;&#123;&#125;)) &#123;&#125;&#125;;matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> matrix &amp;x, <span class="hljs-type">const</span> matrix &amp;y) &#123;<span class="hljs-built_in">assert</span>(x.m == y.n);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(x.n, y.m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; x.m; k++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; y.m; j++) &#123;<span class="hljs-keyword">if</span> (x.a[i][k].<span class="hljs-built_in">empty</span>() || y.a[k][j].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;z.a[i][j] = z.a[i][j] + x.a[i][k] * y.a[k][j];&#125;&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;adj[x].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">son</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);sz[x] += sz[y];<span class="hljs-keyword">if</span> (sz[y] &gt; cnt) &#123;cnt = sz[y];son[x] = y;&#125;&#125;&#125;; <span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>);vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">F</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">S</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i = son[i]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[i]) &#123;<span class="hljs-keyword">if</span> (y != son[i]) &#123;<span class="hljs-built_in">self</span>(self, y);&#125;&#125;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; set_G, set_T;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i = son[i]) &#123;vector&lt;<span class="hljs-type">int</span>&gt; T; vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; set_F;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[i]) &#123;<span class="hljs-keyword">if</span> (y != son[i]) &#123;T = T + F[y];T = T + S[y];set_F.<span class="hljs-built_in">push_back</span>(F[y]);&#125;&#125;<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; vector&lt;<span class="hljs-type">int</span>&gt; &#123;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">return</span> set_F[l];&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>(self, l, mid) * <span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">1</span>, r);&#125;;vector&lt;<span class="hljs-type">int</span>&gt; G;<span class="hljs-keyword">if</span> (set_F.<span class="hljs-built_in">empty</span>()) &#123;G = &#123;<span class="hljs-number">1</span>&#125;;&#125; <span class="hljs-keyword">else</span> &#123;G = <span class="hljs-built_in">calc</span>(calc, <span class="hljs-number">0</span>, set_F.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);&#125;set_G.<span class="hljs-built_in">push_back</span>(G);set_T.<span class="hljs-built_in">push_back</span>(T);&#125;<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; matrix &#123;<span class="hljs-keyword">if</span> (l == r) &#123;matrix <span class="hljs-built_in">res</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = set_G[l];res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);res.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>&#125;;res.a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>&#125;;res.a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>&#125;;res.a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = set_T[l];res.a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>(self, l, mid) * <span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">1</span>, r); &#125;;<span class="hljs-function">matrix <span class="hljs-title">leaf</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)</span></span>;leaf.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;leaf.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>&#125;;matrix res;<span class="hljs-keyword">if</span> (set_G.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;res = leaf;&#125; <span class="hljs-keyword">else</span> &#123;res = <span class="hljs-built_in">calc</span>(calc, <span class="hljs-number">0</span>, set_G.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) * leaf;&#125;F[x] = res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];S[x] = res.a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>];&#125;;<span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> res = F[<span class="hljs-number">1</span>] + S[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; (i &lt; res.<span class="hljs-built_in">size</span>() ? res[i] : <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="牛客多校-5">【7.29】牛客多校 5</h2><h3 id="c.-array-deletion-game">C. Array Deletion Game</h3><p><ahref="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78535003">Code</a></p><p>结论：若 <spanclass="math inline">\(\sum\limits_{i=l+1}^{r-1}&gt;s\)</span>，那么<span class="math inline">\((l, r)\)</span> 与 <spanclass="math inline">\((l+1, r-1)\)</span> 胜负态相同。</p><ul><li>若 <span class="math inline">\((l,r)\)</span> 是必胜态 <spanclass="math inline">\(\to\)</span> <spanclass="math inline">\(\{\)</span>要么 <spanclass="math inline">\((l,r-1)\)</span> 必败<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((1)\)</span> ，<spanclass="math inline">\(\{\)</span>要么 <spanclass="math inline">\((l+1,r)\)</span> 必败<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((2)\)</span>。<ul><li><span class="math inline">\((1)\)</span> 和 <spanclass="math inline">\((2)\)</span> 都能推出 <spanclass="math inline">\((l+1,r-1)\)</span> 必胜。</li></ul></li><li>若 <span class="math inline">\((l,r)\)</span> 是必败态 <spanclass="math inline">\(\to\)</span> <spanclass="math inline">\(\{(l+1,r)\)</span> 必胜<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((3)\)</span>，且 <spanclass="math inline">\(\{(l,r-1)\)</span> 必胜<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((4)\)</span>。<ul><li><span class="math inline">\((3)\)</span> 推出 <spanclass="math inline">\(\{\)</span>要么 <spanclass="math inline">\((l+1,r-1)\)</span> 必败，要么 <spanclass="math inline">\((l+2,r)\)</span> 必败<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((5)\)</span>。</li><li><span class="math inline">\((4)\)</span> 推出 <spanclass="math inline">\(\{\)</span>要么 <spanclass="math inline">\((l+1,r-1)\)</span> 必败，要么 <spanclass="math inline">\((l,r-2)\)</span> 必败<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((6)\)</span>。</li><li>如果 <span class="math inline">\((5)\)</span> 和 <spanclass="math inline">\((6)\)</span> 中第一个子句有一个成立，那么 <spanclass="math inline">\((l+1,r-1)\)</span> 必败。</li><li>否则 <span class="math inline">\(\{(l+2,r)\)</span> 必败<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((7)\)</span>，且 <spanclass="math inline">\(\{(l,r-2)\)</span> 必败<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((8)\)</span>。</li><li><span class="math inline">\((7)\)</span> 推出 <spanclass="math inline">\(\{(l+2,r-1)\)</span> 必胜<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((9)\)</span>，<spanclass="math inline">\((8)\)</span> 推出 <spanclass="math inline">\(\{(l+1,r-2)\)</span> 必胜<spanclass="math inline">\(\}\)</span> <spanclass="math inline">\((10)\)</span>。</li><li>假设 <span class="math inline">\((l+1,r-1)\)</span>是必胜态，那么推出 <span class="math inline">\(\{(l+2,r-1)\)</span>必败，或 <span class="math inline">\((l+1,r-2)\)</span> 必败<spanclass="math inline">\(\}\)</span>，这与 <spanclass="math inline">\((9)(10)\)</span> 矛盾。</li><li>因此，<span class="math inline">\((l+1,r-1)\)</span> 必败。</li></ul></li></ul><p>得证。</p><p>因此，我们可以不断把序列两端各砍掉一个，直到当前 <spanclass="math inline">\(l&#39;, r&#39;\)</span> 满足 <spanclass="math inline">\(\sum\limits_{i=l&#39;+1}^{r&#39;-1}\les\)</span>，即再两边砍一个就寄。</p><p>此时玩家只能不断从一边取数，胜负态确定。</p><p>具体的，设 <span class="math inline">\(fl\)</span>表示最大的下标，满足拿掉 <span class="math inline">\(fl\)</span> 后<span class="math inline">\((fl+1,r&#39;)\)</span> 这一段就 <spanclass="math inline">\(\le s\)</span>；设 <spanclass="math inline">\(fr\)</span> 表示最小的下标，满足拿掉 <spanclass="math inline">\(fr\)</span> 后 <spanclass="math inline">\((l&#39;,fr-1)\)</span> 这一段就 <spanclass="math inline">\(\le s\)</span>。 先手必胜当且仅当 <spanclass="math inline">\(fl-l&#39;\)</span> 是奇数或者 <spanclass="math inline">\(r&#39;-fr\)</span> 是奇数。</p><p>对于一次询问，先一遍二分找出 <spanclass="math inline">\((l&#39;,r&#39;)\)</span>，再两遍二分找出 <spanclass="math inline">\(fl,fr\)</span>。时间复杂度 <spanclass="math inline">\(O(q\log n)\)</span>。</p><h2 id="nwerc-2024">【7.30】NWERC 2024</h2><p><a href="https://codeforces.com/gym/626008">Contest Link</a></p><p>放松场，做的貌似全是签到。剩个 B，队友补了就是我补了（确信</p><h2 id="牛客多校-6">【7.31】牛客多校 6</h2><p>发烧了，头很痛，没打。去校医院开了两盒药，一觉睡到晚上，随手点开题解里的一个easy-mid，发现榜上只过了 20+，没绷住。</p><h2 id="ucup3-18.-seerc-2024">【8.1】Ucup3-18. SEERC 2024</h2><p><a href="https://qoj.ac/contest/1849">Contest Link</a></p><p>感觉没 hdu 有意思，先补一下 hdu。</p><h3 id="lutece3353.-a-boring-game">Lutece3353. A Boring Game</h3><p><ahref="https://cdoj.site/d/lutece/record/688cc1ce385b3643f339badf">Code</a></p><p>今日 hdu 的 A 题弱化，先写一下这题。</p><p>建出一棵 <span class="math inline">\((i, a_i)\)</span>大根笛卡尔树。</p><p>假设当前在点 <span class="math inline">\(i\)</span>，那么点 <spanclass="math inline">\(i\)</span> 子树里的点肯定都能被攻破，相当于每次看“利用当前子树里的所有资源，能否向根节点前进一步”。</p><p>具体的，令 <spanclass="math inline">\(S_x=\sum\limits_{y\in\text{subtree}(x)}b_y\)</span>，那么 <span class="math inline">\(x\)</span> 能走到 <spanclass="math inline">\(fa_x\)</span> 当且仅当 <spanclass="math inline">\(v+S_x\ge a_{fa_x}\)</span>，其中 <spanclass="math inline">\(v\)</span> 表示角色的初始攻击力。</p><p>也就是说，当 <span class="math inline">\(a_{fa_x}-S_x&gt; v\)</span>时，角色就无法继续移动了。对于一个询问 <spanclass="math inline">\((p,v)\)</span>，我们找到 <spanclass="math inline">\(p\)</span> 到根节点的路径上第一个满足 <spanclass="math inline">\(a_{fa_x}-S_x&gt;v\)</span> 的点 ，答案就是 <spanclass="math inline">\(v+S_x\)</span>。而找到 <spanclass="math inline">\(x\)</span> 的过程可以用倍增实现。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h3 id="a.-一个更无聊的游戏">A. 一个更无聊的游戏</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1176&amp;rid=14865">Code</a></p><p>上一题放到了树上。我们仍旧考虑建出 <spanclass="math inline">\((i,a_i)\)</span> 大根笛卡尔树。</p><p>类似点分治的过程，找到最大的 <spanclass="math inline">\(a_i\)</span>，划分为若干子树，然后递归下去。</p><p>比较巧妙的做法是类似今年四川省赛，倒着考虑，按 <spanclass="math inline">\(a_i\)</span> 从小到大枚举 <spanclass="math inline">\(i\)</span>，遍历 <spanclass="math inline">\(i\)</span> 的邻居 <spanclass="math inline">\(j\)</span>，如果 <spanclass="math inline">\(j\)</span> 被遍历过，就把 <spanclass="math inline">\(i\)</span> 设为 <spanclass="math inline">\(j\)</span> 所在连通块的根的祖先。</p><p>建出笛卡尔树后就和上一题无异了。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="ptz-winter-2021-day-8">【8.2】Ptz Winter 2021 Day 8</h2><p><a href="https://qoj.ac/contest/536">Contest Link</a></p><p>今天脑子有点好，感觉写了很多题，不过还是没搞出 E，可惜。</p><h3 id="f.-border-similarity-undertaking">F. Border SimilarityUndertaking</h3><p><a href="https://qoj.ac/submission/1200136">Code</a></p><p>分治。设当前处理的矩形为 <span class="math inline">\([l_1,r_1]\times[l_2,r_2]\)</span>。如果 <spanclass="math inline">\(r_1-l_1&gt;r_2-l_2\)</span>，我们就把矩形转一下，保证矩形的宽度大于高度，接着在中间砍一刀，分成<span class="math inline">\([l_1,r_1]\times [l_2,mid]\)</span> 和 <spanclass="math inline">\([l_1,r_l]\times [mid+1,r_2]\)</span>两部分，如此递归下去。</p><p>每次，我们计数 “左边界小于等于 <spanclass="math inline">\(y=mid\)</span>” 且 “右边界大于等于 <spanclass="math inline">\(y=mid+1\)</span>” 的矩形。</p><p><span class="math inline">\(\forall i\in[l_1,r_1]\)</span>，扫描这一行，找到最小的 <spanclass="math inline">\(L[i]\)</span> 和最大的 <spanclass="math inline">\(R[i]\)</span>，其中 <spanclass="math inline">\(l_2\le L[i]\le mid &lt; R[i]\le r_2\)</span>，满足<span class="math inline">\((i,L[i])\sim (i,R[i])\)</span>为同种字母。同样的，还要处理出 <spanclass="math inline">\(D[i][j]\)</span> 表示 <spanclass="math inline">\((i,j)\)</span> 向下最多能延伸多少格。</p><p>在中心线上，我们枚举待计数矩形的上下边界，贡献可以用前缀和 or树状数组加速计算。</p><p>时间复杂度 <span class="math inline">\(O(nm\lognm)\)</span>。代码里我图方便写的双 <spanclass="math inline">\(\log\)</span>，同样跑得飞快。</p><h2 id="杭电多校-6">【8.4】杭电多校 6</h2><p>前期题做的太慢了，1005 其实很简单但最后一小时二择的时候选了1012。</p><h3 id="钥匙迷宫">1005. 钥匙迷宫</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1177&amp;rid=12268">Code</a></p><p>用大写字母表示锁，小写字母表示钥匙。</p><p>对于一组 <span class="math inline">\((X,x)\)</span>，容易看出：以<span class="math inline">\(x\)</span> 为根时，<spanclass="math inline">\(X\)</span> 子树里的点的答案均为 <spanclass="math inline">\(0\)</span>。可以用树上差分标记所有不能作为起点的<span class="math inline">\(x\)</span>。此时，剩下的能作为起点的 <spanclass="math inline">\(x\)</span>一定形成一个连通块（连通块里只有钥匙没有锁）。</p><p>从这些点出发bfs，模拟开锁的过程，看是否能遍历完图上所有点。若能，则这些起点答案为<span class="math inline">\(1\)</span>，其余为 <spanclass="math inline">\(0\)</span>；否则，答案全为 <spanclass="math inline">\(0\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h3 id="cats-的加减乘除">1012. cats 的加减乘除</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1177&amp;rid=13817">Code</a></p><p>首先，一个符号位填入 <code>+</code> 和 <code>-</code>的概率是均等的。意味着任何一段接在加减后的仅包含乘除的连续段，期望为<spanclass="math inline">\(0\)</span>。因此，整个表达式的期望等于从头开始的乘除连续段的期望。</p><p>分两步，第一步计算所有方案对应的表达式的值之和，第二步计算方案数（即有多少种不同的表达式），二者相除就是期望。</p><p>第二步是简单的，令 <span class="math inline">\(c=\sum[p_i=-1]\)</span>，答案是 <span class="math inline">\(c!\cdot4^{n-1}\)</span>。</p><p>对于第一步，枚举长度 <spanclass="math inline">\(i\)</span>，表示从头开始仅包含乘除的段的长度。设所有长为<span class="math inline">\(i\)</span> 的这样的段的表达式值之和为 <spanclass="math inline">\(\text{ans}[i]\)</span>，答案就是 <spanclass="math inline">\(\text{ans}[i]\times 2\times4^{n-i-1}\)</span>。意为这段紧接的是 <code>+</code> 或<code>-</code>，而之后的符号随便填。</p><p>现在，题目转化为，对每个 <span class="math inline">\(i\in [1,n]\)</span>，求 <span class="math inline">\(\text{ans}[i]\)</span>。</p><p>如果没有 <span class="math inline">\(p_i=-1\)</span>，则 <spanclass="math inline">\(\text{ans}[k]=a_1\prod\limits_{i=2}^{k}\left(a_i+\dfrac{1}{a_i}\right)\)</span>。</p><p>如果存在 <span class="math inline">\(p_i=-1\)</span>，设有 <spanclass="math inline">\(m\)</span> 个 <spanclass="math inline">\(-1\)</span>，这 <spanclass="math inline">\(m\)</span>个位置需要填入序列中没有的数，设这些将要填入的数分别为 <spanclass="math inline">\(b_1,b_2,\ldots,b_m\)</span>。</p><p>发现如果 <spanclass="math inline">\(p_1=-1\)</span>，那将是特殊的，因为 <spanclass="math inline">\(p_1\)</span> 不能是除数。</p><p>分类讨论。当 <span class="math inline">\(p_1\neq -1\)</span> 时，令<span class="math display">\[F(x)=\prod_{i=1}^{m}\left(1+\left(b_i+\dfrac{1}{b_i}\right)x\right)\]</span> 填入 <span class="math inline">\(m\)</span> 项中的 <spanclass="math inline">\(s\)</span> 项，所有表达式的值之和即为 <spanclass="math inline">\([x^s]F(x)\)</span>。这部分用分治 NTT容易计算。</p><p>若 <span class="math inline">\(p_1=-1\)</span>，我们只能钦定 <spanclass="math inline">\(p_1\)</span> 是什么，枚举所有 <spanclass="math inline">\(p_1\)</span> 的可能取值并求和，答案是 <spanclass="math display">\[[x^s]\sum_{i=1}^{m}\dfrac{b_ix}{\left(1+(b_i+\frac{1}{b_i})x\right)}\prod_{i=1}^{m}\left(1+\left(b_j+\dfrac{1}{b_j}\right)x\right)\tag{*}\]</span> 我们重点关注前面那个和式怎么算。</p><p>这个和式是 <span class="math inline">\(m\)</span>个一次分式相加，我们可以将其通分，具体的 <span class="math display">\[\dfrac{F_1(x)}{G_1(x)}+\dfrac{F_2(x)}{G_2(x)}=\dfrac{F_1(x)G_2(x)+F_2(x)G_1(x)}{G_1(x)G_2(x)}\]</span> 等价于三次多项式乘法。我们可以沿用分治 NTT的方法，将每个一次分式作为叶子，回溯时合并上去。</p><p>最后通分完分母可以与 <span class="math inline">\((*)\)</span>式右侧约去，只剩下分子。当然就算你没注意到也只不过多一次多项式求逆而已。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="牛客多校-7">【8.5】牛客多校 7</h2><p>今天过题过得特别快，剩个 H，队友补了就是我补了（确信</p><h2 id="ucup3-35.-kraków">【8.6】Ucup3-35. Kraków</h2><p><a href="https://qoj.ac/contest/1993">Contest Link</a></p><p>F 挺有意思，但是不太会，等 dwdyy 会了教我（躺</p><h2 id="牛客多校-8">【8.7】牛客多校 8</h2><div class="note note-primary">            <p>【整体二分】</p><p>适用：单个询问可以二分解决，询问能离线，询问间没有顺序依赖。</p><p>做法：对值域二分，通常是四元组 <span class="math inline">\((l, r,\{p\},\{q\})\)</span>，表示当前研究的询问的答案在 <spanclass="math inline">\([l, r]\)</span> 内，<spanclass="math inline">\(\{p\}\)</span>是当前要考虑的元素/修改操作的集合，<spanclass="math inline">\(\{q\}\)</span> 是当前要考虑的询问集合。</p><p>很难说得清怎么做。下面是静态区间第 <spanclass="math inline">\(k\)</span> 小的板子。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        静态区间第 k 小    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; p;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;p.<span class="hljs-built_in">push_back</span>(&#123;x, i&#125;);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 4&gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> l, r, k;cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;q.<span class="hljs-built_in">push_back</span>(&#123;l, r, k, i&#125;);&#125;<span class="hljs-function">Fenwick <span class="hljs-title">fen</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;&gt; &amp;p, vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">4</span>&gt;&gt; &amp;q) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (l == r || q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, __, k, i] : q) &#123;ans[i] = l;&#125;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; pl, pr;vector&lt;array&lt;<span class="hljs-type">int</span>, 4&gt;&gt; ql, qr;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;cur : p) &#123;<span class="hljs-keyword">auto</span> &amp;[val, i] = cur; <span class="hljs-keyword">if</span> (val &lt;= mid) &#123;pl.<span class="hljs-built_in">push_back</span>(cur);fen.<span class="hljs-built_in">add</span>(i, <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;pr.<span class="hljs-built_in">push_back</span>(cur);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;cur : q) &#123;<span class="hljs-keyword">auto</span> &amp;[L, R, k, i] = cur;<span class="hljs-type">int</span> res = fen.<span class="hljs-built_in">query</span>(L, R);<span class="hljs-keyword">if</span> (k &lt;= res) &#123;ql.<span class="hljs-built_in">push_back</span>(cur);&#125; <span class="hljs-keyword">else</span> &#123;k -= res;qr.<span class="hljs-built_in">push_back</span>(cur);&#125;&#125;fen.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">self</span>(self, l, mid, pl, ql);<span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">1</span>, r, pr, qr);&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">1e9</span>, p, q);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;</code></pre></div>    </div></div><h3 id="h.-区间-lru">H. 区间 LRU</h3><p><ahref="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78738981">Code</a></p><p>令 <span class="math inline">\(pre[i]\)</span> 表示 <spanclass="math inline">\(a_i\)</span> 上一次出现的位置，<spanclass="math inline">\(f[i]\)</span> 表示区间 <spanclass="math inline">\([pre[i]+1,i-1]\)</span> 中不同的数的个数。</p><p>运用树状数组容易预处理出全部的 <spanclass="math inline">\(f[i]\)</span>，详见 <ahref="https://www.luogu.com.cn/problem/P1972">Link</a>。</p><p>对于第一种类型的询问，相当于问 <span class="math inline">\([l,r]\)</span> 中有多少个 <span class="math inline">\(i\)</span>，满足<span class="math inline">\(pre[i]\ge l\)</span> 且 <spanclass="math inline">\(f[i]&lt;k\)</span>。</p><p>对于第二种类型的询问，相当于问 <spanclass="math inline">\([l,r]\)</span> 中 <spanclass="math inline">\(f[i]\)</span> 的第 <spanclass="math inline">\(k\)</span> 小值。</p><p>整体二分，对于当前四元组 <span class="math inline">\((l,r,\{p\},\{q\})\)</span>，按右端点 <span class="math inline">\(r\)</span>升序遍历所有询问，将所有 <span class="math inline">\(p[i]\ler\)</span>，<span class="math inline">\(f[p[i]]\le mid\)</span> 的 <spanclass="math inline">\(i\)</span> 对应的 <spanclass="math inline">\(pre[i]\)</span>加进树状数组。后面就是标准的处理了。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="杭电多校-7">【8.8】杭电多校 7</h2><p>倒闭 +1。</p><p>1002 想了个和题解完全不同的做法，很麻烦，所以还是补一下正解。</p><h3 id="qoj9904.-最小生成树">QOJ9904. 最小生成树</h3><p><a href="https://qoj.ac/submission/1213030">Code</a></p><p>很有意思的题。</p><p>暴力的做法是：将 <span class="math inline">\(a_i\)</span>从小到大排序，假设当前为 <spanclass="math inline">\(a_k\)</span>，我们可以用并查集将所有 <spanclass="math inline">\(i+j=k\)</span> 且不在一个连通块的 <spanclass="math inline">\((i,j)\)</span> 连起来，支付 <spanclass="math inline">\(a_k\)</span> 的代价。</p><p>我们考虑加速这个过程。对于一个固定的 <spanclass="math inline">\(k\)</span>，所有 <spanclass="math inline">\(i+j=k\)</span> 的 <spanclass="math inline">\((i,j)\)</span> 需要满足 <spanclass="math inline">\(1\le i\le n,\ 1\le j=k-i\le n\)</span>，也就是<span class="math inline">\(\max(1,k-n)\le i\le\min(n,k-1)\)</span>，我们将这个区间称作 <spanclass="math inline">\([l,r]\)</span>。</p><p>在这个区间里，每一对 <span class="math inline">\((i,j)\)</span>都关于 <span class="math inline">\(\dfrac{k}{2}\)</span> 对称，也就是<span class="math inline">\((l, r)\)</span>，<spanclass="math inline">\((l+1,r-1)\)</span>，<spanclass="math inline">\((l+2,r-2)\)</span>，<spanclass="math inline">\(\ldots\)</span> 这样组合。</p><p>做最小生成树时，我们会用并查集连边，令 <spanclass="math inline">\(f_i\)</span> 表示点 <spanclass="math inline">\(i\)</span> 所在连通块的根。</p><p>观察：将所有 <span class="math inline">\(i+j=k\)</span> 的 <spanclass="math inline">\((i,j)\)</span> 全连起来后，区间 <spanclass="math inline">\([l, r]\)</span> 对应的 <spanclass="math inline">\(f\)</span> 数组回文。</p><p>我们反复 check 区间 <span class="math inline">\([l,r]\)</span>，如果不回文，就二分找到第一个不回文的位置，并查集连起来，累加<span class="math inline">\(a_k\)</span> 的贡献。</p><p>具体的，线段树维护正串哈希值和反串哈希值，二分一个固定的长度 <spanclass="math inline">\(p\)</span>，判断 <spanclass="math inline">\([l,r]\)</span> 内长为 <spanclass="math inline">\(p\)</span> 的前缀的正串和长为 <spanclass="math inline">\(p\)</span> 的后缀的反串是否相等。</p><p>因为生成树只用连 <span class="math inline">\(n-1\)</span>次，只会执行 <span class="math inline">\(O(n)\)</span>次二分，每次线段树 check，总复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p><p>另有单 <span class="math inline">\(\log\)</span> 的做法，占坑。</p><h3 id="切披萨">1011. 切披萨</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1178&amp;rid=17840">Code</a></p><p>离线整体二分。</p><p>为了方便之后切上凸壳，预先对点集（以下称 <spanclass="math inline">\(\{p\}\)</span>）按 <spanclass="math inline">\(x\)</span> 坐标从小到大排序，询问（直线集合，下称<span class="math inline">\(\{q\}\)</span>）按斜率 <spanclass="math inline">\(\left(-\dfrac{A}{B}\right)\)</span>从小到大排序，斜率相同优先截距 <spanclass="math inline">\(\left(\dfrac{C}{B}\right)\)</span> 大的。</p><p>对于当前四元组 <spanclass="math inline">\((l,r,\{p\},\{q\})\)</span>，将编号小于等于 <spanclass="math inline">\(mid\)</span> 的询问分进 <spanclass="math inline">\(\{ql\}\)</span>，否则分进 <spanclass="math inline">\(\{qr\}\)</span>。</p><p>问题是 <span class="math inline">\(\{p\}\)</span>要如何划分。一个点被分进 <span class="math inline">\(\{pl\}\)</span>当且仅当它在某一条 <span class="math inline">\(\{ql\}\)</span>内的线段下方。</p><p>单调栈切出 <span class="math inline">\(\{ql\}\)</span>的上凸壳，不仅记录组成上凸壳的每条直线的信息，还要处理出上凸壳上每个交点的横坐标，这样就可以按<span class="math inline">\(x\)</span> 坐标从小到大遍历 <spanclass="math inline">\(\{p\}\)</span>中的每个点，双指针移动到凸壳上对应的直线，判断当前点是否满足 <spanclass="math inline">\(Ax+By\le C\)</span>。满足的分到 <spanclass="math inline">\(\{pl\}\)</span>，否则分到 <spanclass="math inline">\(\{pr\}\)</span>。</p><p>算交点横坐标时，可以直接取整数，因为 <spanclass="math inline">\(\{p\}\)</span> 中均为整点。举个例子，若真实的<span class="math inline">\(x=5.7\)</span>，你取 <spanclass="math inline">\(x’=5\)</span>，那么满足 <spanclass="math inline">\(y\le x\)</span> 的 <spanclass="math inline">\(y\)</span> 也满足 <span class="math inline">\(y\lex&#39;\)</span>；满足 <span class="math inline">\(y&gt;x\)</span> 的<span class="math inline">\(y\)</span> 也满足 <spanclass="math inline">\(y&gt;x&#39;\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\logn)\)</span>。注意不要输出行末空格，问就是 hduoj 特性。</p><h3 id="龙族栖息地">1002. 龙族栖息地</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1178&amp;rid=17856">Code</a></p><p>观察可得，两点 <spanclass="math inline">\((q_1,r_1,s_1),(q_2,r_2,s_2)\)</span>间的最短距离是 <spanclass="math inline">\(\dfrac{|q_1-q_2|+|r_1-r_2|+|s_1-s_2|}{2}\)</span>。</p><p>设核心房间的坐标是 <spanclass="math inline">\((x,y,-x-y)\)</span>，那么任务是最小化 <spanclass="math display">\[f(x,y)=\sum_{i=1}^{n}\left(|x-q_i|+|y-r_i|+|-x-y-s_i|\right)\]</span> 对于一个固定的 <span class="math inline">\(x\)</span>，寻找<span class="math inline">\(y\)</span> 使得 <spanclass="math inline">\(f(x,y)\)</span> 最小是一个经典问题。结论是 <spanclass="math inline">\(y\)</span> 取 <spanclass="math inline">\(\{r_1,r_2,\ldots,r_n,-x-s_1,-x-s_2,\ldots,-x-s_n\}\)</span>这 <span class="math inline">\(2n\)</span> 个数的中位数是最优的。利用<code>std::nth_element</code> 可以线性取出。</p><p>但枚举每一个 <span class="math inline">\(x\)</span>复杂度依然很大。注意到 <span class="math inline">\(f(x,y)\)</span>展开式中的三项每一项都关于 <span class="math inline">\(x,y\)</span>二维下凸，求和后依然二维下凸。因此，三分找到最优的 <spanclass="math inline">\(x\)</span> 即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p><h2 id="ptz-summer-2020-day-3">【8.9】Ptz Summer 2020 Day 3</h2><p><a href="https://qoj.ac/contest/503">Contest Link</a></p><p>挺有意思的场，可补的题挺多的。</p><h3 id="c.-count-on-a-tree-ii-striking-back">C. Count on a Tree IIStriking Back</h3><p><a href="https://qoj.ac/submission/1215742">Code</a></p><p><span class="math inline">\(f(a,b)\ge 2f(c,d)\)</span> 或 <spanclass="math inline">\(f(c,d)\ge 2f(a,b)\)</span>是一个重要的突破点。</p><p>考虑随机化，对于 <span class="math inline">\(k\)</span> 个 <spanclass="math inline">\([0,1]\)</span> 内的实数随机变量，最小值的期望是<span class="math inline">\(\dfrac{1}{k+1}\)</span>。</p><p>我们对每一种颜色随机一个整数，称作哈希值。对于一次询问 <spanclass="math inline">\((a,b,c,d)\)</span>，令 <spanclass="math inline">\(g(a,b)\)</span> 表示 <spanclass="math inline">\(a,b\)</span>两点的简单路径上每个点对应颜色的哈希值的最小值。如果 <spanclass="math inline">\(g(a,b)&lt;g(c,d)\)</span>，我们就能估计 <spanclass="math inline">\(f(a,b)&gt;f(c,d)\)</span>。</p><p>将上述看成一次试验，为保证正确性，我们要进行 <spanclass="math inline">\(B\)</span> 次试验，在这 <spanclass="math inline">\(B\)</span> 次试验中，每次都为所有 <spanclass="math inline">\(n\)</span> 种颜色重新分配哈希值。</p><p>令 <span class="math inline">\(S_{a,b}\)</span> 表示 <spanclass="math inline">\(B\)</span> 次试验中 <spanclass="math inline">\(g(a,b)\)</span> 之和，若 <spanclass="math inline">\(S_{a,b}&lt;S_{c,d}\)</span>，就判定 <spanclass="math inline">\(f(a,b)&gt;f(c,d)\)</span>，此时错误率已经足够低。</p><p>建出 <span class="math inline">\(B\)</span>棵线段树跑重链剖分，时间复杂度 <spanclass="math inline">\(O(nB+mB\log^2n)\)</span>。</p><h2 id="杭电多校-8">【8.11】杭电多校 8</h2><h3 id="最遥远的路">1001. 最遥远的路</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1179&amp;rid=13981">Code</a></p><p>考虑单个询问 <span class="math inline">\([ql, qr]\)</span>怎么做。</p><p>令 <span class="math inline">\(dp[x]\)</span> 表示以 <spanclass="math inline">\(x\)</span> 结尾的最长路径长度。按边权 <spanclass="math inline">\(w\)</span> 从小到大的顺序依次枚举 <spanclass="math inline">\(w\in [ql, qr]\)</span> 的边转移，有 <spanclass="math display">\[dp[y]=\max_{(x,y,w,d)}dp[x]+d\]</span> 若初始 <span class="math inline">\(dp[i]=0,\dp[\text{others}]=-\infty\)</span>，得到的就是以 <spanclass="math inline">\(i\)</span> 为起点，<spanclass="math inline">\(x\)</span> 为终点的最长路径长度。</p><p>线段树分治。对于线段树上一个点 <span class="math inline">\([l,r]\)</span>，存储所有跨过 <spanclass="math inline">\(\dfrac{l+r}{2}\)</span> 的询问。对于一个询问 <spanclass="math inline">\([ql, qr]\)</span>，将其拆分到线段树上的 <spanclass="math inline">\(\log\)</span>个节点上，二分确定每个节点对应该询问的边界。</p><p>分治计算时，设当前为 <span class="math inline">\((l,r)\)</span>，枚举 <span class="math inline">\(1\sim n\)</span>中的每个点 <span class="math inline">\(i\)</span> 作为中转点，在 <spanclass="math inline">\(\text{mid}\)</span> 两侧分别 dp，算出：<spanclass="math inline">\(d1[x]\)</span> 表示 <spanclass="math inline">\((l,\text{mid})\)</span> 中以 <spanclass="math inline">\(x\)</span> 为起点，<spanclass="math inline">\(i\)</span> 为终点的最长路径长度；<spanclass="math inline">\(d2[x]\)</span> 表示 <spanclass="math inline">\((\text{mid} + 1,r)\)</span> 中以 <spanclass="math inline">\(i\)</span> 为起点，<spanclass="math inline">\(x\)</span>为终点的最长路径长度。这样，对于当前节点的每一组询问 <spanclass="math inline">\([ql, qr]\)</span>，就能用如下式子更新答案。 <spanclass="math display">\[\max_{i=ql}^{\text{mid}} d1[i]+\max_{j=\text{mid}+1}^{qr}d2[j]\]</span> 时间复杂度 <span class="math inline">\(O(nm\log m+q\logm)\)</span>。</p><h3 id="不最近的路">1002. 不最近的路</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1179&amp;rid=15881">Code</a></p><p>先考虑在题给的新定义下如何求最短路。</p><p>直接做并不好做，注意到图的边权很小，我们可以枚举边权第 <spanclass="math inline">\(k\)</span> 大的边的权值。</p><p>算法流程如下，感性理解是容易的，详细证明可以看官方题解。</p><ul><li>枚举边权第 <span class="math inline">\(k\)</span> 大的边的权值 <spanclass="math inline">\(v\)</span>（包括 <spanclass="math inline">\(v=0\)</span>）。</li><li>将每条边 <span class="math inline">\((x,y,w)\)</span> 的边权 <spanclass="math inline">\(w\)</span> 重新设置为 <spanclass="math inline">\(w&#39;=\max(0,w-v)\)</span>。</li><li>跑 Dijkstra，得到 <spanclass="math inline">\(dis_v[i]\)</span>，表示从点 <spanclass="math inline">\(1\)</span> 到各个点的距离。</li><li>新定义下 <span class="math inline">\(1\to n\)</span>的最短路权值即为 <spanclass="math inline">\(\min\limits_{v}dis_{v}[n]+kv\)</span>。</li></ul><p>如何求次短路？实际上，次短路仍然可以通过上述算法求出，只不过要求“和求出的最短路不完全重合”。</p><p>为此，我们在跑 Dij 时顺便记录如下两个信息：</p><ul><li><span class="math inline">\(\text{pre}[y]=x\)</span>：表示 <spanclass="math inline">\(y\)</span> 的上一步由 <spanclass="math inline">\(x\)</span> 转移而来。</li><li><span class="math inline">\(\text{nxt}[y]=i\)</span>：其中 <spanclass="math inline">\(i\)</span> 是边 <spanclass="math inline">\((x,y)\)</span> 的编号，这条信息就表示 <spanclass="math inline">\(y\)</span> 从 <spanclass="math inline">\(x\)</span> 的哪条出边转移而来。</li></ul><p>你可能认为只用记录其中一个就行了，但实际上你要考虑次短路可以经过同一个点两次。杭电的数据很水，实测只记录<span class="math inline">\(\text{nxt}\)</span> 就能 AC，一眼随的。</p><p>令 <span class="math inline">\(\text{dis}[x][1]\)</span> 表示到达<span class="math inline">\(x\)</span>的路径完全是第一步算出的最短路的一个前缀，<spanclass="math inline">\(\text{dis}[x][0]\)</span> 表示当前到 <spanclass="math inline">\(x\)</span>的路径已经偏移了最短路，松弛的时候就是： <span class="math display">\[\text{dis}[y][f&#39;]=\min_{f&#39;=f\  \land\  \text{nxt}[y]=i\ \land \\text{pre}[y]=x} \text{dis}[x][f]+w\]</span> 初态 <spanclass="math inline">\(\text{dis}[1][1]=0\)</span>，答案就是 <spanclass="math inline">\(\text{dis}[n][0]\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(m^2\log m)\)</span>。</p><h2 id="牛客多校-9">【8.12】牛客多校 9</h2><p>简单场，但烂完了。</p><h3 id="i.-tree-construction">I. Tree Construction</h3><p><ahref="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78816916">Code</a></p><p>考虑一个简化的问题：给定一棵树的 <spanclass="math inline">\(\text{dis}[i][j]\)</span>，能否还原出树的结构？</p><p>答案是肯定的。将所有 <span class="math inline">\(n^2\)</span> 组<span class="math inline">\(\text{dis}[i][j]\)</span>从小到大排序，每次并查集合并不在同一连通块的两点，最终得到的最小生成树即为所求。原理是：相邻的点因为边权更小，会优先合并。</p><p>回到这题，注意到无论 <spanclass="math inline">\(\text{d1}[i][j]\)</span> 和 <spanclass="math inline">\(\text{d2}[i][j]\)</span> 怎么交换，<spanclass="math inline">\(\text{d}1[i][j]+\text{d}2[i][j]\)</span>都是定值。于是，我们将 <spanclass="math inline">\(\text{d}1[i][j]+\text{d}2[i][j]\)</span> 作为<span class="math inline">\((i,j)\)</span>的边权，跑最小生成树，就能还原树的结构。原理是：相邻的点同样因为 <spanclass="math inline">\(\text{d}1[i][j]+\text{d}2[i][j]\)</span>更小，会优先合并。</p><p>接下来，要确定 <span class="math inline">\(\text{d1}[i][j]\)</span>和 <span class="math inline">\(\text{d2}[i][j]\)</span>如何分配到两棵树上（称为树 <span class="math inline">\(T_1\)</span> 和树<span class="math inline">\(T_2\)</span>）。我们任取一点为根dfs，当前边为 <span class="math inline">\((u,v)\)</span>，不妨先假设<span class="math inline">\(w_1=\text{d1}[u][v]\)</span> 属于 <spanclass="math inline">\(T_1\)</span>，<spanclass="math inline">\(w_2=\text{d2}[u][v]\)</span> 属于 <spanclass="math inline">\(T_2\)</span>，然后遍历已经经过的点，看有没有冲突的地方。有冲突，就交换<span class="math inline">\(w_1\)</span> 和 <spanclass="math inline">\(w_2\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p><h2 id="ucup3-21.-ōokayama">【8.13】Ucup3-21. Ōokayama</h2><p><a href="https://qoj.ac/contest/1872">Contest Link</a></p><p>好难的场。</p><h3 id="m.-cartesian-trees">M. Cartesian Trees</h3><p><a href="https://qoj.ac/submission/1223380">Code</a></p><p>考虑给每个询问的区间 <span class="math inline">\([l, r]\)</span>搞出一个哈希值，这样只用统计有多少不同的哈希值。</p><p>如果两个区间的笛卡尔树同构，哈希值必须相同。我们要想办法提取出一个区间的特征。</p><p>令 <span class="math inline">\(L[i]\)</span> 表示 <spanclass="math inline">\(i\)</span> 左侧最近的 <spanclass="math inline">\(&lt;a_i\)</span> 的位置，<spanclass="math inline">\(R[i]\)</span> 表示 <spanclass="math inline">\(i\)</span> 右侧最近的 <spanclass="math inline">\(&lt;a_i\)</span> 的位置。</p><p>一个想法是，对于一个区间 <spanclass="math inline">\([l,r]\)</span>，我们保存所有满足 <spanclass="math inline">\(l\le L[i]&lt;i\le r\)</span> 的 <spanclass="math inline">\(i-L[i]\)</span>（这表示笛卡尔树上左子树的大小），并按<span class="math inline">\(i\)</span> 升序保存它们，得到一个列表 <spanclass="math inline">\(\{i_1-L[i_1],i_2-L[i_2],\ldots\}\  (i_1&lt;i_2&lt;\ldots)\)</span>，称作<span class="math inline">\(f_1[l,r]\)</span>。</p><p>同样的，对于所有满足 <span class="math inline">\(l\le i&lt;R[i]\ler\)</span> 的 <spanclass="math inline">\(R[i]-i\)</span>（这对于笛卡尔树上右子树的大小），按<span class="math inline">\(i\)</span> 升序保存它们，得到 <spanclass="math inline">\(\{R[i_1]-i_1,R[i_2]-i_2,\ldots\}\(i_1&lt;i_2&lt;\ldots)\)</span>，称作 <spanclass="math inline">\(f_2[l,r]\)</span>。</p><p>两个区间 <span class="math inline">\([l_1,r_1],[l_2,r_2]\)</span>的笛卡尔树同构，当且仅当 <spanclass="math inline">\(f_1[l_1,r_1]=f_1[l_2,r_2]\)</span> 且 <spanclass="math inline">\(f_2[l_1,r_1]=f_2[l_2,r_2]\)</span>。而对于不同构的两个区间，两个等号必有一个不能取到。</p><p>于是，我们将二元组 <span class="math inline">\((f_1[l, r], f_2[l,r])\)</span> 作为区间 <span class="math inline">\([l, r]\)</span>的哈希值是合适的。</p><p>怎么对所有 <span class="math inline">\(Q\)</span>个区间求出哈希值？我们将每个 <span class="math inline">\(i-L[i]\)</span>和 <span class="math inline">\(R[i]-i\)</span>看作一个字符，查询一段区间的 <span class="math inline">\(i-L[i]\)</span>的列表就相当于用字符串哈希询问一个区间的哈希值。</p><p>将所有询问离线，扫描线，对于一组 <spanclass="math inline">\((L[i],i)\)</span>，我们在 <spanclass="math inline">\(i\)</span> 时刻将 <spanclass="math inline">\(i-L[i]\)</span> 的单点哈希值加进树状数组的 <spanclass="math inline">\(L[i]\)</span> 位置。<spanclass="math inline">\((i,R[i])\)</span> 同理。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="牛客多校-10">【8.14】牛客多校 10</h2><p>罚时吃得最饱的一场。疑似凌晨 4 点睡导致脑子一团浆糊，狂暴 wa了四发才醒过来。</p><p>水母，嘿嘿嘿。海星，嘿嘿嘿。鳗鱼，嘿嘿嘿。</p><h2 id="杭电多校-9">【8.15】杭电多校 9</h2><p>三开大失败。虽然我 1007 已经想清楚了，但脑瘫写了个可能会退化到 <spanclass="math inline">\(O(n^2)\)</span> 的东西。</p><p>不过赛后发现即便改过来了，<code>map&lt;array&lt;int, 2&gt;, int&gt;</code>的常数还是很大。</p><p>又狂 T 了十几发之后，终于发现开 <spanclass="math inline">\(n\)</span> 个 <code>map&lt;int, int&gt;</code>会大幅减小常数，之后才过。</p><p>挺好的题，从 <ahref="https://www.luogu.com.cn/article/32975dk3">Link</a>里学到了怎么找到三角剖分里的所有三角形，并为每条有向线段找到逆时针方向的三角形顶点编号。非常巧妙，代码也很短，感谢Diaosi 的指导。</p><h3 id="三角剖分">1007. 三角剖分</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1180&amp;rid=14506&amp;from=rank">Code</a></p><p>首先，任意简单多边形的任一三角剖分的对偶图是一个 “任一节点度数至多为<span class="math inline">\(3\)</span>”的树。也就是说，当你选定任意一点为根，呈现出的是一棵二叉树。</p><p>我们可以在这棵树上进行dp。当然，也可以不显式把树建出来，直接分治求解。</p><p><img src="/image/academic/tri.png" /></p><p>如上图，以对角线 <span class="math inline">\((x,y)\)</span> 为例，在<span class="math inline">\((x,y)\)</span> 右侧（或者说 <spanclass="math inline">\(\overrightarrow{xy}\)</span>的逆时针方向），所在三角形是 <spanclass="math inline">\(xyz\)</span>，我们可以把问题递归到边 <spanclass="math inline">\((x,z)\)</span> 和 <spanclass="math inline">\((z,y)\)</span>。而 <spanclass="math inline">\((x,z)\)</span> 逆时针方向是三角形 <spanclass="math inline">\(xzw_1\)</span>，我们又可以递归到 <spanclass="math inline">\((x,w_1)\)</span> 和 <spanclass="math inline">\((w_1,z)\)</span>。此时已经到了多边形边界，递归停止。</p><p>为方便表述，定义 <span class="math inline">\(S(x,y)\)</span> 表示<span class="math inline">\(\overrightarrow{xy}\)</span>与其逆时针方向的凸多边形边界围成的子多边形。例如，图中 <spanclass="math inline">\(S(x,y)\)</span> 就表示多边形 <spanclass="math inline">\(xyw_2zw_1\)</span>，而 <spanclass="math inline">\(S(y,x)\)</span> 就表示多边形 <spanclass="math inline">\(yxw_3\)</span>。定义 <spanclass="math inline">\(p(x,y)\)</span> 表示 <spanclass="math inline">\(\overrightarrow{xy}\)</span>逆时针方向的三角形顶点编号，对于图中就是 <spanclass="math inline">\(p(x,y)=z\)</span>，<spanclass="math inline">\(p(y,x)=w_3\)</span>。接下来我们就可以开始 dp了。</p><p>令 <span class="math inline">\(f_{S(x,y)}\)</span> 表示 <spanclass="math inline">\(S(x,y)\)</span> 中生成树的数量。</p><p>令 <span class="math inline">\(g_{S(x,y)}\)</span> 表示 <spanclass="math inline">\(S(x,y)\)</span> 中恰有两个连通分量，且 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 不在一个连通分量的生成森林的数量。</p><p>初态：当 <span class="math inline">\(S(x,y)\)</span>为多边形的一段边界时，<spanclass="math inline">\(f_{S(x,y)}=g_{S(x,y)}=1\)</span>。</p><p>令 <span class="math inline">\(z=p(x,y)\)</span>，转移如下 <spanclass="math display">\[\begin{align}g_{S(x,y)} &amp;=f_{S(x,z)}\cdot g_{S(z,y)}+f_{S(z,y)}\cdot g_{S(x,z)}\\f_{S(x,y)} &amp;= f_{S(x,z)} \cdot f_{S(z,y)}+g_{S(x,y)}\end{align}\]</span> 解释一下：先看第一个式子，<spanclass="math inline">\(f_{S(x,z)}\cdot g_{S(z,y)}\)</span> 表示从 <spanclass="math inline">\(S(x,z)\)</span> 中选取一个完整的生成树，再从 <spanclass="math inline">\(S(z,y)\)</span> 中选取 <spanclass="math inline">\(z\)</span> 和 <spanclass="math inline">\(y\)</span> 不在一个连通分量的一个生成森林，这样<span class="math inline">\(z\)</span> 所在的连通分量通过点 <spanclass="math inline">\(z\)</span> 并入了 <spanclass="math inline">\(S(x,z)\)</span> 的生成树，而 <spanclass="math inline">\(x,y\)</span>依然处于不同的连通分量。另一部分同理。</p><p>再看第二个式子，<span class="math inline">\(f_{S(x,z)} \cdotf_{S(z,y)}\)</span> 表示 <span class="math inline">\(S(x,y)\)</span>中不经过边 <span class="math inline">\((x,y)\)</span> 的生成树数量，而<span class="math inline">\(g_{S(x,y)}\)</span> 恰好表示经过边 <spanclass="math inline">\((x,y)\)</span>的生成树数量（将原本不在同一连通分量的 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 所在的连通分量用边 <spanclass="math inline">\((x,y)\)</span> 连起来，得到一棵生成树）。</p><p>至此，我们可以枚举每条对角线，向两侧递归，得到所有的 <spanclass="math inline">\(f_{S(x,y)}\)</span> 和 <spanclass="math inline">\(g_{S(x,y)}\)</span>。使用记忆化搜索，每个 <spanclass="math inline">\(S(x,y)\)</span> 的答案至多只会算一次，所以是单<span class="math inline">\(\log\)</span> 的。</p><p>对于一个询问 <spanclass="math inline">\((x,y)\)</span>，我们要算去掉对角线 <spanclass="math inline">\((x,y)\)</span> 后的生成树数量，答案是 <spanclass="math display">\[(f_{S(x,y)}-g_{S(x,y)})\cdot g_{S(y,x)}+(f_{S(y,x)}-g_{S(y,x)})\cdotg_{S(x,y)}\]</span> 时间复杂度 <span class="math inline">\(O(n\logn)\)</span>。</p><h2 id="ucup3-4.-hongō">【8.16】Ucup3-4. Hongō</h2><p>倒闭，怎么 A 是模拟题，C 感觉没这么简单但也过了一车。</p><h2 id="杭电多校-10">【8.18】杭电多校 10</h2><p>怎么只有我们队在打。</p><h3 id="submission">1001. Submission</h3><p><ahref="https://acm.hdu.edu.cn/contest/view-code?cid=1181&amp;rid=9260">Code</a></p><p>对于一个人 <span class="math inline">\(x\)</span>，设 <spanclass="math inline">\(p_1,p_2,\ldots, p_l\)</span> 表示 <spanclass="math inline">\(x\)</span> 的提交对应的下标。我们将 <spanclass="math inline">\(x\)</span> 留在大脑中的时刻表示成区间，称为“保留区间”，区间的左右端点只有是 <spanclass="math inline">\(p_i\)</span> 时才有用。例如，<spanclass="math inline">\([p_1,p_3],[p_4,p_8]\)</span>表示第一次「仔细阅读」后，第二第三次提交都因 <spanclass="math inline">\(x\)</span> 还在大脑中而被跳过，接着 <spanclass="math inline">\(x\)</span>被踢出大脑，于是在第四次提交时再次「仔细阅读」，之后第五到第八次提交都被跳过。</p><p><em>Observation.</em> 每个人 <span class="math inline">\(x\)</span>对应的 “保留区间” 都只有一个，且形如 <spanclass="math inline">\([p_1,p_i]\)</span>。</p><p>注：严谨来说是 <spanclass="math inline">\([p_1,p_i],[p_{i+1},p_{i+1}],[p_{i+2},p_{i+2}],\ldots,[p_l,p_l]\)</span>。在以下叙述中，单点构成的区间均被略去。</p><p><em>Prove.</em> 假设 <span class="math inline">\(x\)</span> 有两个“保留区间”，形如 <span class="math inline">\([p_1,p_i],[p_j,p_k]\(i&lt;j)\)</span>。当 <span class="math inline">\(x\)</span> 在 <spanclass="math inline">\((p_i,p_{i+1})\)</span>被驱逐，意味着有另一个不在大脑中的人 <spanclass="math inline">\(y\)</span>，试图进入大脑，并且 <spanclass="math inline">\(x\)</span> 的优先级是大脑里所有 <spanclass="math inline">\(k+1\)</span> 个人（包括 <spanclass="math inline">\(y\)</span>）中最低的。在不断挤占的过程中，大脑里<span class="math inline">\(k\)</span>个位置对应的人的优先级只升不降。如果 <spanclass="math inline">\(x\)</span>在之后的某个时刻再次进入大脑，他的优先级仍旧是 <spanclass="math inline">\(k\)</span>个位置中最低的，当下一个人想进来，被驱逐的就一定是 <spanclass="math inline">\(x\)</span>。此时的收益远不如在一开始就将 <spanclass="math inline">\(x\)</span>的优先级调高，使其形成一个更长的保留区间 <spanclass="math inline">\([p_1,p_k]\)</span>。</p><p>于是，问题转化为：有 <span class="math inline">\(m\)</span>个人，每个人有若干形如 <spanclass="math inline">\([p_1,p_i]\)</span>，收益为 <spanclass="math inline">\(i-1\)</span> 的区间（<spanclass="math inline">\(p_2\sim p_i\)</span>被跳过），你要为每个人选择恰好一个区间，使得总收益最大，约束是数轴上所有形如<span class="math inline">\(i.5\)</span> 的位置的被覆盖次数 <spanclass="math inline">\(\le k\)</span>。</p><p>考虑费用流，建模如下。四元组 <spanclass="math inline">\((u,v,f,c)\)</span>，其中 <spanclass="math inline">\(f\)</span> 是容量，<spanclass="math inline">\(c\)</span> 是费用。<spanclass="math inline">\(p_{i,j}\)</span> 表示 <spanclass="math inline">\(i\)</span> 第 <spanclass="math inline">\(j\)</span> 次出现的位置。</p><ul><li><span class="math inline">\(\forall i\in [1,n-1]\)</span>，<spanclass="math inline">\((i,i+1,k,0)\)</span></li><li><span class="math inline">\((S,1,k,0)\)</span>，<spanclass="math inline">\((n,T,k,0)\)</span></li><li><span class="math inline">\(\forall i\in [1,m]\)</span>，<spanclass="math inline">\((p_{i,1},n+i,1,0)\)</span></li><li><span class="math inline">\(\forall p_{i,j\ (j\ge2)}\)</span>，<spanclass="math inline">\((n+i,p_{i,j},1,j-1)\)</span></li></ul><p>当然，我们不可能对所有 <span class="math inline">\(k\in[1,m]\)</span> 都跑一次费用流。经典的套路是把所有容量为 <spanclass="math inline">\(k\)</span> 的边的容量都重新设置为 <spanclass="math inline">\(m\)</span>，每次跑一条增广路出来。</p><p>时间复杂度，<spanclass="math inline">\(O(4031\texttt{ms})\)</span>。</p><h2 id="尾声">【尾声】</h2><p>第二次来清水河集训了，相比第一次，最大的变化可能是学子 mai取代了朝阳二楼的位置（笑哭</p><p>简单回忆，收获比较大的是与生成函数，分治有关的一点技巧，但也只是一点皮毛。</p><p>比较难忘的是前期若干和重链剖分有关的题，以及最后的三角剖分。</p><p>另有若干题没来得及补，例如两道倍增并查集的题。说实话，暑假一过我大概率就没什么动力去补了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UESTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】六月训练日记</title>
      <link href="/posts/a62f5f49.html"/>
      <url>/posts/a62f5f49.html</url>
      
        <content type="html"><![CDATA[<h2 id="qoj9748.-最大公因数的平方和"><ahref="https://qoj.ac/contest/1841/problem/9748">QOJ9748.最大公因数的平方和</a></h2><p><a href="https://qoj.ac/submission/1086982">Code</a></p><p>由莫比乌斯反演，令 <spanclass="math inline">\(g(n)=n^2=\sum\limits_{d\mid n}f(d)\)</span>，则<span class="math inline">\(f(n)=\sum\limits_{d\midn}\mu(d)g\left(\dfrac{n}{d}\right)=\sum\limits_{d\midn}\mu(d)\left(\dfrac{n}{d}\right)^2\)</span>。</p><p>我们可以在调和级数复杂度内预处理出所有的 <spanclass="math inline">\(f(n)\)</span>。</p><p>于是，原式化为 <span class="math display">\[\begin{align}\sum_{i=l}^{r}\sum_{j=L}^{R}\gcd(a_i,b_j)^2&amp;=\sum_{i=l}^{r}\sum_{j=L}^{R}\sum_{d\mid \gcd(a_i,b_j)}f(d)\\&amp;=\sum_{i=l}^{r}\sum_{j=L}^{R}\sum_{d\mid a_i\land d\mid b_j}f(d)\\&amp;=\sum_{d=1}^{n}f(d)\sum_{i=l}^{r}[d\mid a_i]\sum_{j=L}^{R}[d\midb_j]\end{align}\]</span> 后两项形式相同，我们以 <spanclass="math inline">\(\sum\limits_{i=l}^{r}[d\mid a_i]\)</span>为例，相当于问一段区间内有多少个数是某个值 <spanclass="math inline">\(d\)</span> 的倍数。</p><p>阈值分治，设阈值为 <span class="math inline">\(B\)</span>。那么当<span class="math inline">\(d\le B\)</span> 时，我们可以对每个 <spanclass="math inline">\(d\)</span> 处理出一个前缀和，这样每个询问就可以<span class="math inline">\(O(1)\)</span> 查询。这部分是 <spanclass="math inline">\(O(nB+qB)\)</span> 的。</p><p>而 <span class="math inline">\(d&gt;B\)</span> 时，把这个倍数在 <spanclass="math inline">\(\{a\}\)</span> 中的下标记作 <spanclass="math inline">\(i\)</span>，在 <spanclass="math inline">\(\{b\}\)</span> 中的下标记作 <spanclass="math inline">\(j\)</span>。可以看成如下二维数点问题：</p><ul><li>二维平面上有若干个点，每个点的坐标是 <spanclass="math inline">\((i,j)\)</span>，有一个权值 <spanclass="math inline">\(f(d)\)</span>。</li><li>有若干询问，每个询问形如：在一个矩形区域内所有点的权值和。</li></ul><p>利用分块进行二维数点，这部分是 <spanclass="math inline">\(O(\dfrac{n^2}{B^2}+q\sqrt{n})\)</span> 的。</p><h2 id="qoj9476.-012-grid"><ahref="https://qoj.ac/contest/1812/problem/9476">QOJ9476. 012Grid</a></h2><p><a href="https://qoj.ac/submission/1085839">Code</a></p><p>先引用四张官方题解的图片。</p><p><img src="/image/academic/qoj9476_1.png" /></p><p><img src="/image/academic/qoj9476_2.png" /></p><p>不难发现，题目的约束等同于找两条从左下到右上的路径，这两条路径分别分割了<span class="math inline">\(0/1\)</span> 以及 <spanclass="math inline">\(1/2\)</span>，严格不相交。其中前两幅图路径起点都是<span class="math inline">\((0,1)\)</span> 和 <spanclass="math inline">\((1,0)\)</span>，终点都是 <spanclass="math inline">\((n,m-1)\)</span> 和 <spanclass="math inline">\((n-1,m)\)</span>。而后两幅图可以提取出一个子矩形（红圈框起来），只研究这个子矩形的话和前两幅图无异。</p><p>于是我们先研究前两幅图的情况。回忆 LGV 引理，有向无环图上，给定 <spanclass="math inline">\(k\)</span> 个起点 <spanclass="math inline">\(\{a_1,a_2,\ldots,a_k\}\)</span> 和 <spanclass="math inline">\(k\)</span> 个终点 <spanclass="math inline">\(\{b_1,b_2,\ldots,b_k\}\)</span>，那么要满足 <spanclass="math inline">\(a_i\to b_i\)</span> 这 <spanclass="math inline">\(k\)</span> 条路径严格互不相交，方案数是： <spanclass="math display">\[\det\pmatrix{e(a_1,b_1) &amp; e(a_1,b_2) &amp; \cdots &amp; e(a_1,b_k)\\e(a_2,b_1) &amp; e(a_2,b_2) &amp; \cdots &amp; e(a_2,b_k)\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\e(a_k,b_1) &amp; e(a_k,b_2) &amp; \cdots &amp; e(a_k,b_k)}\]</span> 其中 <span class="math inline">\(e(a_i,b_j)\)</span> 表示从<span class="math inline">\(a_i\)</span> 到 <spanclass="math inline">\(b_j\)</span>所有路径的权重之和。再者，一条路径的权重定义为路径上所有边权之积。于是，当图中所有边权都是<span class="math inline">\(1\)</span> 时，<spanclass="math inline">\(e(a_i,b_j)\)</span> 就等价于从 <spanclass="math inline">\(a_i\)</span> 到 <spanclass="math inline">\(b_j\)</span>有多少条不同的路径。再回忆，网格图上，如果只朝右或朝上走（这样相当于有向无环图），那么从点<span class="math inline">\(P(x_1,y_1)\)</span> 到 <spanclass="math inline">\(Q(x_2,y_2)\)</span> 有 <spanclass="math inline">\(\dbinom{|x_1-x_2|+|y_1-y_2|}{|x_1-x_2|}\)</span>种不同的走法（插板法），故 <span class="math inline">\(e(P,Q)=\dbinom{|x_1-x_2|+|y_1-y_2|}{|x_1-x_2|}\)</span>。</p><p>回到本题，<span class="math inline">\(k=2\)</span>，起点分别为 <spanclass="math inline">\((0,1),(1,0)\)</span>，终点分别为 <spanclass="math inline">\((n,m-1),(n-1,m)\)</span>，那么严格不相交路径数等于<span class="math display">\[\det\pmatrix{\dbinom{n+m-2}{n} &amp; \dbinom{n+m-2}{n-1}\\\dbinom{n+m-2}{n-1} &amp; \dbinom{n+m-2}{m}}=\frac{(n+m-2)!(n+m-1)!}{n!m!(n-1)!(m-1)!}\]</span> 这个组合数展开花了我相当多的时间，可能需要一点技巧（</p><p>好，现在我们看向后两幅图，我们现在要枚举那个红框框起来的区域。观察这两幅图，左边这幅子矩形贴着右侧和下侧，我们称这种情况为“右下”，同理右边这幅是 “左右” 的情况。</p><p>于是，共有左上、右下、左右、上下四种情况，后两种比较平凡，枚举矩形的长/宽，乘这样尺寸的矩形有几个，再累加即可。</p><p>对于前两种，矩形的长和宽都需要枚举，相当于求一个这样的式子 <spanclass="math display">\[\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{(i+j-2)!(i+j-1)!}{i!j!(i-1)!(j-1)!}\]</span> 分子的形式引起我们注意，令 <spanclass="math inline">\(p=i+j\)</span>，原式化为 <spanclass="math display">\[\sum_{p=2}^{n+m}(p-2)!(p-1)!\sum_{i+j=k}\underbrace{\frac{1}{i!(i-1)!}}_{\Large f_i}\cdot\underbrace{\frac{1}{j!(j-1)!}}_{\Large g_j}\]</span> 后面那项用 NTT 卷积即可。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log(n+m))\)</span>。</p><h2 id="qoj9479.-and-dna"><ahref="https://qoj.ac/contest/1812/problem/9479">QOJ9479. AndDNA</a></h2><p><a href="https://qoj.ac/submission/1094637">Code</a></p><p>定义 <span class="math inline">\(f_n(m)\)</span>：长度为 <spanclass="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(\{a\}\)</span>，满足 <spanclass="math inline">\(\forall i\in [1,n]\)</span>，<spanclass="math inline">\(a_i+(a_{i-1}\&amp;a_{i+1})=m\)</span>的序列数量。</p><p>先思考 <span class="math inline">\(m\)</span> 比较小的情况。</p><p>当 <span class="math inline">\(m=0\)</span> 时，只有全 <spanclass="math inline">\(0\)</span> 序列能满足要求，故 <spanclass="math inline">\(f_n(0)=1\)</span>。</p><p>当 <span class="math inline">\(m=1\)</span> 时，<spanclass="math inline">\(\{a\}\)</span> 只能是 <spanclass="math inline">\(01\)</span> 序列。根据定义易知 <spanclass="math inline">\(\{a\}\)</span> 需要满足 “没有连续两个 <spanclass="math inline">\(0\)</span>” 且 “没有连续三个 <spanclass="math inline">\(1\)</span>”。</p><p>这等价于在下述状态机中，从任意一个顶点出发，经过 <spanclass="math inline">\(n\)</span> 条边回到同一顶点的路径条数。</p><p><img src="/image/academic/qoj9479.png" /></p><p>邻接矩阵配合矩阵快速幂，可以在 <span class="math inline">\(O(\logn)\)</span> 内解决。</p><p>当 <span class="math inline">\(m\)</span> 为 <spanclass="math inline">\(\ge 2\)</span> 的偶数时，草稿纸上画一下，易知此时<span class="math inline">\(\{a\}\)</span>要么全是偶数，要么全是奇数。</p><ul><li>当 <span class="math inline">\(\{a\}\)</span> 全为偶数时，令 <spanclass="math inline">\(a_i=2b_i\)</span>，方程变为 <spanclass="math inline">\(2b_i+(2b_{i-1}\&amp;2b_{i+1})=m\)</span>。由位运算的性质，括号里的<span class="math inline">\(2\)</span> 可以提出来，于是方程化为 <spanclass="math inline">\(b_i+(b_{i-1}\&amp;b_{i+1})=\dfrac{m}{2}\)</span>。这是一个规模更小的问题，即<span class="math inline">\(f_n(\dfrac{m}{2})\)</span>。</li><li>当 <span class="math inline">\(\{a\}\)</span> 全为奇数时，令 <spanclass="math inline">\(a_i=2b_i+1\)</span>，代入方程，同样能推导出 <spanclass="math inline">\(b_i+(b_{i-1}\&amp;b_{i+1})=\dfrac{m}{2}-1\)</span>。</li></ul><p>故 <spanclass="math inline">\(f_n(m)=f_n(\dfrac{m}{2})+f_n(\dfrac{m}{2}-1)\)</span>。</p><p>当 <span class="math inline">\(m\)</span> 为 <spanclass="math inline">\(\ge 3\)</span> 的奇数时，换一个视角，在计算 <spanclass="math inline">\(a_i+(a_{i-1}\&amp;a_{i+1})\)</span>时二进制下最低位一定不会产生进位。</p><p>这允许我们将最低位和高位部分分开计算，两部分独立，方案数可以乘起来。</p><ul><li>最低位部分，<spanclass="math inline">\(a_i^{(low)}+(a_{i-1}^{(low)}\&amp;a_{i+1}^{(low)})=1\)</span>，即<span class="math inline">\(f_n(1)\)</span>。</li><li>高位部分，把末尾的 <span class="math inline">\(1\)</span>除掉之后剩下 <span class="math inline">\(\dfrac{m-1}{2}\)</span>，即<span class="math inline">\(f_n(\dfrac{m-1}{2})\)</span>。</li></ul><p>故 <span class="math inline">\(f_n(m)=f_n(1)\timesf_n(\dfrac{m-1}{2})\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(\log n+\logm)\)</span>。</p><h2 id="qoj9488.-do-not-turn-back"><ahref="https://qoj.ac/contest/1812/problem/9488">QOJ9488. Do Not TurnBack</a></h2><p><a href="https://qoj.ac/submission/1094352">Code</a></p><p>将 “不连续走同一条边” 的条件称为 <spanclass="math inline">\((*)\)</span> 条件。</p><p>定义一个 <span class="math inline">\(N\times N\)</span> 的方阵 <spanclass="math inline">\(X_k\)</span>：<spanclass="math inline">\(X_k[i][j]\)</span> 表示从 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 长度为 <spanclass="math inline">\(k\)</span> 且满足 <spanclass="math inline">\((*)\)</span> 的路径数量。</p><p>于是答案即为 <span class="math inline">\(X_k[1][n]\)</span>。</p><p>同样定义以下几个 <span class="math inline">\(N\times N\)</span>的矩阵：</p><ul><li><span class="math inline">\(A\)</span>：图 <spanclass="math inline">\(G\)</span> 的邻接矩阵。</li><li><span class="math inline">\(D\)</span>：图 <spanclass="math inline">\(G\)</span>的度数矩阵。（对角矩阵，对角线上的元素为对应顶点的度数）</li><li><span class="math inline">\(I\)</span>：单位矩阵。</li><li><span class="math inline">\(O\)</span>：零矩阵。</li></ul><p>接下来看怎么推导出 <span class="math inline">\(X_k\)</span>。</p><p>当 <span class="math inline">\(k = 1\)</span> 时，显然有 <spanclass="math inline">\(X_1=A\)</span>。</p><p>当 <span class="math inline">\(k=2\)</span> 时，若不考虑 <spanclass="math inline">\((*)\)</span>，答案是 <spanclass="math inline">\(A^2\)</span>。而不满足 <spanclass="math inline">\((*)\)</span> 的路径形如 <spanclass="math inline">\(i\to j\to i\)</span>，这样的路径有 <spanclass="math inline">\(\text{deg}(i)\)</span> 条，于是 <spanclass="math inline">\(X_2=A^2-D\)</span>。</p><p>当 <span class="math inline">\(k\ge 3\)</span> 时，同样考虑从 <spanclass="math inline">\(AX_{k-1}\)</span> 中减去不满足 <spanclass="math inline">\((*)\)</span> 的部分。</p><p>考虑 <span class="math inline">\(AX_{k-1}\)</span> 的含义是所有长度为<span class="math inline">\(k-1\)</span>的合法路径再往前走一步。对于一条路径： <span class="math display">\[a_0\to \ldots \to a_{k-3}\to a_{k-2}\to a_{k-1}\]</span> 不满足 <span class="math inline">\((*)\)</span> 的路径形如，从<span class="math inline">\(a_{k-2}\)</span> 开始走一段 <spanclass="math inline">\(i\to j\to i\ (i=a_{k-2})\)</span>。其中 <spanclass="math inline">\(j\)</span> 的选择有 <spanclass="math inline">\(\text{deg}(i)-1\)</span>种，减一是因为前面的路径合法保证了 <spanclass="math inline">\(j\)</span> 不能是 <spanclass="math inline">\(a_{k-3}\)</span>。于是，不满足 <spanclass="math inline">\((*)\)</span> 的路径数有 <spanclass="math inline">\((D-I)X_{k-2}\)</span> 这么多。</p><p>也就是说，<span class="math inline">\(X_k=AX_{k-1}-(D-I)X_{k-2},\k\ge 3\)</span>。</p><p>写成矩阵快速幂的形式 <span class="math display">\[\pmatrix{X_k\\X_{k-1}}=\pmatrix{A &amp; -(D-I)\\ I &amp;O}\pmatrix{X_{k-1}\\ X_{k-2}}\]</span> 即 <span class="math display">\[\pmatrix{X_k\\X_{k-1}}=\pmatrix{A &amp; -(D-I)\\ I &amp;O}^{k-2}\pmatrix{X_2\\ X_1}\]</span> 时间复杂度 <span class="math inline">\(O(N^3\logK)\)</span>。</p><h2 id="qoj10346.-make-triangle"><ahref="https://qoj.ac/contest/1967/problem/10346">QOJ10346. MakeTriangle</a></h2><p><a href="https://qoj.ac/submission/1105077">Code</a></p><p>令 <span class="math inline">\(S=\sum x_i\)</span>，三个集合分别为<span class="math inline">\(A, B, C\)</span>，则题目可以转化为给出 <spanclass="math inline">\(\{x\}\)</span> 的一个三集合划分使得 <spanclass="math inline">\(|A|=n_a\)</span>，<spanclass="math inline">\(|B|=n_b\)</span>，<spanclass="math inline">\(|C|=n_c\)</span> 且 <spanclass="math inline">\(\min\left(\sum\limits_{x\in A}x,\sum\limits_{x\inB}x,\sum\limits_{x\in C}x\right) &lt; \dfrac{S}{2}\)</span>。</p><p>在以下叙述中，默认 <span class="math inline">\(x_1\le x_2 \le\ldots\le x_n\)</span> 且 <span class="math inline">\(n_a\le n_b\len_c\)</span>。</p><p>下面是一些必要条件</p><ul><li>最大的元素不能太大：<spanclass="math inline">\(x_n+\sum\limits_{i=1}^{n_a-1}x_i&lt;\dfrac{S}{2}\)</span>。</li><li>最大的组要装得下最小的几个元素：<spanclass="math inline">\(\sum\limits_{i=1}^{n_c}x_i&lt;\dfrac{S}{2}\)</span>。</li></ul><p>可以证明这个条件是充分的。但我们选择证明一个比上述条件更强的引理。</p><p><em>Lemma.</em> 如果我们按 <spanclass="math inline">\(\{x_i\}\)</span>从大到小选择它们应该放进的集合（即当前需要放置的元素比任何已经在集合里的元素都要小），设<span class="math inline">\(n&#39;\)</span> 表示还没放的数的个数（即<span class="math inline">\(x_1,x_2,\ldots,x_{n&#39;}\)</span>），<spanclass="math inline">\(n_a&#39;\)</span>，<spanclass="math inline">\(n_b&#39;\)</span>，<spanclass="math inline">\(n_c&#39;\)</span> 表示三个集合的剩余容量（满足<spanclass="math inline">\(n_a&#39;+n_b&#39;+n_c&#39;=n&#39;\)</span>），<spanclass="math inline">\(S_a\)</span>，<spanclass="math inline">\(S_b\)</span>，<spanclass="math inline">\(S_c\)</span>表示三个集合已经装进的数的和，则剩下的这 <spanclass="math inline">\(n&#39;\)</span>个数能合法塞进三个集合的<strong>充要</strong>条件是：</p><ul><li><span class="math inline">\(\exists g\in \{a,b,c\}\)</span>，<spanclass="math inline">\(S_g+x_{n&#39;}+\sum\limits_{i=1}^{n_g&#39;-1}x_i&lt;\dfrac{S}{2}\)</span>。</li><li><span class="math inline">\(\forall g\in \{a,b,c\}\)</span>，<spanclass="math inline">\(S_g+\sum\limits_{i=1}^{n_g&#39;} &lt;\dfrac{S}{2}\)</span>。</li></ul><p><em>Prove.</em> 必要性显然，这里证充分性。我们不妨令集合 <spanclass="math inline">\(A\)</span> 满足第一个条件，那么 <spanclass="math inline">\(S_a+x_{n&#39;}+\sum\limits_{i=1}^{n_a&#39;-1}x_i&lt;\dfrac{S}{2}\)</span>。</p><p>此时将 <span class="math inline">\(x_{n&#39;}\)</span> 放进 <spanclass="math inline">\(A\)</span> 中，剩下的 <spanclass="math inline">\(x_1\sim x_{n&#39;-1}\)</span> 任意放进 <spanclass="math inline">\(B,C\)</span> 中。设如此操作后有 <spanclass="math inline">\(S_a&#39;\)</span>，<spanclass="math inline">\(S_b&#39;\)</span> 和 <spanclass="math inline">\(S_c&#39;\)</span>，则若 <spanclass="math inline">\(S_b&#39;&lt;\dfrac{S}{2}\)</span> 且 <spanclass="math inline">\(S_c&#39;&lt;\dfrac{S}{2}\)</span>，那么我们就已经找到了一组合法划分。否则，<spanclass="math inline">\(\max(S_b&#39;,S_c&#39;)\ge\dfrac{S}{2}\)</span>，不失一般性，我们令 <spanclass="math inline">\(S_b&#39;\ge \dfrac{S}{2}\)</span>。</p><p>此时，<spanclass="math inline">\(S_a&#39;+S_c&#39;&lt;\dfrac{S}{2}\)</span>，我们可以任意交换<span class="math inline">\(A,C\)</span> 中的元素（除 <spanclass="math inline">\(x_{n&#39;}\)</span> 外）。现在，观察如果任意交换<span class="math inline">\(B,C\)</span>中的元素，会发生什么情况。在一次交换中，换进 <spanclass="math inline">\(C\)</span> 的元素 <spanclass="math inline">\(&lt;x_{n&#39;}\)</span>，换出 <spanclass="math inline">\(C\)</span> 的元素 <span class="math inline">\(\ge1\)</span>，那么 <span class="math inline">\(C\)</span>中元素的和最多增长 <spanclass="math inline">\(x_{n&#39;}-1\)</span>。而交换前 <spanclass="math inline">\(S_c&#39;\le S-S_b&#39;-S_a&#39;\le\dfrac{S}{2}-S_a&#39;\le \dfrac{S}{2}-x_{n&#39;}\)</span>。</p><p>意思是，交换后 <span class="math inline">\(S_c&#39;&#39;\leS_c&#39;+(x_{n&#39;}-1)\le\dfrac{S}{2}-x_{n&#39;}+(x_{n&#39;}-1)&lt;\dfrac{S}{2}\)</span>。</p><p>也就是说，<span class="math inline">\(B,C\)</span>也可以任意交换，再加上 <span class="math inline">\(A,C\)</span>可以任意交换，所有元素都可以在三个集合之间调整，直到 <spanclass="math inline">\(S_b&#39;&lt;\dfrac{S}{2}\)</span>。又因为 Lemma的第二个条件的存在，保证了一定能调整出来。故该引理得证。</p><p>好的，现在我们拥有了这个 Lemma，做法也就呼之欲出了：从大到小分配<span class="math inline">\(\{x\}\)</span> 中的元素，逐一尝试分配到<span class="math inline">\(A,B,C\)</span> 中，看一下某次尝试后，Lemma的条件是否满足。若满足，就分配。若无论分配到哪一个集合都无法满足Lemma，就无解。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="qoj9851.-cup-of-water"><ahref="https://qoj.ac/contest/1870/problem/9851">QOJ9851. Cup ofWater</a></h2><p><a href="https://qoj.ac/submission/1120501">Code</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Codeforces </tag>
            
            <tag> QOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】2025 蓝桥杯国赛 CA</title>
      <link href="/posts/c80723a0.html"/>
      <url>/posts/c80723a0.html</url>
      
        <content type="html"><![CDATA[<h3 id="e.-树"><a href="https://www.luogu.com.cn/problem/P12844">E.树</a></h3><p>令 <span class="math inline">\(dp[x][0/1/2]\)</span> 表示在以 <spanclass="math inline">\(x\)</span>为根的子树中，不同选取情况对应的方案数。</p><ul><li><p><span class="math inline">\(dp[x][0]\)</span>：节点 <spanclass="math inline">\(x\)</span> 被选中。</p></li><li><p><span class="math inline">\(dp[x][1]\)</span>：节点 <spanclass="math inline">\(x\)</span>未被选中，但其恰好一个儿子被选中。</p></li><li><p><span class="math inline">\(dp[x][2]\)</span>：节点 <spanclass="math inline">\(x\)</span>未被选中，且其所有儿子也未被选中。</p></li></ul><p>转移如下</p><p><span class="math display">\[\large dp[x][0]=\prod_{y\in son[x]}dp[y][2]\]</span></p><p><span class="math display">\[\large dp[x][1]=\sum_{y\in son[x]}\left(dp[y][0]\prod_{z\in son[x],z\neqy}\left(dp[z][1]+dp[z][2]\right)\right)\]</span></p><p><span class="math display">\[\large dp[x][2]=\prod_{y\in son[x]}(dp[y][1]+dp[y][2])\]</span></p><p>答案是 <spanclass="math inline">\(dp[1][0]+dp[1][1]+dp[1][2]-1\)</span>，减一是为了减去空集。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % mod) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % mod;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span> &amp;&amp; adj[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;dp[x][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;dp[x][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> s0 = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> s1 = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);s0 = s0 * dp[y][<span class="hljs-number">2</span>] % mod;s1 = s1 * (dp[y][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">2</span>]) % mod;&#125;dp[x][<span class="hljs-number">0</span>] = s0;dp[x][<span class="hljs-number">2</span>] = s1;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> inv = <span class="hljs-built_in">qpow</span>(dp[y][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">2</span>], mod - <span class="hljs-number">2</span>);dp[x][<span class="hljs-number">1</span>] = (dp[x][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">0</span>] * s1 % mod * inv % mod) % mod;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> ans = (dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - <span class="hljs-number">1</span> + mod) % mod;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><hr /><h3 id="f.-连锁反应"><ahref="https://www.luogu.com.cn/problem/P12845">F. 连锁反应</a></h3><p>暴力做法就是对于两个炸弹 <span class="math inline">\(x,y\)</span>，如果 <span class="math inline">\(x\)</span> 炸了能顺带把<span class="math inline">\(y\)</span> 炸了，就连一条 <spanclass="math inline">\(x\to y\)</span>。</p><p>将这张图缩点，得到一个 DAG，此时只用数有多少个点入度为 <spanclass="math inline">\(0\)</span> 即可（我们可以从这些点开始引爆）。</p><p>注意到对于每个炸弹，能被它连锁引爆的炸弹形成一个区间，我们可以二分找到这个区间，从该点向这个区间连边，也就是线段树优化建图。具体的，从这个炸弹对应的叶节点向线段树上被这个区间包含的<span class="math inline">\(O(\log n)\)</span> 个节点连边。</p><p>问题就在，线段树结构边的存在，使得缩点后我们不能单纯地找入度为 <spanclass="math inline">\(0\)</span> 的点了。</p><p>但我们仍然可以构建出炸弹的传递链：从所有包含炸弹的 SCC 出发BFS，标记可达的点。而没被这些点指向的包含炸弹的SCC，就是一个可行的引爆点。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegEdge</span> &#123;<span class="hljs-type">int</span> n, all;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; id;<span class="hljs-built_in">SegEdge</span>() &#123;&#125;<span class="hljs-built_in">SegEdge</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;all = <span class="hljs-number">4</span> * n;adj.<span class="hljs-built_in">resize</span>(all + <span class="hljs-number">1</span>);id.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> id[l] = p, <span class="hljs-built_in">void</span>();adj[p].<span class="hljs-built_in">push_back</span>(p &lt;&lt; <span class="hljs-number">1</span>);adj[p].<span class="hljs-built_in">push_back</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> rx, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;adj[x].<span class="hljs-built_in">push_back</span>(p);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (lx &lt;= mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, lx, rx, x);<span class="hljs-keyword">if</span> (rx &gt; mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, lx, rx, x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtoS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, id[x]);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>); <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> p, l, r;cin &gt;&gt; p &gt;&gt; l &gt;&gt; r;a[i] = &#123;p, l, r&#125;;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;b[i] = a[i][<span class="hljs-number">0</span>];&#125;<span class="hljs-function">SegEdge <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">auto</span> [p, l, r] = a[i];<span class="hljs-type">int</span> L = <span class="hljs-built_in">lower_bound</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), p - l) - b.<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> R = <span class="hljs-built_in">upper_bound</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), p + r) - b.<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (L &lt; R) &#123;seg.<span class="hljs-built_in">PtoS</span>(i, L, R);&#125;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = seg.all;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">stk</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> tarjan = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;dfn[x] = low[x] = ++tim;vis[x] = <span class="hljs-literal">true</span>;stk[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : seg.adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">self</span>(self, y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span> &#123;now = stk[top--];vis[now] = <span class="hljs-literal">false</span>;c[now] = cnt;&#125; <span class="hljs-keyword">while</span>(x != now);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<span class="hljs-keyword">if</span> (!dfn[i]) &#123;<span class="hljs-built_in">tarjan</span>(tarjan, i);&#125;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">Adj</span>(cnt + <span class="hljs-number">1</span>);vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; s;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= N; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : seg.adj[x]) &#123;<span class="hljs-keyword">if</span> (c[x] != c[y]) &#123;s.<span class="hljs-built_in">push_back</span>(&#123;c[x], c[y]&#125;);Adj[c[x]].<span class="hljs-built_in">push_back</span>(c[y]);&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">act</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">reach</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x = c[seg.id[i]];act[x] = <span class="hljs-literal">true</span>;reach[x] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(x);&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;<span class="hljs-keyword">if</span> (!reach[y]) &#123;reach[y] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : s) &#123;<span class="hljs-keyword">if</span> (reach[x]) &#123;deg[y]++;&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<span class="hljs-keyword">if</span> (act[i] &amp;&amp; deg[i] == <span class="hljs-number">0</span>) &#123;ans++;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><hr /><h3 id="g.-翻转硬币"><ahref="https://www.luogu.com.cn/problem/P12846">G. 翻转硬币</a></h3><p>下标按 <span class="math inline">\(\bmod \text{LCM}(1,2,3)=6\)</span>分组，每组建一棵线段树。</p><p>第一种操作要么对 <span class="math inline">\(\bmod 0,2,4\)</span>对应的三棵线段树操作，要么对 <span class="math inline">\(\bmod 1, 3,5\)</span> 对应的三棵线段树操作。</p><p>第二种操作，同理每次对两棵线段树操作。</p><p>第三种操作，对所有线段树操作。</p><p>对于每一棵线段树，维护懒标记 <spanclass="math inline">\(\text{rev}\)</span>表示是否翻转，再维护一个区间和即可。</p><p>容易错的地方是怎么把区间 <span class="math inline">\([l,r]\)</span>映射到某棵线段树上对应的区间 <span class="math inline">\([L,R]\)</span>找到，比较稳妥的方式是二分。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazySegmentTree</span> &#123;    <span class="hljs-type">int</span> n;    vector&lt;Info&gt; tr;    vector&lt;Tag&gt; tag;    <span class="hljs-built_in">LazySegmentTree</span>() &#123;&#125;    <span class="hljs-built_in">LazySegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;    <span class="hljs-built_in">init</span>(a);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(vector&lt;Info&gt; &amp;a)</span> </span>&#123;n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = (<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>;tr.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Info</span>());tag.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Tag</span>());<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);    &#125;    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = a[l];            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(ls, l, m, a);        <span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        tr[p] = tr[ls] + tr[rs];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        tr[p].<span class="hljs-built_in">apply</span>(x);        tag[p].<span class="hljs-built_in">apply</span>(x);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-built_in">apply</span>(ls, tag[p]);        <span class="hljs-built_in">apply</span>(rs, tag[p]);        tag[p] = <span class="hljs-built_in">Tag</span>();    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-keyword">return</span> tr[p];        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-keyword">if</span> (qr &lt;= m) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ql &gt;= m + <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);        &#125;    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;    <span class="hljs-keyword">if</span> (ql &gt; qr) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-built_in">apply</span>(p, x);            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">modify</span>(ls, l, m, ql, qr, x);        <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, x);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (ql &gt; qr) &#123;    <span class="hljs-keyword">return</span> ;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, x);    &#125;&#125;; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tag</span> &#123;    <span class="hljs-type">int</span> rev = <span class="hljs-number">0</span>;    <span class="hljs-built_in">Tag</span>() &#123;&#125;    <span class="hljs-built_in">Tag</span>(<span class="hljs-type">int</span> A) &#123;        rev = A;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;        rev ^= t.rev;    &#125;&#125;; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;        <span class="hljs-built_in">Info</span>() &#123;&#125;    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B) &#123;        sum = A;        l = r = B;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;    <span class="hljs-keyword">if</span> (t.rev) &#123;        sum = (r - l + <span class="hljs-number">1</span>) - sum;    &#125;    &#125;&#125;; Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;    Info c;    c.sum = a.sum + b.sum;    c.l = <span class="hljs-built_in">min</span>(a.l, b.l);    c.r = <span class="hljs-built_in">max</span>(a.r, b.r);    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pos</span>(<span class="hljs-number">6</span>, &#123;<span class="hljs-number">0</span>&#125;);vector&lt;vector&lt;Info&gt;&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">6</span>, &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;&#125;);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tot</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;pos[i % <span class="hljs-number">6</span>].<span class="hljs-built_in">push_back</span>(i);a[i % <span class="hljs-number">6</span>].<span class="hljs-built_in">push_back</span>(&#123;x, ++tot[i % <span class="hljs-number">6</span>]&#125;);&#125;vector&lt;LazySegmentTree&lt;Info, Tag&gt;&gt; <span class="hljs-built_in">seg</span>(<span class="hljs-number">6</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;seg[i].<span class="hljs-built_in">init</span>(a[i]);&#125;&#125;<span class="hljs-keyword">auto</span> get = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &#123;<span class="hljs-type">int</span> L = <span class="hljs-built_in">lower_bound</span>(pos[i].<span class="hljs-built_in">begin</span>(), pos[i].<span class="hljs-built_in">end</span>(), l) - pos[i].<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> R = <span class="hljs-built_in">upper_bound</span>(pos[i].<span class="hljs-built_in">begin</span>(), pos[i].<span class="hljs-built_in">end</span>(), r) - pos[i].<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> &#123;L, R&#125;;&#125;;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> op, l, r;cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l % <span class="hljs-number">6</span>, j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; i = (i + <span class="hljs-number">2</span>) % <span class="hljs-number">6</span>, j++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> [L, R] = <span class="hljs-built_in">get</span>(i, l, r);seg[i].<span class="hljs-built_in">modify</span>(L, R, &#123;<span class="hljs-number">1</span>&#125;);&#125;&#125; &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l % <span class="hljs-number">6</span>, j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; i = (i + <span class="hljs-number">3</span>) % <span class="hljs-number">6</span>, j++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> [L, R] = <span class="hljs-built_in">get</span>(i, l, r);seg[i].<span class="hljs-built_in">modify</span>(L, R, &#123;<span class="hljs-number">1</span>&#125;);&#125;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> [L, R] = <span class="hljs-built_in">get</span>(i, l, r);seg[i].<span class="hljs-built_in">modify</span>(L, R, &#123;<span class="hljs-number">1</span>&#125;);&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> [L, R] = <span class="hljs-built_in">get</span>(i, l, r);ans += seg[i].<span class="hljs-built_in">query</span>(L, R).sum;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><hr /><h3 id="h.-斐波那契数列"><ahref="https://www.luogu.com.cn/problem/P12847">H. 斐波那契数列</a></h3><p>纸上展开几项易得： <span class="math display">\[\large G_n=G_1^{F_{n-2}}G_2^{F_{n-1}}(n\ge 3)\]</span></p><p>令 <spanclass="math inline">\(H_n=\prod\limits_{i=1}^{n}G_i\)</span>，<spanclass="math inline">\(S_n=\sum\limits_{i=1}^{n}F_i\)</span>，纸上画一下也有</p><p><span class="math display">\[\large H_n=G_1^{S_{n-2}+1}G_2^{S_{n-1}}(n\ge 3)\]</span></p><p>斐波那契数列有性质</p><p><span class="math display">\[\large S_n=F_{n+2}-1\]</span></p><p>和 <span class="math inline">\(G_1=2,G_2=3\)</span> 一起代入，得</p><p><span class="math display">\[\large H_n=2^{F_n}\cdot3^{F_{n+1}-1}\]</span></p><p>令 <spanclass="math inline">\(p=998244353\)</span>，由欧拉定理，我们相当于求</p><p><span class="math display">\[\large 2^{F_n\bmod (p-1)}\cdot 3^{F_{n+1}-1\bmod (p-1)}\bmod p\]</span></p><p>至于求 <span class="math inline">\(F_n\)</span>，用一个经典的递推</p><p><span class="math display">\[\begin{pmatrix} F_n \\ F_{n-1} \end{pmatrix} = \begin{pmatrix} 1 &amp; 1\\ 1 &amp; 0 \end{pmatrix} \begin{pmatrix} F_{n-1} \\ F_{n-2}\end{pmatrix}\]</span></p><p>也就是</p><p><span class="math display">\[\begin{pmatrix} F_n \\ F_{n-1} \end{pmatrix} = \begin{pmatrix} 1 &amp; 1\\ 1 &amp; 0 \end{pmatrix}^{n-2} \begin{pmatrix} F_{2} \\ F_{1}\end{pmatrix}\]</span></p><p>在 <span class="math inline">\(\bmod (p-1)\)</span>下矩阵快速幂即可。</p><p>时间复杂度 <span class="math inline">\(O(2^3\log n+\logp)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span> &#123;<span class="hljs-type">int</span> n, m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(n), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)) &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)) &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, k)) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cin &gt;&gt; a[i][j];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m - <span class="hljs-number">1</span>];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(n, m); i++) &#123;a[i][i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function">matrix <span class="hljs-title">tp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(m, n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;z.a[j][i] = a[i][j];&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;&#125;;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244352</span>;matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> matrix &amp;x, <span class="hljs-type">const</span> matrix &amp;y) &#123;<span class="hljs-built_in">assert</span>(x.m == y.n);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(x.n, y.m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; x.m; k++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; y.m; j++) &#123;z.a[i][j] += x.a[i][k] * y.a[k][j] % modp;z.a[i][j] %= modp;&#125;&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function">matrix <span class="hljs-title">qpow</span><span class="hljs-params">(matrix a, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-built_in">assert</span>(a.n == a.m);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(a.n)</span></span>;z.<span class="hljs-built_in">build</span>();<span class="hljs-keyword">for</span> ( ; k; k &gt;&gt;= <span class="hljs-number">1</span>, a = a * a) &#123;<span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) z = z * a;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % mod) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % mod;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">matrix <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span></span>;A.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;A.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;A.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-function">matrix <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span></span>;S.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;S.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> T = <span class="hljs-built_in">qpow</span>(A, n - <span class="hljs-number">1</span>) * S;<span class="hljs-type">int</span> p = T.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<span class="hljs-type">int</span> q = (T.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> + modp) % modp;<span class="hljs-type">int</span> ans = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, p) * <span class="hljs-built_in">qpow</span>(<span class="hljs-number">3</span>, q) % mod;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><hr /><h3 id="i.-游戏"><a href="https://www.luogu.com.cn/problem/P12848">I.游戏</a></h3><p>结论：答案至多为 <span class="math inline">\(2\)</span>。</p><p>考虑如下构造： * 先连一条 <spanclass="math inline">\((n-2,n)\)</span>，此时你可以将位于 <spanclass="math inline">\(n-1\)</span> 和 <spanclass="math inline">\(n-2\)</span> 上的数进行交换。</p><ul><li>再连一条 <spanclass="math inline">\((1,n)\)</span>，这样你就可以循环位移了。</li></ul><p>那能循环位移，你每次就可以把要交换的两个相邻的数移到最后进行交换。</p><p>也就是说，你可以自由交换相邻的数了，也就一定能排序，得证。</p><p>接下来考虑什么时候答案为 <span class="math inline">\(0\)</span> 或<span class="math inline">\(1\)</span>。</p><ul><li><p>一开始就排好序就是 <spanclass="math inline">\(0\)</span>。</p></li><li><p>若能通过至多一次区间循环位移排好序就是 <spanclass="math inline">\(1\)</span>。</p></li><li><p>否则就是 <span class="math inline">\(2\)</span>。</p></li></ul><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_sorted</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>())) &#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (a[l] == l) &#123;l++;&#125;<span class="hljs-keyword">while</span> (a[r] == r) &#123;r--;&#125;<span class="hljs-type">int</span> p = <span class="hljs-built_in">min_element</span>(a.<span class="hljs-built_in">begin</span>() + l, a.<span class="hljs-built_in">begin</span>() + r + <span class="hljs-number">1</span>) - a.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p + <span class="hljs-number">1</span>, lst = p; i != p; i++) &#123;<span class="hljs-keyword">if</span> (i == r + <span class="hljs-number">1</span>) &#123;i = l;&#125;<span class="hljs-keyword">if</span> (a[i] != a[lst] + <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125; lst = i;&#125;cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><hr /><h3 id="j.-公路"><a href="https://www.luogu.com.cn/problem/P12849">J.公路</a></h3><p>拆贡献。枚举每一种颜色（即边权），把和该颜色相同的边全部拆掉，整棵树被拆分为若干连通块，设每个连通块的点数分别为<spanclass="math inline">\(T_1,T_2,\ldots,T_m\)</span>。那么，这种颜色的贡献就是：<span class="math display">\[n(n-1)-\sum_{i=1}^{m}T_i(T_i-1)\]</span></p><p>最终的答案就是每种颜色的贡献之和。</p><p>选定任意一个点为根，一个朴素的想法是对每种颜色建出虚树（取对应颜色的边下面的点，以及根节点），这确实是可行的。</p><p>设 <span class="math inline">\(sz[x]\)</span> 表示以 <spanclass="math inline">\(x\)</span>为根的子树大小，称虚树上在我们选取的点集中的点称为黑点（特别的，包括根节点），其它点称为白点。</p><p>那么我们可以对每个黑点 <span class="math inline">\(x\)</span>算出它所在的连通块的大小，即</p><p><span class="math display">\[sz[x]-\sum_{y,\ y\text{ 是 } x \text{ 子树中的黑点 }, \text{ 且 } x\to y\text{ 的路径上没有其它黑点}} sz[y]\]</span></p><p>具体的，如果 <span class="math inline">\(y\)</span>上面的点是白点，就可以把 <span class="math inline">\(sz[y]\)</span>传递上去。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>，但实际 T了，跑了 1.1s。</p><p>下面的代码经过刻意卡常，洛谷上跑了 820ms。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;vector&lt;<span class="hljs-type">int</span>&gt; col[N];vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; adj[N];<span class="hljs-type">int</span> tim, tot, fa[N][<span class="hljs-number">20</span>], sz[N], dfn[N], dep[N], id[N], rid[N], f[N];<span class="hljs-type">bool</span> inTree[N];<span class="hljs-keyword">using</span> _node = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">VirtualTree</span> &#123;<span class="hljs-type">int</span> n;<span class="hljs-built_in">VirtualTree</span>(<span class="hljs-type">int</span> size) &#123;<span class="hljs-keyword">this</span>-&gt;n = size;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath)</span> </span>&#123;dfn[x] = ++tim;fa[x][<span class="hljs-number">0</span>] = fath;dep[x] = dep[fath] + <span class="hljs-number">1</span>;sz[x] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= __lg(dep[x]) + <span class="hljs-number">1</span>; i++) &#123;fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (y != fath) &#123;col[w].<span class="hljs-built_in">push_back</span>(y);<span class="hljs-built_in">dfs</span>(y, x);sz[x] += sz[y];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<span class="hljs-built_in">dfs</span>(rt, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;<span class="hljs-keyword">while</span> (dep[x] &gt; dep[y]) &#123;x = fa[x][__lg(dep[x] - dep[y])];&#125;<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(dep[x]); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i]) &#123;x = fa[x][i];y = fa[y][i];&#125;&#125;<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];&#125;vector&lt;<span class="hljs-type">int</span>&gt; b;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(_node &amp;Adj, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">// cout &lt;&lt; &quot;Add (&quot; &lt;&lt; x &lt;&lt; &quot; -&gt; &quot; &lt;&lt; y &lt;&lt; &quot;)\n&quot;; </span><span class="hljs-keyword">if</span> (id[x] == <span class="hljs-number">0</span>) &#123;id[x] = ++tot;rid[tot] = x;b.<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">if</span> (id[y] == <span class="hljs-number">0</span>) &#123;id[y] = ++tot;rid[tot] = y;b.<span class="hljs-built_in">push_back</span>(y);&#125;Adj[id[x]].<span class="hljs-built_in">push_back</span>(id[y]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Del</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span> (!b.<span class="hljs-built_in">empty</span>()) &#123;id[b.<span class="hljs-built_in">back</span>()] = <span class="hljs-number">0</span>;b.<span class="hljs-built_in">pop_back</span>();&#125;tot = <span class="hljs-number">0</span>;&#125;<span class="hljs-function">_node <span class="hljs-title">getTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-built_in">Del</span>();<span class="hljs-type">int</span> sz = <span class="hljs-number">2</span> * a.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> top = <span class="hljs-number">1</span>;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), [&amp;] (<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;i, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;j) &#123;<span class="hljs-keyword">return</span> dfn[i] &lt; dfn[j];&#125;);<span class="hljs-function">_node <span class="hljs-title">Adj</span><span class="hljs-params">(sz + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stk</span><span class="hljs-params">(sz + <span class="hljs-number">1</span>)</span></span>;stk[top] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> lca = <span class="hljs-built_in">LCA</span>(x, stk[top]);<span class="hljs-keyword">if</span> (lca != stk[top]) &#123;<span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span> &amp;&amp; dfn[stk[top - <span class="hljs-number">1</span>]] &gt; dfn[lca]) &#123;<span class="hljs-built_in">Add</span>(Adj, stk[top - <span class="hljs-number">1</span>], stk[top]);top--;&#125;<span class="hljs-keyword">if</span> (lca != stk[top - <span class="hljs-number">1</span>]) &#123;Adj[id[lca]].<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">Add</span>(Adj, lca, stk[top]);stk[top] = lca;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">Add</span>(Adj, lca, stk[top]);top--;&#125;&#125;Adj[id[x]].<span class="hljs-built_in">clear</span>();stk[++top] = x;&#125;<span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">Add</span>(Adj, stk[top - <span class="hljs-number">1</span>], stk[top]);top--;&#125;<span class="hljs-keyword">return</span> Adj;&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">VirtualTree <span class="hljs-title">G</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;G.<span class="hljs-built_in">add</span>(x, y, w);&#125;G.<span class="hljs-built_in">init</span>(<span class="hljs-number">1</span>);<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (col[i].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1ll</span> * n * (n - <span class="hljs-number">1</span>);col[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : col[i]) &#123;inTree[x] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">auto</span> Adj = G.<span class="hljs-built_in">getTree</span>(col[i]);<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (inTree[rid[x]]) &#123;f[x] = sz[rid[x]];&#125; <span class="hljs-keyword">else</span> &#123;f[x] = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);<span class="hljs-keyword">if</span> (!inTree[rid[x]]) &#123;f[x] += f[y];&#125;&#125;<span class="hljs-keyword">if</span> (inTree[rid[x]]) &#123;<span class="hljs-type">int</span> g = f[x];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;g -= f[y];&#125;res -= <span class="hljs-number">1ll</span> * g * (g - <span class="hljs-number">1</span>);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, id[<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : col[i]) &#123;inTree[x] = <span class="hljs-literal">false</span>;&#125;ans += res;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -600 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】2025 四川省赛</title>
      <link href="/posts/977db6c9.html"/>
      <url>/posts/977db6c9.html</url>
      
        <content type="html"><![CDATA[<p>挺匆忙的，到乐山就吃了一顿跷脚牛肉。</p><p>参赛体验的话，场地太热容易红温，蚊虫也多，除此之外都还好。</p><p>Mid 都不怎么开得出来啊，要努力加训了。</p><p>以下题解按个人主观难度排序。</p><p><a href="https://codeforces.com/gym/105949">Contest Link</a></p><hr /><h3 id="i.-本质不同的后缀">I. 本质不同的后缀</h3><p><ahref="https://codeforces.com/gym/105949/submission/323473043">Code</a></p><p>逆序将每个字符串插进 Trie，最后 Trie 的结点数就是答案。</p><p>时间复杂度 <span class="math inline">\(O(\sum |S_i|\cdot26)\)</span>。</p><hr /><h3 id="f.-逆序对">F. 逆序对</h3><p><ahref="https://codeforces.com/gym/105949/submission/323396253">Code</a></p><p>填 <code>?</code> 的策略肯定是：存在一个分界点，分界点前的<code>?</code> 填 <span class="math inline">\(1\)</span>，分界点后的<code>?</code> 填 <span class="math inline">\(0\)</span>。</p><p>考虑先让所有 <code>?</code> 都是 <spanclass="math inline">\(0\)</span>，然后从左到右逐个变成 <spanclass="math inline">\(1\)</span>，维护逆序对数。</p><p>只需要动态记录前缀 <span class="math inline">\(1\)</span> 和后缀<span class="math inline">\(0\)</span> 的个数。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><hr /><h3 id="h.-胡图图">H. 胡图图</h3><p><ahref="https://codeforces.com/gym/105949/submission/323441010">Code</a></p><p><span class="math inline">\(X\)</span> 轴和 <spanclass="math inline">\(Y\)</span> 轴可以分开考虑。</p><p>令 <span class="math inline">\(f[i][0/1]\)</span> 表示从 <spanclass="math inline">\(0\to i\)</span> 走偶数/奇数步最少需要走几步，<spanclass="math inline">\(dx=|x-X|\)</span>，<spanclass="math inline">\(dy=|y-Y|\)</span>，则</p><p><span class="math display">\[ans = \min\begin{cases}\max(f[dx][0],f[dy][0])\\ \max(f[dx][1],f[dy][1])\end{cases}\]</span></p><p>纸上列个表易得： <span class="math display">\[f[i][0]=\begin{cases}0 &amp;,i=0\\2\cdot \left\lfloor\dfrac{x-1}{4}\right\rfloor + 2&amp;,\text{otherwise}\end{cases}\]</span></p><p><span class="math display">\[f[i][1]=\begin{cases}3 &amp;,i=0\\2\cdot \left\lfloor\dfrac{x+1}{4}\right\rfloor + 1&amp;,\text{otherwise}\end{cases}\]</span></p><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><hr /><h3 id="j.-四川省赛">J. 四川省赛</h3><p><ahref="https://codeforces.com/gym/105949/submission/326459637">Code</a></p><p>经典的树形 dp。</p><p>令 <span class="math inline">\(f[x][i=0\sim 4]/g[x][i=0\sim4]\)</span> 分别表示从 <span class="math inline">\(x\)</span>子树中的某处开始，直到 <span class="math inline">\(x\)</span> 为止匹配了<code>SCCPC</code> 中的前缀 <span class="math inline">\([0,i]\/\)</span> 后缀 <span class="math inline">\([i,4]\)</span>的方案数。</p><p>对于一个 <span class="math inline">\(x\)</span>，答案有两类： *直接以 <span class="math inline">\(x\)</span> 结尾，即 <spanclass="math inline">\(f[x][4]+g[x][0]\)</span>。</p><ul><li>以 <span class="math inline">\(x\)</span>为中转两个子树拼起来，枚举中转点 <spanclass="math inline">\(i\)</span>，即</li></ul><p><span class="math display">\[\sum_{y\in son[x]}\sum_{i=1}^{3}f[y][i-1]\cdot (sg[i+1]-g[y][i+1])\]</span></p><p>其中 <span class="math inline">\(sg[i]=\sum\limits_{y\inson[x]}g[y][i]\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><hr /><h3 id="k.-点分治">K. 点分治</h3><p><ahref="https://codeforces.com/gym/105949/submission/323477922">Code</a></p><p>正难则反，倒着扫描序列。</p><p>对于一个 <span class="math inline">\(x=p[i]\)</span>，遍历 <spanclass="math inline">\(x\)</span> 的邻居 <spanclass="math inline">\(y\)</span>，如果 <spanclass="math inline">\(y\)</span> 被访问过，设 <spanclass="math inline">\(y\)</span> 所在连通块中 “在 <spanclass="math inline">\(p[i\sim n]\)</span> 中最靠前的点” 为 <spanclass="math inline">\(z\)</span>，则可以确定 <spanclass="math inline">\(x\)</span> 是 <spanclass="math inline">\(z\)</span> 的父亲，接着将 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 用并查集并起来。</p><p>不难发现，此时 <span class="math inline">\(y\)</span> 所在连通块中“在 <span class="math inline">\(\{p\}\)</span> 中最靠前的点” 变成了<spanclass="math inline">\(x\)</span>。编写代码时，可以直接将当前扫描到的点作为新连通块的根，这样<span class="math inline">\(z\)</span> 就能直接 find 得到了。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><hr /><h3 id="a.-最小乘积">A. 最小乘积</h3><p><ahref="https://codeforces.com/gym/105949/submission/323538858">Code</a></p><p>这道题的关键是想到： * 状态设计：<spanclass="math inline">\(dp[x][i]\)</span> 表示所有从 <spanclass="math inline">\(1\to x\)</span> 的路径，路径上 <spanclass="math inline">\(\sum a\)</span> 为 <spanclass="math inline">\(i\)</span> 时，<span class="math inline">\(\sumb\)</span> 的最小值。</p><ul><li>转移顺序：外层枚举第二维，让 <span class="math inline">\(\suma\)</span> 小的状态先转移，不会出现环。</li></ul><p>转移方程是朴素的： <span class="math display">\[dp[y][i + a] = \min_{x\to y}(dp[x][i] + b)\]</span></p><p>答案即 <span class="math inline">\(\min\limits_{i=1}^{n}(i\cdotdp[n][i])\)</span>。</p><p>时间复杂度 <spanclass="math inline">\(O(nm\max\{a_i\})\)</span>。</p><hr /><h3 id="c.-最优时间">C. 最优时间</h3><p><ahref="https://codeforces.com/gym/105949/submission/323461032">Code</a></p><p>先把所有 <span class="math inline">\(i\in [1,n]\)</span> 的 <spanclass="math inline">\(S(i)\)</span> 处理出来。</p><p>暴力迭代，令 <span class="math inline">\(f[x]\)</span> 表示 <spanclass="math inline">\(x\)</span> 的答案，则 dp 转移如下： <spanclass="math display">\[f[i]=\min(f[i-1],\frac{\sum_{j\in S(i)}f[j-1]}{|S(i)|})\]</span></p><p>迭代 <span class="math inline">\(100\)</span> 次即可 AC。</p><p>官方题解证明了这个式子是收敛的，但并没有证明为什么是 <spanclass="math inline">\(100\)</span> 次，问就是你说过没过吧。</p><p>时间复杂度 <span class="math inline">\(O(100\cdot n\logn+q)\)</span>。</p><hr /><h3 id="l.-abc">L. abc</h3><p><ahref="https://codeforces.com/gym/105949/submission/323570713">Code</a></p><p>我们用 <span class="math inline">\(c_{a/b/c}\)</span> 表示 <spanclass="math inline">\(a/b/c\)</span> 的出现次数。</p><p>最为关键的观察是： <span class="math display">\[\max(|c_a-c_b|,|c_a-c_c|,|c_b-c_c|)=\frac{|c_a-c_b| + |c_a-c_c| +|c_b-c_c|}{2}\]</span></p><p>于是，我们要求的变成了： <span class="math display">\[\frac{1}{2}(\sum_{T\in S}|c_a-c_b|+\sum_{T\in S}|c_a-c_c|+\sum_{T\inS}|c_b-c_c|)\]</span></p><p>这对吗？这不对。只有对满足 ” <spanclass="math inline">\(a,b,c\)</span> 均出现了” 的子串 <spanclass="math inline">\(T\)</span> 来说，贡献才是正确的。</p><p>否则我们考虑我们把贡献算错了多少。</p><p>当 <span class="math inline">\(S\)</span> 的某个子串 <spanclass="math inline">\(T\)</span> 恰有 <spanclass="math inline">\(a,b,c\)</span> 中的一种字符时，我们期望得到 <spanclass="math inline">\(0\)</span>，但我们算成了 <spanclass="math inline">\(\dfrac{|c_a-0|+|c_a-0|+|0-0|}{2}=c_a\)</span>（这里假设<span class="math inline">\(T\)</span> 只含 <spanclass="math inline">\(a\)</span>），即多算了 <spanclass="math inline">\(c_a=|T|\)</span>。</p><p>故我们要减去</p><p><span class="math display">\[\sum_{T\in S,\ T \text{ 只含 } a,b,c \text{ 中的一种字符}} |T|\]</span></p><p>怎么算这个式子？</p><ul><li>对于一个长为 <span class="math inline">\(n\)</span>的字符串，它的所有子串的长度之和为 <spanclass="math inline">\(\dfrac{n(n+1)(n+2)}{6}\)</span>。</li></ul><p>所以我们只用 <span class="math inline">\(O(n)\)</span>扫一遍，对每个极长单色段计算贡献。</p><p>当 <span class="math inline">\(S\)</span> 的某个子串 <spanclass="math inline">\(T\)</span> 恰有 <spanclass="math inline">\(a,b,c\)</span> 中的两种字符时，我们期望得到 <spanclass="math inline">\(|c_a-c_b|\)</span>（这里假设 <spanclass="math inline">\(T\)</span> 只含 <spanclass="math inline">\(a,b\)</span>），但我们算成了 <spanclass="math inline">\(\dfrac{|c_a-c_b|+|c_a-0|+|c_b-0|}{2}\)</span>，多算了</p><p><span class="math display">\[\frac{|c_a-c_b|+c_a+c_b}{2}-|c_a-c_b|=\frac{c_a+c_b-|c_a-c_b|}{2}=\min(c_a,c_b)\]</span></p><p>故我们要减去： <span class="math display">\[\sum_{T\in S,\ T \text{ 只含 }a,b}\min(c_a,c_b)+\sum_{T\in S,\ T \text{ 只含 }a,c}\min(c_a,c_c)+\sum_{T\in S,\ T \text{ 只含 }b,c}\min(c_b,c_c)\]</span></p><p>怎么算这个式子？</p><p>以第一项为例，它其实等于</p><p><span class="math display">\[\frac{1}{2}\sum_{T\in S, T \text{ 只含 } a,b}|T|-|c_a-c_b|\]</span></p><p>搞不懂的话在纸上画两条线就搞懂了。</p><p>但这样还是很麻烦。实际上，我们还可以改写成</p><p><span class="math display">\[\frac{1}{2}\sum_{T\in S, T \text{ 不含 } c}|T|-|c_a-c_b|\]</span></p><p>这是因为如果 <span class="math inline">\(T\)</span>只含一种字符的话，另一种字符的出现次数看作 <spanclass="math inline">\(0\)</span>，即 <spanclass="math inline">\(\min(c_a,c_b)=0\)</span>，完全不影响我们计数。</p><p>于是，枚举不含某个字符，找到极长连续段，计算贡献。</p><p>那现在最后的问题是，形如 <spanclass="math inline">\(\sum\limits_{T\in S}|c_a-c_b|\)</span>要怎么算。</p><p>将 <span class="math inline">\(a\)</span> 看作 <spanclass="math inline">\(1\)</span>，<span class="math inline">\(b\)</span>看作 <span class="math inline">\(-1\)</span>，求前缀和，记作 <spanclass="math inline">\(\{pre\}\)</span>，那么转化为了</p><p><span class="math display">\[\sum\limits_{0\le i &lt; j\le |S|}|pre[i]-pre[j]|\]</span></p><p>将 <span class="math inline">\(\{pre\}\)</span> 排序，答案就是</p><p><span class="math display">\[\sum_{i=1}^{n}(i\cdot pre[i]-\sum_{j=1}^{i-1}pre[j])\]</span></p><p>扫一遍即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><hr /><h3 id="g.-丢番图">G. 丢番图</h3><p><ahref="https://codeforces.com/gym/105949/submission/323823685">Code</a></p><p>将方程写成矩阵的形式： <span class="math display">\[\begin{pmatrix}a_1^0 &amp; a_2^0 &amp; \cdots &amp; a_n^0 \\a_1^1 &amp; a_2^1 &amp; \cdots &amp; a_n^1 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_1^{n-1} &amp; a_2^{n-1} &amp; \cdots &amp; a_n^{n-1}\end{pmatrix}\begin{pmatrix}x_1 \\x_2 \\\vdots \\x_n\end{pmatrix}=\begin{pmatrix}t^0 \\t^1 \\\vdots \\t^{n-1}\end{pmatrix}\]</span></p><p>可见系数矩阵 <span class="math inline">\(A\)</span>是范德蒙德矩阵的转置。</p><p>依据克莱姆法则，这个线性方程组的解为</p><p><span class="math display">\[x_k=\frac{\det(A_k)}{\det (A)}\tag{1}\]</span></p><p>其中 <span class="math inline">\(A_k\)</span> 是将矩阵 <spanclass="math inline">\(A\)</span> 的第 <spanclass="math inline">\(k\)</span> 列替换为列向量 <spanclass="math inline">\((t^0\ \ t^1\ \ \cdots \ \ t^{n-1})^{T}\)</span>后的新矩阵。</p><p>先看分母 <spanclass="math inline">\(\det(A)\)</span>，依据行列式的性质有 <spanclass="math inline">\(\det(A)=\det(A^T)\)</span>，而 <spanclass="math inline">\(A^{T}\)</span> 是范德蒙德矩阵。于是</p><p><span class="math display">\[\det(A) = \prod_{1 \le i &lt; j \le n} (a_j - a_i)\]</span></p><p>再看分子 <spanclass="math inline">\(\det(A^k)\)</span>，眼尖的你会发现这仍然是一个范德蒙德矩阵的转置，只不过生成元从<span class="math inline">\((a_1\ \ a_2\ \cdots\ a_n)\)</span> 变为了<span class="math inline">\((a_1\ \cdots \ t \ \cdots \a_n)\)</span>。于是</p><p><span class="math display">\[\det(A_k) = \left( \prod_{\substack{1 \le i &lt; j \le n \\ i,j \neq k}}(a_j - a_i) \right) \cdot \left( \prod_{i=1}^{k-1} (t - a_i) \right)\cdot \left( \prod_{j=k+1}^{n} (a_j - t) \right)\]</span></p><p>将 <span class="math inline">\(\det(A)\)</span> 和 <spanclass="math inline">\(\det(A_k)\)</span> 的展开代入公式 <spanclass="math inline">\((1)\)</span>，大部分的项都可以约分，最终剩下</p><p><span class="math display">\[\large x_k = \frac{\prod\limits_{i=1, i \neq k}^{n} (t -a_i)}{\prod\limits_{i=1, i \neq k}^{n} (a_k - a_i)}\tag{2}\]</span></p><p>到这一步，计算每个 <span class="math inline">\(x_k\)</span> 需要<span class="math inline">\(O(n)\)</span> 时间，于是我们已经可以 <spanclass="math inline">\(O(n^2)\)</span> 地解决这个问题了。</p><p>接下来的优化需要引入一个辅助多项式，令</p><p><span class="math display">\[F(x) = \prod_{i=1}^{n} (x - a_i)\]</span></p><p>那么，<span class="math inline">\((2)\)</span> 的分子等价于 <spanclass="math inline">\(\dfrac{F(t)}{t-a_k}\)</span>。</p><p>比较困难的是 <span class="math inline">\((2)\)</span>的分母部分，当你尝试用含 <span class="math inline">\(F(a_k)\)</span>的式子去描述这一部分，即 <spanclass="math inline">\(\dfrac{F(a_k)}{(a_i-a_i)}\)</span>，分母为 <spanclass="math inline">\(0\)</span> 显然就不可取了。</p><p>考虑 <span class="math inline">\(F(x)\)</span>的导数，依据乘积求导法则，有</p><p><span class="math display">\[\frac{d}{dx} F(x) = \sum_{j=1}^{n} \left( \frac{d}{dx}(x-a_j) \cdot\prod_{i=1, i \neq j}^{n}(x-a_i) \right)=\sum_{j=1}^{n} \prod_{i=1, i\neq j}^{n} (x - a_i)\]</span></p><p>直观上来看是 <span class="math inline">\(n\)</span>项一堆乘积之和，当 <span class="math inline">\(x=a_k\)</span> 时： *<span class="math inline">\(j=k\)</span> 的项等价于 <spanclass="math inline">\(\prod\limits_{i=1, i \neq k}^{n} (a_k -a_i)\)</span>。</p><ul><li><span class="math inline">\(j\neq k\)</span> 的项一定会有 <spanclass="math inline">\(i=k\)</span> 的时候，此时 <spanclass="math inline">\(a_k-a_i=0\)</span>，整个项就为 <spanclass="math inline">\(0\)</span>。</li></ul><p>于是 <span class="math inline">\((2)\)</span> 的分母就等价于 <spanclass="math inline">\(F&#39;(a_k)\)</span>。</p><p>总结一下，我们有</p><p><span class="math display">\[x_k=\frac{F(t)}{(t-a_k)F&#39;(a_k)}\]</span></p><p>其中 <span class="math inline">\(F(t)\)</span> 可以将 <spanclass="math inline">\(t\)</span> 代入 <spanclass="math inline">\(F(x)\)</span> 线性算。</p><p>问题变为如何快速对所有 <span class="math inline">\(k\in[1,n]\)</span> 求 <span class="math inline">\(F&#39;(a_k)\)</span>。</p><ul><li><span class="math inline">\(F(x)\)</span> 为 <spanclass="math inline">\(n\)</span> 个一次多项式相乘，可以用分治 NTT 在<span class="math inline">\(O(n\log^2n)\)</span> 内构建。</li><li>知道了 <span class="math inline">\(F(x)\)</span> 每一项的系数，<spanclass="math inline">\(F&#39;(x)\)</span> 可以线性构建。</li><li>求 <span class="math inline">\(F&#39;(x)\)</span> 在 <spanclass="math inline">\(x=a_1,a_2,\ldots,a_n\)</span> 处的值，即<ahref="https://www.luogu.com.cn/problem/P5050">【模板】多项式多点求值</a>，同样为<span class="math inline">\(O(n\log^2 n)\)</span>。</li></ul><hr /><h3 id="e.-竞赛图">E. 竞赛图</h3><p><ahref="https://codeforces.com/gym/105949/submission/324298923">Code</a></p><p>强连通 <span class="math inline">\(n(n\ge 3)\)</span>阶竞赛图一定存在一条哈密顿回路，因此 <spanclass="math inline">\(k\)</span> 元环与大小为 <spanclass="math inline">\(k\)</span> 的强连通分量等价。</p><p>特判 <span class="math inline">\(k=2\text{ or }k&gt;n\)</span> 答案为<span class="math inline">\(0\)</span>。问题转化为求包含至少一个大小为<span class="math inline">\(k\)</span> 的 SCC 的 <spanclass="math inline">\(n\)</span> 个点的有标号竞赛图数量。</p><p>记号约定如下： * <span class="math inline">\(f_i\)</span>：大小为<span class="math inline">\(i\)</span> 的有标号强连通竞赛图数量。</p><ul><li><p><span class="math inline">\(g_i\)</span>：大小为 <spanclass="math inline">\(i\)</span> 的有标号竞赛图数量。显然 <spanclass="math inline">\(g(i)=2^{\Large\frac{i(i-1)}{2}}\)</span>。</p></li><li><p><span class="math inline">\(h_i\)</span>：大小为 <spanclass="math inline">\(i\)</span> 的所有 SCC 都 <spanclass="math inline">\(&lt;k\)</span> 的有标号竞赛图数量。</p></li></ul><p>容斥，答案是 <span class="math inline">\(g_n-h_n\)</span>。</p><p>如何求 <spanclass="math inline">\(h_n\)</span>？首先，竞赛图缩点后会形成一条链，链首（即入度为<span class="math inline">\(0\)</span>的点）向之后的所有点连边。计数时，我们从 <spanclass="math inline">\(n\)</span> 个点里选出 <spanclass="math inline">\(i\in [1,k)\)</span> 个点作为链首，这 <spanclass="math inline">\(i\)</span> 个点组成 SCC 的方式就是 <spanclass="math inline">\(f_i\)</span>，剩下 <spanclass="math inline">\(n-i\)</span> 个点也需要满足 “所有 SCC 都 <spanclass="math inline">\(&lt; k\)</span>”，所以是 <spanclass="math inline">\(h_{n-i}\)</span>，于是</p><p><span class="math display">\[h_n=\sum_{i=1}^{k-1}\binom{n}{i}f_ih_{n-i}\tag{1}\]</span></p><p>先假设我们知道 <spanclass="math inline">\(f_i\)</span>，来看我们如何算这个式子。</p><p>这是一个典型的使用EGF（指数生成函数）计算的式子，但因为我是初学者，所以写一下推导过程。</p><p>将组合数展开，我们有</p><p><span class="math display">\[h_n=\sum_{i=1}^{k-1}\frac{n!}{i!(n-i)!}f_ih_{n-i}\]</span></p><p>移项</p><p><span class="math display">\[\frac{h_n}{n!}=\sum_{i=1}^{k-1}\left(\frac{f_i}{i!}\right)\left(\frac{h_{n-i}}{(n-i)!}\right)\]</span></p><p>这是一个卷积的形式。</p><p>令 <spanclass="math inline">\(H(x)=\sum\limits_{i=0}^{\infty}\dfrac{h_i}{i!}x^i\)</span>，<spanclass="math inline">\(F_{&lt;k}(x)={\sum\limits_{i=1}^{k-1}}\dfrac{f_i}{i!}x^i\)</span>，则</p><p><span class="math display">\[H(x)=1+F_{&lt;k}(x)H(x)\]</span></p><p>其中 <span class="math inline">\(1\)</span> 是因为 <spanclass="math inline">\(h_0=1\)</span>，有 <spanclass="math inline">\([x^0]H(x)=1\)</span>，这一项卷积里没有。</p><p>再移项，最终得到</p><p><span class="math display">\[H(x)=\frac{1}{1-F_{&lt;k}(x)}\tag{2}\]</span></p><p>只需要一次多项式求逆，之后 <spanclass="math inline">\(h_n=[x^n]H(x)\cdot n!\)</span>。</p><p>接下来看如何求 <span class="math inline">\(f_i\)</span>。</p><p>类似 <span class="math inline">\((1)\)</span>，我们能得到一个 <spanclass="math inline">\(g_n\)</span> 的递推式：从 <spanclass="math inline">\(n\)</span> 个点里选出 <spanclass="math inline">\(i\in [1,n]\)</span> 个点作为链首，这 <spanclass="math inline">\(i\)</span> 个点组成 SCC 的方式就是 <spanclass="math inline">\(f_i\)</span>，剩下 <spanclass="math inline">\(n-i\)</span> 个点只用构成竞赛图就可以了，所以是<span class="math inline">\(g_{n-i}\)</span>，于是</p><p><span class="math display">\[g_n=\sum_{i=1}^{n}\binom{n}{i}f_ig_{n-i}\]</span></p><p>可以发现，除了求和上界变成了 <spanclass="math inline">\(n\)</span>，这简直和 <spanclass="math inline">\((1)\)</span> 一毛一样。</p><p>这其实是 EGF 计数有标号的一般套路，求和上界变成 <spanclass="math inline">\(n\)</span> 意味着我们可以用所有大小（也就是 <spanclass="math inline">\([1,n]\)</span>）的强连通竞赛图构成整体。而在 <spanclass="math inline">\((1)\)</span> 中我们只能使用大小 <spanclass="math inline">\(&lt;k\)</span> 的强连通竞赛图。</p><p>于是，类似 <span class="math inline">\((1)\to (2)\)</span>的过程，我们有</p><p><span class="math display">\[G(x)=\frac{1}{1-F(x)}\]</span></p><p>这里 <spanclass="math inline">\(F(x)={\sum\limits_{i=1}^{\infty}}\dfrac{f_i}{i!}x^i\)</span>，<spanclass="math inline">\(G(x)={\sum\limits_{i=0}^{\infty}}\dfrac{g_i}{i!}x^i\)</span>。</p><p>移项</p><p><span class="math display">\[F(x)=1-\frac{1}{G(x)}\]</span></p><p>最后 <span class="math inline">\(f_i=[x^i]F(x)\cdot i!\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】五月训练日记</title>
      <link href="/posts/9a6e3ac7.html"/>
      <url>/posts/9a6e3ac7.html</url>
      
        <content type="html"><![CDATA[<p>拼尽全力无法战胜 div2b，要重开了。(╥﹏╥)</p><figure><img src="https://kisuraop.github.io/image/academic/remake.png"alt="remake" /><figcaption aria-hidden="true">remake</figcaption></figure><h2 id="cf2108e.-spruce-dispute"><ahref="https://codeforces.com/contest/2108/problem/E">CF2108E. SpruceDispute</a></h2><p>*2600 <ahref="https://codeforces.com/contest/2108/submission/318087489">Code</a></p><p>考虑如何给删完点后的剩下 <span class="math inline">\(n-1\)</span>个点分配颜色使得答案最大。</p><p>拆贡献，对于一条边，我们肯定想让跨过这条边的路径尽可能多。换句话说，设这条边两侧的子树大小分别为<span class="math inline">\(a,b\(a&lt;b)\)</span>，我们肯定想让子树大小为 <spanclass="math inline">\(a\)</span> 的一侧的点的颜色互不相同。</p><p>可以证明，从这棵树的重心开始按 dfs 序涂色最优。即按 dfs 顺序 <spanclass="math inline">\(1\to 2\to 3\to \ldots \to\left\lfloor\frac{n}{2}\right\rfloor\to 1\to 2\to \ldots\to\left\lfloor\frac{n}{2}\right\rfloor\)</span> 这么涂。</p><p>想到这么做是因为重心满足 “最大的子树不超过 <spanclass="math inline">\(\left\lfloor\frac{n}{2}\right\rfloor\)</span>”这一条件。首先，按 dfs序涂色是毋庸置疑的，这样能保证同样的颜色肯定被隔在了不同子树，一个类似结论的题是<ahref="https://atcoder.jp/contests/arc160/tasks/arc160_e">arc160e</a>。其次，考虑从一个非重心点<span class="math inline">\(x\)</span> 向重心方向移动到 <spanclass="math inline">\(y\)</span> 的过程，边 <spanclass="math inline">\((x,y)\)</span>两侧子树较小的那一侧在变大，能容纳更多颜色，一定不劣。</p><p>至此，以重心为根，所有颜色都被分到了不同子树，两个颜色相同的点之间的简单路径长度可以改写为两个点到重心的距离之和。因此，总答案可以改写为所有点到重心的距离和。</p><p>接着，考虑删掉哪个点。我们拥有以下两个观察： *删叶子比删其它点优。因为删非叶子会让其子树内的点的深度都 <spanclass="math inline">\(-1\)</span>，不划算。</p><ul><li>其次，在所有叶子中，删深度最小的。这是上一段的直接推论。</li></ul><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1450c1c2.-errich-tac-toe"><ahref="https://codeforces.com/contest/1450/problem/C2">CF1450C1/C2.Errich-Tac-Toe</a></h2><p>*2100 <ahref="https://codeforces.com/contest/1450/submission/318153681">Code</a>（C1）</p><p>*2300 <ahref="https://codeforces.com/contest/1450/submission/318153746">Code</a>（C2）</p><p>见到 <spanclass="math inline">\(\lfloor\frac{k}{3}\rfloor\)</span>，可以有意识的将操作划分为三个等价类，满足三个等价类的操作数之和为<spanclass="math inline">\(k\)</span>。这样根据抽屉原理，一定有一类操作的数量<span class="math inline">\(\le \lfloor\frac{k}{3}\rfloor\)</span>。</p><p>对于 C1，令 <span class="math inline">\(t_{i,j}=(i+j)\bmod3\)</span>，那么网格被划分成了三类。定义三种操作如下： * <spanclass="math inline">\(\forall \ t_{i,j}=0\)</span> 的 <spanclass="math inline">\((i,j)\)</span>，若 <spanclass="math inline">\(s_{i,j}= X\)</span>，改为 <spanclass="math inline">\(O\)</span>。</p><ul><li><p><span class="math inline">\(\forall \ t_{i,j}=1\)</span> 的 <spanclass="math inline">\((i,j)\)</span>，若 <spanclass="math inline">\(s_{i,j}= X\)</span>，改为 <spanclass="math inline">\(O\)</span>。</p></li><li><p><span class="math inline">\(\forall \ t_{i,j}=2\)</span> 的 <spanclass="math inline">\((i,j)\)</span>，若 <spanclass="math inline">\(s_{i,j}= X\)</span>，改为 <spanclass="math inline">\(O\)</span>。</p></li></ul><p>注意到上述任意一种操作都能实现目标（因为任意三个横着的或竖着的格子必定包含<span class="math inline">\(t_{i,j}\)</span> 的三种取值）。</p><p>并且这三类操作的操作数之和恰好为 <spanclass="math inline">\(k\)</span>，根据抽屉原理，一定有一种操作满足操作数<span class="math inline">\(\le \lfloor\frac{k}{3}\rfloor\)</span>。</p><p>对于 C2，同样令 <span class="math inline">\(t_{i,j}=(i+j)\bmod3\)</span>，但三种操作变化如下： * <span class="math inline">\(\forall \t_{i,j}=0\)</span> 的 <span class="math inline">\((i,j)\)</span>，若<span class="math inline">\(s_{i,j}= X\)</span>，改为 <spanclass="math inline">\(O\)</span>；<span class="math inline">\(\forall \t_{i,j}=1\)</span> 的 <span class="math inline">\((i,j)\)</span>，若<span class="math inline">\(s_{i,j}= O\)</span>，改为 <spanclass="math inline">\(X\)</span>。</p><ul><li><p><span class="math inline">\(\forall \ t_{i,j}=1\)</span> 的 <spanclass="math inline">\((i,j)\)</span>，若 <spanclass="math inline">\(s_{i,j}= X\)</span>，改为 <spanclass="math inline">\(O\)</span>；<span class="math inline">\(\forall \t_{i,j}=2\)</span> 的 <span class="math inline">\((i,j)\)</span>，若<span class="math inline">\(s_{i,j}= O\)</span>，改为 <spanclass="math inline">\(X\)</span>。</p></li><li><p><span class="math inline">\(\forall \ t_{i,j}=2\)</span> 的 <spanclass="math inline">\((i,j)\)</span>，若 <spanclass="math inline">\(s_{i,j}= X\)</span>，改为 <spanclass="math inline">\(O\)</span>；<span class="math inline">\(\forall \t_{i,j}=0\)</span> 的 <span class="math inline">\((i,j)\)</span>，若<span class="math inline">\(s_{i,j}= O\)</span>，改为 <spanclass="math inline">\(X\)</span>。</p></li></ul><p>每种操作都由两个形如 <span class="math inline">\(X\toO\)</span>，<span class="math inline">\(O\to X\)</span>的子操作组合而成，保证了任意三个横着的或竖着的格子都一定不全为 <spanclass="math inline">\(X/O\)</span>。</p><p>又对于每个 <span class="math inline">\(s_{i,j}\)</span> 不为<code>.</code> 的格子，至多变化一次，所以上述三种操作的操作数之和仍然是<span class="math inline">\(k\)</span>。</p><p>同理也一定有一种操作满足操作数 <span class="math inline">\(\le\lfloor\frac{k}{3}\rfloor\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="cf1450e.-capitalism"><ahref="https://codeforces.com/contest/1450/problem/E">CF1450E.Capitalism</a></h2><p>*2700 <ahref="https://codeforces.com/contest/1450/submission/318179144">Code</a></p><p>首先，原图一定构成二分图，按照 <spanclass="math inline">\(a_i\)</span>的奇偶性分成两侧。不是二分图一定无解。</p><p>其次，考虑未定向的边 <spanclass="math inline">\((u,v)\)</span>，需要满足 <spanclass="math inline">\(a_u=a_v+1\)</span> 或 <spanclass="math inline">\(a_v=a_u+1\)</span>。</p><p>转换成可以使用差分约束的形式，也就是 <spanclass="math inline">\(a_u-a_v\le 1\)</span> 且 <spanclass="math inline">\(a_v-a_u\le 1\)</span>。</p><p>但这两个条件只是必要条件，若充分则还需满足 <spanclass="math inline">\(a_u\neq a_v\)</span>。但注意到二分图自然满足 <spanclass="math inline">\(a_u\neq a_v\)</span>（边权为 <spanclass="math inline">\(1\)</span>且没有奇环的情况下两个相邻点的最短路的奇偶性一定不同），故判完二分图上面的转化自然充要。</p><p>接着，考虑已经定向了的边 <spanclass="math inline">\((u,v)\)</span>，不妨令 <spanclass="math inline">\(a_v=a_u+1\)</span>，则同样可以转化为：<spanclass="math inline">\(a_u-a_v\le -1\)</span> 且 <spanclass="math inline">\(a_v-a_u\le 1\)</span>。</p><p>现在可以开始跑差分约束了，但还面临两个问题： *Q1：如何保证跑出来的可行解极差最大？</p><ul><li>Q2：选出哪一个点作为起点（零势点）？</li></ul><p>A1：差分约束跑出来的可行解就是每个变量在其约束条件下的最大值。你也可以想象选定零势点后，最大值不可能超过从起点出发到某一点的最短路。</p><p>A2：我们选取每一个点都作为零势点跑 spfa，并钦定 <spanclass="math inline">\(0\)</span> 是最小值，这样最后若存在 <spanclass="math inline">\(dis&lt;0\)</span>或负环，该方案就不合法，忽略掉就行了。</p><p>于是，做法是遍历 <span class="math inline">\(i\in[1,n]\)</span>，钦定 <span class="math inline">\(i\)</span>为起点跑出一个 <span class="math inline">\(dis\)</span>序列，最后取极差最大的即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2m)\)</span>。</p><h2 id="cf1445e.-team-building"><ahref="https://codeforces.com/contest/1445/problem/E">CF1445E.Team-Building</a></h2><p>*2500 <ahref="https://codeforces.com/contest/1445/submission/318251078">Code</a></p><p>题意概括一下：给定一个 <span class="math inline">\(n\)</span> 个点<span class="math inline">\(m\)</span> 条边的图，有 <spanclass="math inline">\(k\)</span>种颜色，每个点的颜色你也知道，问选出两种颜色，使它们的导出子图是二分图的方案数。</p><p>首先，你得会怎么用并查集判断二分图，不懂的可以做一下 <ahref="https://www.luogu.com.cn/problem/P1525">P1525</a> 以及 <ahref="https://www.luogu.com.cn/problem/P5787">P5787</a>。</p><p>这里总结一下，分如下几步： * 初始化一个大小为 <spanclass="math inline">\(2n\)</span> 的并查集。</p><ul><li>遍历每条边 <span class="math inline">\((x,y)\)</span>：<ul><li><p>若 <spanclass="math inline">\(\text{dsu.same}(x,y)\)</span>，则不是二分图。</p></li><li><p><spanclass="math inline">\(\text{dsu.merge}(x,y+n)\)</span>，<spanclass="math inline">\(\text{dsu.merge}(y,x+n)\)</span>。</p></li><li><p>若 <span class="math inline">\(\text{dsu.same}(x,x+n)\)</span> 或<spanclass="math inline">\(\text{dsu.same}(y,y+n)\)</span>，则不是二分图。</p></li></ul></li><li>否则是二分图。</li></ul><p>回到该题，我们可以把图中的所有边分为两类，第一类是连接相同颜色的边，第二类是连接不同颜色的边。</p><p>我们先把第一类边都连起来，对所有 <spanclass="math inline">\(k\)</span> 种颜色判断第 <spanclass="math inline">\(i\)</span>种颜色构成的单色连通块是否是二分图。</p><p>一种颜色的单色连通块若不是二分图，那么这种颜色与其它颜色的导出子图就一定不是二分图。（因为二分图等价于没有奇环，有奇环的图和其它图并起来原来的奇环也不会消失）</p><p>设有 <span class="math inline">\(cnt\)</span>种颜色的单色连通块是二分图，那么答案的上界是 <spanclass="math inline">\(\frac{cnt(cnt-1)}{2}\)</span>，尝试容斥一下，排除一些不是二分图的组合。</p><p>暴力的做法是 <span class="math inline">\(O(cnt^2)\)</span>枚举两种颜色，将连接这两种颜色的边的第二类边加上，判断是否为二分图。</p><p>注意到第二类边的数量是有限的，如果改成枚举边的话，就是 <spanclass="math inline">\(O(m)\)</span> 的。</p><p>一种简洁且直接的做法是对每一个颜色二元组 <spanclass="math inline">\((col_x,col_y)\)</span> 记录有哪些边 <spanclass="math inline">\((u,v)\)</span> 连接了颜色分别为 <spanclass="math inline">\(col_x\)</span> 和 <spanclass="math inline">\(col_y\)</span> 的点。即用一个<code>map&lt;array&lt;int, 2&gt;, vector&lt;array&lt;int, 2&gt;&gt;&gt;</code>存边，虽然多了一个 <spanclass="math inline">\(\log\)</span>，但相比把边按颜色排序的做法会好写很多。</p><p>注意到整个判断过程第一类边一直保留，第二类边在判断完一种颜色组合后需要撤销，故用一个可撤销并查集来维护。</p><p>时间复杂度 <span class="math inline">\(O(m\log m+m\logn)\)</span>。</p><h2 id="cf2102e.-23-kingdom"><ahref="https://codeforces.com/contest/2102/problem/E">CF2102E. 23Kingdom</a></h2><p>*2200 <ahref="https://codeforces.com/contest/2102/submission/319302504">Code</a></p><p>题目相当于对所有 <span class="math inline">\(i\in[1,n]\)</span>，选出至多一组 <spanclass="math inline">\(a_l=i\)</span>，<spanclass="math inline">\(a_r=i\)</span>，<spanclass="math inline">\(l&lt;r\)</span> 的 <spanclass="math inline">\(l,r\)</span>，并累加 <spanclass="math inline">\(r-l\)</span> 的贡献。</p><p>因为序列中的每个数只能变小不能变大，故从大到小枚举 <spanclass="math inline">\(i\)</span>，试图确定左右端点，没用上的位置丢进一个集合<span class="math inline">\(S\)</span>里备选。而用上的数将来也可能变小作为新的端点，所以这其实是一个反悔贪心问题。</p><p>现在，对于一个 <span class="math inline">\(i\)</span>，我们从 <spanclass="math inline">\(S\)</span> 中取出最小的数作为 <spanclass="math inline">\(l\)</span>，最大的数作为 <spanclass="math inline">\(r\)</span>。有两种选择： * <spanclass="math inline">\([l,r]\)</span> 作为一个新的线段。</p><ul><li><span class="math inline">\(l\)</span> 替代已有线段中最大的 <spanclass="math inline">\(l\)</span>，<span class="math inline">\(r\)</span>替代已有线段中最小的 <span class="math inline">\(r\)</span>。</li></ul><p>二选一怎么选？注意到已有线段中最大的 <spanclass="math inline">\(l\)</span> 一定小于已有线段中最小的 <spanclass="math inline">\(r\)</span>，否则肯定不优。</p><p>如果 <span class="math inline">\([l,r]\)</span>加进当前线段集合后仍然满足上述条件，那么这条新线段的贡献肯定严格大于第二种情况。</p><p>反过来，如果 <span class="math inline">\((L&#39;,R&#39;)\)</span>加进去变成 <span class="math inline">\(L\ L&#39; \ L\ R&#39; \ L\ R\ R\R\)</span>，那就不如 <span class="math inline">\(L&#39;\)</span>替换最后一个 <span class="math inline">\(L\)</span>，变成 <spanclass="math inline">\(L\ L\ L&#39;\ R\ R\ R\)</span>。</p><p>故优先判断 <span class="math inline">\([l,r]\)</span>作为一个新线段是否可行，不行再考虑替代已有的左右端点。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2110d.-fewer-batteries"><ahref="https://codeforces.com/contest/2110/problem/D">CF2110D. FewerBatteries</a></h2><p><ahref="https://codeforces.com/contest/2110/submission/321181200">Code</a></p><p>二分答案。设二分出的答案是 <spanclass="math inline">\(mid\)</span>，那么策略就固定了：在把电池拿到 <spanclass="math inline">\(mid\)</span> 个前，能拿就尽量拿。</p><p>DAG 上 dp，令 <span class="math inline">\(dp[x]\)</span> 表示从 <spanclass="math inline">\(1\to x\)</span> 这一段最多能拿到的电池数目： <spanclass="math display">\[dp[y]=\min(mid,\max_{x\to y}(dp[x]+b[y]))\]</span></p><p>初始令 <spanclass="math inline">\(dp[x]=\begin{cases}\min(mid,b[1])&amp;,x=1\\-1&amp;,x&gt;1\end{cases}\)</span>，最后 check 一下 <spanclass="math inline">\(dp[n]\)</span> 是否非负即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p><h2 id="cf2110e.-melody"><ahref="https://codeforces.com/contest/2110/problem/E">CF2110E.Melody</a></h2><p><ahref="https://codeforces.com/contest/2110/submission/321149178">Code</a></p><p>不要等到失去，才后悔那天写欧拉路径没有从非零度点开始遍历……把两个属性看成一个二元组 <spanclass="math inline">\((a_i,b_i)\)</span>，不难发现对于一个合法的序列，一定是：<spanclass="math inline">\((a_i\)</span> 变，<spanclass="math inline">\(b_i\)</span> 不变 <spanclass="math inline">\()\)</span> <spanclass="math inline">\(\to\)</span> <spanclass="math inline">\((a_i\)</span> 不变，<spanclass="math inline">\(b_i\)</span> 变 <spanclass="math inline">\()\)</span> <spanclass="math inline">\(\to\)</span> <spanclass="math inline">\((a_i\)</span> 变，<spanclass="math inline">\(b_i\)</span> 不变 <spanclass="math inline">\()\)</span> <spanclass="math inline">\(\ldots\)</span> 如此循环。</p><p>将二元组 <span class="math inline">\((a_i,b_i)\)</span> 看成一条连接<span class="math inline">\(a_i,b_i\)</span> 的边，这里得离散化。</p><p>离散化的时候注意 <span class="math inline">\((\cdot,a_i)\)</span> 和<span class="math inline">\((a_i,\cdot)\)</span>是区分开的，你也可以看成二分图。</p><p>那么答案就是这张无向图的一条欧拉路径。</p><p>尤其注意非零度点要连通。时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Atcoder </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】四月训练日记</title>
      <link href="/posts/52d312a5.html"/>
      <url>/posts/52d312a5.html</url>
      
        <content type="html"><![CDATA[<h2 id="cf1709e.-xor-tree"><ahref="https://codeforces.com/contest/1709/problem/E">CF1709E. XORTree</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1709/submission/313331153">Code</a></p><p>注意到操作时改成的正整数没有大小限制，不妨改成 <spanclass="math inline">\(2^{k}\)</span>（<spanclass="math inline">\(k\)</span>充分大），这样经过该点的路径的权值绝对不可能为 <spanclass="math inline">\(0\)</span>。</p><p>指定一个根节点（不妨为 <spanclass="math inline">\(1\)</span>），假定路径 <spanclass="math inline">\(x\leftrightarrow y\)</span> 是坏的（也就是异或和为<span class="math inline">\(0\)</span>），那么容易说明修改 <spanclass="math inline">\(z=\text{LCA}(x,y)\)</span> 是最优的。</p><p>考虑这么一个过程：从根节点开始向下 dfs，回溯时判断当前节点 <spanclass="math inline">\(z\)</span> 是否能作为一条坏的路径的 <spanclass="math inline">\(\text{LCA}\)</span>。若能，答案 <spanclass="math inline">\(+1\)</span>；否则不做修改。</p><p>问题转换为如何进行这个判定。设 <spanclass="math inline">\(f_x\)</span> 代表从根节点开始的前缀异或和，即路径<span class="math inline">\(1\leftrightarrow x\)</span>的权值。那么，路径 <span class="math inline">\(x\leftrightarrowy\)</span> 是坏的等价于 <span class="math inline">\(f_x\oplus f_y\oplusa_{\text{LCA}(x,y)}=0\)</span>。</p><p>对每一个顶点 <span class="math inline">\(z\)</span> 维护一个<code>std::set</code>，存储以 <span class="math inline">\(z\)</span>为根的子树里的节点的 <span class="math inline">\(f\)</span>集合。这样当我们合并 <span class="math inline">\(z\)</span>的一个儿子（设为 <spanclass="math inline">\(p\)</span>）的信息时，只用遍历 <spanclass="math inline">\(z,p\)</span>中较小的一个集合，在另一个集合里查有没有符合要求的元素。</p><p>若当前节点需要修改，就清空当前节点的<code>std::set</code>，否则合并儿子的信息。</p><p>这是一个启发式合并的过程，时间复杂度 <spanclass="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="cf1981d.-turtle-and-multiplication"><ahref="https://codeforces.com/contest/1981/problem/D">CF1981D. Turtle andMultiplication</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1981/submission/313367256">Code</a></p><p>当所有 <span class="math inline">\(a_i\)</span> 都是质数时，<spanclass="math inline">\(a_i\cdot a_{i+1}\not=a_j\cdot a_{j+1}\)</span>的充要条件是无序对 <span class="math inline">\((a_i,a_{i+1})\)</span>和无序对 <span class="math inline">\((a_j,a_{j+1})\)</span> 不同。当<span class="math inline">\(a_i\)</span>不都是质数时，充要条件会退化成必要条件，更劣，故优先思考 <spanclass="math inline">\(a_i\)</span> 都是质数时是否能构造。</p><p>将无序对 <span class="math inline">\((a_i,a_{i+1})\)</span>看作一条无向边，那么问题转换为找到一个最小的 <spanclass="math inline">\(m\)</span>，满足 <spanclass="math inline">\(m\)</span> 个点构成的完全图存在一条覆盖 <spanclass="math inline">\(n-1\)</span>条边（每条边至多被覆盖一次）的路径。</p><p>当 <span class="math inline">\(m\)</span>为奇数时，图上所有顶点的度数都是偶数，存在一条长 <spanclass="math inline">\(\frac{m(m-1)}{2}+m\)</span> 的欧拉回路（<spanclass="math inline">\(+m\)</span> 是因为每个点都有自环，算一条边）。</p><p>当 <span class="math inline">\(m\)</span>为偶数时，图上所有顶点的度数都是奇数。无向图存在欧拉路径的条件是有 <spanclass="math inline">\(0/2\)</span>个点是奇度点，其它为偶度点。考虑删边，只留下两个奇度点，一种留下最多边的方式是删<spanclass="math inline">\((2,3),(4,5),(6,7),\ldots,(m-2,m-1)\)</span>。剩余边数是<spanclass="math inline">\(\frac{m(m-1)}{2}+m-\frac{m}{2}+1\)</span>。</p><p>二分出最小满足条件的 <spanclass="math inline">\(m\)</span>，构造出对应的 <spanclass="math inline">\(m\)</span> 个点的完全图（若 <spanclass="math inline">\(m\)</span>是偶数还要按上述规则删边），跑出一条欧拉路径。若路径上第 <spanclass="math inline">\(i\)</span> 个点是 <spanclass="math inline">\(x\)</span>，对应到序列上 <spanclass="math inline">\(a_i\)</span> 就是第 <spanclass="math inline">\(x\)</span> 小的质数。</p><p>当 <span class="math inline">\(m=1500\)</span> 时，构造出的图有 <spanclass="math inline">\(1125001&gt;10^6\)</span> 条边，而第 <spanclass="math inline">\(1500\)</span> 小的质数是 <spanclass="math inline">\(12553&lt;3\cdot 10^5\)</span>，满足条件。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1981e.-turtle-and-intersected-segments"><ahref="https://codeforces.com/contest/1981/problem/E">CF1981E. Turtle andIntersected Segments</a></h2><p>*2600 <ahref="https://codeforces.com/contest/1981/submission/313615140">Code</a></p><p>对于三条两两相交的线段 <spanclass="math inline">\([l_1,r_1,a_1],[l_2,r_2,a_2],[l_3,r_3,a_3]\)</span>，设<span class="math inline">\(a_1\le a_2\le a_3\)</span>，那么可以仅保留边<span class="math inline">\(1\leftrightarrow 2,\ 2\leftrightarrow3\)</span>。（因为 <spanclass="math inline">\(|a_1-a_3|=|a_1-a_2|+|a_2-a_3|\)</span>，选第 <spanclass="math inline">\(3\)</span> 条边肯定不优） 不难发现对于每一条线段<spanclass="math inline">\([l_i,r_i,a_i]\)</span>，我们只用保留两条边：</p><ol type="1"><li><p>与该线段相交的线段中，权值（设为 <spanclass="math inline">\(a_j\)</span>）最大且满足 <spanclass="math inline">\(a_j\le a_i\)</span> 的边。</p></li><li><p>与该线段相交的线段中，权值（设为 <spanclass="math inline">\(a_j\)</span>）最小且满足 <spanclass="math inline">\(a_j\ge a_i\)</span> 的边。</p></li></ol><p>扫描线，维护一个<code>std::set</code>，扫描到一条线段的左端点时就把线段的权值加进去，扫描到右端点时就把对应的权值删掉。保留的边相当于线段在容器中的前驱和后继。</p><p>最终处理出的侯选边有 <span class="math inline">\(O(n)\)</span>条，跑最小生成树即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="abc399e.-replace"><ahref="https://atcoder.jp/contests/abc399/tasks/abc399_e">abc399e.Replace</a></h2><p><ahref="https://atcoder.jp/contests/abc399/submissions/64455710">Code</a></p><p>连边 <span class="math inline">\(S_i\to T_i\)</span>。</p><p>首先每个点至多有一条出边，否则 <code>-1</code>。<spanclass="math inline">\(26\)</span> 个点都有入度，也为<code>-1</code>。</p><p>否则答案的下界是图上的边数（不含自环）。</p><p>对于一个环，分两种情况： * 环上存在入度为 <spanclass="math inline">\(2\)</span> 的点。说明存在一条边 <spanclass="math inline">\(x\to y\)</span> 满足 <spanclass="math inline">\(y\)</span> 在环上而 <spanclass="math inline">\(x\)</span> 不在。设 <spanclass="math inline">\(y\)</span> 的另一条入边是 <spanclass="math inline">\(z\to y\)</span>，此时可以花 <spanclass="math inline">\(1\)</span> 的代价将 <spanclass="math inline">\(z\)</span> 改为 <spanclass="math inline">\(x\)</span>，破环成链，且不花费额外次数（即用 <spanclass="math inline">\(1\)</span> 次操作断了一条边，与预设“答案是图上的边数” 相符）。</p><ul><li>环上所有点入度为 <spanclass="math inline">\(1\)</span>。此时只能将环上任意一点 <spanclass="math inline">\(x\)</span>替换为图中的一个孤点，最后再改回来，花费了 <spanclass="math inline">\(1\)</span> 点额外次数。</li></ul><p>于是答案是图上的边数 <span class="math inline">\(+\)</span>第二类环的数量。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1139e.-maximize-mex"><ahref="https://codeforces.com/problemset/problem/1139/E">CF1139E.Maximize Mex</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1139/submission/314383443">Code</a></p><p>考虑没有人离开社团的情况。此时二分答案，设二分的 <spanclass="math inline">\(\text{mex}\)</span> 是 <spanclass="math inline">\(mid\)</span>，那么只需要保留潜力值 <spanclass="math inline">\(&lt;mid\)</span> 的学生。</p><p>建出一个二分图，左部图是 <span class="math inline">\(m\)</span>个社团，右部图对应 <span class="math inline">\(0\sim mid - 1\)</span> 这<span class="math inline">\(mid\)</span>个潜力值。对于一个学生，我们可以连出一条边，最终只要看最大匹配是否为<span class="math inline">\(mid\)</span>。</p><p>若有学生离开了，相当于删掉一条边，这是不好处理的。但我们想到 Dinic可以动态加边，于是离线下来倒着做。</p><p>但每加一条边就要重新二分枚举 <spanclass="math inline">\(\text{mex}\)</span> 就太低效了。注意到加边的时候<span class="math inline">\(\text{mex}\)</span>只增不减，换句话匹配数只增不减。我们可以从 <spanclass="math inline">\(1\)</span> 开始枚举 <spanclass="math inline">\(\text{mex}\)</span>，每次将 <spanclass="math inline">\(p[i]=\text{mex}-1\)</span>的学生加到图上，若匹配数恰好为 <spanclass="math inline">\(\text{mex}\)</span>，就 <spanclass="math inline">\(\text{mex}\leftarrow\text{mex}+1\)</span>，重复这个流程。</p><p>此时，一个学生 <span class="math inline">\(i\)</span>加入社团，分两种情况处理： 1. 加入时枚举的 <spanclass="math inline">\(\text{mex}\ge p[i]\)</span>。直接加边即可。</p><ol start="2" type="1"><li>加入时枚举的 <spanclass="math inline">\(\text{mex}&lt;p[i]\)</span>。将学生 <spanclass="math inline">\(i\)</span> 加进备选名单里，等 <spanclass="math inline">\(\text{mex}\)</span> 枚举到的时候再加边。</li></ol><p>时间复杂度 <span class="math inline">\(O(\text{MaxFlow}(m,n))\)</span>。</p><h2 id="cf1746f.-kazaee"><ahref="https://codeforces.com/contest/1746/problem/F">CF1746F.Kazaee</a></h2><p>*2800 <ahref="https://codeforces.com/contest/1746/submission/314411747">Code</a></p><p>先将所有数（包括原有的 <span class="math inline">\(a_i\)</span>与每次修改后的 <span class="math inline">\(x\)</span>）进行离散化。</p><p>一个暴力的做法是对每个数都维护一个树状数组，这样整道题能在 <spanclass="math inline">\(O(n^2+qn\log n)\)</span> 内解决。</p><p>面临的困难无非只有一点：对于一个区间，时间复杂度不允许我们 check区间里每一个数的出现次数。</p><p>一个关键点是，一段区间中，如果所有数字的出现次数都是 <spanclass="math inline">\(k\)</span> 的倍数，其出现次数之和也一定为 <spanclass="math inline">\(k\)</span> 的倍数，但这是必要不充分条件。</p><p>随机化，在值域内随机选出 <span class="math inline">\(B\)</span>个子集，对于一个询问，逐一 check每一个子集，看每个子集里的数的出现次数之和是否为 <spanclass="math inline">\(k\)</span> 的倍数。</p><p>而单点修改时，遍历这 <span class="math inline">\(B\)</span>个子集，若当前子集包含修改前/修改后的数，就相应在树状数组上修改。</p><p>为了保证正确性，每个子集按照以下方式随机： * <spanclass="math inline">\(\forall i\in [1,W]\)</span>，<spanclass="math inline">\(i\)</span> 有 <spanclass="math inline">\(\dfrac{1}{2}\)</span> 的概率选进子集。其中 <spanclass="math inline">\(W\)</span> 为离散化后的值域。</p><p>错误率分析：最坏情况下，判错当且仅当存在一对数 <spanclass="math inline">\(x,y\)</span>，满足 <spanclass="math inline">\(k\mid cnt_x+cnt_y\)</span> 且 <spanclass="math inline">\(k\not\mid cnt_x\)</span>，<spanclass="math inline">\(k\not\mid cnt_y\)</span>。四种情况：选 <spanclass="math inline">\(x\)</span> 没选 <spanclass="math inline">\(y\)</span>，选 <spanclass="math inline">\(y\)</span> 没选 <spanclass="math inline">\(x\)</span>，没选 <spanclass="math inline">\(x\)</span> 没选 <spanclass="math inline">\(y\)</span>，选 <spanclass="math inline">\(x\)</span> 选 <spanclass="math inline">\(y\)</span>，它们在概率上各占 <spanclass="math inline">\(\dfrac{1}{4}\)</span>，其中仅第三第四种会犯错，占<span class="math inline">\(\dfrac{1}{2}\)</span>。取 <spanclass="math inline">\(B=30\)</span>，错误率就是 <spanclass="math inline">\(\dfrac{1}{2^{30}}\)</span>，足够低了。</p><p>时间复杂度 <span class="math inline">\(O(nB\log n+qB\logn)\)</span>。</p><h2 id="abc401f.-add-one-edge-3"><ahref="https://atcoder.jp/contests/abc401/tasks/abc401_f">abc401f. AddOne Edge 3</a></h2><p><ahref="https://atcoder.jp/contests/abc401/submissions/64815017">Code</a></p><p>记 <span class="math inline">\(G\)</span> 为树 <spanclass="math inline">\(1\)</span>，<span class="math inline">\(H\)</span>为树 <span class="math inline">\(2\)</span>。</p><p>记 <span class="math inline">\(d_1,A_1,A_2\)</span> 为 <spanclass="math inline">\(G\)</span> 的直径及其两个端点，<spanclass="math inline">\(d_2,B_1,B_2\)</span> 为 <spanclass="math inline">\(H\)</span> 的直径及其两个端点。</p><p>记 <span class="math inline">\(f_x/g_x\)</span> 为以 <spanclass="math inline">\(G/H\)</span> 中的点 <spanclass="math inline">\(x\)</span> 为端点的最长的路径的长度，显然有 <spanclass="math inline">\(f_x=\max(dis(A_1,x),dis(A_2,x))\)</span>，<spanclass="math inline">\(g_x=\max(dis(B_1,x),dis(B_2,x))\)</span>。</p><p>对于一条连接了 <span class="math inline">\(G\)</span> 中点 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(H\)</span> 中点 <spanclass="math inline">\(j\)</span> 的边，新图直径变为 <spanclass="math inline">\(\max(\max(d_1,d_2),f_i+g_j+1)\)</span>。</p><p>将 <span class="math inline">\(f_x,g_x\)</span> 升序排序，枚举 <spanclass="math inline">\(f_i\)</span>，就能二分或双指针求出有多少个满足<span class="math inline">\(f_i+g_j+1&gt;\max(d_1,d_2)\)</span> 的 <spanclass="math inline">\(g_j\)</span>，贡献就是一段 <spanclass="math inline">\(g\)</span> 的后缀和。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1749e.-cactus-wall"><ahref="https://codeforces.com/contest/1749/problem/E">CF1749E. CactusWall</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1749/submission/316076925">Code</a></p><p>转化：相当于寻找一条 <code>#</code>构成的路径，这条路径从第一列开始，到最后一列结束，且每次只能走对角线的四个方向。</p><p>先把图上所有可以放置 <code>#</code> 的位置找出来（包括原来就有的<code>#</code>），称作关键点。</p><p>建图，源点 <span class="math inline">\(S\)</span>向第一列的关键点连边，每个关键点向四个对角线方向的关键点连边，最后一列的关键点向汇点<span class="math inline">\(T\)</span> 连边。</p><p>一条边 <span class="math inline">\((u,v)\)</span> 的边权取决于 <spanclass="math inline">\(v\)</span>，若 <spanclass="math inline">\(v\)</span> 为汇点或原来就有 <code>#</code>的位置，边权就是 <span class="math inline">\(0\)</span>；否则边权是<span class="math inline">\(1\)</span>（代表需要在此处新放置一个<code>#</code>）。</p><p>跑最短路即可，记一下路径方案也就有了。</p><p>时间复杂度：<span class="math inline">\(O(nm\log nm)\)</span>。若使用01bfs 还可以省去 <span class="math inline">\(\log\)</span>。</p><h2 id="cf2096e.-wonderful-teddy-bears"><ahref="https://codeforces.com/contest/2096/problem/E">CF2096E. WonderfulTeddy Bears</a></h2><p>*2400 <ahref="https://codeforces.com/contest/2096/submission/316390064">Code</a></p><p>将 <code>B</code> 看作 <spanclass="math inline">\(0\)</span>，<code>P</code> 看作 <spanclass="math inline">\(1\)</span>。</p><p>对一个长为 <span class="math inline">\(3\)</span>的子串操作，分为以下四种情况。</p><ol type="1"><li><p><span class="math inline">\(010\to 001\)</span>；</p></li><li><p><span class="math inline">\(100\to 001\)</span>；</p></li><li><p><span class="math inline">\(101\to 011\)</span>；</p></li><li><p><span class="math inline">\(110\to 011\)</span>。</p></li></ol><p>我们将操作 <span class="math inline">\(1,3\)</span> 归为一类，称为<span class="math inline">\(A\)</span>；操作 <spanclass="math inline">\(2,4\)</span> 归为一类，称为 <spanclass="math inline">\(B\)</span>。</p><p>之所以这么分，是因为观察到如下性质： * <spanclass="math inline">\(A\)</span> 类操作能将逆序对数 <spanclass="math inline">\(-1\)</span>，而 <spanclass="math inline">\(B\)</span> 类操作能将逆序对数 <spanclass="math inline">\(-2\)</span>。</p><ul><li><span class="math inline">\(A\)</span> 类操作能改变一个 <spanclass="math inline">\(0\)</span> 的下标奇偶性，而 <spanclass="math inline">\(B\)</span> 类操作不能。</li></ul><p>令 <span class="math inline">\(c_0,c_1\)</span> 分别表示序列中 <spanclass="math inline">\(0/1\)</span> 的个数，<spanclass="math inline">\(rev\)</span> 表示逆序对数，<spanclass="math inline">\(tot\)</span> 表示下标为偶数的 <spanclass="math inline">\(0\)</span> 的数量。</p><p>想象一个排好序的的 <span class="math inline">\(01\)</span> 串：有<spanclass="math inline">\(\left\lfloor\frac{c_0}{2}\right\rfloor\)</span> 个<span class="math inline">\(0\)</span> 的下标为偶数（1-index）。</p><p>那么可以先用 <spanclass="math inline">\(\left|tot-\left\lfloor\frac{c_0}{2}\right\rfloor\right|\)</span>次 <span class="math inline">\(A\)</span> 类操作调整奇偶性，再用 <spanclass="math inline">\(B\)</span> 类操作减少逆序对数。</p><p>可以预见的是调整奇偶性后逆序对数一定是偶数，故最后不必再用 <spanclass="math inline">\(A\)</span> 类操作减少逆序对数。</p><p>答案是 <spanclass="math inline">\(\left|tot-\left\lfloor\frac{c_0}{2}\right\rfloor\right|+\dfrac{(rev-\left|tot-\left\lfloor\frac{c_0}{2}\right\rfloor\right|)}{2}=\dfrac{rev+\left|tot-\left\lfloor\frac{c_0}{2}\right\rfloor\right|}{2}\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1977d.-xorificator"><ahref="https://codeforces.com/contest/1977/problem/D">CF1977D.XORificator</a></h2><p>*2300 <ahref="https://codeforces.com/contest/1977/submission/316507565">Code</a></p><p>注意到当我们钦定某个点 <span class="math inline">\((x,y)\)</span>为那一列（即第 <span class="math inline">\(y\)</span> 列）唯一的 <spanclass="math inline">\(1\)</span>时，每一行是否需要翻转就被唯一确定了（或者说整个矩阵都被确定了）。</p><p>考虑枚举每个点作为那一列唯一的 <spanclass="math inline">\(1\)</span>，问题转换为如何快速知道该状态下有多少列仅有一个<span class="math inline">\(1\)</span>。</p><p>反向思考，钦定一个点作为那一列唯一的 <spanclass="math inline">\(1\)</span> 时，把此时的 XORificator记录下来（题解里用的 Zobrist hashing，implement非常精悍短小），答案就是出现次数最多的 XORificator 的出现次数。</p><p>时间复杂度 <span class="math inline">\(O(nm\log nm)\)</span>。</p><h2 id="cf1622d.-shuffle"><ahref="https://codeforces.com/contest/1622/problem/D">CF1622D.Shuffle</a></h2><p>*2000 <ahref="https://codeforces.com/contest/1622/submission/316676899">Code</a></p><p>要求本质不同看起来十分困难，但有个 trick是你枚举所有区间，然后钦定这个区间的左端点和右端点都一定发生了变化，这样计数不重不漏，考虑起来就轻松很多。</p><p>先特判掉整个串的 <span class="math inline">\(1\)</span> 都不足 <spanclass="math inline">\(k\)</span> 个的情况。</p><p>首先，枚举的区间需要满足 “区间内 <spanclass="math inline">\(1\)</span> 的个数 <span class="math inline">\(\lek\)</span>”，为什么是小于等于？因为我们实际操作的区间恰有 <spanclass="math inline">\(k\)</span> 个 <spanclass="math inline">\(1\)</span>，但相对原来发生变化的区间可以是一个子集。</p><p>接着，区间两侧的数必须发生变化，非两侧的数任意排列，贡献就是一个组合数。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="cf1622e.-math-test"><ahref="https://codeforces.com/contest/1622/problem/E">CF1622E. MathTest</a></h2><p>*2200 <ahref="https://codeforces.com/contest/1622/submission/316688280">Code</a></p><p>trick：拆绝对值。<span class="math inline">\(|x_i-r_i|\)</span>可以拆成 <span class="math inline">\(x_i-r_i\)</span> 和 <spanclass="math inline">\(r_i-x_i\)</span> 两种，时间复杂度允许我们 <spanclass="math inline">\(O(2^n)\)</span> 枚举每一种拆法。</p><p>贪心，我们可以统计出每道题被多少个人解决了（如果那个人是 <spanclass="math inline">\(x_i-r_i\)</span>，<spanclass="math inline">\(r_i\)</span> 的贡献是负的，就当作 <spanclass="math inline">\(-1\)</span> 个人；反之 <spanclass="math inline">\(r_i-x_i\)</span> 就看作 <spanclass="math inline">\(+1\)</span> 个人），给被更多人解决的题赋值一个大的<span class="math inline">\(p_j\)</span>。</p><p>因为绝对值被拆掉了，<span class="math inline">\(\{p\}\)</span>确定之后最终答案也确定了，取 <span class="math inline">\(\max\)</span>即可。</p><p>时间复杂度 <span class="math inline">\(O(nm2^n)\)</span>。</p><h2 id="cf1354e.-graph-coloring"><ahref="https://codeforces.com/contest/1354/problem/E">CF1354E. GraphColoring</a></h2><p>*2100 <ahref="https://codeforces.com/contest/1354/submission/317219740">Code</a></p><p>注意到 <span class="math inline">\(1,3\)</span> 作为一组，<spanclass="math inline">\(2\)</span>作为一组，组间连边组内不连边，构成二分图。</p><p>故 <code>YES</code>的必要条件是给定的图的每一个连通分量均是二分图。</p><p>接着考虑数量限制：我们只用关心 <span class="math inline">\(2\)</span>的数量能否得到满足，<span class="math inline">\(2\)</span> 满足了 <spanclass="math inline">\(1,3\)</span> 自然满足。</p><p>设给定的图有 <span class="math inline">\(m\)</span> 个连通分量，第<span class="math inline">\(i\)</span> 个连通分量有 <spanclass="math inline">\(L_i\)</span> 个左部点，<spanclass="math inline">\(R_i\)</span> 个右部点。</p><p>现在我们要对每个连通分量选出左部或者右部填 <spanclass="math inline">\(2\)</span>，另一部 <spanclass="math inline">\(1,3\)</span> 任意填。</p><p>抽象出来相当于有 <span class="math inline">\(m\)</span>个集合，每个集合可以选 <span class="math inline">\(L_i\)</span> 或 <spanclass="math inline">\(R_i\)</span>中的恰好一个，判断是否存在一种选择方案使得选出的 <spanclass="math inline">\(m\)</span> 个数的总和是 <spanclass="math inline">\(n_2\)</span>。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个集合选出的数是否能凑成 <spanclass="math inline">\(j\)</span>，还需另开一个数组记录方案。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="cf1354f.-summoning-minions"><ahref="https://codeforces.com/contest/1354/problem/F">CF1354F. SummoningMinions</a></h2><p>*2500 <ahref="https://codeforces.com/contest/1354/submission/317254824">Code1</a><ahref="https://codeforces.com/contest/1354/submission/317268482">Code2</a></p><p>对于一个将来需要销毁的仆从，将它升级没有意义，故选择召唤之后马上销毁。</p><p>于是，最佳策略应该形如： 1. 从 <span class="math inline">\(n\)</span>个仆从中选择 <span class="math inline">\(k-1\)</span> 个召唤。</p><ol start="2" type="1"><li><p>从剩下的 <span class="math inline">\(n-k+1\)</span> 仆从中选择<span class="math inline">\(n-k\)</span> 个召唤后立即销毁。</p></li><li><p>召唤剩下的那 <span class="math inline">\(1\)</span>个仆从。</p></li></ol><p>在第一步中，假设仆从 <span class="math inline">\(i\)</span> 在第<span class="math inline">\(j\)</span> 个被召唤，则贡献是 <spanclass="math inline">\(a_i+b_i (j-1)\)</span>。</p><p>在第二步中，仆从 <span class="math inline">\(i\)</span>被召唤的贡献固定为 <span class="math inline">\(b_i(k-1)\)</span>。</p><p>在第三步中，仆从 <span class="math inline">\(i\)</span>被召唤的贡献为 <spanclass="math inline">\(a_i+b_i(k-1)\)</span>，可以和第一步的贡献合并。</p><p>建立二分图，左部点代表仆从，右部点代表被召唤时的顺序，问题转化为一个满二分图的最大权匹配，跑最大费用最大流即可。</p><p>时间复杂度 <span class="math inline">\(O(T\cdot\text{MinCostMaxFlow}(n, n^2))\)</span>。</p><p>另一种方法是注意到在第一步中，选定的 <spanclass="math inline">\(k\)</span> 个仆从（与第三步合并了，所以是 <spanclass="math inline">\(k\)</span> 个）一定按 <spanclass="math inline">\(b_i\)</span> 升序召唤。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个仆从选出 <spanclass="math inline">\(j\)</span> 个放在第一步的最大答案。 <spanclass="math display">\[dp[i][j] = \max(dp[i-1][j]+b_i(k-1),dp[i-1][j-1]+a_i+b_i(j-1))\]</span></p><p>回溯以记录方案。</p><p>时间复杂度 <span class="math inline">\(O(Tnk)\)</span>。</p><h2 id="cf555e.-case-of-computer-network"><ahref="https://codeforces.com/problemset/problem/555/E">CF555E. Case ofComputer Network</a></h2><p>*2800 <ahref="https://codeforces.com/contest/555/submission/317567976">Code</a></p><p>位于同一个边双连通分量中的点总是可以互相到达。（指总是存在一种可行的定向方案）边双缩点，对于一组 <span class="math inline">\((s_i, d_i)\)</span>，若<span class="math inline">\(s_i\)</span> 和 <spanclass="math inline">\(d_i\)</span> 在同一个边双内，则可以忽略。</p><p>否则，<span class="math inline">\(s_i\to d_i\)</span>上的边的方向就被固定了。（此处的 <spanclass="math inline">\(s_i,d_i\)</span> 指的都是其所在边双的编号，下同）固定一个根，对每个点维护两个标记 <span class="math inline">\(up\)</span>和 <span class="math inline">\(down\)</span> 分别表示上下两个方向。</p><p>对于一组询问，<span class="math inline">\(s_i\to\text{LCA}(s_i,d_i)\)</span> 上的点的 <spanclass="math inline">\(up\)</span> 标记 <spanclass="math inline">\(+1\)</span>，<spanclass="math inline">\(\text{LCA}(s_i,d_i)\to d_i\)</span> 上的点的 <spanclass="math inline">\(down\)</span> 标记 <spanclass="math inline">\(+1\)</span>，这个操作可以用树上差分简单实现。</p><p>最后，若有一个点同时有非零的 <span class="math inline">\(up\)</span>和 <span class="math inline">\(down\)</span> 标记，就是<code>No</code>。</p><p>此题有若干细节： * 图不连通，缩点后是一个森林，处理 LCA时要小心。</p><ul><li><p>若询问中的两个点不在一个连通分量内，直接就是<code>No</code>。</p></li><li><p>有重边。若两个点之间有重边，则它们属于同一个边双。</p></li></ul><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p><h2 id="abc399f.-range-power-sum"><ahref="https://atcoder.jp/contests/abc399/tasks/abc399_f">abc399f. RangePower Sum</a></h2><p><ahref="https://atcoder.jp/contests/abc399/submissions/65320388">Code</a></p><p>令 <span class="math inline">\(s_i=\sum\limits_{j=1}^{i}s_j\)</span>，则： <span class="math display">\[\begin{align}\sum_{1\le l\le r\le N}\left(\sum_{l\le i\le r}a_i\right)^k&amp;= \sum_{l=1}^{n}\sum_{r=l}^{n}\left(s_r-s_{l-1}\right)^k \\&amp;=\sum_{l=1}^{n}\sum_{r=l}^{n}\sum_{i=0}^{k}(-1)^{k-i}\binom{k}{i}s_r^{i}s_{l-1}^{k-i}\\&amp;=\sum_{i=0}^{k}(-1)^{k-i}\binom{k}{i}\sum_{l=1}^{n}\sum_{r=l}^{n}s_r^{i}s_{l-1}^{k-i}\\&amp;=\sum_{i=0}^{k}(-1)^{k-i}\binom{k}{i}\sum_{r=1}^{n}\sum_{l=1}^{r}s_r^{i}s_{l-1}^{k-i}\\&amp;=\sum_{i=0}^{k}(-1)^{k-i}\binom{k}{i}\sum_{r=1}^{n}s_r^{i}\sum_{l=1}^{r}s_{l-1}^{k-i}\\\end{align}\]</span></p><p>枚举 <span class="math inline">\(i,r\)</span>，而 <spanclass="math inline">\(\sum\limits_{l=1}^{r}s_{l-1}^{k-i}\)</span>可以预处理前缀和 <span class="math inline">\(O(1)\)</span> 求。</p><p>时间复杂度 <span class="math inline">\(O(nk)\)</span>。</p><h2 id="cf2104g.-modulo-3"><ahref="https://codeforces.com/contest/2104/problem/G">CF2104G. Modulo3</a></h2><p>*2700 <ahref="https://codeforces.com/contest/2104/submission/317693007">Code</a></p><p>每个点至多有一条出边，意味着这个图由若干环和链组成。并且，这种特殊的结构使得同一个环上的点的颜色一定相同，而链上的每个点都能取<span class="math inline">\(k\)</span> 种颜色中的任意一种。</p><p>具体的，设图中环的数量为 <span class="math inline">\(c\)</span>，第<span class="math inline">\(i\)</span> 个环的长度为 <spanclass="math inline">\(l_i\)</span>，对于一个给定的 <spanclass="math inline">\(k\)</span>，答案是： <span class="math display">\[k^c\cdotk^{(n-\sum\limits_{i=1}^{c}l_i)}=k^{n+c-\sum\limits_{i=1}^{c}l_i}\]</span></p><p>根据欧拉定理，对于任意互质的 <spanclass="math inline">\(a,p\)</span>，有 <spanclass="math inline">\(a^{\varphi(p)}\equiv1\pmod{p}\)</span>，进一步对于任意 <spanclass="math inline">\(x\)</span> 有 <spanclass="math inline">\(a^x\equiv a^{x\bmod \varphi(p)}\pmod{p}\)</span>。于是： <span class="math display">\[k^{n+c-\sum\limits_{i=1}^{c}l_i}\equivk^{(n+c-\sum\limits_{i=1}^{c}l_i)\bmod 2}=k^{n\bmod 2+c\bmod2+\sum\limits_{i=1}^{c}l_i\bmod 2}\pmod{3}\]</span></p><p>注：当 <span class="math inline">\(k\)</span> 和 <spanclass="math inline">\(3\)</span> 不互质时，<spanclass="math inline">\(k\)</span> 为 <spanclass="math inline">\(3\)</span> 的倍数，答案一定是 <spanclass="math inline">\(0\)</span>，可以特判掉。</p><p>令 <span class="math inline">\(M = c\bmod2+\sum\limits_{i=1}^{c}l_i\bmod 2\)</span>，注意到奇环对 <spanclass="math inline">\(M\)</span> 是没有任何贡献的，于是 <spanclass="math inline">\(M\)</span> 等价于 “偶环个数 <spanclass="math inline">\(\bmod 2\)</span>”。</p><p>有向图偶环是不好维护的，但这题中只要有偶环就一定连通（指存在一个点，环上的所有点都能从该点到达），故实际上我们可以当作无向图偶环来处理，用一个并查集维护。</p><p>因为是动态图，所以还要套一个线段树分治。</p><p>时间复杂度 <span class="math inline">\(O(q\log^2 q)\)</span>。</p><h2 id="qoj7653.-balloon-darts"><ahref="https://qoj.ac/contest/1402/problem/7653">qoj7653. BalloonDarts</a></h2><p><a href="https://qoj.ac/submission/1007001">Code</a></p><p>枚举一条直线都会用掉 <span class="math inline">\(O(n^2)\)</span>的复杂度，启发我们并不需要枚举所有 <spanclass="math inline">\(n\)</span> 个点。</p><p>依据抽屉原理，<span class="math inline">\(k\)</span> 条直线（这里<span class="math inline">\(k=3\)</span>）上任取 <spanclass="math inline">\(k+1\)</span> 个点，必然有两点满足确定的直线是<span class="math inline">\(k\)</span> 条中的一条。</p><p>或者反证法，如果选出的 <span class="math inline">\(k+1\)</span>个点不存在两点组成目标直线中的一条，则这 <spanclass="math inline">\(k+1\)</span> 个点需要 <spanclass="math inline">\(k+1\)</span> 条直线才能消除。</p><p>于是我们的做法是： * 对于当前 <spanclass="math inline">\(k\)</span>，从前 <spanclass="math inline">\(k+1\)</span>个点里选两点构成一条直线，遍历所有剩下的点，消除在这条直线上的点。</p><ul><li>将问题递归到 <spanclass="math inline">\(k-1\)</span>。边界条件是点数 <spanclass="math inline">\(\le 2k\)</span> 返回 <code>true</code>。</li></ul><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1437e.-make-it-increasing"><ahref="https://codeforces.com/contest/1437/problem/E">CF1437E. Make ItIncreasing</a></h2><p>*2200 <ahref="https://codeforces.com/contest/1437/submission/317756029">Code</a></p><p>trick：令 <span class="math inline">\(a_i\leftarrowa_i-i\)</span>，则最长上升子序列 <spanclass="math inline">\(\to\)</span> 最长不下降子序列。</p><p>令 <span class="math inline">\(a_0=-\infty,a_{n+1}=+\infty\)</span>并将 <span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(n+1\)</span> 加进 <spanclass="math inline">\(\{b\}\)</span>中，则整个数列被划分为若干可以修改的段。</p><p>每个段分开考虑，设当前段为 <spanclass="math inline">\([l,r]\)</span>，则需要修改的位置数量是 <spanclass="math inline">\((r-l+1)-cnt\)</span>，其中 <spanclass="math inline">\(cnt\)</span> 是 <spanclass="math inline">\([l,r]\)</span> 中值在 <spanclass="math inline">\([a_{l-1},a_{r+1}]\)</span>里的最长不下降子序列长度。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1440d.-graph-subset-problem"><ahref="https://codeforces.com/contest/1440/problem/D">CF1440D. GraphSubset Problem</a></h2><p>*2600 <ahref="https://codeforces.com/contest/1440/submission/317876586">Code</a></p><p>将一个 <span class="math inline">\(k\)</span> 个点的 clique 称作<span class="math inline">\(k\)</span> -clique，满足题意的子集称作good-subset。</p><p>注意到一个点如果度数 <spanclass="math inline">\(&lt;k-1\)</span>，那么它既不可能组成 <spanclass="math inline">\(k\)</span> -clique，也不可能组成good-subset，我们可以把这个点删掉。</p><p>当一个点被删掉时，它的邻居的度数就会 <spanclass="math inline">\(-1\)</span>，进而可能出现新的度数 <spanclass="math inline">\(&lt;k-1\)</span>的点，所以我们是按照类似拓扑序的方式删点（当一个点度数 <spanclass="math inline">\(&lt;k-1\)</span> 时被加进队列）。</p><p>最终，图上所有点的度数都至少是 <spanclass="math inline">\(k-1\)</span>（如果至少是 <spanclass="math inline">\(k\)</span>，那么所有点一定组成good-subset，直接输出）。此时，要满足 <spanclass="math inline">\(\frac{n(k-1)}{2}\le m\)</span>，剩余点数 <spanclass="math inline">\(n\)</span> 满足 <span class="math inline">\(n\le\frac{2m}{k-1}\)</span>。</p><p>我们可以枚举每个度数为 <span class="math inline">\(k-1\)</span>的点作为 <span class="math inline">\(k\)</span> -clique的一部分，标记它和它的 <span class="math inline">\(k-1\)</span>个邻居，<span class="math inline">\(O(k^2\log k)\)</span> 验证这个 <spanclass="math inline">\(k\)</span> -clique 是否合法。（<spanclass="math inline">\(\log\)</span>是在邻接表中二分查找的复杂度，如果使用 <code>unordered_map</code>或其它哈希方法则可以省去） 最多验证 <spanclass="math inline">\(n\)</span> 个点，故复杂度 <spanclass="math inline">\(\le \frac{2m}{k-1}\cdot k^2\log k\approx O(mk\logk)\)</span>。又由 <span class="math inline">\(\frac{k(k-1)}{2}\lem\)</span>，故 <span class="math inline">\(k\le\sqrt{2m}\)</span>，也就是 <span class="math inline">\(O(m\sqrt{m}\logm)\)</span>，可以接受。</p><p>若找到了一个 <span class="math inline">\(k\)</span>-clique，就可以退出。否则，将这个点删掉。最终如果没有删光，仍旧得到一个点度数至少为<span class="math inline">\(k\)</span> 的图，一定是 good-subset。</p><p>注意到找 <span class="math inline">\(k\)</span> -clique的过程和一开始一样需要删点，删点后要跑拓扑，那么不如将一个点加进队列条件调整为度数<spanclass="math inline">\(&lt;k\)</span>，一遍拓扑一边验证当前点是否可能组成<span class="math inline">\(k\)</span> -clique。</p><p>写代码之前务必想清楚实现的细节，本题容易枚举不当导致复杂度退化。</p><p>时间复杂度 <span class="math inline">\(O(m\sqrt{m}\logm)\)</span>。</p><h2 id="cf1440e.-greedy-shopping"><ahref="https://codeforces.com/contest/1440/problem/E">CF1440E. GreedyShopping</a></h2><p>*2600 <ahref="https://codeforces.com/contest/1440/submission/317776762">Code</a></p><p>操作一不会破坏序列的单调性，<spanclass="math inline">\(\{a\}\)</span> 始终单调递减。</p><p>对于操作 <code>1 x y</code>，我们可以二分出第一个 <spanclass="math inline">\(a_i&lt; y\)</span> 的下标 <spanclass="math inline">\(i\)</span>，转换为将区间 <spanclass="math inline">\([i,x]\)</span> 修改为 <spanclass="math inline">\(y\)</span>。</p><p>对于操作 <code>2 x y</code>，一个直观的想法二分出 <spanclass="math inline">\(x\)</span> 右侧第一个满足 <spanclass="math inline">\(\sum\limits_{i=x}^{p} a_i&gt;y\)</span> 的 <spanclass="math inline">\(p\)</span>，然后贡献就是区间 <spanclass="math inline">\([x,p-1]\)</span>的长度。但注意到并不是只有这一段区间有贡献，实际可以是 <spanclass="math inline">\(x\)</span> 右侧的若干段区间。</p><p>可以证明，区间个数至多是 <span class="math inline">\(O(\logy)\)</span> 级别的。我们用 <span class="math inline">\(1\)</span>表示选中的区间，<span class="math inline">\(0\)</span>表示未选中的区间，那么 <span class="math inline">\(x\)</span> 右侧形如<span class="math inline">\(101010\ldots\)</span>，左数第一个 <spanclass="math inline">\(0\)</span> 的 <span class="math inline">\(\suma_i\)</span>（设为 <span class="math inline">\(A\)</span>）比左数第一个<span class="math inline">\(1\)</span> 的 <spanclass="math inline">\(\sum a_i\)</span>（设为 <spanclass="math inline">\(B\)</span>）要小，那么这一组 <spanclass="math inline">\(10\)</span> 存在就说明 <spanclass="math inline">\(y-A &lt; B &lt; A\to y&lt;2A\toA&gt;\frac{y}{2}\)</span>，即每次 <span class="math inline">\(y\)</span>都至少消费掉自身的一半，得证。</p><p>回到证明之前，当找到 <span class="math inline">\(p\)</span>后，累加贡献，<span class="math inline">\(y\)</span> 减去区间 <spanclass="math inline">\([x,p - 1]\)</span> 的和，就可以继续在 <spanclass="math inline">\(p\)</span> 右侧二分出第一个 <spanclass="math inline">\(a_j\le y\)</span> 的 <spanclass="math inline">\(j\)</span>，再在 <spanclass="math inline">\(j\)</span> 右侧二分出第一个满足 <spanclass="math inline">\(\sum\limits_{i=j}^{p_2}a_i&gt; y\)</span> 的 <spanclass="math inline">\(p_2\)</span>，得到区间 <spanclass="math inline">\([j,p_2-1]\)</span>，以此类推…操作一用线段树区间赋值，操作二在线段树上二分，可以少一个 <spanclass="math inline">\(\log\)</span>，共二分 <spanclass="math inline">\(O(\log y)\)</span> 次。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n +q\log n\logw)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Atcoder </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】2025 UESTCPC 初赛</title>
      <link href="/posts/94193aa7.html"/>
      <url>/posts/94193aa7.html</url>
      
        <content type="html"><![CDATA[<p>据说题比去年初赛要简单，但我去年抱上了 lyc大腿，所以完全不记得去年难度怎么样了。</p><p>今年来验题，但水平有限（集训队垫底水平），只验了一些简单题。</p><p>其中 A 题是经出题人提醒做出来的，D 偷看了 Tag，H 和 L则完全不会，等有出题人题解了我再补上来。代码都写的很唐，也不一定是最优解，不要笑话我QAQ。</p><hr /><p>主观难度分布（H、L 未做出）： * 签到：F，G，J，N。</p><ul><li><p>Easy：B，C，I，O，P。</p></li><li><p>Easy_Mid：K，M。</p></li><li><p>Mid：D，E，Q。</p></li><li><p>Mid_Hard：<spanclass="math inline">\(\varnothing\)</span>。</p></li><li><p>Hard：A。</p></li></ul><p>写下这段话的时候还有三天才初赛，大胆猜测决赛线是 <spanclass="math inline">\(4\)</span> 题（签到即送）。</p><p>（upd on 04.01）大一队伍 4 题，非大一队伍 5 题，外校未知。</p><hr /><p>（upd on 赛后）按榜来看 H 是 Easy/Easy_Mid，L 是 Mid_Hard/Hard。</p><hr /><p>（upd on 03.31）来点链接。</p><p>补题链接：<ahref="https://cdoj.site/d/lutece/p?q=category%3ALutece%2C%E6%A0%A1%E8%B5%9B%2C%E5%88%9D%E8%B5%9B%2C2025">Cdoj</a>。</p><p>题面：<ahref="https://kisuraop.github.io/oth/2025UESTCPC/statement.pdf">Statement</a>。</p><p>出题人题解：<ahref="https://kisuraop.github.io/oth/2025UESTCPC/solution.pdf">Solution</a>。</p><p>查重前榜单：<ahref="https://kisuraop.github.io/oth/2025UESTCPC/scoreboard.mhtml">Scoreboard</a>。</p><hr /><p>（upd on 赛后）来点 Statistics。</p><p>本场比赛共有 405 支队伍报名，其中正式队 278 支，打星队 127 支。</p><p>有效参赛队伍（至少通过 <span class="math inline">\(1\)</span>题）总计 309 支，其中正式队 212 支，打星队 97 支。</p><p>最终 3 支队伍 AK，过题数情况如下。</p><table style="width:100%;"><thead><tr><th>组别 | 过题数</th><th>17</th><th>16</th><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>正式队</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>2</td><td>4</td></tr><tr><td>打星队</td><td>2</td><td>0</td><td>1</td><td>2</td><td>2</td><td>8</td><td>8</td><td>6</td></tr></tbody></table><table style="width:100%;"><thead><tr><th>组别 | 过题数</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th></tr></thead><tbody><tr><td>正式队</td><td>9</td><td>14</td><td>8</td><td>14</td><td>23</td><td>14</td><td>56</td><td>35</td><td>31</td></tr><tr><td>打星队</td><td>6</td><td>3</td><td>8</td><td>10</td><td>9</td><td>5</td><td>17</td><td>6</td><td>4</td></tr></tbody></table><p>接收到 8978 份有效 submissions，1698 份答案正确。</p><hr /><p>（upd on 初赛日）来点赛时趣事：</p><p>08:58 哎我草怎么是我发题面，赶紧登上 dj 下了个发到群里。</p><p>09:20 卧槽了，C 怎么被暴力过了，还碾压std。验题的时候不交暴力导致的。</p><p>09:43 大哥给 C 加了一组数据，好很多了。</p><p>10:03 哎哎，I 的精度被浮点数硬抗过去了，精度大师。</p><p>10:47 Queue 莫名其妙 5min 了，有点爆了。</p><p>10:55 Queue 越来越长了，爆爆爆，准备多搞几台服务器加 judgehost。</p><p>11:20 加了一台 8c16g 开了 8 个 judgehost，把原来的关掉了，只跑web。</p><p>11:27 貌似有点好转（？）</p><p>11:31 好起来了。终于有时间看榜，发现 M 竟然还没人过啊，低估了。</p><p>Fun Fact：在 pool 里 M 的难度是 *1300，有点幽默。</p><p>11:41 DeepSleep 这么厉害啊，队里两个 2000+ 就是不一样。</p><p>11:52 网页 502 了？？？？</p><p>11:55 k4c 很快就发现<code>/etc/php/8.2/fpm/pool.d/domjudge.conf</code> 里<code>request_slowlog_timeout</code> 的值写成了<code>10si</code>，多了个 <code>i</code>。改完马上又好了。</p><p>12:01 L 被开出来了啊。你知道的，我一直是 DeepSleep 的粉丝。</p><p>下午就比较清闲了，大概就是时不时把 judgehost 的 internal error 给resolved 一下。</p><p>本来想润去打洛谷的蓝桥杯模拟赛，斟酌了一下还是算了。</p><p>这期间 QQ收到了若干人机大学生发来的<del>弱智</del>让人啼笑皆非的私信。</p><p>15:37 sooke 拿到了 first AK!</p><p>16:58 第一发交 clar 的代码出现了。</p><p>不知道会不会有往 clar 里交奶龙的，很期待啊！</p><p>19:08 DeepSleep 也 AK 了，仿佛看到了泥电的下一支 wf 队。</p><p>20:10 爆爆爆，O被乱搞搞过去了。更有戏剧性的是我看出题人的题解，突然发现我验题的时候写了个错解（下面改正了），太难绷了。</p><p>在这里给大伙磕头了。</p><hr /><h3 id="a.-炼金术士">A. 炼金术士</h3><p>拉姆齐定理指出，<span class="math inline">\(6\)</span>个点的完全图（<spanclass="math inline">\(K_6\)</span>）用两种颜色任意着色（每条边都必须着色），必然存在至少一个单色三角形。</p><p>这意味着我们选出的 “黑化边” 与 “白化边” 并集的边导出子图一定不含<span class="math inline">\(K_6\)</span>。</p><p>发扬人类智慧，考虑这么一种构造：将 <spanclass="math inline">\(n\)</span> 个点划分成尽可能平均的 <spanclass="math inline">\(5\)</span>个集合，每个集合内部互不连边，不同集合间全部连边。</p><p>根据抽屉原理，从中任意选出 <span class="math inline">\(6\)</span>个点，至少有 <span class="math inline">\(2\)</span>个来自同一集合，没有连边，故不含 <spanclass="math inline">\(K_6\)</span>。在此基础上，容易说明这样的构造具有最大连边数。</p><p>接着，我们要将这些边划分成两个集合，每个集合不含三元环，且其中一个集合能塞得下给定的长度为<span class="math inline">\(k\)</span> 的无环链。</p><p>再度发扬人类智慧，给上述 <span class="math inline">\(5\)</span>个点集编号 <span class="math inline">\(0\sim 4\)</span>，进行如下构造：* “黑化边”：点集 <span class="math inline">\(i\)</span> 中的所有点向点集<span class="math inline">\((i+1)\bmod 5\)</span>中的所有点连出的边。</p><ul><li>“白化边”：剩下的所有边。</li></ul><p>因为一个三元环肯定有一条边的两个端点不来自相邻的点集，故 “黑化边”不含三元环。</p><p>而 “白化边” 要满足 “任意一条边都不来自相邻点集”，则至少需要 <spanclass="math inline">\(6\)</span> 个点集，不满足。</p><p>此外，在这 <span class="math inline">\(5\)</span>个点集上绕圈圈，一定能构造出一条包含所有 <spanclass="math inline">\(n\)</span>个顶点的链，将给定的链随便插进一个位置即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><p><a href="https://kisuraop.github.io/image/academic/UESTCPC1.png"><imgsrc="https://kisuraop.github.io/image/academic/UESTCPC1.png" /></a></p><p>上图是 <span class="math inline">\(n=7\)</span> 的图例，<spanclass="math inline">\(5\)</span> 个集合的大小分别为 <spanclass="math inline">\(2, 2, 1, 1, 1\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(<span class="hljs-number">5</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bel</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;b[cur].<span class="hljs-built_in">push_back</span>(x);bel[x] = cur;cur = (cur + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>;vis[x] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;b[cur].<span class="hljs-built_in">push_back</span>(i);bel[i] = cur;cur = (cur + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>;&#125;&#125;&#125;<span class="hljs-function">vector <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<span class="hljs-type">int</span> j = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b[i]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : b[j]) &#123;vis[x][y] = vis[y][x] = <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<span class="hljs-keyword">if</span> (bel[i] != bel[j] &amp;&amp; vis[i][j] == <span class="hljs-number">0</span>) &#123;vis[i][j] = vis[j][i] = <span class="hljs-number">2</span>;&#125;&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;ans += (vis[i][j] &gt; <span class="hljs-number">0</span>);&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<span class="hljs-keyword">if</span> (vis[i][j] == <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&#x27;+&#x27;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[i][j] == <span class="hljs-number">2</span>) &#123;cout &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&#x27;0&#x27;</span>;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="b.-简单可满足性问题">B. 简单可满足性问题</h3><p>假定已经将所有变量赋过了值，可以分出以下三类子句。</p><ol type="1"><li><p>该子句所有变量均为 <spanclass="math inline">\(1\)</span>，此时子句的值为 <spanclass="math inline">\(1\)</span>。</p></li><li><p>该子句所有变量均为 <spanclass="math inline">\(0\)</span>，此时子句的值为 <spanclass="math inline">\(0\)</span>。</p></li><li><p>该子句部分变量为 <spanclass="math inline">\(1\)</span>，此时子句的值为 <spanclass="math inline">\(1\)</span>。</p></li></ol><p>注意到当我们给所有变量取反时，第一和第二类子句个数互换，第三类子句个数不变。</p><p>而 “第一 + 第三” 类子句的个数和 “第二 + 第三” 类子句的个数总有一个<span class="math inline">\(\ge \lceil\frac{m}{2}\rceil\)</span>。</p><p>给所有变量任意赋值，验证不满足后就全部取反，总有一个满足条件。</p><p>时间复杂度 <span class="math inline">\(O(m)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> num;cin &gt;&gt; num;<span class="hljs-type">int</span> ok = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;ok |= y;&#125;<span class="hljs-keyword">if</span> (ok) &#123;res++;&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (res * <span class="hljs-number">2</span> &lt; m) &#123;ans = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="c.-箭串">C. 箭串</h3><p>将询问离线。暴力做就是倒序遍历每个区间，如果是<code>*</code>，就覆盖；否则不操作。</p><p>用 <code>std::set</code> 维护当前还存活的 <code>*</code>的位置。对于一个询问 <span class="math inline">\([l,r]\)</span>，二分出<code>std::set</code> 中第一个 <span class="math inline">\(\gel\)</span> 的位置，迭代器一直向右，修改沿途位置即可。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;string s = <span class="hljs-built_in">string</span>(n + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;*&#x27;</span>);vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; op;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;op.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);&#125;<span class="hljs-built_in">reverse</span>(op.<span class="hljs-built_in">begin</span>(), op.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">R</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;set&lt;<span class="hljs-type">int</span>&gt; t;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;L[i] = i - <span class="hljs-number">1</span>;R[i] = i + <span class="hljs-number">1</span>;t.<span class="hljs-built_in">insert</span>(i);&#125;<span class="hljs-keyword">auto</span> del = [&amp;] (<span class="hljs-type">int</span> i) &#123;t.<span class="hljs-built_in">erase</span>(i);L[R[i]] = L[i];R[L[i]] = R[i];&#125;; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [p, l] : op) &#123;<span class="hljs-keyword">auto</span> it = t.<span class="hljs-built_in">lower_bound</span>(p);<span class="hljs-keyword">if</span> (it == t.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = *it; i &lt;= p + l - <span class="hljs-number">1</span>; i = R[i]) &#123;<span class="hljs-keyword">if</span> (i == p || i &gt;= p + l - <span class="hljs-number">3</span>) &#123;s[i] = <span class="hljs-string">&#x27;&gt;&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;s[i] = <span class="hljs-string">&#x27;-&#x27;</span>;&#125;<span class="hljs-built_in">del</span>(i);&#125;&#125;s = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="d.-阿罗祖斯坦的桥">D. 阿罗祖斯坦的桥</h3><p>令 <span class="math inline">\(f[l][r],g[l][r]\)</span> 分别表示在<span class="math inline">\([l,r]\)</span>里建桥的最大数量和最小总长度，然后就是一个裸的区间 dp。</p><p>发现 <span class="math inline">\(w(l,r)=d\cdot\text{arcsin}(\frac{\text{dis}(l,r)}{d})\)</span>具有单调性（跨度大桥更长）和四边形不等式条件（交叉弱于包含），套一个四边形不等式优化的板子即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-10</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, d;    cin &gt;&gt; n &gt;&gt; d;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        cin &gt;&gt; a[i];        pre[i + <span class="hljs-number">1</span>] = pre[i] + a[i];    &#125;    <span class="hljs-keyword">auto</span> cost = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> * d * <span class="hljs-built_in">asin</span>(<span class="hljs-number">1.0</span> * (pre[r] - pre[l]) / d);    &#125;;    <span class="hljs-keyword">auto</span> ok = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; <span class="hljs-type">bool</span> &#123;        <span class="hljs-keyword">return</span> pre[r] - pre[l] &lt;= d;    &#125;;    <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">2</span>))</span>, <span class="hljs-title">m</span><span class="hljs-params">(f)</span></span>;    <span class="hljs-function">vector <span class="hljs-title">g</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-type">double</span>&gt;(n + <span class="hljs-number">2</span>))</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;        m[i][i] = i;        <span class="hljs-keyword">if</span> (i &lt; n + <span class="hljs-number">1</span>) &#123;            m[i][i + <span class="hljs-number">1</span>] = i;        &#125;    &#125;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n + <span class="hljs-number">1</span>; len++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n + <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = m[i][j - <span class="hljs-number">1</span>]; k &lt;= m[i + <span class="hljs-number">1</span>][j]; k++) &#123;                <span class="hljs-keyword">if</span> (f[i][k] + f[k][j] &gt; f[i][j]) &#123;                    f[i][j] = f[i][k] + f[k][j];                    g[i][j] = g[i][k] + g[k][j];                    m[i][j] = k;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f[i][k] + f[k][j] == f[i][j]) &#123;                    <span class="hljs-keyword">if</span> (g[i][k] + g[k][j] &lt; g[i][j]) &#123;                        g[i][j] = g[i][k] + g[k][j];                        m[i][j] = k;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>(i, j)) &#123;                f[i][j]++;                g[i][j] += <span class="hljs-built_in">cost</span>(i, j);            &#125;        &#125;    &#125;    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">12</span>) &lt;&lt; g[<span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">solve</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="e.-猫猫城大选困难版">E. 猫猫城大选（困难版）</h3><p>把问题 format 一下：给定一个变量 <spanclass="math inline">\(x\)</span>，初始为 <spanclass="math inline">\(0\)</span>，四种操作如下，问最终 <spanclass="math inline">\(x\)</span> 的期望。</p><ol type="1"><li><span class="math inline">\(x\leftarrow x+1\)</span>；</li><li><span class="math inline">\(x\leftarrow x-1\)</span>；</li><li><span class="math inline">\(\begin{cases}x\leftarrow x+1&amp;,x&gt;0\\ x\leftarrow x-1&amp;,x&lt;0\\ p_i \text{概率}+1,(1-p_i)\text{ 概率}-1 &amp;,x=0\end{cases}\)</span></li><li><span class="math inline">\(\begin{cases}x\leftarrow x-1&amp;,x&gt;0\\ x\leftarrow x+1&amp;,x&lt;0\\ p_i \text{概率}+1,(1-p_i)\text{ 概率}-1 &amp;,x=0\end{cases}\)</span></li></ol><p>我们发现对于两个 <span class="math inline">\(x=0\)</span>的位置，其间进行的操作是确定的。</p><p>具体的，假设当前时刻操作前 <span class="math inline">\(x=0\)</span>且当前为第 <span class="math inline">\(3/4\)</span> 类操作：若选择了<span class="math inline">\(+1\)</span>，则直到下一次 <spanclass="math inline">\(x=0\)</span> 之前 <spanclass="math inline">\(x\)</span> 的值都是正的；若选择了 <spanclass="math inline">\(-1\)</span>，则直到下一次 <spanclass="math inline">\(x=0\)</span> 之前 <spanclass="math inline">\(x\)</span> 的值都是负的。</p><p>令 <span class="math inline">\(dp[i]\)</span> 代表若第 <spanclass="math inline">\(i\)</span> 个时刻操作前 <spanclass="math inline">\(x=0\)</span>，最后 <spanclass="math inline">\(x\)</span> 的期望值。</p><p>从后向前转移，<span class="math inline">\(dp[i]=p[i]\cdotf(i)+(1-p[i])\cdot g(i)\)</span>。</p><p>其中 <span class="math inline">\(f(i)/g(i)\)</span> 代表第 <spanclass="math inline">\(i\)</span> 时刻选择了 <spanclass="math inline">\(+1/-1\)</span> 的情况下，之后的贡献。</p><p>以 <span class="math inline">\(f(i)\)</span> 为例，若之后不存在 <spanclass="math inline">\(x=0\)</span> 的时刻，<spanclass="math inline">\(f(i)=a_n-a_i+1\)</span>，其中 <spanclass="math inline">\(a_i\)</span> 表示假定 <spanclass="math inline">\(x\)</span> 一直 <spanclass="math inline">\(&gt;0\)</span>，按顺序执行完第 <spanclass="math inline">\(i\)</span> 次操作后的结果；否则设这 <spanclass="math inline">\(i\)</span> 之后第一个 <spanclass="math inline">\(x=0\)</span> 的时刻为 <spanclass="math inline">\(\text{nxt}\)</span>，有 <spanclass="math inline">\(f(i)=dp[\text{nxt+1}]\)</span>。</p><p>找 <span class="math inline">\(\text{nxt}\)</span>的过程可以用线段树实现，时间复杂度 <span class="math inline">\(O(n\logn)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">power</span><span class="hljs-params">(T a, <span class="hljs-type">int</span> b)</span> </span>&#123;    T res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; b; b /= <span class="hljs-number">2</span>, a *= a)        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>) res *= a;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;    <span class="hljs-type">int</span> res = a * b % p;    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) res += p;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> P&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MInt</span> &#123;    <span class="hljs-type">int</span> x;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">()</span> : x&#123;</span>&#125; &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : x&#123;</span><span class="hljs-built_in">norm</span>(x % <span class="hljs-built_in">getMod</span>())&#125; &#123;&#125;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> Mod;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getMod</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> P &gt; <span class="hljs-number">0</span> ? P : Mod;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">setMod</span><span class="hljs-params">(<span class="hljs-type">int</span> Mod_)</span> </span>&#123; Mod = Mod_;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">norm</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += <span class="hljs-built_in">getMod</span>(); <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-built_in">getMod</span>()) x -= <span class="hljs-built_in">getMod</span>(); <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123; MInt res; res.x = <span class="hljs-built_in">norm</span>(<span class="hljs-built_in">getMod</span>() - x); <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> MInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">assert</span>(x != <span class="hljs-number">0</span>); <span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(*<span class="hljs-keyword">this</span>, <span class="hljs-built_in">getMod</span>() - <span class="hljs-number">2</span>);&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>*=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">mul</span>(x, rhs.x, <span class="hljs-built_in">getMod</span>()); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>+=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">norm</span>(x + rhs.x); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>-=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">norm</span>(x - rhs.x); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>/=(MInt rhs) &amp; &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> *= rhs.<span class="hljs-built_in">inv</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>*(MInt lhs, MInt rhs) &#123; MInt res = lhs; res *= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>+(MInt lhs, MInt rhs) &#123; MInt res = lhs; res += rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-(MInt lhs, MInt rhs) &#123; MInt res = lhs; res -= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>/(MInt lhs, MInt rhs) &#123; MInt res = lhs; res /= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, MInt &amp;a) &#123; <span class="hljs-type">int</span> v; is &gt;&gt; v; a = <span class="hljs-built_in">MInt</span>(v); <span class="hljs-keyword">return</span> is;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> MInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.<span class="hljs-built_in">val</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MInt lhs, MInt rhs) &#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() == rhs.<span class="hljs-built_in">val</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(MInt lhs, MInt rhs) &#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() != rhs.<span class="hljs-built_in">val</span>();&#125;&#125;;<span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-type">int</span> MInt&lt;<span class="hljs-number">0</span>&gt;::Mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> V, <span class="hljs-type">int</span> P&gt;<span class="hljs-keyword">constexpr</span> MInt&lt;P&gt; CInv = <span class="hljs-built_in">MInt</span>&lt;P&gt;(V).<span class="hljs-built_in">inv</span>();<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">using</span> Z = MInt&lt;modp&gt;;<span class="hljs-comment">// template&lt;int P&gt;</span><span class="hljs-comment">// int MInt&lt;P&gt;::Mod = P;</span><span class="hljs-comment">// using Z = MInt&lt;0&gt;;</span><span class="hljs-comment">// Z::setMod(mod);</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n;vector&lt;Info&gt; tr;<span class="hljs-built_in">SegmentTree</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a) &#123;<span class="hljs-function">vector&lt;Info&gt; <span class="hljs-title">b</span><span class="hljs-params">(a.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;b[i] = a[i];&#125;<span class="hljs-built_in">init</span>(b);&#125;<span class="hljs-built_in">SegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;<span class="hljs-built_in">init</span>(a);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(vector&lt;Info&gt; &amp;a)</span> </span>&#123;n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;tr.<span class="hljs-built_in">assign</span>((<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>, <span class="hljs-built_in">Info</span>());<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;tr[p] = a[l];<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(ls, l, m, a);<span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);<span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;tr[p] = tr[ls] + tr[rs];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;tr[p] = x;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (pos &lt;= m) &#123;<span class="hljs-built_in">modify</span>(ls, l, m, pos, x);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, pos, x);&#125;<span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, x);&#125;<span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();&#125;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> tr[p];&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);&#125;<span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-type">int</span> res = <span class="hljs-built_in">findFirst</span>(ls, l, m, ql, qr, pred);<span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;res = <span class="hljs-built_in">findFirst</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &gt; qr) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1LL</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">findFirst</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">return</span> l;&#125;<span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-type">int</span> res = <span class="hljs-built_in">findLast</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);<span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;res = <span class="hljs-built_in">findLast</span>(ls, l, m, ql, qr, pred);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &gt; qr) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1LL</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">findLast</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);&#125;<span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span><span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<span class="hljs-type">int</span> mx = -inf;<span class="hljs-type">int</span> mn = inf;<span class="hljs-built_in">Info</span>() &#123;&#125;<span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> x) &#123;mx = x;mn = x;&#125;&#125;;Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;Info c;c.mx = <span class="hljs-built_in">max</span>(a.mx, b.mx);c.mn = <span class="hljs-built_in">min</span>(a.mn, b.mn); <span class="hljs-keyword">return</span> c;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">op</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;Z&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; op[i] &gt;&gt; p[i];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">pb</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;pa[i] = pa[i - <span class="hljs-number">1</span>];pb[i] = pb[i - <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">1</span>) &#123;pa[i]++;pb[i]++;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">2</span>) &#123;pa[i]--;pb[i]--;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">3</span>) &#123;pa[i]++;pb[i]--;&#125; <span class="hljs-keyword">else</span> &#123;pa[i]--;pb[i]++;&#125;&#125;<span class="hljs-function">SegmentTree&lt;Info&gt; <span class="hljs-title">sa</span><span class="hljs-params">(pa)</span>, <span class="hljs-title">sb</span><span class="hljs-params">(pb)</span></span>;<span class="hljs-function">vector&lt;Z&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-keyword">auto</span> getP = [&amp;] () -&gt; Z &#123;<span class="hljs-type">int</span> pos = sa.<span class="hljs-built_in">findFirst</span>(i + <span class="hljs-number">1</span>, n, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.mn &lt;= pa[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> * (op[i] == <span class="hljs-number">4</span>);&#125;);<span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">return</span> pa[n] - pa[i] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> dp[pos + <span class="hljs-number">1</span>];&#125;;<span class="hljs-keyword">auto</span> getN = [&amp;] () -&gt; Z &#123;<span class="hljs-type">int</span> pos = sb.<span class="hljs-built_in">findFirst</span>(i + <span class="hljs-number">1</span>, n, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.mx &gt;= pb[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span> * (op[i] == <span class="hljs-number">4</span>);&#125;);<span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">return</span> pb[n] - pb[i] - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> dp[pos + <span class="hljs-number">1</span>];&#125;;dp[i] = p[i] * <span class="hljs-built_in">getP</span>() + (<span class="hljs-number">1</span> - p[i]) * <span class="hljs-built_in">getN</span>();&#125;cout &lt;&lt; dp[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="f.-我知道你姓啥">F. 我知道你姓啥！</h3><p>竖着看，相当于 <span class="math inline">\(m\)</span> 个长为 <spanclass="math inline">\(n\)</span> 的字符串。我们的目标是使这 <spanclass="math inline">\(m\)</span> 个字符串互不相同。</p><p>一次添加操作相当于给每个字符串末尾添上 <spanclass="math inline">\(0\)</span> 或 <spanclass="math inline">\(1\)</span>。对于两个相同的字符串，在其末尾一个添<span class="math inline">\(0\)</span>，一个添 <spanclass="math inline">\(1\)</span>，就能让它们不同。</p><p>用 <code>std::map</code> 统计出原来的 <spanclass="math inline">\(m\)</span>个字符串中出现次数最多的串，设其出现次数为 <spanclass="math inline">\(c\)</span>。一次操作能让 <spanclass="math inline">\(c\leftarrow\lceil\frac{c}{2}\rceil\)</span>，暴力模拟即可。</p><p>时间复杂度 <span class="math inline">\(O(nm\log m)\)</span>。</p><p>Fun Fact：赛前出题人打算把 <code>std::unordered_map</code>卡掉，但因为是签到，所以后来觉得没有必要就没卡。</p><p>Bonus：可以用 Trie 做到 <spanclass="math inline">\(O(nm)\)</span>。</p><p>Fun Fact2：你可能会因为看到我 F 和 P的题解和出题人题解一模一样，然后联想到我是出题人。这是错的，出题人只是不想写题解了就让我发一份上去。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; s[i];&#125;map&lt;string, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;string t;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;t += s[i][j];&#125;mp[t]++;&#125;<span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, x] : mp) &#123;mx = <span class="hljs-built_in">max</span>(mx, x);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (mx != <span class="hljs-number">1</span>) &#123;mx = (mx + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;ans++;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-猜数游戏">G. 猜数游戏</h3><p>可以找到 <span class="math inline">\(\ge l\)</span> 的最小的满足<span class="math inline">\(x\bmod p=a\)</span> 的位置 <spanclass="math inline">\(i\)</span>，判断 <spanclass="math inline">\(i\)</span> 是否 <span class="math inline">\(\ler\)</span>。</p><p>令 <span class="math inline">\(i=kp+a\ge l\)</span>，得 <spanclass="math inline">\(k\ge \lceil\frac{l-a}{p} \rceil\)</span>，故 <spanclass="math inline">\(i=\lceil\frac{l-a}{p}\rceil p+a\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> a, p, l, r;cin &gt;&gt; a &gt;&gt; p &gt;&gt; l &gt;&gt; r;<span class="hljs-type">int</span> x = (l - a + p - <span class="hljs-number">1</span>) / p * p + a;<span class="hljs-keyword">if</span> (x &lt;= r) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="h.-独立事件">H. 独立事件</h3><p>(upd on 03.31)</p><p>当 <span class="math inline">\(P(A)=0/1\)</span> 时，答案是 trivial的。否则，存在以下推导： <span class="math display">\[\begin{align}&amp;P(A)P(B_I)=P(A\cap B_I)\\\rightarrow\ &amp;P(B_I\mid A)=P(B_I\mid \overline{A}) \\\rightarrow\&amp;\frac{P(AB_I)}{P(A)}=\frac{P(\overline{A}B_I)}{P(\overline{A})}\end{align}\]</span></p><p>记 <span class="math inline">\(f[i]\)</span> 表示在事件 <spanclass="math inline">\(A\)</span> 对应的集合中选出元素总和为 <spanclass="math inline">\(i\)</span> 的方案数。</p><p>记 <span class="math inline">\(g[i]\)</span> 表示在事件 <spanclass="math inline">\(\overline{A}\)</span> 对应的集合中选出元素总和为<span class="math inline">\(i\)</span> 的方案数。</p><p>那么答案是： <span class="math display">\[\sum_{i=0}^{1000}\sum_{j=0}^{1000}f[i]\cdot g[j]\cdot[\frac{i}{P(A)}=\frac{j}{P(\overline{A})}]\]</span></p><p>其中，<spanclass="math inline">\(P(A)=\dfrac{\sum\limits_{i=1}^{k}a_i}{1000}\)</span>，<spanclass="math inline">\(P(\overline{A})=1-P(A)\)</span>。<spanclass="math inline">\(f[i]\)</span> 和 <spanclass="math inline">\(g[i]\)</span> 可以分别用 <spanclass="math inline">\(01\)</span> 背包求出。</p><p>时间复杂度 <span class="math inline">\(O(nw+w^2)\)</span>，<spanclass="math inline">\(w\)</span> 为值域。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">power</span><span class="hljs-params">(T a, <span class="hljs-type">int</span> b)</span> </span>&#123;    T res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (; b; b /= <span class="hljs-number">2</span>, a *= a)        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span>) res *= a;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;    <span class="hljs-type">int</span> res = a * b % p;    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) res += p;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> P&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MInt</span> &#123;    <span class="hljs-type">int</span> x;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">()</span> : x&#123;</span>&#125; &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : x&#123;</span><span class="hljs-built_in">norm</span>(x % <span class="hljs-built_in">getMod</span>())&#125; &#123;&#125;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> Mod;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getMod</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> P &gt; <span class="hljs-number">0</span> ? P : Mod;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">setMod</span><span class="hljs-params">(<span class="hljs-type">int</span> Mod_)</span> </span>&#123; Mod = Mod_;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">norm</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += <span class="hljs-built_in">getMod</span>(); <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-built_in">getMod</span>()) x -= <span class="hljs-built_in">getMod</span>(); <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x;&#125;    <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123; MInt res; res.x = <span class="hljs-built_in">norm</span>(<span class="hljs-built_in">getMod</span>() - x); <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> MInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">assert</span>(x != <span class="hljs-number">0</span>); <span class="hljs-keyword">return</span> <span class="hljs-built_in">power</span>(*<span class="hljs-keyword">this</span>, <span class="hljs-built_in">getMod</span>() - <span class="hljs-number">2</span>);&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>*=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">mul</span>(x, rhs.x, <span class="hljs-built_in">getMod</span>()); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>+=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">norm</span>(x + rhs.x); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>-=(MInt rhs) &amp; &#123; x = <span class="hljs-built_in">norm</span>(x - rhs.x); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;    <span class="hljs-keyword">constexpr</span> MInt &amp;<span class="hljs-keyword">operator</span>/=(MInt rhs) &amp; &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> *= rhs.<span class="hljs-built_in">inv</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>*(MInt lhs, MInt rhs) &#123; MInt res = lhs; res *= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>+(MInt lhs, MInt rhs) &#123; MInt res = lhs; res += rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>-(MInt lhs, MInt rhs) &#123; MInt res = lhs; res -= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> MInt <span class="hljs-keyword">operator</span>/(MInt lhs, MInt rhs) &#123; MInt res = lhs; res /= rhs; <span class="hljs-keyword">return</span> res;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, MInt &amp;a) &#123; <span class="hljs-type">int</span> v; is &gt;&gt; v; a = <span class="hljs-built_in">MInt</span>(v); <span class="hljs-keyword">return</span> is;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> MInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.<span class="hljs-built_in">val</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MInt lhs, MInt rhs) &#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() == rhs.<span class="hljs-built_in">val</span>();&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(MInt lhs, MInt rhs) &#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">val</span>() != rhs.<span class="hljs-built_in">val</span>();&#125;&#125;;<span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-type">int</span> MInt&lt;<span class="hljs-number">0</span>&gt;::Mod = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> V, <span class="hljs-type">int</span> P&gt;<span class="hljs-keyword">constexpr</span> MInt&lt;P&gt; CInv = <span class="hljs-built_in">MInt</span>&lt;P&gt;(V).<span class="hljs-built_in">inv</span>();<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">using</span> Z = MInt&lt;modp&gt;;<span class="hljs-comment">// template&lt;int P&gt;</span><span class="hljs-comment">// int MInt&lt;P&gt;::Mod = P;</span><span class="hljs-comment">// using Z = MInt&lt;0&gt;;</span><span class="hljs-comment">// Z::setMod(mod);</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>, T = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (i &lt;= k) &#123;S += a[i];&#125; <span class="hljs-keyword">else</span> &#123;T += a[i];&#125;&#125;<span class="hljs-function">vector&lt;Z&gt; <span class="hljs-title">f</span><span class="hljs-params">(S + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">g</span><span class="hljs-params">(T + <span class="hljs-number">1</span>)</span></span>;f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = S; j &gt;= a[i]; j--) &#123;f[j] += f[j - a[i]];&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = T; j &gt;= a[i]; j--) &#123;g[j] += g[j - a[i]];&#125;&#125;Z ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= S; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= T; j++) &#123;<span class="hljs-keyword">if</span> (i * T == j * S) &#123;ans += f[i] * g[j];&#125;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="i.-圆与直线交点">I. 圆与直线交点</h3><p>因为不能出现浮点数，所以整个计算过程要保留分数形式。</p><p>python 的 fraction 是简单的，能帮你自动约分，四则运算也很方便。C++要么手写分数类，要么另谋出路。</p><ol type="1"><li><p>使用外心坐标公式求出三角形的外心坐标 <spanclass="math inline">\((X,Y)\)</span>。</p></li><li><p>任取三点之一，坐标公式计算其与外心的距离，得到半径的平方 <spanclass="math inline">\(R^2\)</span>。</p></li><li><p>由点到直线的距离公式，有： <span class="math display">\[d=\frac{|(X-P_x)V_y-(Y-P_y)V_x|}{\sqrt{V_x^2+V_y^2}}\]</span></p></li><li><p>移项，两边平方，得到相切的充要条件 <spanclass="math inline">\([(X-P_x)V_y-(Y-P_y)V_x]^2=R^2(V_x^2+V_y^2)\)</span>。</p></li><li><p>相交和相离改等号为不等号即可。</p></li></ol><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fractions <span class="hljs-keyword">import</span> *<span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():x1, y1 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())x2, y2 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())x3, y3 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())Px, Py = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())Vx, Vy = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())A1 = (x2 - x1) * <span class="hljs-number">2</span>B1 = (y2 - y1) * <span class="hljs-number">2</span>C1 = x2 * x2 + y2 * y2 - x1 * x1 - y1 * y1A2 = (x3 - x2) * <span class="hljs-number">2</span>B2 = (y3 - y2) * <span class="hljs-number">2</span>C2 = x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2X = Fraction(C1 * B2 - C2 * B1, A1 * B2 - A2 * B1)Y = Fraction(A1 * C2 - A2 * C1, A1 * B2 - A2 * B1)dx = Fraction(x1, <span class="hljs-number">1</span>) - Xdy = Fraction(y1, <span class="hljs-number">1</span>) - YR2 = dx * dx + dy * dyV_sq = Vx * Vx + Vy * Vygoal = R2 * V_sqt1 = (X - Fraction(Px, <span class="hljs-number">1</span>)) * Fraction(Vy, <span class="hljs-number">1</span>)t2 = (Y - Fraction(Py, <span class="hljs-number">1</span>)) * Fraction(Vx, <span class="hljs-number">1</span>)Z = t1 - t2Z = Z * Z;O = Z - goal<span class="hljs-keyword">if</span> O == Fraction(<span class="hljs-number">0</span>):<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Or&quot;</span>)<span class="hljs-keyword">elif</span> O &gt; Fraction(<span class="hljs-number">0</span>):<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<span class="hljs-keyword">else</span>:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):solve() <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:main()</code></pre></div>    </div></div><hr /><h3 id="j.-创建用户">J. 创建用户</h3><p>按照题意模拟即可。</p><p>C++ 使用 <code>getline</code> 读入一整行。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    string tmp;    <span class="hljs-built_in">getline</span>(cin, tmp);<span class="hljs-type">int</span> n = <span class="hljs-built_in">stoll</span>(tmp);map&lt;string, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;<span class="hljs-built_in">getline</span>(cin, s);string t;<span class="hljs-type">int</span> lst = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<span class="hljs-keyword">if</span> (lst == <span class="hljs-number">-1</span>) &#123;t += s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j);&#125; <span class="hljs-keyword">else</span> &#123;t += s[lst + <span class="hljs-number">1</span>]; &#125;lst = j;&#125;&#125;t += s[lst + <span class="hljs-number">1</span>];<span class="hljs-type">int</span> tot = ++mp[t] - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (tot &gt; <span class="hljs-number">0</span>) &#123;t += <span class="hljs-built_in">to_string</span>(tot);&#125;cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-哲学之门">K. 哲学之门</h3><p>想好怎么枚举是重要的。</p><p><a href="https://kisuraop.github.io/image/academic/UESTCPC2.png"><imgsrc="https://kisuraop.github.io/image/academic/UESTCPC2.png" /></a></p><p>我的做法是枚举三度点 <span class="math inline">\(i\)</span>，遍历<span class="math inline">\(i\)</span> 的邻接点，让每个邻居都尝试作为<span class="math inline">\(O\)</span>，这样 <spanclass="math inline">\(A,B\)</span> 就是另外两个邻居。</p><p>再枚举 <span class="math inline">\(A\)</span> 的邻居 <spanclass="math inline">\(C\)</span>，<span class="math inline">\(B\)</span>的邻居 <span class="math inline">\(D\)</span>。将 <spanclass="math inline">\(C\)</span> 的邻居放进一个容器里，然后枚举 <spanclass="math inline">\(D\)</span> 的邻居，若和 <spanclass="math inline">\(C\)</span> 共有就是 <spanclass="math inline">\(x\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> get = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B, <span class="hljs-type">int</span> O) &#123;<span class="hljs-keyword">if</span> (adj[O].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[O]) &#123;<span class="hljs-keyword">if</span> (x == A || x == B) &#123;<span class="hljs-keyword">return</span> ;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; b &#123;O, A, B&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[O]) &#123;vis[x] = <span class="hljs-literal">true</span>;b.<span class="hljs-built_in">push_back</span>(x);&#125;vis[O] = <span class="hljs-literal">true</span>;vis[A] = <span class="hljs-literal">true</span>;vis[B] = <span class="hljs-literal">true</span>;set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> C : adj[A]) &#123;<span class="hljs-keyword">if</span> (vis[C]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[C] = <span class="hljs-literal">true</span>;set&lt;<span class="hljs-type">int</span>&gt; s;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[C]) &#123;s.<span class="hljs-built_in">insert</span>(x);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> D : adj[B]) &#123;<span class="hljs-keyword">if</span> (vis[D]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[D] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[D]) &#123;<span class="hljs-keyword">if</span> (vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(x)) &#123;ans++;&#125;&#125;vis[D] = <span class="hljs-literal">false</span>;&#125;vis[C] = <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;vis[x] = <span class="hljs-literal">false</span>;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (adj[i].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">get</span>(i, adj[i][<span class="hljs-number">0</span>], adj[i][<span class="hljs-number">1</span>], adj[i][<span class="hljs-number">2</span>]);<span class="hljs-built_in">get</span>(i, adj[i][<span class="hljs-number">1</span>], adj[i][<span class="hljs-number">2</span>], adj[i][<span class="hljs-number">0</span>]);<span class="hljs-built_in">get</span>(i, adj[i][<span class="hljs-number">0</span>], adj[i][<span class="hljs-number">2</span>], adj[i][<span class="hljs-number">1</span>]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="m.-前兜车一转后兜车一转">M. 前兜车一转后兜车一转</h3><p>选定的前缀和后缀可以是不交、恰交、相交，每种情况都讨论一下。</p><p>恰交是简单的。</p><p>不交的话预处理出 <span class="math inline">\(suf[i]\)</span> 代表翻转<span class="math inline">\(i\sim n\)</span>中的任一后缀的最大收益。接着枚举前缀，另一段的最大贡献就能查表了。</p><p>相交的话是类似的。枚举 <span class="math inline">\(i\)</span>代表翻转前缀 <span class="math inline">\(1\simi\)</span>，此时要选定一个 <span class="math inline">\(j\in[1,i]\)</span> 然后翻转后缀 <span class="math inline">\(j\sim n\)</span>并让贡献最大。推一下式子，这等价于找到让 <spanclass="math inline">\(|a_j-a_n|-|a_j-a_{j-1}|\)</span> 最大的 <spanclass="math inline">\(j\)</span>，一样可以预处理出一个前缀和。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">auto</span> f = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a[i] - a[j]);&#125;;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;res += <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> ans = res;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;ans = <span class="hljs-built_in">max</span>(ans, res - <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, n));&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">suf</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">1</span>; i--) &#123;suf[i] = <span class="hljs-built_in">max</span>(suf[i + <span class="hljs-number">1</span>], -<span class="hljs-built_in">f</span>(i, i - <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(n, i - <span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">2</span>; i++) &#123;ans = <span class="hljs-built_in">max</span>(ans, res - <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>) + suf[i + <span class="hljs-number">2</span>]);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;pre[i] = <span class="hljs-built_in">max</span>(pre[i - <span class="hljs-number">1</span>], -<span class="hljs-built_in">f</span>(i - <span class="hljs-number">1</span>, i) + <span class="hljs-built_in">f</span>(i, n));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;ans = <span class="hljs-built_in">max</span>(ans, res - <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>) + pre[i]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="n.-幸运之环-ii">N. 幸运之环 II</h3><p>用 dfs 找出这棵基环树的环。</p><p>找到环上最小的点 <span class="math inline">\(x\)</span>，再看一下<span class="math inline">\(x\)</span>沿环上两个方向的邻居，哪个邻居小就往哪个方向输出。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;vector&lt;<span class="hljs-type">int</span>&gt; cir;&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">ins</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-literal">true</span>;ins[x] = <span class="hljs-literal">true</span>;f[x] = fa;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (ins[y] &amp;&amp; cir.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i != y; i = f[i]) &#123;cir.<span class="hljs-built_in">push_back</span>(i);&#125;cir.<span class="hljs-built_in">push_back</span>(y);&#125;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;ins[x] = <span class="hljs-literal">false</span>;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-type">int</span> len = cir.<span class="hljs-built_in">size</span>();cout &lt;&lt; len &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;cir.<span class="hljs-built_in">insert</span>(cir.<span class="hljs-built_in">end</span>(), cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> p = <span class="hljs-number">-1</span>, mn = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; cir.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">if</span> (cir[i] &lt; mn) &#123;mn = cir[i];p = i;&#125;&#125;cout &lt;&lt; cir[p] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">if</span> (cir[p - <span class="hljs-number">1</span>] &lt; cir[p + <span class="hljs-number">1</span>]) &#123;<span class="hljs-type">int</span> t = p, tot = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (tot &lt; len) &#123;t--;<span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) &#123;t = cir.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;cout &lt;&lt; cir[t] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;tot++;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> t = p, tot = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (tot &lt; len) &#123;t++;<span class="hljs-keyword">if</span> (t == cir.<span class="hljs-built_in">size</span>()) &#123;t = <span class="hljs-number">0</span>;&#125;cout &lt;&lt; cir[t] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;tot++;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="o.-不走回头路">O. 不走回头路</h3><p>在一个强连通分量内，所有的点都可以互相到达。即同一个 SCC内的景点可以任意安排游览顺序。</p><p>缩点，得到一个 DAG。若要能遍历所有的点，这个 DAG 必然是一条链。</p><p>在 DAG 上 dp（令 <span class="math inline">\(f[x]\)</span> 代表以<span class="math inline">\(x\)</span>结尾的链的长度的最大值），判断是否存在一个点 <spanclass="math inline">\(f[x]=cnt\)</span> 即可（<spanclass="math inline">\(cnt\)</span> 是缩点后的图的顶点数）。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><p>FunFact：一个误区是只判断缩点后的图 “恰有一个入度为 <spanclass="math inline">\(0\)</span> 的点” 和 “恰有一个出度为 <spanclass="math inline">\(0\)</span>” 的点，这是错误的，反例是 <spanclass="math inline">\(1\to 2\to 3,\ 1\to4\to3\)</span>。赛时的数据有这个缺陷（包括其它一些没缩点乱搞度数的做法也过了），磕头<spanclass="math inline">\(+1\)</span>。补题链接里的数据是更新过的。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">stk</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(n + <span class="hljs-number">1</span>);<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x] = low[x] = ++tim;vis[x] = <span class="hljs-literal">true</span>;stk[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span> &#123;now = stk[top--];vis[now] = <span class="hljs-literal">false</span>;c[now] = cnt;scc[cnt].<span class="hljs-built_in">push_back</span>(now);&#125; <span class="hljs-keyword">while</span>(x != now);&#125;&#125;;vector&lt;set&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">Adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> shrinkPoint = [&amp;]() &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (c[x] == c[y]) <span class="hljs-keyword">continue</span>;Adj[c[x]].<span class="hljs-built_in">insert</span>(c[y]);&#125;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!dfn[i]) &#123;<span class="hljs-built_in">tarjan</span>(i);&#125;&#125;<span class="hljs-built_in">shrinkPoint</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rd</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= cnt; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;rd[y]++;&#125;&#125;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<span class="hljs-keyword">if</span> (rd[i] == <span class="hljs-number">0</span>) &#123;q.<span class="hljs-built_in">push</span>(i);f[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;f[y] = <span class="hljs-built_in">max</span>(f[y], f[x] + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (--rd[y] == <span class="hljs-number">0</span>) &#123;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (*<span class="hljs-built_in">max_element</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>()) == cnt) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="p.-相同字符">P. 相同字符</h3><p>预处理 <span class="math inline">\(pre[i]\)</span> 代表从前向后在<span class="math inline">\(a\)</span> 中匹配上 <spanclass="math inline">\(b\)</span> 中的字符的个数，即 <spanclass="math inline">\(a[0..i]\)</span> 能匹配上 <spanclass="math inline">\(b[0..(pre[i]-1)]\)</span>。</p><p>预处理 <span class="math inline">\(suf[i]\)</span> 代表从后向前在<span class="math inline">\(a\)</span> 中匹配上 <spanclass="math inline">\(b\)</span> 中的字符的个数，即 <spanclass="math inline">\(a[i..n-1]\)</span> 能匹配上 <spanclass="math inline">\(b[(m-suf[i])..m-1]\)</span>。</p><p>上述的匹配不区分大小写。</p><p>若 <span class="math inline">\(a\)</span> 中无大写字母，判断 <spanclass="math inline">\(\max(suf[0],pre[n-1])=m\)</span>是否成立即可。</p><p>否则枚举 <span class="math inline">\(b\)</span>中每一个与大写字母相同的位置 <spanclass="math inline">\(i\)</span>，判断 <spanclass="math inline">\(pre[i-1] \ge i\)</span> 和 <spanclass="math inline">\(suf[i+1]\ge m-i-1\)</span> 是否成立。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string a, b;cin &gt;&gt; a &gt;&gt; b;<span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<span class="hljs-type">int</span> m = b.<span class="hljs-built_in">size</span>();<span class="hljs-type">int</span> pos = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isupper</span>(a[i])) &#123;pos = i;a[i] = <span class="hljs-built_in">tolower</span>(a[i]);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(n)</span></span>;pre[<span class="hljs-number">0</span>] = (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]);suf[n - <span class="hljs-number">1</span>] = (a.<span class="hljs-built_in">back</span>() == b.<span class="hljs-built_in">back</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;pre[i] = pre[i - <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (pre[i] &lt; m) &#123;pre[i] += (b[pre[i]] == a[i]);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;suf[i] = suf[i + <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (suf[i] &lt; m) &#123;suf[i] += (b[m - suf[i] - <span class="hljs-number">1</span>] == a[i]);&#125;&#125;<span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(suf[<span class="hljs-number">0</span>], pre[n - <span class="hljs-number">1</span>]) == m) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> L = (pos == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : pre[pos - <span class="hljs-number">1</span>]);<span class="hljs-type">int</span> R = (pos == n - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : suf[pos + <span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-keyword">if</span> (b[i] == a[pos]) &#123;<span class="hljs-keyword">if</span> (L &gt;= i &amp;&amp; R &gt;= m - i - <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="q.-校车">Q. 校车</h3><p>数据范围识状压。将给定的 <span class="math inline">\(w\)</span>个路口称作关键点。</p><p>令 <span class="math inline">\(dp[S][i]\)</span>代表从起点出发经过了状态 <span class="math inline">\(S\)</span>中的点，最终到达关键点 <span class="math inline">\(i\)</span>所需的路程。</p><ul><li><p>初态：<spanclass="math inline">\(dp[\{i\}][i]=\text{dis}(1,p_i)\)</span>。</p></li><li><p>转移：<span class="math inline">\(dp[S\cup\{j\}][j]=\min(dp[S\cup\{j\}][j],dp[S][i]+\text{dis}(p_i,p_j))\)</span>，其中 <spanclass="math inline">\(i\in S,j\not\in S\)</span>。</p></li></ul><p>那么经过 <span class="math inline">\(S\)</span>中的点再返回起点的最短距离 <spanclass="math inline">\(f[S]=\min\limits_{i\inS}(dp[S][i]+\text{dis}(1,p_i))\)</span>。</p><p>二分答案，设二分出的答案是 <spanclass="math inline">\(mid\)</span>，问题转化为判断是否能用不超过 <spanclass="math inline">\(k\)</span> 条 <span class="math inline">\(f[S]\lemid\)</span> 的路径覆盖所有 <span class="math inline">\(w\)</span>个关键点。</p><p>设 <span class="math inline">\(g[S]\)</span> 表示覆盖 <spanclass="math inline">\(S\)</span> 中的点需要的最小路径条数，判定就是<span class="math inline">\(g[\{1,2,\ldots,w\}]\le k\)</span>。</p><ul><li><p>初态：<spanclass="math inline">\(g[\varnothing]=0\)</span>。</p></li><li><p>转移：<span class="math inline">\(g[S\cup T]=\min(g[S\cupT],g[S]+1)\)</span>，其中 <span class="math inline">\(f[T]\lemid\)</span>。</p></li></ul><p>注意：转移的时候不需要对每一个 <span class="math inline">\(S\)</span>都枚举所有的 <span class="math inline">\(T\)</span>，那样是 <spanclass="math inline">\(O(4^w)\)</span>。只需要 <spanclass="math inline">\(O(3^w)\)</span> 枚举所有所有状态的子状态就行。</p><p>时间复杂度 <span class="math inline">\(O(wm\log m+w^22^w+20\cdot3^{w})\)</span>。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, m, w, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; w &gt;&gt; k;    vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-type">int</span> x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);        adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(w)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;        cin &gt;&gt; p[i];    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function">vector <span class="hljs-title">d</span><span class="hljs-params">(w, vector&lt;<span class="hljs-type">int</span>&gt;(w))</span></span>;    &#123;        <span class="hljs-keyword">auto</span> dijkstra = [&amp;] (<span class="hljs-type">int</span> S) &#123;            vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">dis</span>(n + <span class="hljs-number">1</span>, inf);            <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;                    <span class="hljs-meta">#<span class="hljs-keyword">define</span> P pair<span class="hljs-string">&lt;int, int&gt;</span></span>            priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; Q;            Q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);            dis[S] = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;                <span class="hljs-keyword">auto</span> [dist, x] = Q.<span class="hljs-built_in">top</span>();                Q.<span class="hljs-built_in">pop</span>();                <span class="hljs-keyword">if</span> (vis[x]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                vis[x] = <span class="hljs-literal">true</span>;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;                    <span class="hljs-keyword">if</span> (dis[y] &gt; dist + w) &#123;                        dis[y] = dist + w;                        Q.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);                    &#125;                &#125;            &#125;            <span class="hljs-keyword">return</span> dis;        &#125;;        dis = <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;            <span class="hljs-keyword">auto</span> A = <span class="hljs-built_in">dijkstra</span>(p[i]);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; w; j++) &#123;                d[i][j] = A[p[j]];            &#125;        &#125;    &#125;        <span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; w, vector&lt;<span class="hljs-type">int</span>&gt;(w, inf))</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;        dp[<span class="hljs-number">1</span> &lt;&lt; i][i] = dis[p[i]];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; w); S++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;            <span class="hljs-keyword">if</span> ((S &gt;&gt; i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> || dp[S][i] == inf) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; w; j++) &#123;                <span class="hljs-keyword">if</span> ((S &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-type">int</span> nS = S | (<span class="hljs-number">1</span> &lt;&lt; j);                    <span class="hljs-keyword">if</span> (d[i][j] &lt; <span class="hljs-number">1e10</span>) &#123;                        dp[nS][j] = <span class="hljs-built_in">min</span>(dp[nS][j], dp[S][i] + d[i][j]);                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; w, inf)</span></span>;    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; w); S++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;            <span class="hljs-keyword">if</span> ((S &gt;&gt; i &amp; <span class="hljs-number">1</span>) &amp;&amp; dp[S][i] != inf) &#123;                f[S] = <span class="hljs-built_in">min</span>(f[S], dp[S][i] + dis[p[i]]);            &#125;        &#125;        <span class="hljs-keyword">if</span> (f[S] &lt; <span class="hljs-number">1e10</span>) &#123;            mx = <span class="hljs-built_in">max</span>(mx, f[S]);        &#125;    &#125;    <span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> mid) &#123;        vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">g</span>(<span class="hljs-number">1</span> &lt;&lt; w, inf);        g[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; w); S++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> T = S; ; T = (T - <span class="hljs-number">1</span>) &amp; S) &#123;    <span class="hljs-keyword">if</span> (f[S ^ T] &lt;= mid) &#123;    g[S] = <span class="hljs-built_in">min</span>(g[S], g[T] + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span> (T == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">break</span>;    &#125;    &#125;    &#125;        <span class="hljs-keyword">return</span> g[(<span class="hljs-number">1</span> &lt;&lt; w) - <span class="hljs-number">1</span>] &lt;= k;    &#125;;    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = mx, ans = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;            ans = mid;            r = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            l = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">solve</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> UESTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】三月训练日记</title>
      <link href="/posts/5dc05f53.html"/>
      <url>/posts/5dc05f53.html</url>
      
        <content type="html"><![CDATA[<p>说是三月份，但实际上是从 2025.02.24 开始的，紧接着寒假。</p><p>表扬 <ahref="https://cftracker.netlify.app/contests">CFTracker</a>，让我知道我去年原来有这么多题遗漏了没有补。</p><p>开学给自己定的节奏是每场 CF 必打，此外一周 vp 至少三场，补 *2500以下，如果闲着就到 CFTracker 里解决历史遗留问题，周末晚上的 abc/arc非急事不错过。</p><p>愿我获得算法之神的庇佑。</p><h2 id="abc394e.-palindromic-shortest-path"><ahref="https://atcoder.jp/contests/abc394/tasks/abc394_e">abc394e.Palindromic Shortest Path</a></h2><p><ahref="https://atcoder.jp/contests/abc394/submissions/63139453">Code</a></p><p>把从 <span class="math inline">\(S\)</span> 到 <spanclass="math inline">\(T\)</span> 的路径看成一个状态 <spanclass="math inline">\((S,T)\)</span>。初始只有两种状态是合法的：</p><ul><li><span class="math inline">\(\forall i\in [1,n]\)</span>，<spanclass="math inline">\((i,i)\)</span>。</li><li><span class="math inline">\(\forall i\in[1,n],j\in[1,n],s[i][j]\neq\text{“}-\text{”}\)</span>，<spanclass="math inline">\((i,j)\)</span>。</li></ul><p>以这些状态为起点进行 bfs。对于当前状态 <spanclass="math inline">\((x,y)\)</span>，二维枚举 <spanclass="math inline">\(i,j\)</span>，若 <spanclass="math inline">\(s[i][x]=s[y][j]\)</span>，说明可拓展，将状态 <spanclass="math inline">\((i,j)\)</span> 压入队列中。</p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="abc394f.-alkane"><ahref="https://atcoder.jp/contests/abc394/tasks/abc394_f">abc394f.Alkane</a></h2><p><ahref="https://atcoder.jp/contests/abc394/submissions/63140699">Code</a></p><p>令 <span class="math inline">\(dp[x]\)</span> 代表 <spanclass="math inline">\(x\)</span> 贡献了三个儿子的答案。</p><p>转移自然是 <span class="math inline">\(dp[x]\)</span>取它儿子里面最大的三个 <span class="math inline">\(dp[y]\)</span>求和。</p><p>对于当前节点 <spanclass="math inline">\(x\)</span>，有这么几种情况：</p><ul><li><span class="math inline">\(x\)</span> 的度数 <spanclass="math inline">\(\ge 1\)</span>，遍历所有儿子，取度数 <spanclass="math inline">\(\ge 4\)</span> 的儿子的 <spanclass="math inline">\(dp[y]\)</span> 加上 <spanclass="math inline">\(x\)</span> 自身一个计入答案。</li><li><span class="math inline">\(x\)</span> 的度数 <spanclass="math inline">\(\ge 4\)</span>，且有 <spanclass="math inline">\(\ge 4\)</span> 个儿子，取最大的四个 <spanclass="math inline">\(dp[y]\)</span> 的和加上 <spanclass="math inline">\(x\)</span> 自身一个计入答案。</li><li><span class="math inline">\(x\)</span> 的度数 <spanclass="math inline">\(\ge 4\)</span>，且有 <spanclass="math inline">\(\ge 3\)</span> 个儿子，则计算出 <spanclass="math inline">\(dp[x]\)</span> 传递上去。</li><li>除此之外 <span class="math inline">\(x\)</span>只能作为一个叶子贡献给父亲。</li></ul><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1004e.-sonya-and-ice-cream"><ahref="https://codeforces.com/contest/1004/problem/E">CF1004E. Sonya andIce Cream</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1004/submission/307667954">Code</a></p><p>将 <span class="math inline">\(A,B\)</span> 两点间的距离简记为 <spanclass="math inline">\(d_{AB}\)</span>。</p><p>结论：最佳的路径一定被直径包含。</p><ul><li>首先，一个经典的结论是：对于树上任意一点，离它最远的点一定是直径的两个端点之一。对于直径外一点<span class="math inline">\(x\)</span>，设离 <spanclass="math inline">\(x\)</span> 最近的直径上的点是点 <spanclass="math inline">\(y\)</span>，当 <spanclass="math inline">\(x\)</span> 向 <spanclass="math inline">\(y\)</span> 靠近时，离 <spanclass="math inline">\(x\)</span>最远的点仍然是直径的两个端点，但最远距离减小，故取 <spanclass="math inline">\(y\)</span> 优于 <spanclass="math inline">\(x\)</span>。于是，我们选的第一个点肯定是在直径上。</li><li>设我们选的第一个点是 <spanclass="math inline">\(A\)</span>，接下来证明 <spanclass="math inline">\(A\)</span> 沿着直径扩展最佳。如下图，<spanclass="math inline">\(L,R\)</span> 是直径的两个端点，<spanclass="math inline">\(E,G\)</span> 分别是 <spanclass="math inline">\(D,F\)</span> 向下延伸出去最远的点。若从 <spanclass="math inline">\(A\)</span> 出发沿直径选了 <spanclass="math inline">\(B\)</span>，答案是 <spanclass="math inline">\(\max(d_{LA},d_{AE},d_{BG},d_{BR})\)</span>；若沿子树方向选了<span class="math inline">\(D\)</span>，答案是 <spanclass="math inline">\(\max(d_{LA},d_{DE},d_{AR},d_{AG})\)</span>。依据直径的性质有<span class="math inline">\(d_{BG} &lt; d_{BR}\)</span>，<spanclass="math inline">\(d_{AG}&lt;d_{AR}\)</span>，<spanclass="math inline">\(d_{AE} &lt; d_{LA}\)</span>，<spanclass="math inline">\(d_{DE} &lt; d_{LA}\)</span>，此时相当于比较 <spanclass="math inline">\(\max(d_{LA},d_{BR})\)</span> 与 <spanclass="math inline">\(\max(d_{LA},d_{AR})\)</span>，又 <spanclass="math inline">\(d_{AR} &gt; d_{BR}\)</span>，故选 <spanclass="math inline">\(B\)</span> 相比选 <spanclass="math inline">\(D\)</span> 更优。将 <spanclass="math inline">\(A,B\)</span> 看成一个整体，同理可证明选 <spanclass="math inline">\(C\)</span> 比选 <spanclass="math inline">\(F\)</span>要更优，以此类推……因此路径肯定是沿着直径方向一直扩展。</li></ul><p><img src="/image/academic/CF1004.png" style="zoom:50%;" /></p><p>当 <span class="math inline">\(k\)</span>大于等于直径长度时，就选完整个直径。否则在直径上搞一个长为 <spanclass="math inline">\(k\)</span>的滑动窗口，窗口两侧延伸出去的最长距离可以预处理前缀后缀和计算，窗口内部子树的答案等同于区间最值。</p><p>时间复杂度 <span class="math inline">\(O(n\logn)\)</span>，若用单调队列求极值就是 <spanclass="math inline">\(O(n)\)</span>。</p><h2 id="cf1969e.-unique-array"><ahref="https://codeforces.com/contest/1969/problem/E">CF1969E. UniqueArray</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1969/submission/307896648">Code</a></p><p>对于一个数 <span class="math inline">\(a_i\)</span>，设 <spanclass="math inline">\(a_i\)</span> 上一个出现的位置是 <spanclass="math inline">\(\text{lst}_{a_i}\)</span>，下一个出现的位置是<span class="math inline">\(\text{nxt}_{a_i}\)</span>，那么 <spanclass="math inline">\(a_i\)</span> 在区间 <spanclass="math inline">\([l,r]\)</span> 中唯一的充要条件是 <spanclass="math inline">\(l\in(\text{lst}_{a_i},i]\)</span> 且 <spanclass="math inline">\(r\in [i,\text{nxt}_{a_i})\)</span>。</p><p>考虑从左到右枚举线段的右端点 <spanclass="math inline">\(r\)</span>，判断是否有不合法的左端点。</p><p>令 <span class="math inline">\(\text{llst}_{a_i}\)</span> 是 <spanclass="math inline">\(a_i\)</span>的上一个的上一个的出现位置。当右端点移动到 <spanclass="math inline">\(i\)</span> 时，<spanclass="math inline">\((\text{llst}_{a_i},\text{lst}_{a_i}]\)</span>这一段不能再作为合法的左端点了，我们将这个区间 <spanclass="math inline">\(-1\)</span>。而 <span class="math inline">\(l\in(\text{lst}_{a_i},i]\)</span> 是新增的合法左端点，我们将这个区间 <spanclass="math inline">\(+1\)</span>。</p><p>如此一来，对于当前右端点 <span class="math inline">\(i\)</span>，以<span class="math inline">\(l\in[1,i]\)</span> 为左端点的区间全部 unique就等价于区间 <span class="math inline">\([1,i]\)</span> 的最小值 <spanclass="math inline">\(&gt;0\)</span>。若不满足条件，我们就把 <spanclass="math inline">\(a_i\)</span>替换掉，并且贪心的想肯定是替换成一个序列里从没出现过的数。替换后，左端点就能存在于<span class="math inline">\([1,i]\)</span> 中的任何位置，于是我们将区间<span class="math inline">\([1,i]+1\)</span>，同时把答案 <spanclass="math inline">\(+1\)</span>。</p><p>整个过程仅涉及区间加、区间极值，使用线段树维护。时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2064f.-we-be-summing"><ahref="https://codeforces.com/contest/2064/problem/F">CF2064F. We BeSumming</a></h2><p>*2600 <ahref="https://codeforces.com/contest/2064/submission/307985033">Code</a></p><p>注意到随着 <span class="math inline">\(i\)</span> 增加，<spanclass="math inline">\(\min(b_1,\ldots,b_i)\)</span> 递减，<spanclass="math inline">\(\max(b_{i+1},\ldots,b_m)\)</span>也递减。这两项加起来要是定值，说明对于任意 epic 的序列，满足相加等于<span class="math inline">\(k\)</span> 的 <spanclass="math inline">\(\min(b_1,\ldots,b_i)\)</span> 唯一，<spanclass="math inline">\(\max(b_{i+1},\ldots,b_m)\)</span>也唯一。我们把前缀 <span class="math inline">\(\min\)</span>这一项的值记为 <span class="math inline">\(x\)</span>，后缀 <spanclass="math inline">\(\max\)</span> 这一项自然是 <spanclass="math inline">\(k-x\)</span>。对于满足该要求的序列，称之为 <spanclass="math inline">\(x\)</span>-epic 序列，并将 <spanclass="math inline">\(\min(b_1,\ldots,b_i)=x\)</span> 的 <spanclass="math inline">\(i\)</span>称为分割点。不难发现分割点一定构成一段连续的区间。</p><p>记 <span class="math inline">\(lmn_i\)</span> 为 <spanclass="math inline">\(i\)</span> 左侧第一个 <spanclass="math inline">\(\le a_i\)</span> 的位置，<spanclass="math inline">\(lmx_i\)</span> 为 <spanclass="math inline">\(i\)</span> 左侧第一个 <spanclass="math inline">\(&gt;a_i\)</span> 的位置，<spanclass="math inline">\(rmx_i\)</span> 为 <spanclass="math inline">\(i\)</span> 右侧第一个 <spanclass="math inline">\(\ge a_i\)</span> 的位置，<spanclass="math inline">\(rmn_i\)</span> 为右侧第一个 <spanclass="math inline">\(&lt; a_i\)</span> 的位置。</p><p>依据第一段的分析，我们枚举 <spanclass="math inline">\(x\)</span>，对每个 <spanclass="math inline">\(x\)</span> 统计有多少 <spanclass="math inline">\(x\)</span>-epic 的子数组。对于当前 <spanclass="math inline">\(a_i=x\)</span>，若要 <spanclass="math inline">\(a_i\)</span>成为前缀最小值（为了计数不重复，这里指第一个前缀最小值），左端点可以是<span class="math inline">\((lmn_i+1,i]\)</span>中的任意一个。再枚举满足 <span class="math inline">\(j &gt;i\)</span> 且<span class="math inline">\(a_j=k-x\)</span> 的 <spanclass="math inline">\(j\)</span>，若要 <spanclass="math inline">\(a_j\)</span>成为后缀最大值（同理这里指最后一个后缀最大值），右端点可以是 <spanclass="math inline">\([j,rmx_i)\)</span>。</p><p>不难发现，<span class="math inline">\(a_i,a_j\)</span>要分别作为最小前缀和最大后缀贡献答案，当且仅当区间 <spanclass="math inline">\((lmn_i,rmn_i)\)</span> 和 <spanclass="math inline">\((lmx_j,rmx_j)\)</span> 相交，此时 <spanclass="math inline">\([lmx_j,rmn_i]\)</span>内的任意一点均为分割点。若满足此条件，包含 <spanclass="math inline">\([i,j]\)</span> 的任一子数组均 <spanclass="math inline">\(a_i\)</span>-epic，贡献是 <spanclass="math inline">\((rmx_j-j)\times(i-lmn_i)\)</span>。</p><p>可以使用树状数组或线段树快速统计贡献。时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</p><h2id="cf2072g.-ive-been-flipping-numbers-for-300-years-and-calculated-the-sum"><ahref="https://codeforces.com/contest/2072/problem/G">CF2072G. I’ve BeenFlipping Numbers for 300 Years and Calculated the Sum</a></h2><p>*2200 <ahref="https://codeforces.com/contest/2072/submission/308019731">Code</a></p><p>阈值分治。</p><ul><li><p>当 <span class="math inline">\(p \le \sqrt{n}\)</span>时，暴力计算 <spanclass="math inline">\(\text{rev}(n,p)\)</span>。时间复杂度 <spanclass="math inline">\(O(\sqrt{n})\)</span>。</p></li><li><p>当 <span class="math inline">\(p&gt;n\)</span> 时，<spanclass="math inline">\(\text{rev}(n,p)=n\)</span>。时间复杂度 <spanclass="math inline">\(O(1)\)</span>。</p></li></ul><p>只用考虑 <span class="math inline">\(\sqrt{n}&lt;p\le n\)</span>时如何快速计算。</p><p>注意到 <span class="math inline">\(n\)</span> 在 <spanclass="math inline">\(p\)</span>进制下最多只有两位，翻转后式子写出来是： <span class="math display">\[\begin{align}&amp;\quad\ (n\bmod p)\cdot p+\left\lfloor\frac{n}{p}\right\rfloor\\&amp;=(n-\left\lfloor\frac{n}{p}\right\rfloor \cdot p)\cdotp+\left\lfloor\frac{n}{p}\right\rfloor\\&amp;=-\left\lfloor\frac{n}{p}\right\rfloor\cdotp^2+np+\left\lfloor\frac{n}{p}\right\rfloor\end{align}\]</span> 数论分块枚举 <spanclass="math inline">\(\left\lfloor\dfrac{n}{p}\right\rfloor\)</span>的值，一段区间内 <span class="math inline">\(p^2\)</span> 的和以及 <spanclass="math inline">\(p\)</span> 的和可以用公式快速计算。</p><p>时间复杂度 <span class="math inline">\(O(t\sqrt{n})\)</span>，<spanclass="math inline">\(t\)</span> 是数据组数。</p><h2 id="cf1839d.-ball-sorting"><ahref="https://codeforces.com/contest/1839/problem/D">CF1839D. BallSorting</a></h2><p>*2100 <ahref="https://codeforces.com/contest/1839/submission/308219457">Code</a></p><p>考虑这么一种操作策略：选择原序列的任意一个上升子序列，称这个子序列里的元素为选定点。我们钦定选定点都不动，那么所需要<span class="math inline">\(0\)</span>的最小个数就是极长非选定点连续段的个数。</p><p>容易发现枚举所有的上升子序列可以涵盖所有可能的最优策略。</p><p>另一个观察是对于非选定点，可以只通过 <spanclass="math inline">\(1\)</span> 次移动就能移动到正确的位置上。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 表示若 <spanclass="math inline">\(i\)</span> 是一个选定点，<spanclass="math inline">\([1,i]\)</span> 中有至多 <spanclass="math inline">\(j\)</span> 个极长非选定点连续段，将 <spanclass="math inline">\([1,i]\)</span> 排好序的最小代价。</p><p>枚举上升子序列的上一个元素（即上一个选定点），做出以下转移： <spanclass="math display">\[dp[i][j]=\min\begin{cases}dp[i][j - 1]\\dp[i-1][j] &amp;,\text{if }c[i-1]&lt;c[i]\\dp[k][j-1]+(i-k-1)&amp;,\forall k\in[0,i-1),c[k]&lt;c[i]\end{cases}\]</span></p><ul><li><p>初态：<spanclass="math inline">\(dp[i][0]=\begin{cases}0&amp;,\text{if}\{c\}\textbf{ 在 }[1,i] \textbf{ 单调增}\\\text{inf}&amp;,\text{otherwise}\end{cases}\)</span></p></li><li><p>答案：<span class="math inline">\(\min\begin{cases}dp[n][k]\\dp[i][k-1]+(n-i)&amp;,\forall i\in[1,n)\end{cases}\)</span></p></li></ul><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="cf1839e.-decreasing-game"><ahref="https://codeforces.com/contest/1839/problem/E">CF1839E. DecreasingGame</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1839/submission/308401912">Code</a></p><p>结论：后手必胜当且仅当 <span class="math inline">\(\{a\}\)</span>能被划分为元素和相等的两部分。</p><ul><li><p>充分性：设划分成的两部分为 <spanclass="math inline">\(A,B\)</span>，后手必胜的策略如下。若先手选择了<span class="math inline">\(A\)</span> 中的元素，后手就选择 <spanclass="math inline">\(B\)</span> 中的元素；否则后手选择 <spanclass="math inline">\(A\)</span> 中的元素。如此操作后 <spanclass="math inline">\(A,B\)</span> 两部分的元素和都减少了 <spanclass="math inline">\(d\)</span>，因此任何时刻 <spanclass="math inline">\(A,B\)</span>两部分元素和相等。于是若先手还能继续游戏（即选择了一个 <spanclass="math inline">\(a_i&gt;0\)</span> 的 <spanclass="math inline">\(i\)</span>），后手也一定能从另一部分里找到一个<span class="math inline">\(j\neq i\)</span> 使得 <spanclass="math inline">\(a_j&gt;0\)</span>。</p></li><li><p>必要性：若初始 <span class="math inline">\(\{a\}\)</span>不能划分为元素和相等的两部分，则能够证明后续每一轮操作后 <spanclass="math inline">\(\{a\}\)</span>仍旧不能划分为元素和相等的两部分。</p><ul><li>设某一轮中两人选择了 <spanclass="math inline">\(a_i,a_j\)</span>，不妨令 <spanclass="math inline">\(a_i\le a_j\)</span>。假设操作前 <spanclass="math inline">\(\{a\}\)</span>不能被划分为了总和相等的两部分而操作结束后可以，令操作结束后 <spanclass="math inline">\(a_j-a_i\)</span> 所在的那部分其它数的和为 <spanclass="math inline">\(s_1\)</span>，另一部分总和为 <spanclass="math inline">\(s_2\)</span>，则 <spanclass="math inline">\(s_1+(a_j-a_i)=s_2\)</span>。移项得 <spanclass="math inline">\(s_1+a_j=s_2+a_i\)</span>，矛盾。</li></ul><p>于是，先手无论怎么抉择最后的局面都一定是只剩一个非零数或两个不同的非零数，必胜。</p></li></ul><p>最后的问题是如何找出这个划分，这等价于找一个和为 <spanclass="math inline">\(\dfrac{\sum a_i}{2}\)</span>的子序列，是一个经典的背包问题。</p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="abc394g.-dense-buildings"><ahref="https://atcoder.jp/contests/abc394/tasks/abc394_g">abc394g. DenseBuildings</a></h2><p><ahref="https://atcoder.jp/contests/abc394/submissions/63238482">Code</a></p><p>对于一组询问 <spanclass="math inline">\((x_1,y_1,z_1,x_2,y_2,z_2)\)</span>，如果我们找到一条路径连通<span class="math inline">\((x_1,y_1)\)</span> 与 <spanclass="math inline">\((x_2,y_2)\)</span> 且路径上最低的楼房高 <spanclass="math inline">\(h\)</span>。那么：</p><ul><li>若 <span class="math inline">\(h&lt;\min(z_1,z_2)\)</span>，则垂直方向上我们要 <spanclass="math inline">\(z_1\to h\)</span> 再 <spanclass="math inline">\(h\to z_2\)</span>，写成式子是 <spanclass="math inline">\(z_1+z_2-2h\)</span>。</li><li>若 <span class="math inline">\(h \ge \min(z_1,z_2)\)</span>，答案是<span class="math inline">\(|z_1-z_2|\)</span>。</li></ul><p>为了让答案最小，我们肯定是找最大的 <spanclass="math inline">\(h\)</span>。</p><p>对于相邻的楼房，连边，边权是较低的楼房的高度。</p><p>问题转化为有若干组询问，每次询问两个点，需要找出两点间的一条简单路径，让路径上所有边的边权最小值最大（最大瓶颈路）。</p><p>这是个经典的问题（NOIP 货车运输），做法是 kruskal重构树或者在最大生成树上倍增。</p><h2 id="cf1982d.-beauty-of-the-mountains"><ahref="https://codeforces.com/contest/1982/problem/D">CF1982D. Beauty ofthe mountains</a></h2><p>*1700 <ahref="https://codeforces.com/contest/1982/submission/308516339">Code</a></p><p>把有雪的格子称为 <span class="math inline">\(0\)</span>格子，没雪的格子称为 <span class="math inline">\(1\)</span> 格子。</p><p>先计算出初始 <span class="math inline">\(1\)</span> 格子的高度和与<span class="math inline">\(0\)</span> 格子的高度和的差值，记作 <spanclass="math inline">\(s\)</span>。</p><p>对于每一个 <span class="math inline">\(k\times k\)</span>的矩形，我们可以用二维前缀和快速计算出对这个矩形整体 <spanclass="math inline">\(+1\)</span> 对 “<spanclass="math inline">\(1\)</span> 格子的高度和与 <spanclass="math inline">\(0\)</span> 格子的高度和的差值”的贡献，把这个贡献记作 <span class="math inline">\(c_i\)</span>。</p><p>问题转化为给定序列 <spanclass="math inline">\(\{c\}\)</span>，求以下不定方程是否有解。 <spanclass="math display">\[c_1x_1+c_2x_2+\ldots+c_mx_m=s\]</span> 根据裴蜀定理，有解当且仅当 <spanclass="math inline">\(\gcd(c_1,c_2,\ldots,c_m)\mid s\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(nm\log k)\)</span>。</p><h2 id="cf1848c.-vika-and-price-tags"><ahref="https://codeforces.com/contest/1848/problem/C">CF1848C. Vika andPrice Tags</a></h2><p>*1800 <ahref="https://codeforces.com/contest/1848/submission/308637343">Code</a></p><p><span class="math inline">\(\tiny{不是哥们，我怎么又卡 \text{ div2C}了，呜哇呜哇呜}\)</span></p><p>考虑单独一组 <span class="math inline">\((a_i,b_i)\)</span>，设终态是<span class="math inline">\((0,x)\)</span>，那么有循环： <spanclass="math display">\[(0,x)\to (x,x)\to (x,0)\to(0,x)\]</span> 因此设当前 <span class="math inline">\((a_i,b_i)\)</span>最少需要 <span class="math inline">\(d_i\)</span> 次操作达成 <spanclass="math inline">\(a_i=0\)</span>，那么 <code>Yes</code> 当且仅当<span class="math inline">\(\forall i,j\in [1,n]\)</span>，<spanclass="math inline">\(d_i\equiv d_j\pmod {3}\)</span>。</p><p>接下来的任务是对每一组 <span class="math inline">\((a,b)\)</span>求出相应的 <span class="math inline">\(d\)</span>。</p><p>考虑辗转相除的过程，当 <span class="math inline">\(a&lt;b\)</span>时，令 <span class="math inline">\(b=ka+p\)</span>， <spanclass="math inline">\(p\in[0,a)\)</span>，状态变化如下：</p><p><span class="math display">\[(a,ka+p)\to(ka+p, (k-1)a+p)\to((k-1)a+p,a)\to(a,(k-2)a+p)\]</span></p><p>发现在三轮操作后，<span class="math inline">\(k\)</span> 减少了 <spanclass="math inline">\(2\)</span>。又因为我们只关心 <spanclass="math inline">\(d\bmod 3\)</span> 后的结果，于是 <spanclass="math inline">\((a,ka+p)\)</span> 和 <spanclass="math inline">\((a,(k-2)a+p)\)</span>是等价的。进一步，奇偶性相同的 <span class="math inline">\(k\)</span>都可以看作等价。我们仅取 <span class="math inline">\(k=0/1\)</span>讨论即可。</p><ul><li><span class="math inline">\(k=1\)</span> 时，有 <spanclass="math inline">\((a,a+p)\to(a+p,p)\to(p,a)\)</span>。</li><li><span class="math inline">\(k=0\)</span> 时，就是 <spanclass="math inline">\((a,p)\)</span>。</li></ul><p>故以下递归成立： <span class="math display">\[d(a,ka+p)\to \begin{cases}2+d(p,a)&amp;,k \textbf{ 为奇数}\\ d(a,p)&amp;, k\textbf{ 为偶数}\end{cases}\]</span> 当 <span class="math inline">\(a\ge b\)</span> 时，同理取<span class="math inline">\(a=kb+p\)</span>，<spanclass="math inline">\(p\in[0,b)\)</span>，则：</p><p><span class="math display">\[(kb+p,b)\to (b, (k-1)b+p)\to ((k-1)b+p, (k-2)b+p)\to ((k-2)b+p,b)\]</span></p><ul><li><span class="math inline">\(k=1\)</span> 时，有 <spanclass="math inline">\((b+p,b)\to(b,p)\)</span>。</li><li><span class="math inline">\(k=0\)</span> 时，就是 <spanclass="math inline">\((p,b)\)</span>。</li></ul><p>故以下递归成立： <span class="math display">\[d(kb+p,b)\to \begin{cases}1+d(b,p)&amp;,k \textbf{ 为奇数}\\ d(p,b)&amp;, k\textbf{ 为偶数}\end{cases}\]</span> 边界情况：<span class="math inline">\(d(0,*)=0\)</span>，<spanclass="math inline">\(d(*,0)=1\)</span>。</p><p>递归层数同辗转相除。时间复杂度 <span class="math inline">\(O(n\logw)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p><h2 id="cf1848d.-vika-and-bonuses"><ahref="https://codeforces.com/contest/1848/problem/D">CF1848D. Vika andBonuses</a></h2><p>*2200 <ahref="https://codeforces.com/contest/1848/submission/308650958">Code</a></p><p>按 <span class="math inline">\(t=s\bmod 10\)</span> 分类讨论。</p><ul><li>若 <span class="math inline">\(t=0\)</span>，操作二没有作用，答案是<span class="math inline">\(sk\)</span>。</li><li>若 <spanclass="math inline">\(t=5\)</span>，最多进行一次操作二，答案是 <spanclass="math inline">\(\max(sk,(s+5)(k-1))\)</span>。</li><li>若 <span class="math inline">\(t=2,4,6,8\)</span>，注意到末尾有循环<span class="math inline">\(2\to4\to 8\to6\to2\)</span>。每一轮循环<span class="math inline">\(s\)</span> 增加 <spanclass="math inline">\(20\)</span>，枚举循环完整进行的次数 <spanclass="math inline">\(x\)</span>，贡献为 <spanclass="math inline">\((s+20x)(k-4x)\)</span>，这是一个二次函数，可以<span class="math inline">\(O(1)\)</span> 求最大值。于是我们枚举最终<span class="math inline">\(s\)</span> 末尾是 <spanclass="math inline">\(2,4,6,8\)</span> 的情况，对每种情况分别求答案再取<span class="math inline">\(\max\)</span>。</li><li>若 <spanclass="math inline">\(t=1,3,7,9\)</span>，执行一次操作后就和上一种情况等同了。</li></ul><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><h2 id="cf1848f.-vika-and-wiki"><ahref="https://codeforces.com/contest/1848/problem/F">CF1848F. Vika andWiki</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1848/submission/308661424">Code</a></p><p>令 <span class="math inline">\(f_{i,j}\)</span> 表示进行 <spanclass="math inline">\(i\)</span> 次操作后 <spanclass="math inline">\(a_j\)</span> 的值。</p><p><span class="math display">\[\begin{align}&amp;f_0=\{a\} \\&amp;f_{1,i}=f_{0,i}\oplus f_{0,i+1}\\&amp;f_{2,i}=f_{1,i}\oplus f_{1,i+1}=(f_{0,i}\oplusf_{0,i+1})\oplus(f_{0,i+1}\oplus f_{0,i+2})=f_{0,i}\oplus f_{0,i+2}\\&amp;f_{3,i}=f_{2,i}\oplus f_{2,i+1}=(f_{0,i}\oplus f_{0,i+2})\oplus(f_{0,i+1}\oplus f_{0,i+3})\\&amp;f_{4,i}=f_{3,i}\oplus f_{3,i+1}=(f_{0,i}\oplus f_{0,i+1}\oplusf_{0,i+2}\oplus f_{0,i+3})\oplus (f_{0,i+1}\oplus f_{0,i+2}\oplusf_{0,i+3}\oplus f_{0,i+4})=f_{0,i}\oplus f_{0,i+4}\\\end{align}\]</span></p><p>非常 amazing 啊经过大力找规律，得到的结论是进行 <spanclass="math inline">\(2^k,k\in N^+\)</span> 次操作后，<spanclass="math inline">\(f_{2^k,i}=f_{0,i}\oplus f_{0,(i+2^k)\bmodn}\)</span>。</p><p>题目又保证 <span class="math inline">\(n\)</span> 是 <spanclass="math inline">\(2\)</span> 的幂，故 <spanclass="math inline">\(n\)</span> 次操作后 <spanclass="math inline">\(\{a\}\)</span> 一定全 <spanclass="math inline">\(0\)</span>，没有无解的情况。</p><p>接着，又观察到若 <span class="math inline">\(\{a\}\)</span> 已经全<span class="math inline">\(0\)</span>，再操作肯定也是全 <spanclass="math inline">\(0\)</span>，换句话说答案可以二分。</p><p>设二分出的答案是 <span class="math inline">\(x\)</span>，预处理对于<span class="math inline">\(k\in[0,\log n]\)</span>，操作 <spanclass="math inline">\(2^k\)</span> 次后的数组，枚举 <spanclass="math inline">\(x\)</span> 的每一位大力操作即可。</p><p>更聪明的做法是倍增，令 <spanclass="math inline">\(i=\frac{n}{2},\frac{n}{4},\frac{n}{8},\ldots\)</span>，对每个 <span class="math inline">\(i\)</span> 先令 <spanclass="math inline">\(\{b\}=\{a\}\)</span>，在 <spanclass="math inline">\(\{b\}\)</span> 上操作 <spanclass="math inline">\(i\)</span> 次，若操作后 <spanclass="math inline">\(\{b\}\)</span> 不全为 <spanclass="math inline">\(0\)</span>，说明答案比 <spanclass="math inline">\(i\)</span> 大，此时将答案累加上 <spanclass="math inline">\(i\)</span> 并把 <spanclass="math inline">\(\{b\}\)</span> 赋值给 <spanclass="math inline">\(\{a\}\)</span>。</p><p>时间复杂度前者 <span class="math inline">\(O(n\log^2n)\)</span>，后者 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2070e.-game-with-binary-string"><ahref="https://codeforces.com/contest/2070/problem/E">CF2070E. Game withBinary String</a></h2><p>*2200 <ahref="https://codeforces.com/contest/2070/submission/308694558">Code</a></p><p>后手为了让 <span class="math inline">\(0\)</span>尽可能少，一定是拿取相邻的一个 <span class="math inline">\(1\)</span>和一个 <spanclass="math inline">\(0\)</span>。又因为序列是循环的，故若序列中存在至少一个<span class="math inline">\(1\)</span> 和一个 <spanclass="math inline">\(0\)</span>，就肯定有相邻的 <spanclass="math inline">\(10\)</span> 或者 <spanclass="math inline">\(01\)</span>。</p><p>我们将这个游戏做一个转化：先手不必拿取相邻的两个 <spanclass="math inline">\(0\)</span>，而是序列中的任意两个 <spanclass="math inline">\(0\)</span>；同时后手也不必拿取相邻的 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(0\)</span>，而是序列中的任何一个 <spanclass="math inline">\(1\)</span> 以及任何一个 <spanclass="math inline">\(0\)</span>（若没有 <spanclass="math inline">\(0\)</span> 就是任意两个 <spanclass="math inline">\(1\)</span>）。</p><p>此时，在一个完整回合中，总计三个 <spanclass="math inline">\(0\)</span> 和一个 <spanclass="math inline">\(1\)</span> 被取走，我们不难想到按序列长度<spanclass="math inline">\(\bmod 4\)</span> 进行分类。记我们研究的序列长为<span class="math inline">\(m\)</span>，用 <spanclass="math inline">\(c_{0/1}\)</span> 代表序列中 <spanclass="math inline">\(0/1\)</span> 的数量，手玩后得到如下结论。</p><ul><li>若 <span class="math inline">\(m\bmod4=0\)</span>，先手赢得游戏当且仅当 <span class="math inline">\(c_0\ge3c_1+1\)</span>。</li><li>若 <span class="math inline">\(m\bmod4=1\)</span>，先手赢得游戏当且仅当 <span class="math inline">\(c_0\ge3c_1+2\)</span>。</li><li>若 <span class="math inline">\(m\bmod4=2\)</span>，先手赢得游戏当且仅当 <span class="math inline">\(c_0\ge3c_1+2\)</span>。</li><li>若 <span class="math inline">\(m\bmod4=3\)</span>，先手赢得游戏当且仅当 <span class="math inline">\(c_0\ge3c_1-1\)</span>。</li></ul><p>其中 <span class="math inline">\(c_0\ge 3c_1+k_i\)</span> 这个 <spanclass="math inline">\(k_i\)</span>并不唯一，如果你推出来其它的数值，也是对的。</p><p>接下来，可以断言：这个必胜条件对于原游戏仍然成立。</p><p>这看起来很违反直觉，因为后手虽然在原游戏中仍然能找到 <spanclass="math inline">\(0,1\)</span> 相邻，但先手不一定能找到两个相邻的<span class="math inline">\(0\)</span>。</p><p>我们将这个 Claim做一个等价转化：如果原问题（移除相邻字符）与转化后的游戏（移除任意位置字符）的胜负结果一致，那么当原问题中先手无法操作时，转化后的游戏中先手也一定会输。</p><p>而先手无法操作时，序列一定形如 <spanclass="math inline">\(0101\cdots0101\)</span>，即 <spanclass="math inline">\(c_1\gec_0\)</span>，这个条件和上述四个先手必胜条件都相悖，因此先手必败。证毕。</p><p>原问题转化为求满足上述四个条件之一的子串有多少个。我们将序列中的<span class="math inline">\(1\)</span> 看作 <spanclass="math inline">\(-3\)</span>，<spanclass="math inline">\(0\)</span> 看作 <spanclass="math inline">\(1\)</span> 求前缀和，条件 <spanclass="math inline">\(c_0\ge 3c_1+k_i\)</span> 便等价于区间和 <spanclass="math inline">\(\ge k_i\)</span>。</p><p>对<span class="math inline">\(\bmod 4\)</span>相同的下标维护一个树状数组，每次到这四个树状数组里统计贡献。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1895c.-torn-lucky-ticket"><ahref="https://codeforces.com/contest/1895/problem/C">CF1895C. Torn LuckyTicket</a></h2><p>*1400 <ahref="https://codeforces.com/contest/1895/submission/308826631">Code</a></p><p>上手直接蟒就容易写成一坨的题。（至少我是这样QAQ</p><p>这里给出一种优雅的解法。以下默认 0-index。</p><p>把数字看成字符串，记 <span class="math inline">\(f(i,j)\)</span>代表第 <span class="math inline">\(i\)</span> 位到第 <spanclass="math inline">\(j\)</span> 位之间数位的和。</p><p>遍历每个串，设当前串长为 <spanclass="math inline">\(m\)</span>，<span class="math inline">\(\foralli\in[0,m)\)</span>，将二元组 <spanclass="math inline">\(\{f(0,i)-f(i+1,m-1),(i+1)-(m-i-1)\}\)</span>记录进一个 <code>std::map</code> 中。</p><p>枚举每个串作为拼接左侧，能与它拼起来构成 pair 的字符串数等价于二元组<span class="math inline">\(\{f(0,m-1),m\}\)</span> 和 <spanclass="math inline">\(\{-f(0,m-1),-m\}\)</span> 的数目和。</p><p>容易发现一个字符串既能做左侧合法拼接又能做右侧合法拼接的情况被规避掉了，计数不重不漏。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1895d.-xor-construction"><ahref="https://codeforces.com/contest/1895/problem/D">CF1895D. XORConstruction</a></h2><p>*1900 <ahref="https://codeforces.com/contest/1895/submission/308831646">Code</a></p><p>设 <span class="math inline">\(s_i=a_1\oplus a_2\oplus \cdots \oplusa_i\)</span>。</p><p>则 <span class="math inline">\(\forall i&gt;1\)</span>，<spanclass="math inline">\(b_i=b_{i-1}\oplus a_{i-1}=b_{i-2}\oplusa_{i-2}\oplus a_{i-1}=\cdots=b_1\oplus s_{i-1}\)</span>。</p><p>要让 <span class="math inline">\(b_i&lt;n\)</span>，就是让 <spanclass="math inline">\(\max\limits_{i\in[1,n]}(b_1\opluss_{i-1})&lt;n\)</span>。</p><p>枚举 <span class="math inline">\(b_1\)</span>，用 trie找到这个异或最大值，看它是否 <spanclass="math inline">\(&lt;n\)</span>。</p><p>因为单次判断是 <span class="math inline">\(\log\)</span> 级别的，从<span class="math inline">\(0\)</span> 到 <spanclass="math inline">\(n-1\)</span> 暴力枚举就好。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<spanclass="math inline">\(w\)</span> 是值域。</p><h2 id="cf1894d.-neutral-tonality"><ahref="https://codeforces.com/contest/1894/problem/D">CF1894D. NeutralTonality</a></h2><p>*1700 <ahref="https://codeforces.com/contest/1894/submission/308865251">Code</a></p><p>依据 Dilworth 定理，<span class="math inline">\(\{b\}\)</span>一定是排成降序最优，此时插进 <span class="math inline">\(\{a\}\)</span>中最多让 LIS 长度 <span class="math inline">\(+1\)</span>。</p><p>我们只需尝试构造一种插入方式使得 LIS 长度尽可能不变。</p><p>贪心地想，对于当前 <spanclass="math inline">\(a_i\)</span>，可以将最小值 <spanclass="math inline">\(\ge a_i\)</span> 的一段下降序列插入到 <spanclass="math inline">\(a_i\)</span> 的前面，此时 LIS长度一定不会增加。</p><p>维护一个双指针即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1894e.-freedom-of-choice"><ahref="https://codeforces.com/contest/1894/problem/E">CF1894E. Freedom ofChoice</a></h2><p>*2000 <ahref="https://codeforces.com/contest/1894/submission/308868532">Code</a></p><p>设 <span class="math inline">\(L=\sum\limits_{i=1}^{m}l_i\)</span>，<span class="math inline">\(R =\sum\limits_{i=1}^{m}r_i\)</span>，<spanclass="math inline">\(N=\sum\limits_{i=1}^{m}n_i\)</span>。</p><p>断言：当 <span class="math inline">\(R-L+1&gt;N\)</span> 时，答案为<span class="math inline">\(0\)</span>。</p><ul><li>根据 anti-beauty 的定义，一个 <spanclass="math inline">\(|X|\)</span> 对应一个 <spanclass="math inline">\(a_i\)</span>，而 <spanclass="math inline">\(a_i\)</span> 一共有 <spanclass="math inline">\(N\le 10^5\)</span> 种取值。当 <spanclass="math inline">\(|X|\)</span> 有 <spanclass="math inline">\(R-L+1&gt;N\)</span>种取值时，由抽屉原理，一定存在一个 <spanclass="math inline">\(|X|\)</span> 没有 <spanclass="math inline">\(a_i\)</span> 与之对应，此时答案为 <spanclass="math inline">\(0\)</span>。</li></ul><p>否则我们可以 <span class="math inline">\(O(N)\)</span> 枚举 <spanclass="math inline">\(|X|\in [L,R]\)</span>，对于每一个multiset，策略一定是 “若能不拿 <span class="math inline">\(|X|\)</span>就不拿”。</p><p>具体地，初始化计数器 <spanclass="math inline">\(cnt=0\)</span>。对于当前 multiset，除了 <spanclass="math inline">\(|X|\)</span> 之外所有 <spanclass="math inline">\(a_i\)</span> 的 <spanclass="math inline">\(c_i\)</span> 之和为 <spanclass="math inline">\(s\)</span>，若 <spanclass="math inline">\(s&lt;l_i\)</span>，则有 <spanclass="math inline">\(l_i-s\)</span> 个 <spanclass="math inline">\(|X|\)</span> 是必须要拿的，令 <spanclass="math inline">\(cnt\leftarrow cnt+l_i-s\)</span> 且 <spanclass="math inline">\(s\leftarrow l_i\)</span>；否则 <spanclass="math inline">\(s=\min(s,r_i)\)</span>。将每个 multiset 的 <spanclass="math inline">\(s\)</span> 求和，设为 <spanclass="math inline">\(S\)</span>。</p><p>若 <span class="math inline">\(S\ge|X|\)</span>，说明我们只需支付必要的 <spanclass="math inline">\(cnt\)</span> 个 <spanclass="math inline">\(|X|\)</span> 就能满足要求，当前 <spanclass="math inline">\(|X|\)</span> 的答案就是 <spanclass="math inline">\(cnt\)</span>；否则，我们还需在 <spanclass="math inline">\(cnt\)</span> 的基础上支付额外的 <spanclass="math inline">\(|X|-S\)</span>。</p><p>当然，我们不能对每个 <span class="math inline">\(|X|\in[L,R]\)</span>都枚举所有 <span class="math inline">\(m\)</span> 个multisets。我们用一个 <code>std::map&lt;int, set&lt;int&gt;&gt;</code>预处理出 <span class="math inline">\(|X|\)</span> 存在于哪些 multiset中。此外还需要记录在每个 multiset 中 <spanclass="math inline">\(|X|\)</span> 的 <spanclass="math inline">\(c_i\)</span> 是多少。</p><p>时间复杂度 <span class="math inline">\(O(N\log N)\)</span>。</p><h2 id="cf2028d.-alices-adventures-in-cards"><ahref="https://codeforces.com/contest/2028/problem/D">CF2028D. Alice’sAdventures in Cards</a></h2><p>*2000 <ahref="https://codeforces.com/contest/2028/submission/308902705">Code</a></p><p>Alice 能从第 <span class="math inline">\(i\)</span> 列移动到第 <spanclass="math inline">\(j\ (j&gt;i)\)</span> 列当且仅当 <spanclass="math inline">\(\exists k\in\{0,1,2\}\)</span>，<spanclass="math inline">\(a[k][j]&lt;a[k][i]\)</span>。</p><p>考虑从后向前枚举 <span class="math inline">\(i\)</span>，维护 <spanclass="math inline">\(dp[i]\)</span> 表示 Alice 能否从第 <spanclass="math inline">\(i\)</span> 列经过一系列移动到达第 <spanclass="math inline">\(n\)</span> 列。</p><p>为方便转移，令 <span class="math inline">\(\text{minp}[k]\)</span>代表第 <span class="math inline">\(k\)</span> 行的当前后缀中 <spanclass="math inline">\(dp=1\)</span> 且值最小的元素的下标，那么 <spanclass="math inline">\(dp[i]=1\)</span> 当且仅当 <spanclass="math inline">\(\exists k\in \{0,1,2\}\)</span>，<spanclass="math inline">\(a[k][\text{minp}[k]]&lt;a[k][i]\)</span>。</p><p>同时若 <span class="math inline">\(dp[i]=1\)</span>，就 check一下每一行的 <span class="math inline">\(\text{minp}\)</span>能不能更新。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2028e.-alices-adventures-in-the-rabbit-hole"><ahref="https://codeforces.com/contest/2028/problem/E">CF2028E. Alice’sAdventures in the Rabbit Hole</a></h2><p>*2300 <ahref="https://codeforces.com/contest/2028/submission/308910581">Code</a></p><p>令 <span class="math inline">\(f_x\)</span> 表示点 <spanclass="math inline">\(x\)</span> 的答案，由题 <spanclass="math inline">\(f_{1}=1\)</span>，<spanclass="math inline">\(f_{leaf}=0\)</span>。</p><p>每次轮到 Alice操作肯定是向根节点走，轮到皇后操作肯定是前往距当前节点最近的叶子。</p><p>设当前研究的点为 <span class="math inline">\(x\)</span>，点 <spanclass="math inline">\(y\)</span> 是 <spanclass="math inline">\(x\)</span> 的儿子且在 <spanclass="math inline">\(x\)</span> 的所有儿子中离叶子最近，则： <spanclass="math display">\[f_x=\frac{1}{2}(f_{fa}+f_y)\]</span> 尝试待定系数，设 <spanclass="math inline">\(f_x=k_xf_{fa}+b_x\)</span>，代入。</p><p><span class="math display">\[\begin{align}f_x={\color{Red}k_x}f_{fa}+\color{Green}{b_x}&amp;=\frac{1}{2}(f_{fa}+f_y)\\&amp;=\dfrac{1}{2}(f_{fa}+k_yf_x+b_y)\\&amp;=\frac{1}{2}(f_{fa}+k_y(k_xf_{fa}+b_x)+b_y)\\&amp;=\frac{1}{2}((k_xk_y+1)f_{fa}+k_yb_x+b_y)\\&amp;={\color{Red}\frac{1}{2}(k_xk_y+1)}f_{fa}+{\color{Green}\frac{1}{2}(k_yb_x+b_y)}\end{align}\]</span></p><p>标红的两项对应相等，标绿的两项对应相等，解得： <spanclass="math display">\[k_x=\frac{1}{2-k_y}\qquad b_x=\frac{b_y}{2-k_y}\]</span> 又因叶子节点有 <spanclass="math inline">\(k_{leaf}=b_{leaf}=0\)</span>，根据 <spanclass="math inline">\(b_x\)</span> 递推式易知对于任意节点 <spanclass="math inline">\(b_x\)</span> 均为 <spanclass="math inline">\(0\)</span>。</p><p>用一遍 dfs 至下而上求出每个节点的 <spanclass="math inline">\(k_x\)</span>，再 dfs 一遍即可求出 <spanclass="math inline">\(f_x\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1820e.-the-fox-and-the-complete-tree-traversal"><ahref="https://codeforces.com/contest/1820/problem/E">CF1820E. The Foxand the Complete Tree Traversal</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1820/submission/309151081">Code</a></p><p>萌萌性质题。手玩之后做出如下 Claim。</p><ul><li>能找到一个符合要求的回路当且仅当整棵树是一个毛毛虫（由一条主链和长度不超过<span class="math inline">\(1\)</span>的支链组成的结构）。而整棵树是毛毛虫时，直径显然可以充当主链。</li></ul><p>换句话说，<code>Yes</code>当且仅当这棵树由直径和接在直径上的若干单点组成。</p><p>令 <span class="math inline">\(dp[x]\)</span> 代表 <spanclass="math inline">\(x\)</span> 的子树中以 <spanclass="math inline">\(x\)</span>为毛毛虫的头的最大毛毛虫大小。转移是朴素的，最后只需判断这棵树的最大毛毛虫大小是否等于<span class="math inline">\(n\)</span>。如果你不熟悉可以看一下 <spanclass="math inline">\(\to\)</span> <ahref="https://www.luogu.com.cn/problem/P3174">Link</a>。</p><p>最后是构造方案。如下图构造即可（<spanclass="math inline">\(x,y\)</span>是直径端点），其实就是看这个点在直径序列上下标的奇偶性。</p><p><img src="/image/academic/CF1820E.png" /></p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1982e.-number-of-k-good-subarrays"><ahref="https://codeforces.com/contest/1982/problem/E">CF1982E. Number ofk-good subarrays</a></h2><p>*2300 <ahref="https://codeforces.com/contest/1982/submission/309161811">Code</a></p><p>设 <span class="math inline">\(f(x,y)\)</span> 代表 <spanclass="math inline">\(n=x,k=y\)</span> 时的答案，考虑分治： <spanclass="math display">\[f(n,k)\to f(m,k),f(n-m,k-1)\]</span> 其中 <spanclass="math inline">\(m=\text{bit}\underline{}\text{floor}(n)\)</span>。后一部分相当于把最<span class="math inline">\(n\)</span> 最高位的 <spanclass="math inline">\(1\)</span> 拿掉，所以是 <spanclass="math inline">\(k-1\)</span>。</p><p>分治的时候对当前 <span class="math inline">\((n,k)\)</span>返回一个三元组 <spanclass="math inline">\((l,r,ans)\)</span>，分别代表最大的 <spanclass="math inline">\(l\)</span> 满足 <spanclass="math inline">\([0,l)\)</span> 是 k-good 的，最小的 <spanclass="math inline">\(r\)</span> 满足 <spanclass="math inline">\([n-r,n)\)</span> 是 k-good的，以及当前状态的答案。</p><p>合并的时候类似线段树维护前后缀，分情况讨论即可。</p><p>时间复杂度 <span class="math inline">\(O(t\log^2n)\)</span>，其中一个 <span class="math inline">\(\log\)</span> 来自<code>std::map</code> 的记忆化。</p><h2 id="cf1797e.-li-hua-and-array"><ahref="https://codeforces.com/contest/1797/problem/E">CF1797E. Li Hua andArray</a></h2><p>*2300 <ahref="https://codeforces.com/contest/1797/submission/309307708">Code</a></p><p>将值域内的所有 <span class="math inline">\(x\)</span> 与 <spanclass="math inline">\(\varphi(x)\)</span> 连边（<spanclass="math inline">\(\varphi(x)\)</span> 是 <spanclass="math inline">\(x\)</span> 的父亲），构成一棵深度为 <spanclass="math inline">\(O(\log w)\)</span> 的树，根是 <spanclass="math inline">\(1\)</span>。</p><p>操作 <span class="math inline">\(1\)</span>相当于让一段区间内的点同时跳向父亲，操作 <spanclass="math inline">\(2\)</span>相当于求一段区间内的点的深度和，以及一段区间内所有点的 LCA 的深度。</p><p>对于操作 <span class="math inline">\(1\)</span>，因为树高是 <spanclass="math inline">\(\log\)</span> 级别，所以可以暴跳。若一个点跳到了<spanclass="math inline">\(1\)</span>，它后面就不再跳了，故用双向链表维护非<span class="math inline">\(1\)</span> 的节点。这样所有的操作 <spanclass="math inline">\(1\)</span> 复杂度之和不超过 <spanclass="math inline">\(O(n\log w)\)</span>。</p><p>对于操作 <spanclass="math inline">\(2\)</span>，因为我们采取暴跳，所以深度和是好维护的，每跳一步就用线段树对深度进行单点修改。最多修改<span class="math inline">\(O(n\log w)\)</span> 次，故复杂度为 <spanclass="math inline">\(O(n\log n\log w)\)</span>。</p><p>最后一个问题就是如何快速求若干点的 LCA，有结论：</p><ul><li>一堆点的 LCA 等同于 “dfs 序最小点” 和 “dfs 序最大点” 的 LCA。</li></ul><p>还是用线段树维护一段区间里最小 dfn 和最大 dfn，这样就是单 <spanclass="math inline">\(\log\)</span> 的。</p><p>编码时要注意并不需要倍增求 LCA，暴跳求 LCA就行了，因为空间限制不允许你倍增。</p><p>时间复杂度 <span class="math inline">\(O(w+n\log n\log w+m\logn)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><h2 id="cf1974g.-money-buys-less-happiness-now"><ahref="https://codeforces.com/contest/1974/problem/G">CF1974G. Money BuysLess Happiness Now</a></h2><p>*2000 <ahref="https://codeforces.com/contest/1974/submission/309608229">Code</a></p><p>非常经典的反悔贪心。契机是每次换取的幸福值是一样的，你只关心得到了多少，而不关心来自哪次交易。</p><p>用一个大根堆存储已经进行完交易的 <spanclass="math inline">\(c_i\)</span>，每次没钱时就把堆顶弹出来。</p><p>时间复杂度 <span class="math inline">\(O(m\log m)\)</span>。</p><h2 id="cf1797f.-li-hua-and-path"><ahref="https://codeforces.com/contest/1797/problem/F">CF1797F. Li Hua andPath</a></h2><p>*3000 <ahref="https://codeforces.com/contest/1797/submission/309616026">Code</a></p><p>这篇题解将会用到 Kruskal 点权多叉重构树。推荐前往 <ahref="https://www.cnblogs.com/alex-wei/p/Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree_Tree.html">Link</a>了解，如果你未曾接触过。</p><p>我们将树上的一对 pair <span class="math inline">\((u,v)\)</span>分成三类，<span class="math inline">\(A\)</span> 类满足 <spanclass="math inline">\(u\)</span> 是 <span class="math inline">\(u\tov\)</span> 上的最小点，<span class="math inline">\(B\)</span> 类满足<span class="math inline">\(v\)</span> 是 <spanclass="math inline">\(u\to v\)</span> 上的最大点，<spanclass="math inline">\(C\)</span> 类则同时满足 <spanclass="math inline">\(u\)</span> 是最小点且 <spanclass="math inline">\(v\)</span> 是最大点。简单容斥，答案是 <spanclass="math inline">\(|A|+|B|-2|C|\)</span>。</p><p>先考虑 <span class="math inline">\(A\)</span> 类路径的个数怎么求。求<span class="math inline">\(A\)</span> 类本质上是对每一个点 <spanclass="math inline">\(i\)</span>，找从 <spanclass="math inline">\(i\)</span> 出发只经过编号大于等于 <spanclass="math inline">\(i\)</span>的点能到达的点集大小。我们按点权从大到小的顺序建出原树的 Kruskal点权多叉重构树（后文称为 <span class="math inline">\(A\)</span>树），此时这棵树满足小根堆的性质，对于其上任意一点 <spanclass="math inline">\(x\)</span>，从 <spanclass="math inline">\(x\)</span> 出发能到达的点全在 <spanclass="math inline">\(x\)</span> 的子树中。因此 <spanclass="math inline">\(|A|=\sum\limits_{i=1}^{n}(sz_i-1)\)</span>。<spanclass="math inline">\(sz_i\)</span> 代表重构树上点 <spanclass="math inline">\(i\)</span> 的子树大小。</p><p>同理 <span class="math inline">\(B\)</span>类路径就是按点权从小到大建树（称为 <spanclass="math inline">\(B\)</span> 树），这棵树满足大根堆的性质。</p><p>接着考虑 <span class="math inline">\(C\)</span> 类路径。一个 pair<span class="math inline">\((u,v)\)</span> 满足 <spanclass="math inline">\(C\)</span> 类当且仅当 <spanclass="math inline">\(u\)</span> 在 <spanclass="math inline">\(A\)</span> 树上是 <spanclass="math inline">\(v\)</span> 的祖先，且 <spanclass="math inline">\(u\)</span> 在 <spanclass="math inline">\(B\)</span> 树上是 <spanclass="math inline">\(v\)</span>的子孙。容易将这个问题转化为子树加，利用树状数组维护。</p><p>最后考虑那 <span class="math inline">\(m\)</span>次操作。注意到我们加的点的编号递增，这能引申出一系列良好的性质。</p><p>设新加的点编号为 <span class="math inline">\(x\)</span>，则 <spanclass="math inline">\(x\)</span> 在 <spanclass="math inline">\(A\)</span> 树上一定是叶子，在 <spanclass="math inline">\(B\)</span> 树上一定是根。进一步，<spanclass="math inline">\(x\)</span> 对 <spanclass="math inline">\(A\)</span> 类的贡献就是它的深度（对每个祖先贡献<span class="math inline">\(1\)</span> 的子树大小），对 <spanclass="math inline">\(B\)</span> 类的贡献就是加进去的时候整个 <spanclass="math inline">\(B\)</span> 树的大小（即 <spanclass="math inline">\(x-1\)</span>）。对于 <spanclass="math inline">\(C\)</span> 类，因为 <spanclass="math inline">\(x\)</span> 编号最大，只能作为 pair 的第二维，<spanclass="math inline">\((u,x)\)</span> 是 <spanclass="math inline">\(C\)</span> 类当且仅当 <spanclass="math inline">\(u\)</span> 在 <spanclass="math inline">\(A\)</span> 树上是 <spanclass="math inline">\(x\)</span> 的祖先，且在 <spanclass="math inline">\(B\)</span> 树上是 <spanclass="math inline">\(x\)</span> 的子孙。换句话说 <spanclass="math inline">\(C\)</span> 类贡献与 <spanclass="math inline">\(A\)</span> 类相同，是 <spanclass="math inline">\(x\)</span> 的深度。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="abc396g.-flip-row-or-col"><ahref="https://atcoder.jp/contests/abc396/tasks/abc396_g">abc396g. FlipRow or Col</a></h2><p><ahref="https://atcoder.jp/contests/abc396/submissions/63615012">Code</a></p><p>对于一行来说，如果这一行有 <span class="math inline">\(c\)</span> 个<span class="math inline">\(1\)</span>，我们肯定是调整至 <spanclass="math inline">\(\min(c,W-c)\)</span> 个 <spanclass="math inline">\(1\)</span>。</p><p>记 <span class="math inline">\(B_i\)</span> 代表第 <spanclass="math inline">\(i\)</span>行对应的十进制数，枚举每一列是否翻转，答案是： <spanclass="math display">\[\min_{X=0}^{2^W-1}\sum_{i=0}^{H-1}\min(\text{popcount}(B_i\oplusX),W-\text{popcount}(B_i\oplus X))\]</span>对于枚举的每一种列状态，时间复杂度不允许我们再枚举每一行，我们考虑对把<span class="math inline">\(\text{popcount}(B_i\oplus X)\)</span> 相同的<span class="math inline">\(i\)</span> 一起统计。</p><p>令 <span class="math inline">\(dp[X][c]\)</span> 代表满足 <spanclass="math inline">\(\text{popcount}(B_i\oplus X)=c\)</span> 的 <spanclass="math inline">\(i\)</span> 的数量，枚举 <spanclass="math inline">\(X,c\)</span> 以及 <spanclass="math inline">\(j\in[0,W)\to\)</span> 从状态 <spanclass="math inline">\(X\oplus 2^j\)</span> 转移过来。</p><p>答案是 <spanclass="math inline">\(\min\limits_{X=0}^{2^W-1}\sum\limits_{c=0}^{W}dp[X][c]\cdot\min(c,W-c)\)</span>。时间复杂度<span class="math inline">\(O(W^22^W)\)</span>。</p><h2 id="cf2029e.-common-generator"><ahref="https://codeforces.com/contest/2029/problem/E">CF2029E. CommonGenerator</a></h2><p>*2100 <ahref="https://codeforces.com/contest/2029/submission/309724863">Code</a></p><p><strong>Claim 1.</strong> <span class="math inline">\(2\)</span>能生成所有的合数。</p><ul><li>首先，<span class="math inline">\(2\)</span>的倍数显然可以合成。否则假设当前合数为 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(x\)</span>一定可以表示成 <span class="math inline">\(x=pq\)</span>，其中 <spanclass="math inline">\(p\)</span> 是 <spanclass="math inline">\(x\)</span> 的最小质因数且 <spanclass="math inline">\(p\ge 3,q&gt;1\)</span>。又 <spanclass="math inline">\(pq\)</span> 可以由 <spanclass="math inline">\((p-1)q\)</span> 合成，而 <spanclass="math inline">\(p-1\)</span> 是偶数，偶数可以由 <spanclass="math inline">\(2\)</span> 生成，故 <spanclass="math inline">\(x=pq\)</span> 可以由 <spanclass="math inline">\(2\)</span> 生成。</li></ul><p><strong>Claim 2. </strong> 质数只能由它自己生成。（显然，不证了）</p><p>至此我们扫一遍 <spanclass="math inline">\(\{a\}\)</span>，若没有质数，答案是 <spanclass="math inline">\(2\)</span>；若有不同的质数，无解。</p><p>否则设唯一质数为 <span class="math inline">\(p\)</span>，我们只用考虑<span class="math inline">\(p\)</span> 能否生成 <spanclass="math inline">\(\{a\}\)</span> 中剩下的所有数。</p><p><strong>Claim 3. </strong> <span class="math inline">\(p\)</span>能生成偶数 <span class="math inline">\(x\)</span> 当且仅当 <spanclass="math inline">\(x\ge 2p\)</span>。</p><ul><li>因为 <span class="math inline">\(p\)</span> 第一步只能变成 <spanclass="math inline">\(2p\)</span>，<spanclass="math inline">\(2p\)</span> 又是偶数。之后一直 <spanclass="math inline">\(+2\)</span> 得到所有 <spanclass="math inline">\(\ge 2p\)</span> 的偶数。</li></ul><p><strong>Claim4. </strong> <span class="math inline">\(p\)</span>能生成奇合数 <span class="math inline">\(x\)</span> 当且仅当 <spanclass="math inline">\(x-\text{minp}_x\ge 2p\)</span>，其中 <spanclass="math inline">\(\text{minp}_x\)</span> 是 <spanclass="math inline">\(x\)</span> 的最小质因数。</p><ul><li><span class="math inline">\(x-\text{minp}_x\)</span> 是最大的 <spanclass="math inline">\(&lt; x\)</span> 的偶数。若 <spanclass="math inline">\(x-\text{minp}_x &lt; 2p\)</span>，即最大的能生成<span class="math inline">\(x\)</span> 的偶数都无法生成，自然无解。</li></ul><p>素数和最小质因数都能线性筛，这样每组数据就是线性的。</p><p>时间复杂度 <span class="math inline">\(O(w+n)\)</span>，<spanclass="math inline">\(w\)</span> 是值域。</p><h2 id="arc194c.-cost-to-flip"><ahref="https://atcoder.jp/contests/arc194/tasks/arc194_c">arc194c. Costto Flip</a></h2><p><ahref="https://atcoder.jp/contests/arc194/submissions/63650748">Code</a></p><p>用二元组 <span class="math inline">\((x,y)\)</span> 代表状态 <spanclass="math inline">\(A_i=x,B_i=y\)</span>。首先 <spanclass="math inline">\((0,1)\)</span> 和 <span class="math inline">\((1,0)\)</span> 是无可避免的，<span class="math inline">\((0,0)\)</span>不用动，<span class="math inline">\((1,1)\)</span>既可以选择不动也可以选择 <span class="math inline">\(1\to 0\)</span> 再<span class="math inline">\(0\to 1\)</span>。</p><p>依据贪心原则，满足状态 <span class="math inline">\((1, 0)\)</span>的列肯定是按 <span class="math inline">\(c_i\)</span>从大到小进行操作，满足状态 <span class="math inline">\((0,1)\)</span>的列肯定是按 <span class="math inline">\(c_i\)</span>从小到大进行操作。此外，对于状态 <span class="math inline">\((1,1)\)</span>，也一定存在一个阈值 <spanclass="math inline">\(W\)</span>，使得 <spanclass="math inline">\(C_i\le W\)</span> 的列选择不动，<spanclass="math inline">\(C_i&gt;W\)</span> 的列选择 <spanclass="math inline">\(1\to 0\)</span> 再 <spanclass="math inline">\(0\to 1\)</span>。</p><p>我们考虑从小到大枚举这个阈值，列出式子并观察增量有何变化。</p><p>所有 <span class="math inline">\((1,1)\)</span> 选择不动时，有：<span class="math display">\[ans=\sum_{p=1}^{X}(p-1)C_{ip}+\sum_{p=1}^{Y}pC_{jp}+(X+Y)\sum_{p=1}^{Z}C_{kp}\]</span> 其中 <span class="math inline">\(C_{i1}\ge C_{i2}\ge C_{i3}\ge\ldots\ge C_{iX}\)</span> 代表满足状态 <spanclass="math inline">\((1,0)\)</span> 的 <spanclass="math inline">\(C\)</span>，<span class="math inline">\(C_{j1}\geC_{j2}\ge C_{j3}\ge \ldots\ge C_{jY}\)</span> 代表满足状态 <spanclass="math inline">\((0, 1)\)</span> 的 <spanclass="math inline">\(C\)</span>，<spanclass="math inline">\(C_{k1},C_{k2},\ldots,C_{kZ}\)</span>则代表满足状态 <span class="math inline">\((1, 1)\)</span> 的 <spanclass="math inline">\(C\)</span>。</p><p>选中一个状态 <span class="math inline">\((1,1)\)</span>进行操作时，设对应的 <span class="math inline">\(C\)</span> 为 <spanclass="math inline">\(C_x\)</span>，最后一项会变成 <spanclass="math inline">\((X+Y+2)\left(\sum C_{kp}-C_x\right)\)</span>。</p><p>对于前面两项，拿第一项举例。操作前： <span class="math display">\[0\cdot C_{i1}+1\cdot C_{i2}+2\cdot C_{i3}+3\cdot C_{i4}+ 4\cdotC_{i5}+5\cdot C_{i6}\]</span> 将 <span class="math inline">\(C_x\)</span> 插入后： <spanclass="math display">\[0\cdot C_{i1}+1\cdot C_{i2}+2\cdot C_{i3}+{\color{Green}3\cdotC_{x}}+{\color{Red}4}\cdot C_{i4}+ {\color{Red}5}\cdotC_{i5}+{\color{Red}6}\cdot C_{i6}\]</span> 插入的位置可以二分出来，增量则是一段后缀。</p><p>但这并不意味着需要动态维护后缀和，因为我们插入的 <spanclass="math inline">\(C_x\)</span> 递减，每次插入的位置一定在之前的<span class="math inline">\(C_x\)</span> 之后。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="arc194d.-reverse-brackets"><ahref="https://atcoder.jp/contests/arc194/tasks/arc194_d">arc194d.Reverse Brackets</a></h2><p><ahref="https://atcoder.jp/contests/arc194/submissions/63655541">Code</a></p><p>建出括号树（包括虚根），一次操作相当于选定一个点 <spanclass="math inline">\(x\)</span>（设 <spanclass="math inline">\(x\)</span> 的儿子按原序列顺序依次是 <spanclass="math inline">\(y_1,y_2,y_3,\ldots\)</span>），接着选定一个区间<span class="math inline">\([l,r]\)</span>，将 <spanclass="math inline">\(y_l,y_{l+1},\ldots,y_r\)</span>连带它们的子树翻转。</p><p>不难发现如此操作能任意排列一个点的儿子。</p><p>接着就是数树的形态了。我们把同构的两棵子树用相同的数字表示，对于一个点来说，将以它所有儿子为根的子树代表的数字排成序列，方案数相当于重排这个序列能得到的本质不同的序列数量。</p><p>使用树哈希容易做到 <span class="math inline">\(O(n\log n)\)</span> 或<span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2071f.-towering-arrays"><ahref="https://codeforces.com/contest/2071/problem/F">CF2071F. ToweringArrays</a></h2><p>*2700 <ahref="https://codeforces.com/contest/2071/submission/310224979">Code</a></p><p>题外话：时限 6s，拼尽全力卡常喜提5999ms。上面代码放的是没有刻意卡常的版本，clone 下来跑了 7s。</p><p>二分答案，设二分出的答案是 <spanclass="math inline">\(p\)</span>，我们就要找到最长的 <spanclass="math inline">\(p-towering\)</span> 序列的长度 <spanclass="math inline">\(m\)</span>，判断是否 <spanclass="math inline">\(n-m\le k\)</span>。</p><p>考虑遍历序列上的每一个位置 <spanclass="math inline">\(i\)</span>，check <spanclass="math inline">\(a_i\)</span> 是否能作为 <spanclass="math inline">\(p-towering\)</span> 序列的最高点。此时 <spanclass="math inline">\(a_i\)</span>两侧延伸出去的长度独立，我们可以只考虑一边，然后把序列 reverse做另一边。</p><p>现在的问题是对于每一个 <span class="math inline">\(i\)</span>，求序列<span class="math inline">\(a_1\sim a_i\)</span> 中以 <spanclass="math inline">\(a_i\)</span> 结尾的最长的子序列 <spanclass="math inline">\(\{s\}\)</span>，满足 <spanclass="math inline">\(s\)</span> 最后一个元素 <spanclass="math inline">\(\ge p\)</span>，倒数第二个元素 <spanclass="math inline">\(\ge p-1\)</span>，倒数第三个元素 <spanclass="math inline">\(\ge p-2\)</span>，<spanclass="math inline">\(\ldots\)</span></p><p>结论：若 <span class="math inline">\(a_{i}\gep\)</span>，对于任意满足 <span class="math inline">\(j&lt;i\)</span> 且<span class="math inline">\(a_j\ge p\)</span> 的 <spanclass="math inline">\(j\)</span>，序列 <spanclass="math inline">\(a_1\sim a_i\)</span> 构造出的 <spanclass="math inline">\(\{s\}\)</span> 一定完全包含序列 <spanclass="math inline">\(a_1\sim a_{j}\)</span> 构造出的 <spanclass="math inline">\(\{s\}\)</span> 中的元素。换句话说随着 <spanclass="math inline">\(i\)</span> 增加，我们一定只是在 <spanclass="math inline">\(\{s\}\)</span> 的末尾添加元素。</p><ul><li>当我们把 <span class="math inline">\(a_i\)</span> 加进 <spanclass="math inline">\(\{s\}\)</span> 后，<spanclass="math inline">\(\{s\}\)</span> 中倒数第 <spanclass="math inline">\(i\)</span> 个元素要求 <spanclass="math inline">\(\ge p-i+1\)</span>，而在原来的 <spanclass="math inline">\(\{s\}\)</span> 中倒数第 <spanclass="math inline">\(i-1\)</span> 个元素满足 <spanclass="math inline">\(\ge p-i+2\)</span>。故得证。</li></ul><p>一个使用线段树维护 <span class="math inline">\(\{s\}\)</span>最长长度的流程是：</p><ol type="1"><li>按顺序扫描序列，对于当前 <spanclass="math inline">\(i\)</span>，给线段树上第 <spanclass="math inline">\(i\)</span> 个位置赋值 <spanclass="math inline">\(p-a_i\)</span>。</li><li>找到 <span class="math inline">\(1\sim i\)</span> 中最后一个值 <spanclass="math inline">\(\le0\)</span> 的位置，设下标为 <spanclass="math inline">\(t\)</span>。将 <spanclass="math inline">\(a_t\)</span> 加进 <spanclass="math inline">\(\{s\}\)</span> 中，并给线段树上 <spanclass="math inline">\(1\sim t\)</span> 这段前缀 <spanclass="math inline">\(-1\)</span>。（多一个元素自然前面的元素限制 <spanclass="math inline">\(-1\)</span>）</li><li>将位置 <span class="math inline">\(t\)</span> 设为 <spanclass="math inline">\(+\infty\)</span>。（保证已经选中的之后不再选中）</li><li>重复步骤 <span class="math inline">\(2,3\)</span> 直到找不到值 <spanclass="math inline">\(\le 0\)</span> 的位置。此时 <spanclass="math inline">\(\{s\}\)</span> 中元素个数即为当前 <spanclass="math inline">\(i\)</span> 的答案。</li></ol><p>时间复杂度 <span class="math inline">\(O(n\log n\logw)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><h2 id="cf2074g.-game-with-triangles-season-2"><ahref="https://codeforces.com/contest/2074/problem/G">CF2074G. Game WithTriangles: Season 2</a></h2><p>*2100 <ahref="https://codeforces.com/contest/2074/submission/310276404">Code</a></p><p>区间 dp。拆环成链，记 <span class="math inline">\(dp[L][R]\)</span>为区间 <span class="math inline">\([L,R]\)</span> 的答案。</p><p>从小到大枚举长度，对于当前 <spanclass="math inline">\([L,R]\)</span>，枚举 <spanclass="math inline">\(k\in[L+1,R-1]\)</span> 让 <spanclass="math inline">\(L,k,R\)</span> 成为三角形的三个顶点。 <spanclass="math display">\[dp[L][R]=\max_{k\in(L,R)}(dp[L+1][k-1]+dp[k+1][R-1]+a_L\cdot a_k\cdota_R)\]</span> 别忘了还有区间 dp 的定义式： <span class="math display">\[dp[L][R]=\max_{k\in[L,R)}(dp[L][k]+dp[k+1][R])\]</span> 时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="cf1994d.-funny-game"><ahref="https://codeforces.com/contest/1994/problem/D">CF1994D. FunnyGame</a></h2><p>*1900 <ahref="https://codeforces.com/contest/1994/submission/310362959">Code</a></p><p>我们只关心连哪些边，而不关心连边的顺序。</p><p>按 <span class="math inline">\(x\)</span>从大到小考虑，我们每次将选出的两个点用并查集连起来，这样每次操作后连通块个数<span class="math inline">\(-1\)</span>。</p><p>第一次操作，要找到两个点 <span class="math inline">\(u,v\)</span>满足 <span class="math inline">\(|a_u-a_v|=n-1\)</span>，换个写法就是<span class="math inline">\(a_u\equiv a_v\pmod{n-1}\)</span>。此时图上有<span class="math inline">\(n\)</span>个连通块，从每个连通块里任选一个点，就是 <spanclass="math inline">\(n\)</span> 个点。根据鸽笼原理，这 <spanclass="math inline">\(n\)</span> 个点里一定存在一对 <spanclass="math inline">\(u,v\)</span> 满足 <spanclass="math inline">\(a_u\equiv a_v\pmod{n-1}\)</span>。</p><p>第二次操作，要找到两个点 <span class="math inline">\(u,v\)</span>满足 <span class="math inline">\(a_u\equiva_v\pmod{n-2}\)</span>。此时图上有 <spanclass="math inline">\(n-1\)</span>个连通块，从每个连通块里任选一个点，就是 <spanclass="math inline">\(n-1\)</span> 个点。根据鸽笼原理，这 <spanclass="math inline">\(n-1\)</span> 个点里也一定存在一对 <spanclass="math inline">\(u,v\)</span> 满足 <spanclass="math inline">\(a_u\equiv a_v\pmod{n-2}\)</span>。</p><p>第三次操作，<span class="math inline">\(\ldots\)</span></p><p>综上，本题一定有解，按照上述流程构造一个即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="cf1994f.-stardew-valley"><ahref="https://codeforces.com/contest/1994/problem/F">CF1994F. StardewValley</a></h2><p>*2500 <ahref="https://codeforces.com/contest/1994/submission/310403549">Code</a></p><p>把有 NPC 的边称为 <span class="math inline">\(1\)</span> 边，否则称为<span class="math inline">\(0\)</span> 边。</p><p>我们要找到一条经过每条 <span class="math inline">\(1\)</span>边恰好一次的回路。可以将该问题转化为选择一些 <spanclass="math inline">\(0\)</span>边删掉，使得图中所有点的度均为偶数，这样我们只用跑一遍欧拉回路就行。</p><p>当我们删除一条边时，如果两个端点原来都是奇度点，那么图中奇度点个数<spanclass="math inline">\(-2\)</span>；如果两个端点原来度数一奇一偶，那么图中奇度点个数不变。</p><p>于是，建出一个只有 <span class="math inline">\(0\)</span>边的图，<code>YES</code>的充要条件就是对于图中每个连通分量，奇度点个数均为偶数。</p><p>一个较好的实现是：对每个连通分量 dfs，在 dfs生成树上至下而上贪心地删边，若删到根后根是奇度点，就是<code>NO</code>。这样删哪条边也顺便记录了。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2049f.-mex-or-mania"><ahref="https://codeforces.com/contest/2049/problem/F">CF2049F. MEX ORMania</a></h2><p>*2700 <ahref="https://codeforces.com/contest/2049/submission/310513955">Code</a></p><p>由 <span class="math inline">\(\text{mex} \le \text{max}+1\le\text{or}+1\)</span>，题目条件成立当且仅当这两个不等号同时取等。</p><p><span class="math inline">\(\text{mex}=\max +1\)</span>当且仅当序列包含了 <span class="math inline">\(0\sim \max\)</span>中的所有数，<span class="math inline">\(\text{or}=\max\)</span>当且仅当序列中的数在二进制下是 <span class="math inline">\(\max\)</span>的子集。同时取等意味着这个序列包含了 <span class="math inline">\(0\sim2^k-1\)</span> 中的所有数，<span class="math inline">\(k\inN\)</span>。</p><p>我们不妨枚举每个 <spanclass="math inline">\(k\)</span>，判断是否存在一段区间包含了 <spanclass="math inline">\(0\sim 2^k-1\)</span> 中的所有数，且不包含 <spanclass="math inline">\(\ge 2^k\)</span> 的数。</p><p>在不考虑修改的情况下，我们可以把 <spanclass="math inline">\(&lt;2^k\)</span> 的数用并查集连在一起，然后用一个<code>unordered_map</code>维护这个连通块不同的数的个数。若不同的数的个数恰好是 <spanclass="math inline">\(2^k\)</span>，就说明这个连通块是符合条件的。</p><p>接下来我们面临 <span class="math inline">\(q\)</span>次单点加，当区间里的一个数超出了 <spanclass="math inline">\(2^k-1\)</span>，这个区间就会分成两个子区间，这是不好处理的。</p><p>于是考虑离线，倒着操作序列，变成单点减。我们依旧是对每个 <spanclass="math inline">\(k\)</span> 维护一个并查集，将 <spanclass="math inline">\(&lt; 2^k\)</span>的数连在一起，这样每次只用考虑是否可以将被操作的位置的两端合并成一个大区间。若可以，就启发式合并，将小的那一段区间<code>unordered_map</code> 记录的信息合并到大的那一段区间来。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="cf2078g.-another-folding-strip"><ahref="https://codeforces.com/contest/2078/problem/G">CF2078G. AnotherFolding Strip</a></h2><p>*2700 <ahref="https://codeforces.com/contest/2078/submission/310973326">Code</a></p><p>两个格子通过折叠能一上一下挨着当且仅当这两个格子的下标之差为奇数。</p><p>换句话说，一次操作相当于选择一组下标序列 <spanclass="math inline">\(i_1,i_2,i_3,\ldots\)</span>，其中 <spanclass="math inline">\(\forall k &gt; 0\)</span>，<spanclass="math inline">\(i_{k}\)</span> 与 <spanclass="math inline">\(i_{k+1}\)</span> 奇偶性不同，然后使这些位置上的值<span class="math inline">\(+1\)</span>。</p><p>倒着考虑，每次让一组下标序列对应位置上的值 <spanclass="math inline">\(-1\)</span>，问将 <spanclass="math inline">\(\{a\}\)</span> 变成全 <spanclass="math inline">\(0\)</span> 序列的最小操作次数。</p><p>对序列进行黑白染色：<span class="math inline">\(\foralli\in[1,n]\)</span>，令 <spanclass="math inline">\(b_i=(-1)^ia_i\)</span>。</p><p>令一次操作后的 <span class="math inline">\(\{b\}\)</span> 为 <spanclass="math inline">\(\{b&#39;\}\)</span>，一个很强的性质是对于 <spanclass="math inline">\(1\sim n\)</span> 上任意一个区间 <spanclass="math inline">\([l,r]\)</span>，有 <spanclass="math inline">\(\left|\sum\limits_{i=l}^{r}b&#39;_i-\sum\limits_{i=l}^{r}b_i\right|\le 1\)</span>。</p><p>这意味着若 <span class="math inline">\(\{b\}\)</span> 上存在一个和为<span class="math inline">\(k\)</span> 的子段，那么这个子段至少要进行<span class="math inline">\(|k|\)</span> 次操作才能变为全 <spanclass="math inline">\(0\)</span>。</p><p>故 <span class="math inline">\(f(a_1a_2\ldots a_n)\)</span> 的下界是<span class="math inline">\(\max\limits_{1\le l\le r\len}\left|\sum\limits_{i=l}^{r}b_i\right|\)</span>。事实上能够证明该下界可达，具体见官方题解。（毕竟下标序列的选择条件是相当宽松的，退一步写一个<span class="math inline">\(O(n^2)\)</span>检验样例也很容易，这里就不证了）</p><p>令 <spanclass="math inline">\(pre_i=\sum\limits_{j=1}^{i}b_j\)</span>，式子变成<span class="math inline">\(\max\limits_{1\le l\le r\len}\left|pre_r-pre_{l-1}\right|\)</span>，即 <spanclass="math inline">\(\{pre\}\)</span> 的极差。</p><p>原问题转化为求 <span class="math inline">\(\{b\}\)</span>所有连续子序列的极差之和。枚举一个数作为极大值/极小值占领的区间，单调栈或线段树均可做。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span> 或 <spanclass="math inline">\(O(n)\)</span>。</p><h2 id="cf2082f.-mst-in-modulo-graph"><ahref="https://codeforces.com/contest/2082/problem/F">CF2082F. MST inModulo Graph</a></h2><p>*2600 <ahref="https://codeforces.com/contest/2082/submission/311029035">Code</a></p><p>对每一个 <span class="math inline">\(p_i\)</span>，枚举 <spanclass="math inline">\(k=p_i,2p_i,3p_i,\ldots\)</span>，再二分出第一个<span class="math inline">\(\ge k\)</span> 的 <spanclass="math inline">\(p_j\)</span>。将这对 <spanclass="math inline">\((i,j)\)</span> 放进候选表里。</p><p>此时对于 <span class="math inline">\(p_i\)</span> 来说，<spanclass="math inline">\(p_j\bmod p_i\)</span> 最小的 <spanclass="math inline">\(p_j\)</span> 一定在候选表中。</p><p>最终我们会有 <span class="math inline">\(O(n\log n)\)</span>条候选边（调和级数效应）。用这些边跑最小生成树即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h2 id="cf2075d.-equalization"><ahref="https://codeforces.com/contest/2075/problem/D">CF2075D.Equalization</a></h2><p>*2000 <ahref="https://codeforces.com/contest/2075/submission/311292632">Code</a></p><p>每次操作相当于将二进制下的 <span class="math inline">\(x\)</span> 或<span class="math inline">\(y\)</span> 右移一定位数。</p><p>假若我们确定了最优答案中 <span class="math inline">\(x\)</span>右移了 <span class="math inline">\(k_1\)</span> 位，<spanclass="math inline">\(y\)</span> 右移了 <spanclass="math inline">\(k_2\)</span> 位，该如何计算最小操作次数？</p><p>将一次花费 <span class="math inline">\(2^k\)</span>的操作看作一个物品，这个物品的体积是 <spanclass="math inline">\(k\)</span>，价值是 <spanclass="math inline">\(2^k\)</span>，且每个物品至多被选一次。</p><p>也就是说这是一个 <span class="math inline">\(01\)</span>背包问题，而且是两个背包，容量分别为 <spanclass="math inline">\(k_1\)</span> 与 <spanclass="math inline">\(k_2\)</span>。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 为两个背包分别塞了<span class="math inline">\(i\)</span> 体积和 <spanclass="math inline">\(j\)</span> 体积东西时的选取物品的最小价值。</p><ul><li>初态：<spanclass="math inline">\(dp[i][j]=\begin{cases}0&amp;,i=0\cap j=0\\ \infty&amp;,\text{otherwise}\end{cases}\)</span></li><li>转移：<span class="math inline">\(dp[i][j]=\min\limits_{1\le k\le60}\begin{cases}dp[i-k][j]+2^k &amp;,k\le i\\ dp[i][j-k]+2^k &amp;,k\lej\end{cases}\)</span></li><li>答案：<span class="math inline">\(dp[k_1][k_2]\)</span>。</li></ul><p>但事实上 <span class="math inline">\(k_1\)</span> 和 <spanclass="math inline">\(k_2\)</span> 并不能贪心地确定。</p><p>正确的做法是枚举所有 “<span class="math inline">\(x\)</span> 右移<span class="math inline">\(k_1\)</span> 位 <spanclass="math inline">\(=\)</span> <span class="math inline">\(y\)</span>右移 <span class="math inline">\(k_2\)</span> 位” 的 <spanclass="math inline">\(k_1\)</span> 与 <spanclass="math inline">\(k_2\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(\log^3w)-O(\log^2w)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p><h2 id="cf1808d.-petya-petya-petr-and-palindromes"><ahref="https://codeforces.com/contest/1808/problem/D">CF1808D. Petya,Petya, Petr, and Palindromes</a></h2><p>*2100 <ahref="https://codeforces.com/contest/1808/submission/311347398">Code</a></p><p>正难则反，用总和减去相等数对造成的贡献得到答案。</p><p>所有长为 <span class="math inline">\(k\)</span> 的子串的palindromicity 之和为 <spanclass="math inline">\(\lfloor\frac{k}{2}\rfloor(n-k+1)\)</span>。</p><p>考虑满足 <span class="math inline">\(a_i=a_j\)</span> 的一对 <spanclass="math inline">\((i,j)(i&lt;j)\)</span>，这对 <spanclass="math inline">\((i,j)\)</span> 能造成 <spanclass="math inline">\(1\)</span> 的贡献当且仅当：</p><ul><li><p><span class="math inline">\(i\bmod 2=j\bmod 2\)</span>；</p></li><li><p><span class="math inline">\(j-i+1\le k\)</span>；</p></li><li><p><span class="math inline">\(i-\frac{k-(j-i+1)}{2}\ge1\)</span>；</p></li><li><p><span class="math inline">\(j+\frac{k-(j-i+1)}{2}\len\)</span>。</p></li></ul><p>解得 <span class="math inline">\(j\in[\max(i+1,k+1-i),\min(n,i+k-1,2n-k-i+1)]\)</span>。</p><p>将 <span class="math inline">\(\{a\}\)</span>按照下标奇偶分成两个数组。对每个数组 <spanclass="math inline">\(\{b\}\)</span>，枚举 <spanclass="math inline">\(i\)</span>，二分出上述区间里有多少个 <spanclass="math inline">\(j\)</span> 满足 <spanclass="math inline">\(b_i=b_j\)</span>，计入贡献。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1808e1e2.-minibuses-on-venus"><ahref="https://codeforces.com/contest/1808/problem/E1">CF1808E1/E2.Minibuses on Venus</a></h2><p>*2200 <ahref="https://codeforces.com/contest/1808/submission/311374162">Code</a>（E1）</p><p>*2500 <ahref="https://codeforces.com/contest/1808/submission/311387002">Code</a>（E2）</p><p>将 <span class="math inline">\(n\)</span> 个数位看成一个长为 <spanclass="math inline">\(n\)</span> 的数列 <spanclass="math inline">\(\{a\}\)</span>，每个元素的取值是 <spanclass="math inline">\([0,k)\)</span>。</p><p>一个数列满足条件当且仅当 <span class="math inline">\(\existsi\in[1,n]\)</span>，<span class="math inline">\(a_i\equiva_1+a_2+\ldots+a_{i-1}+a_{i+1}+\ldots a_n\pmod{k}\)</span>。</p><p>令 <spanclass="math inline">\(S=\sum\limits_{i=1}^{n}a_i\)</span>，则改写为<span class="math inline">\(a_i\equiv S-a_i\pmod {k}\)</span>，也就是<span class="math inline">\(2a_i\equiv S\pmod {k}\)</span>。</p><p>容斥，用总方案数 <span class="math inline">\(k^n\)</span> 减去 <spanclass="math inline">\(\forall i\in[1,n]\)</span>，<spanclass="math inline">\(2a_i\not\equiv S\pmod {k}\)</span> 的 <spanclass="math inline">\(\{a\}\)</span> 的数量。</p><p>当我们每次往 <span class="math inline">\(\{a\}\)</span>里添一个数时，<span class="math inline">\(S\)</span> 会动态变化。但<spanclass="math inline">\(\bmod k\)</span> 下 <spanclass="math inline">\(S\)</span> 只有 <spanclass="math inline">\(k\)</span> 种取值，所以我们可以枚举 <spanclass="math inline">\(S\)</span>。</p><p>对于一个固定的 <spanclass="math inline">\(S\)</span>，满足条件的序列数量可以用动态规划求解。</p><p>令 <span class="math inline">\(dp_{i,j}\)</span> 表示已经填了前 <spanclass="math inline">\(i\)</span> 个数，这 <spanclass="math inline">\(i\)</span> 个数和为 <spanclass="math inline">\(j\)</span> 的方案数。</p><ul><li><p>初态：<span class="math inline">\(dp_{0,0}=1\)</span>；</p></li><li><p>转移：<span class="math inline">\(\forall x\in [0,k),\forallj\in[0,k),2x\not\equiv S\pmod {k}\)</span>，<spanclass="math inline">\(dp_{i,(j+x)\bmodk}=dp_{i,(j+x)\bmod{k}}+dp_{i-1,j}\)</span>；</p></li><li><p>答案：<span class="math inline">\(dp_{n,S}\)</span>。</p></li></ul><p>时间复杂度 <span class="math inline">\(O(nk^3)\)</span>，可以通过E1。</p><p>这个转移看起来就很矩阵，于是令矩阵 <spanclass="math inline">\(A_{i,(i+j)\bmod k}=[2j\not\equivS\pmod{k}]\)</span>，则： <span class="math display">\[[dp_{i,0},dp_{i,1},\cdots,dp_{i,k-1}]\times A=[dp_{i+1,0},dp_{i+1,1},\cdots,dp_{i+1,k-1}]\]</span></p><ul><li>初态：<spanclass="math inline">\(dp_0=[1,0,0,\cdots,0]\)</span>；</li><li>答案：<span class="math inline">\(dp_{0}\times A^{n}\)</span> 的第<span class="math inline">\(S\)</span> 项。</li></ul><p>矩阵快速幂是 <span class="math inline">\(O(k^3\logn)\)</span>，加上枚举 <span class="math inline">\(S\)</span>，就是 <spanclass="math inline">\(O(k^4\log n)\)</span> ，并不能通过 E2。<ahref="https://codeforces.com/contest/1808/submission/311376877">Code</a></p><p>但注意到 <span class="math inline">\(A\)</span>是一个循环矩阵（每一行都是上一行的循环右移），这意味着我们可以把 <spanclass="math inline">\(dp_{i,0}\sim dp_{i,k-1}\)</span>看成多项式的系数，用循环卷积去优化它。</p><p>具体地，定义多项式 <span class="math inline">\(f_i(x) = dp_{i,0}\cdotx^0+dp_{i,1}\cdot x^1+\cdots+dp_{i,k-1}\cdot x^{k-1}\)</span>。</p><p>转移多项式 <span class="math inline">\(G(x)\)</span> 取 <spanclass="math inline">\(A\)</span> 的第一行，也就是 <spanclass="math inline">\([x^i]G(x)=[2i\not\equiv S\pmod{k}]\)</span>。</p><p>答案即 <span class="math inline">\([x^S](f_0\timesG^n(x))\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(k^3\log n)\)</span>，如果会FFT 能做到 <span class="math inline">\(O(k^2\logn)\)</span>。能吗？反正我不会QAQ。</p><h2 id="abc397g.-maximize-distance"><ahref="https://atcoder.jp/contests/abc397/tasks/abc397_g">abc397g.Maximize Distance</a></h2><p><ahref="https://atcoder.jp/contests/abc397/submissions/63932043">Code</a></p><p>二分答案，设二分出的答案是 <spanclass="math inline">\(d\)</span>，那么需要判定让 <spanclass="math inline">\(1\to n\)</span> 的最短路为 <spanclass="math inline">\(d\)</span> 的最小操作次数是否 <spanclass="math inline">\(\le K\)</span>。</p><p>当 <span class="math inline">\(d=1\)</span>时，问题等价于选定一个最小边集，使得任何一条从 <spanclass="math inline">\(1\to n\)</span>的路径都无可避免地经过这个边集中的边。换句话说，边集中的边将原图分割成了两部分，即最小割。</p><p>当 <span class="math inline">\(d&gt;1\)</span>时，我们能通过建模将问题转化为一个分层图的最小割。</p><p><img src="/image/academic/AT1.jpg" /></p><p>上图是 <span class="math inline">\(d=1\)</span>的情况，标注出的数字代表流量。考虑同样的图，但 <spanclass="math inline">\(d=3\)</span>：</p><p><img src="/image/academic/AT3.jpg" /></p><p>这只是一个分层图的框架，当我们需要让 <span class="math inline">\(1\ton\)</span> 的最短路为 <span class="math inline">\(3\)</span>时，会出现一些问题。</p><p><img src="/image/academic/AT6.jpg" /></p><p>左图是我们期望的：分层图的每一层都选定了一些边，且每一层选定的边都组成了原图的一个最小割。把它们割掉，原图不连通，这样一个<span class="math inline">\(d\)</span> 层的分层图的最小割就是让 <spanclass="math inline">\(1\to n\)</span> 的最短路为 <spanclass="math inline">\(d\)</span>的最小操作次数。但能这么做的前提是每一层选定的边集互不相同，右图中我们只选定了三条边就能让图不连通，显然不合法。</p><p><img src="/image/academic/final.jpg" /></p><p>解决方案是对于每一条存在于原图中的边 <spanclass="math inline">\((u,v)\)</span>，<spanclass="math inline">\(\forall i\in[1,d)\)</span>，从第 <spanclass="math inline">\(i\)</span> 层的 <spanclass="math inline">\(u\)</span> 向第 <spanclass="math inline">\(i+1\)</span> 层的 <spanclass="math inline">\(v\)</span>连边。这样选中不同层的同一条边就没有了意义。</p><p>时间复杂度 <spanclass="math inline">\(O(\text{maxflow}(n^2,mn+n^2)\log n)\)</span>。</p><h2 id="cf2035e.-monster"><ahref="https://codeforces.com/contest/2035/problem/E">CF2035E.Monster</a></h2><p>*2300 <ahref="https://codeforces.com/contest/2035/submission/311492543">Code</a></p><p>假设我们总共使用了 <span class="math inline">\(a\)</span> 次操作<span class="math inline">\(1\)</span>，<spanclass="math inline">\(b\)</span> 次操作 <spanclass="math inline">\(2\)</span>。</p><p>贪心地想，最优策略一定是 “提升 <span class="math inline">\(k\)</span>次攻击力，打一次”，“提升 <span class="math inline">\(k\)</span>次攻击力，打一次”，<span class="math inline">\(\ldots\)</span>，如此反复<spanclass="math inline">\(c=\min(\left\lfloor\frac{a}{k}\right\rfloor,b)\)</span>次，再将剩下的 <span class="math inline">\(a\bmod k\)</span>次攻击力提升用完，打 <span class="math inline">\(b-c\)</span>次怪物。</p><p>等差数列求和，造成的总伤害 <spanclass="math inline">\(\text{damage}(a,b)=\frac{c(c+1)}{2}k+a(b-c)\)</span>，总代价<span class="math inline">\(\text{cost}(a,b)=ax+by\)</span>。</p><p>发现当 <span class="math inline">\(a\)</span> 固定时，<spanclass="math inline">\(\text{damage}(a,b)\)</span> 随着 <spanclass="math inline">\(b\)</span> 增加单调不降；当 <spanclass="math inline">\(b\)</span> 固定时，<spanclass="math inline">\(\text{damage}(a,b)\)</span> 随着 <spanclass="math inline">\(a\)</span> 增加单调不降。</p><p>于是可以枚举 <span class="math inline">\(a\)</span>，二分出使得 <spanclass="math inline">\(\text{damage}(a,b)\ge z\)</span> 的最小 <spanclass="math inline">\(b\)</span>；或者枚举 <spanclass="math inline">\(b\)</span>，二分出使得 <spanclass="math inline">\(\text{damage}(a,b)\ge z\)</span> 的最小 <spanclass="math inline">\(a\)</span>。</p><p>但 <span class="math inline">\(a,b\)</span>太大不能枚举，根据你对算法竞赛的了解这时候肯定从哪里推导出一个神秘的不等式然后把<span class="math inline">\(a\)</span> 或 <spanclass="math inline">\(b\)</span>的上界缩小。恭喜你猜对了。（实际上你可以根据时限和数据组数试一个刚好不会超时的上界）</p><p>证明：<span class="math inline">\(\min(a,b)\le\sqrt{2z}\)</span>。</p><ul><li>当 <span class="math inline">\(k=1\)</span>时，攻击间隔最短，最低效。此时 <spanclass="math inline">\(c=\min(\left\lfloor\frac{a}{k}\right\rfloor)=\min(a,b)\)</span>，而当你提升一次攻击力就打一次的时候，最后一次操作不是攻击肯定没有意义，所以<span class="math inline">\(a\le b\)</span>，故 <spanclass="math inline">\(c=a\)</span>。</li><li>此时 <span class="math inline">\(\text{damage}(a,b)\ge\frac{a(a+1)}{2}+a(b-a)=\frac{a(2b-a+1)}{2}\ge\frac{a(2b-b+1)}{2}&gt;\frac{ab}{2}\)</span>。</li><li>当 <span class="math inline">\(\text{damage}(a,b)\)</span> 取到<span class="math inline">\(z\)</span> 时，有 <spanclass="math inline">\(z&gt;\frac{ab}{2}\)</span>，即 <spanclass="math inline">\(ab&lt;2z\)</span>，<spanclass="math inline">\(\min(a,b)\le \sqrt{2z}\)</span>，得证。</li></ul><p>时间复杂度 <span class="math inline">\(O(\sqrt{z}\logz)\)</span>。</p><h2 id="cf2085c.-serval-and-the-formula"><ahref="https://codeforces.com/contest/2085/problem/C">CF2085C. Serval andThe Formula</a></h2><p>*1600 <ahref="https://codeforces.com/contest/2085/submission/312151000">Code</a></p><p><span class="math inline">\((x + k)+(y+k)=(x+k)\oplus(y+k)\)</span>等价于 <span class="math inline">\((x+k)\&amp; (y+k)=0\)</span>。</p><p>注意到 <span class="math inline">\(2^p\)</span> 和任何 <spanclass="math inline">\(&lt;2^p\)</span> 的数按位与的结果都是 <spanclass="math inline">\(0\)</span>。</p><p>故考虑把 <span class="math inline">\(x+k\)</span> 和 <spanclass="math inline">\(y+k\)</span> 中较大的那个构造成 <spanclass="math inline">\(2^p\)</span> 的形式。</p><p>若 <span class="math inline">\(x=y\)</span>，无解；否则不妨取 <spanclass="math inline">\(p=59\)</span>，答案是 <spanclass="math inline">\(2^{59}-\max(x,y)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><h2 id="cf2085d.-serval-and-kaitenzushi-buffet"><ahref="https://codeforces.com/contest/2085/problem/D">CF2085D. Serval andKaitenzushi Buffet</a></h2><p>*2000 <ahref="https://codeforces.com/contest/2085/submission/312157113">Code</a></p><p>你选的第 <span class="math inline">\(i\)</span> 个数的下标 <spanclass="math inline">\(p_i\)</span> 一定满足 <spanclass="math inline">\(p_i\le n-i(k+1)+1\)</span>。</p><p>按顺序遍历，每到一个这样的节点就从前缀里选一个还没被选的最大的数计入答案。</p><p>优先队列或线段树均可，时间复杂度 <span class="math inline">\(O(n\logn)\)</span>。</p><h2 id="cf2085e.-serval-and-modulo"><ahref="https://codeforces.com/contest/2085/problem/E">CF2085E. Serval andModulo</a></h2><p>*2200 <ahref="https://codeforces.com/contest/2085/submission/312161892">Code</a></p><p>最为关键的观察：<span class="math inline">\(\sum a-\sum b\)</span> 是<span class="math inline">\(k\)</span> 的倍数。（因为 <spanclass="math inline">\(\forall i\in[1,n]\)</span>， <spanclass="math inline">\(b_i\)</span> 都由 <spanclass="math inline">\(a_i\)</span> 减去若干个 <spanclass="math inline">\(k\)</span> 得到）</p><p>枚举 <span class="math inline">\(\sum a-\sum b\)</span>的所有因数暴力 check，复杂度是可以接受的。</p><p>时间复杂度 <span class="math inline">\(O(n\cdot \sigma(\suma_i)+\sqrt{\sum a_i})\)</span>。</p><h2 id="cf2090d.-simple-permutation"><ahref="https://codeforces.com/contest/2090/problem/D">CF2090D. SimplePermutation</a></h2><p>*1700 <ahref="https://codeforces.com/contest/2090/submission/312039158">Code</a></p><p><span class="math inline">\(1\sim n\)</span> 内的素数都没有 <spanclass="math inline">\(\left\lfloor\frac{n}{3}\right\rfloor-1\)</span>这么多，所以一个素数肯定被用了不只一次。</p><p>考虑形如 <spanclass="math inline">\(p,p-1,p+1,p-2,p+2,\cdots\)</span>的结构，此时前缀和出现了 <spanclass="math inline">\(p,3p,5p,\cdots\)</span>，它们除以 <spanclass="math inline">\(i\)</span> 恰好都是 <spanclass="math inline">\(p\)</span>。</p><p>为了让这个结构尽可能长，取 <span class="math inline">\(p\)</span>为最靠近 <span class="math inline">\(\frac{n}{2}\)</span>的素数即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1654e.-arithmetic-operations"><ahref="https://codeforces.com/contest/1654/problem/E">CF1654E. ArithmeticOperations</a></h2><p>*2300 <ahref="https://codeforces.com/contest/1654/submission/312269153">Code</a></p><p>考虑求出最多不需要修改的位置个数 <spanclass="math inline">\(cnt\)</span>，答案就是 <spanclass="math inline">\(n-cnt\)</span>。</p><p>设 <span class="math inline">\(\forall i\in [1,n]\)</span>，<spanclass="math inline">\(b_i=a_i-i\cdot d\)</span>。当公差 <spanclass="math inline">\(d\)</span> 确定时，<spanclass="math inline">\(\{b\}\)</span> 中众数的出现次数就是对应的 <spanclass="math inline">\(cnt\)</span>。</p><p>阈值分治，设 <span class="math inline">\(B\)</span> 为阈值。当 <spanclass="math inline">\(-B \le d \le   B\)</span> 时，直接枚举 <spanclass="math inline">\(d\)</span>，扫一遍求众数，这部分是 <spanclass="math inline">\(O(nB)\)</span>。</p><p>当 <span class="math inline">\(d&lt; -B\)</span> 或 <spanclass="math inline">\(d&gt;B\)</span> 时，若存在两个位置 <spanclass="math inline">\(i,j\)</span> 不会被修改，那么 <spanclass="math inline">\(|i-j|\le \frac{W}{B}\)</span>。</p><p>枚举左端点 <span class="math inline">\(i\)</span>，右端点扫描 <spanclass="math inline">\([i+1,i+\frac{W}{B}]\)</span>，若 <spanclass="math inline">\(j-i\mid a_j-a_i\)</span>，那么 <spanclass="math inline">\(\dfrac{a_j-a_i}{j-i}\)</span>就是一个可能的公差。</p><p>把所有可能的公差都 <span class="math inline">\(O(n)\)</span> check一遍，是不能够接受的。</p><p>合理的做法是用一个桶对当前左端点 <spanclass="math inline">\(i\)</span> 统计公差 <spanclass="math inline">\(\dfrac{a_j-a_i}{j-i}\)</span>的众数的出现次数，设为 <span class="math inline">\(tot\)</span>，那么<span class="math inline">\(cnt=tot+1\)</span>。</p><p>时间复杂度 <spanclass="math inline">\(O(n(B+\frac{W}{B}))\)</span>，显然 <spanclass="math inline">\(B\)</span> 取 <spanclass="math inline">\(\sqrt{W}\)</span> 最优。</p><h2 id="cf1809f.-traveling-in-berland"><ahref="https://codeforces.com/contest/1809/problem/F">CF1809F. Travelingin Berland</a></h2><p>*2500 <ahref="https://codeforces.com/contest/1809/submission/312731463">Code</a></p><p><span class="math inline">\(b_i=1\)</span>的点是特殊的，因为总是可以假定我们在到达一个 <spanclass="math inline">\(b_i=1\)</span> 的点时油量恰好为 <spanclass="math inline">\(0\)</span>。（否则不如把剩余的油换到这个加油站来加）</p><p>定义 <span class="math inline">\(c(i,j)\)</span> 代表从点 <spanclass="math inline">\(i\)</span> 行驶到点 <spanclass="math inline">\(j\)</span> 的最小代价，满足 <spanclass="math inline">\(b_i=1/2\)</span> 但 <spanclass="math inline">\(b_j=1\)</span>，且 <spanclass="math inline">\(b_{i+1}\sim b_{j-1}=2\)</span>。（换句话说 <spanclass="math inline">\(b_j\)</span> 是 <span class="math inline">\(i\toj\)</span> 方向上最近的油价为 <span class="math inline">\(1\)</span>的点）</p><p>令 <span class="math inline">\(d=dis(i,j)\)</span>，则： <spanclass="math display">\[c(i,j)=\begin{cases}2d&amp;,b_i=2\\d&amp;,b_i=1\cap d\le k\\2d-k&amp;,b_i=1\cap d&gt;k\end{cases}\]</span> 这意味着从一个 <span class="math inline">\(b_i=1/2\)</span>的点到下一个 <span class="math inline">\(b_i=1\)</span>的点的代价是可以快速计算的。</p><p>破环成链。令 <span class="math inline">\(\text{nxt}[i][j]\)</span>代表点 <span class="math inline">\(i\)</span> 的下 <spanclass="math inline">\(2^j\)</span> 个油价为 <spanclass="math inline">\(1\)</span> 点的编号，<spanclass="math inline">\(f[i][j]\)</span> 代表点 <spanclass="math inline">\(i\)</span> 到下 <spanclass="math inline">\(2^j\)</span> 个油价为 <spanclass="math inline">\(1\)</span> 的点的代价，倍增。</p><p>最后还要加上 “终点背后最近的 <spanclass="math inline">\(b_i=1\)</span> 的点到终点的距离”。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1700c.-helping-the-nature"><ahref="https://codeforces.com/contest/1700/problem/C">CF1700C. Helpingthe Nature</a></h2><p>*1700 <ahref="https://codeforces.com/contest/1700/submission/312820855">Code</a></p><p>设差分数组 <spanclass="math inline">\(b_i=a_i-a_{i-1}\)</span>。三种操作分别对应：</p><ol type="1"><li><span class="math inline">\(b_1\leftarrow b_1-1\)</span> ，<spanclass="math inline">\(b_{i+1}\leftarrow b_{i+1}+1\)</span> 。</li><li><span class="math inline">\(b_{i}\leftarrow b_i-1\)</span>。</li><li><span class="math inline">\(b_1\leftarrow b_1+1\)</span>。</li></ol><p>题目转化为求最小的操作次数使得 <span class="math inline">\(\foralli\in [1,n]\)</span>，<span class="math inline">\(b_i=0\)</span>。</p><p>先考虑将 <span class="math inline">\(b_2\sim b_n\)</span> 变成 <spanclass="math inline">\(0\)</span>。涉及到 <spanclass="math inline">\(b_i,i\in [2,n]\)</span>的操作只有前两条，操作一能让一个 <spanclass="math inline">\(b_i\)</span> 加一，操作二能让一个 <spanclass="math inline">\(b_i\)</span> 减一。于是这部分的代价是 <spanclass="math inline">\(\sum\limits_{i=2}^{n}b_i\)</span>。</p><p>再考虑将 <span class="math inline">\(b_1\)</span> 变成 <spanclass="math inline">\(0\)</span>。注意到操作二 <spanclass="math inline">\(i\)</span> 取 <spanclass="math inline">\(1\)</span> 时就是 “<spanclass="math inline">\(b_1\leftarrowb_1-1\)</span>”，配合操作三，这部分的代价就是 <spanclass="math inline">\(|b_1|\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1981c.-turtle-and-an-incomplete-sequence"><ahref="https://codeforces.com/contest/1981/problem/C">CF1981C. Turtle andan Incomplete Sequence</a></h2><p>*1800 <ahref="https://codeforces.com/contest/1981/submission/313255211">Code</a></p><p>特判：初态不满足要求或全是 <spanclass="math inline">\(-1\)</span>。</p><p>设左数/右数第一个不为 <span class="math inline">\(-1\)</span>的位置分别为 <span class="math inline">\(i,j\)</span>，则 <spanclass="math inline">\(a_1\sim a_i\)</span> 和 <spanclass="math inline">\(a_j\sim a_n\)</span> 是好填的，反复 <spanclass="math inline">\(\times 2,\div 2\)</span> 即可。</p><p>接下来问题转化为：给定长为 <span class="math inline">\(m\)</span>的数组 <span class="math inline">\(\{b\}\)</span>，其中 <spanclass="math inline">\(b_1 \neq -1\)</span>，<spanclass="math inline">\(b_m\neq -1\)</span>，<spanclass="math inline">\(\forall i\in(1,m)\)</span>，<spanclass="math inline">\(b_i=-1\)</span>，求一个合法的填数。</p><p>不难发现固定了 <span class="math inline">\(b_i\)</span>，那么 <spanclass="math inline">\(b_{i+1}\)</span> 只有 <spanclass="math inline">\(\div 2\)</span> 下取整，<spanclass="math inline">\(\times2\)</span> 和 <spanclass="math inline">\(\times 2+1\)</span>三种选择，这相当于在标号满二叉树上向父亲/左儿子/右儿子走一步。于是问题变成了在满二叉树上找一条从<span class="math inline">\(b_1\)</span> 到 <spanclass="math inline">\(b_m\)</span> 且长 <spanclass="math inline">\(m-1\)</span> 的路径。</p><p>求出 <span class="math inline">\(b_1\)</span> 和 <spanclass="math inline">\(b_m\)</span> 在满二叉树上的 LCA，计算出 <spanclass="math inline">\(b_1,b_m\)</span> 之间的简单路径长度 <spanclass="math inline">\(len\)</span>（这里 <spanclass="math inline">\(len\)</span> 是路径上除了 <spanclass="math inline">\(b_1,b_m\)</span> 外点的数目）。那么若 <spanclass="math inline">\((m-2)&lt;len\)</span> 或 <spanclass="math inline">\(m-2 \not\equiv len\pmod{2}\)</span>，就无解。</p><p>否则构造方式就是从两边分别跳父亲，中间的一段反复 <spanclass="math inline">\(\times 2,\div 2\)</span> 补齐。</p><p>求 LCA 可以暴跳，时间复杂度 <span class="math inline">\(O(n\logw)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Atcoder </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】2025 UESTC 寒假集训</title>
      <link href="/posts/1e7fc2bd.html"/>
      <url>/posts/1e7fc2bd.html</url>
      
        <content type="html"><![CDATA[<p>奇怪，怎么来训的人这么少。</p><p>这期间晚上打的 CF 包含在这里面了 <spanclass="math inline">\(\to\)</span> <ahref="https://kisuraop.github.io/posts/abc8fb81.html">Link</a>。虽然大概率还没来得及补。</p><p>训了一个寒假还是希望自己能有一点长进的，虽然现在还看不到…甚至写下这段话的时候CF 还掉了大分。</p><h2 id="day-1">【2.15】Day 1</h2><p><a href="https://vjudge.net/contest/693557">Virtual JudgeLink</a></p><p>尽力了，E、F 我评估了一下已经远超我目前的 dp水平。那就没题可补了。</p><p>菜猫你怎么这么坏。</p><h2 id="day-2">【2.16】Day 2</h2><p><a href="https://vjudge.net/contest/693898">Virtual JudgeLink</a></p><p>dp 还在追着我跑QAQ。</p><div class="note note-info">            <p><ahref="https://atcoder.jp/contests/arc160/tasks/arc160_c?lang=en">E.Power Up</a></p><p>题意：给定 <span class="math inline">\(n\)</span>个元素的可重集，你可以选择出现次数 <span class="math inline">\(\ge2\)</span> 的 <span class="math inline">\(x\)</span>，删除两个 <spanclass="math inline">\(x\)</span> 然后插入一个 <spanclass="math inline">\(x+1\)</span>。你可以执行任意多次，问能得到多少种不同的集合。对998244353 取模。</p><p><span class="math inline">\(1 \le n,a_i \le 2\cdot10^5\)</span>。</p>          </div><div class="note note-success">            <p>考虑从小到大合并，</p><p>设 <span class="math inline">\(dp[i][j]\)</span> 表示已经将 <spanclass="math inline">\(&lt; i\)</span> 的数合并，合并后有 <spanclass="math inline">\(j\)</span> 个 <spanclass="math inline">\(i\)</span> 的方案数。</p><p>设 <span class="math inline">\(cnt[i]\)</span> 表示集合中原始 <spanclass="math inline">\(i\)</span> 的个数，则有转移： <spanclass="math display">\[dp[i][j +cnt[i]]=\sum_{k=j\times2}^{\inf}dp[i-1][k]\]</span> 对于相同的 <spanclass="math inline">\(j\)</span>，可以用一个后缀和 <spanclass="math inline">\(O(1)\)</span> 转移，并用 <code>std::map</code>只保留有用的状态。此时状态数就是枚举的 <spanclass="math inline">\(j\)</span>的总和，由于每次合并都能将出现次数减半，可以预见 <spanclass="math inline">\(j\)</span>的总和不会很大。实际能证明状态数接近线性。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> W = <span class="hljs-number">2e5</span> + <span class="hljs-number">100</span>;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(W + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];cnt[a[i]]++;&#125;map&lt;<span class="hljs-type">int</span>, vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; dp;dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= W; i++) &#123;<span class="hljs-type">int</span> num = (*dp[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">rbegin</span>())[<span class="hljs-number">0</span>];<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(num + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : dp[i - <span class="hljs-number">1</span>]) &#123;f[x] = y;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = num - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;f[j] += f[j + <span class="hljs-number">1</span>];f[j] %= mod;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= num / <span class="hljs-number">2</span>; j++) &#123;dp[i].<span class="hljs-built_in">push_back</span>(&#123;j + cnt[i], f[j * <span class="hljs-number">2</span>]&#125;);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : dp[W]) &#123;ans = (ans + y) % mod;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><ahref="https://atcoder.jp/contests/abc288/tasks/abc288_e?lang=en">F. WishList</a></p><p>题意：有 <span class="math inline">\(N\)</span> 件商品，第 <spanclass="math inline">\(i\)</span> 件价格 <spanclass="math inline">\(A_i\)</span>，你需要其中的 <spanclass="math inline">\(M\)</span> 件，编号分别为 <spanclass="math inline">\(X_1,X_2,\cdots,X_M\)</span>。每次购买某个商品<span class="math inline">\(i\)</span> 时，若其在所有未买商品中编号第<span class="math inline">\(j\)</span> 小，就要付 <spanclass="math inline">\(A_i+C_j\)</span> 的钱。求买到这 <spanclass="math inline">\(M\)</span>件物品最少需要多少钱。（可以买不想要的商品）</p><p><span class="math inline">\(1 \le M \le N\le 5000\)</span>，<spanclass="math inline">\(1 \le A_i,C_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 件商品中买了 <spanclass="math inline">\(j\)</span> 件所需的最少钱数。</p><ul><li>若不买第 <span class="math inline">\(i\)</span> 件商品，则 <spanclass="math inline">\(dp[i][j]=dp[i-1][j]\)</span>。</li><li>若买第 <span class="math inline">\(i\)</span> 件商品，考虑到此时第<span class="math inline">\(i\)</span> 件在所有未买商品中的顺序最小是第<span class="math inline">\(i-j+1\)</span> 件，最大是第 <spanclass="math inline">\(i\)</span>件，并且可以通过调整购买顺序使得该商品位次恰好对应 <spanclass="math inline">\(C[i-j+1\sim i]\)</span> 中的最小值时买下。故有<spanclass="math inline">\(dp[i][j]=dp[i-1][j-1]+\min\limits_{k=i-j+1}^{i}C[k]+A[i]\)</span>。</li></ul><p>当然若第 <span class="math inline">\(i\)</span> 件商品在必须要买的<span class="math inline">\(M\)</span> 件之中，就不考虑第一种情况。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SparseTable</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ST;<span class="hljs-built_in">SparseTable</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr) &#123;<span class="hljs-keyword">this</span>-&gt;n = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;ST.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span> ,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(__lg(n) + <span class="hljs-number">1</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ST[i][<span class="hljs-number">0</span>] = arr[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= __lg(n); j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1LL</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++) &#123;ST[i][j] = <span class="hljs-built_in">min</span>(ST[i][j - <span class="hljs-number">1</span>], ST[i + (<span class="hljs-number">1LL</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> len = __lg(r - l + <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ST[l][len], ST[r - (<span class="hljs-number">1LL</span> &lt;&lt; len) + <span class="hljs-number">1</span>][len]);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; c[i];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">need</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;need[x] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">SparseTable <span class="hljs-title">st</span><span class="hljs-params">(c)</span></span>;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, inf))</span></span>;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span>) &#123;dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + st.<span class="hljs-built_in">query</span>(i - j + <span class="hljs-number">1</span>, i) + a[i];&#125;<span class="hljs-keyword">if</span> (need[i] == <span class="hljs-number">0</span>) &#123;dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j]);&#125;&#125;&#125;<span class="hljs-type">int</span> ans = *<span class="hljs-built_in">min_element</span>(dp[n].<span class="hljs-built_in">begin</span>(), dp[n].<span class="hljs-built_in">end</span>());cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://atcoder.jp/contests/abc288/tasks/abc288_f">G.Integer Division</a></p><p>题意：给定一个 <span class="math inline">\(N\)</span> 位数 <spanclass="math inline">\(X\)</span>，可以把 <spanclass="math inline">\(X\)</span>分成若干段（或不分割），得分为将每一段数值的乘积。求所有分割方法的得分之和，对998244353 取模。</p><p><span class="math inline">\(2 \le N \le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>令 <span class="math inline">\(dp[i]\)</span> 表示只考虑前 <spanclass="math inline">\(i\)</span> 位时答案，<spanclass="math inline">\(s(l, r)\)</span> 表示区间 <spanclass="math inline">\([l, r]\)</span> 构成的十进制整数数值，则： <spanclass="math display">\[\begin{align}dp[i] &amp;= \sum_{j=0}^{i-1}dp[j]\cdot s(j+1,i)\\&amp;=\sum_{j=0}^{i-1}dp[j]\cdot(10\cdot s(j+1,i-1)+X[i])\\&amp;=10 \sum_{j=0}^{i-2}dp[j]\cdots(j+1,i-1)+\sum_{j=0}^{i-1}dp[j]\cdot X[i]\\&amp;=10\cdot dp[i-1]+\sum_{j=0}^{i-1}dp[j]\cdot X[i]\end{align}\]</span> 中间求和上标替换成 <span class="math inline">\(i-2\)</span>是因为 <span class="math inline">\(s(i,i-1)\)</span> 没有意义。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;string s;cin &gt;&gt; s;s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;dp[<span class="hljs-number">1</span>] = s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-type">int</span> sum = dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;dp[i] = (<span class="hljs-number">10</span> * dp[i - <span class="hljs-number">1</span>] + sum * (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)) % mod;sum = (sum + dp[i]) % mod;&#125;cout &lt;&lt; dp[n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><ahref="https://atcoder.jp/contests/arc160/tasks/arc160_d?lang=en">H.Mahjong</a></p><p>题意：称一个序列 <span class="math inline">\(\{b\}\)</span>是好的当且仅当 <span class="math inline">\(\sum b_i=m\)</span>且可以通过任意次以下两种操作使得 <spanclass="math inline">\(\{b\}\)</span> 全为 <spanclass="math inline">\(0\)</span>。</p><ul><li>选一个元素减 <span class="math inline">\(k\)</span>。</li><li>选一个长为 <span class="math inline">\(k\)</span> 的连续段每个元素减<span class="math inline">\(1\)</span>。</li></ul><p>问有多少个长为 <span class="math inline">\(n\)</span> 的非负整数序列<span class="math inline">\(\{a\}\)</span> 是好的，对 998244353取模。</p><p><span class="math inline">\(1 \le k\le n\le 2000\)</span>，<spanclass="math inline">\(1\le m\le 10^{18}\)</span>。</p>          </div><div class="note note-success">            <p>计数 <span class="math inline">\(\{a\}\)</span> 即考虑初始一个全为<span class="math inline">\(0\)</span>的序列，通过那两种操作能变成哪些。</p><p>首先两种操作每次对总和的贡献都是 <spanclass="math inline">\(k\)</span>，若 <span class="math inline">\(k\nmidm\)</span>，一定无解。否则两种操作的次数加起来一定是 <spanclass="math inline">\(\frac{m}{k}\)</span>。</p><p>注意到选同一个长为 <span class="math inline">\(k\)</span>的段进行操作 <span class="math inline">\(2\)</span>，反复进行 <spanclass="math inline">\(k\)</span> 次，等同于对每个位置都进行一次操作<spanclass="math inline">\(1\)</span>。为了计数不重复，钦定对于同一个段，操作<span class="math inline">\(2\)</span> 最多进行 <spanclass="math inline">\(k-1\)</span> 次。</p><p>用一个长为 <span class="math inline">\(2n-k+1\)</span> 的序列 <spanclass="math inline">\(\{c\}\)</span> 来表示一种操作序列：</p><ul><li><span class="math inline">\(c_1\sim c_{n-k+1}\)</span> 这 <spanclass="math inline">\(n-k+1\)</span> 个数代表了那 <spanclass="math inline">\(n-k+1\)</span> 个长为 <spanclass="math inline">\(k\)</span> 的连续段分别进行了多少次操作 <spanclass="math inline">\(2\)</span>。</li><li><span class="math inline">\(c_{n-k+2}\sim c_{2n-k+1}\)</span> 这<span class="math inline">\(n\)</span>个数代表了每个位置分别进行了多少次操作 <spanclass="math inline">\(1\)</span>。</li></ul><p>此时，原问题等价为有多少个长为 <spanclass="math inline">\(2n-k+1\)</span> 的非负整数序列 <spanclass="math inline">\(\{c\}\)</span> 满足：</p><ul><li><span class="math inline">\(\forall i\in [1,n-k+1]\)</span>，<spanclass="math inline">\(c_i&lt;k\)</span>。</li><li><spanclass="math inline">\(\sum\limits_{i=1}^{2n-k+1}c_i=\dfrac{m}{k}\)</span>。</li></ul><p>运用容斥和插板法，答案是： <span class="math display">\[\sum_{t=0}^{n-k+1}(-1)^{t}\binom{n-k+1}{t}\binom{\frac{m}{k}-tk+2n-k}{2n-k}\]</span> 文末有详细的推导。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<span class="hljs-keyword">if</span> (m % k) &#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;mint s = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt;= n - k + <span class="hljs-number">1</span>; t++) &#123;s += (t &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * <span class="hljs-built_in">C</span>(n - k + <span class="hljs-number">1</span>, t) * <span class="hljs-built_in">bfC</span>(m / k - t * k + <span class="hljs-number">2</span> * n - k, <span class="hljs-number">2</span> * n - k);&#125;cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;</code></pre></div>    </div></div><div class="note note-primary">            <p>给定 <span class="math inline">\(n,m,k,s\)</span>，有多少个长为 <spanclass="math inline">\(n\)</span> 的数列 <spanclass="math inline">\(\{a\}\)</span> 满足以下要求？</p><ul><li><span class="math inline">\(\forall i\in [1,n]\)</span>，<spanclass="math inline">\(a_i \ge 0\)</span>。</li><li><span class="math inline">\(\forall i\in[1,m]\)</span>，<spanclass="math inline">\(a_i \le k\)</span>。</li><li><span class="math inline">\(\sum\limits_{i=1}^{n}a_i=s\)</span>。</li></ul><p>若不考虑条件 <spanclass="math inline">\(2\)</span>，解的数目可以通过经典的隔板法得到：<span class="math display">\[\binom{s+n-1}{n-1}\]</span> 即将总和为 <span class="math inline">\(s\)</span> 看成 <spanclass="math inline">\(s\)</span> 个 <spanclass="math inline">\(1\)</span>，在这 <spanclass="math inline">\(s\)</span> 个 <spanclass="math inline">\(1\)</span> 中间插 <spanclass="math inline">\(n-1\)</span> 个板，分成的 <spanclass="math inline">\(n\)</span>个部分每个部分的和对应一个非负整数。</p><p>考虑条件 <span class="math inline">\(2\)</span>，对每个 <spanclass="math inline">\(i\in[1,m]\)</span> 的 <spanclass="math inline">\(a_i\)</span>，定义事件 <spanclass="math inline">\(P_i\)</span>：“<spanclass="math inline">\(a_i&gt;k\)</span>”。</p><p>那么，根据容斥原理： <span class="math display">\[\begin{align}\textbf{不违反任何 } P_i \textbf{ 的解数}&amp;= \textbf{总情况数}\\&amp;-\sum \textbf{违反至少一个 } P_i \textbf{ 的情况数} \\&amp;+\sum \textbf{违反至少两个 } P_i \textbf{ 的情况数} \\&amp;- \cdots\end{align}\]</span> 我们枚举 <spanclass="math inline">\(t\)</span>，代表违反的约束的个数，那么答案是：<span class="math display">\[\sum_{t=0}^{m}(-1)^{t}\binom{m}{t}\cdot[\textbf{违反了至少 }t\textbf{ 个}P_i \textbf{ 的情况数}]\]</span> 其中 <span class="math inline">\(\binom{m}{t}\)</span>代表从前 <span class="math inline">\(m\)</span> 个位置中选 <spanclass="math inline">\(t\)</span> 个位置，钦定这 <spanclass="math inline">\(t\)</span> 个位置上的数<strong>一定</strong> <spanclass="math inline">\(&gt;k\)</span>。</p><p>也就是说，这 <span class="math inline">\(t\)</span>个位置上的数的合法取值变成了 <spanclass="math inline">\([k+1,*]\)</span>，而其它位置上的数的合法取值为<span class="math inline">\([0,*]\)</span>，这等价于将总和 <spanclass="math inline">\(s\)</span> 替换成 <spanclass="math inline">\(s&#39;=s-t(k+1)\)</span>。</p><p>于是，问题转化为有多少个长为 <span class="math inline">\(n\)</span>的非负整数序列和为 <spanclass="math inline">\(s-t(k+1)\)</span>，根据前文提到的隔板法，答案是：<span class="math display">\[\binom{s-t(k+1)+n-1}{n-1}\]</span> 代回容斥后的式子，即得： <span class="math display">\[ans=\sum_{t=0}^{m}(-1)^{t}\binom{m}{t}\binom{s-t(k+1)+n-1}{n-1}\]</span></p>          </div><hr /><div class="note note-info">            <p><ahref="https://atcoder.jp/contests/arc160/tasks/arc160_e?lang=en">J. MakeBiconnected</a></p><p>题意：给定一棵 <span class="math inline">\(n\)</span>个点的树，点有点权 <spanclass="math inline">\(w_i\)</span>，且每个点度数至多为 <spanclass="math inline">\(3\)</span>。你可以在树上加边，加一条连接 <spanclass="math inline">\(i,j\)</span> 的边耗费 <spanclass="math inline">\(w_i+w_j\)</span>。求将这棵树变成点双连通图的最小花费。</p><p><span class="math inline">\(3 \le n \le 2\cdot 10^5\)</span>，<spanclass="math inline">\(1 \le w_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>首先优先连叶子肯定不劣。假设我们给这个树选定了一个根，两个叶子能连起来当且仅当它们在这个根的不同的子树中。令这棵树有<span class="math inline">\(k\)</span> 个叶子：</p><ul><li>若 <span class="math inline">\(k\)</span>为偶数，可以证明一定存在一个根使得这这 <spanclass="math inline">\(k\)</span> 个叶子能够用 <spanclass="math inline">\(\frac{k}{2}\)</span>条边两两连接。这个根只需满足叶子最多的子树的叶子个数不超过 <spanclass="math inline">\(\frac{k}{2}\)</span>，可以用反证法证明。</li></ul><p>当然我们并不用真的求出这个根：既然一定存在，设这 <spanclass="math inline">\(k\)</span> 个叶子 dfs 序跑出来的编号为 <spanclass="math inline">\(d_1,d_2,\cdots d_k\)</span>，那么 <spanclass="math inline">\(d_i\)</span> 连 <spanclass="math inline">\(d_{(i+\frac{k}{2}) \bmod k\ +1}\)</span>就是最优的。</p><ul><li>若 <span class="math inline">\(k\)</span>为奇数，考虑枚举多出来的那个叶子 <spanclass="math inline">\(x\)</span>，然后剩下的按偶数的方法两两连接。 设<span class="math inline">\(x\)</span> 往上跳到的第一个三度点是 <spanclass="math inline">\(y\)</span>，那么断言 <spanclass="math inline">\(x\)</span> 可以和除了 <spanclass="math inline">\(x\to y\)</span>路径上的点之外的所有点连边，我们只用挑权值最小的连即可。</li></ul><p>tip：dfs 时可以选择一个三度点为根，这样 <spanclass="math inline">\(x\)</span> 向根的方向一定能跳到一个三度点。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; w[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">is3</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> rt = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (adj[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;is3[i] = <span class="hljs-literal">true</span>;rt = i;&#125;&#125;<span class="hljs-keyword">if</span> (rt == <span class="hljs-number">-1</span>) &#123;vector&lt;<span class="hljs-type">int</span>&gt; ex;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (adj[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;ex.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;1\n&quot;</span> &lt;&lt; ex[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ex[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;vector&lt;<span class="hljs-type">int</span>&gt; leaf;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;f[x] = fa;<span class="hljs-keyword">if</span> (adj[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;leaf.<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;; <span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> cnt = leaf.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; cnt / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + cnt / <span class="hljs-number">2</span> &lt; cnt; i++) &#123;cout &lt;&lt; leaf[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; leaf[i + cnt / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-keyword">return</span> ;&#125;set&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; s;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;s.<span class="hljs-built_in">insert</span>(&#123;w[i], i&#125;);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; res;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<span class="hljs-type">int</span> x = leaf[i];vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; tmp;<span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;s.<span class="hljs-built_in">extract</span>(&#123;w[x], x&#125;);tmp.<span class="hljs-built_in">push_back</span>(&#123;w[x], x&#125;);<span class="hljs-keyword">if</span> (is3[x]) &#123;<span class="hljs-keyword">break</span>;&#125;x = f[x];&#125;<span class="hljs-keyword">auto</span> [val, anoid] = *s.<span class="hljs-built_in">begin</span>();res.<span class="hljs-built_in">push_back</span>(&#123;val, anoid, i&#125;);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : tmp) &#123;s.<span class="hljs-built_in">insert</span>(x);&#125;&#125;<span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">auto</span> [_, anoid, mnid] = res[<span class="hljs-number">0</span>];vector&lt;<span class="hljs-type">int</span>&gt; fir, sec;array&lt;<span class="hljs-type">int</span>, 2&gt; spe;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<span class="hljs-keyword">if</span> (i == mnid) &#123;spe = &#123;leaf[i], anoid&#125;;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (fir.<span class="hljs-built_in">size</span>() &lt; cnt / <span class="hljs-number">2</span>) &#123;fir.<span class="hljs-built_in">push_back</span>(leaf[i]);&#125; <span class="hljs-keyword">else</span> &#123;sec.<span class="hljs-built_in">push_back</span>(leaf[i]);&#125;&#125;&#125;cout &lt;&lt; cnt / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fir.<span class="hljs-built_in">size</span>(); i++) &#123;cout &lt;&lt; fir[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; sec[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;cout &lt;&lt; spe[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; spe[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="day-3">【2.17】 Day 3</h2><p><a href="https://vjudge.net/contest/694161">Virtual JudgeLink</a></p><p>红了，D 一直 wa，拍完才发现没想清楚。</p><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1866C">D. CompletelySearching for Inversions</a></p><p>题意：给一个 <span class="math inline">\(n\)</span>个点的有向无环图，边权为 <span class="math inline">\(0/1\)</span>，且从<span class="math inline">\(1\)</span> 可以到达任意点。从 <spanclass="math inline">\(1\)</span> 开始跑一个不带 <code>vis</code> 的dfs，并将沿途边权记录下来，形成一个二进制串。求这个串的逆序对个数，对998244353 取模。</p><p><span class="math inline">\(2 \le n \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>将边权为 <span class="math inline">\(0/1\)</span> 的边称为 <spanclass="math inline">\(0/1\)</span> 边。</p><p>先跑一遍正常的dfs，回溯时统计答案。当我们从终点向前加一个点时，形成的新贡献是从 <spanclass="math inline">\(1\)</span> 开始 dfs 到这个点的路上经过的 <spanclass="math inline">\(1\)</span> 边数量乘上这个点后面 <spanclass="math inline">\(0\)</span> 边的数量。至于这个点后面的 <spanclass="math inline">\(1\)</span> 边对后面的 <spanclass="math inline">\(0\)</span>边造成的贡献，已经包含在后面的答案里了。</p><p>令 <span class="math inline">\(pre1[x]\)</span> 表示从 <spanclass="math inline">\(1\)</span> 开始 dfs 到 <spanclass="math inline">\(x\)</span> 经过的 <spanclass="math inline">\(1\)</span> 边的数量，<spanclass="math inline">\(suf0[x]\)</span> 表示从 <spanclass="math inline">\(x\)</span> 到 dfs 末尾这一段经过的 <spanclass="math inline">\(0\)</span> 边的数量，<spanclass="math inline">\(f[x]\)</span> 表示 <spanclass="math inline">\(x\)</span> 向后形成的闭合子图的答案，则： <spanclass="math display">\[f[x]=\sum_{x\to y} (f[y]+pre1[x]\cdot suf0[y])\]</span> 时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> num;cin &gt;&gt; num;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<span class="hljs-type">int</span> y, w;cin &gt;&gt; y &gt;&gt; w;adj[i].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre1</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">suf0</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span>) &#123;suf0[x]++;f[x] += pre1[x]; f[x] %= mod;&#125; <span class="hljs-keyword">else</span> &#123;pre1[x]++;&#125;<span class="hljs-keyword">if</span> (!vis[y]) &#123;<span class="hljs-built_in">self</span>(self, y);&#125;f[x] += f[y];f[x] %= mod;f[x] += pre1[x] * suf0[y] % mod;f[x] %= mod;pre1[x] += pre1[y];pre1[x] %= mod;suf0[x] += suf0[y];suf0[x] %= mod;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);cout &lt;&lt; f[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1762D">G. GCDQueries</a></p><p>题意：交互题，给定一个 <span class="math inline">\(0\sim n-1\)</span>的排列，你需要通过不超过 <span class="math inline">\(2n\)</span>次询问找到两个下标 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 满足 <spanclass="math inline">\(p_x=0\)</span> 或 <spanclass="math inline">\(p_y=0\)</span>。每次询问你可以问两个下标 <spanclass="math inline">\(i,j\)</span>，交互器返回 <spanclass="math inline">\(\gcd(p_i,p_j)\)</span>。</p><p><span class="math inline">\(2 \le n \le 2 \cdot 10^4\)</span>。</p>          </div><div class="note note-success">            <p>题目的要求暗示了 <span class="math inline">\(0\)</span>的位置是不能确定的，只能是排除到只剩两个位置。考虑三个不同的位置 <spanclass="math inline">\(i,j,k\)</span>，令 <spanclass="math inline">\(A=\text{query}(i,k)=\gcd(i,k)\)</span>，<spanclass="math inline">\(B=\text{query(j,k)}=\gcd(j,k)\)</span>。<spanclass="math inline">\(A,B\)</span> 间只能是以下三种关系：</p><ul><li><span class="math inline">\(A=B\)</span>。此时能断言 <spanclass="math inline">\(p_k\neq0\)</span>，因为 <spanclass="math inline">\(p_i\neq p_j\)</span>。</li><li><span class="math inline">\(A&lt;B\)</span>。此时能断言 <spanclass="math inline">\(p_i\neq 0\)</span>，因为 <spanclass="math inline">\(\gcd(p_k,0)=p_k&gt;\gcd(p_k,x),x&gt;0\)</span>。</li><li><span class="math inline">\(A&gt;B\)</span>。此时能断言 <spanclass="math inline">\(p_j\neq 0\)</span>，原因同上。</li></ul><p>如此一来，我们每次选三个还不确定是不是 <spanclass="math inline">\(0\)</span> 的下标问两次就能排除一个，排除 <spanclass="math inline">\(n-2\)</span> 次即可。总共用了 <spanclass="math inline">\(2(n-2)=2n-4\)</span> 次询问。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;<span class="hljs-type">int</span> x;cin &gt;&gt; x;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;set&lt;<span class="hljs-type">int</span>&gt; s;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;s.<span class="hljs-built_in">insert</span>(i);&#125;<span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<span class="hljs-type">int</span> x = *s.<span class="hljs-built_in">begin</span>();s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<span class="hljs-type">int</span> y = *s.<span class="hljs-built_in">begin</span>();s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<span class="hljs-type">int</span> z = *s.<span class="hljs-built_in">begin</span>();s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<span class="hljs-type">int</span> res1 = <span class="hljs-built_in">query</span>(x, z);<span class="hljs-type">int</span> res2 = <span class="hljs-built_in">query</span>(y, z);<span class="hljs-keyword">if</span> (res1 == res2) &#123;s.<span class="hljs-built_in">insert</span>(x);s.<span class="hljs-built_in">insert</span>(y);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res1 &lt; res2) &#123;s.<span class="hljs-built_in">insert</span>(y);s.<span class="hljs-built_in">insert</span>(z);&#125; <span class="hljs-keyword">else</span> &#123;s.<span class="hljs-built_in">insert</span>(x);s.<span class="hljs-built_in">insert</span>(z);&#125;&#125;<span class="hljs-type">int</span> x = *s.<span class="hljs-built_in">begin</span>();s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<span class="hljs-type">int</span> y = *s.<span class="hljs-built_in">begin</span>();cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;<span class="hljs-type">int</span> z;cin &gt;&gt; z;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1534E">H. LostArray</a></p><p>题意：交互题，给定 <spanclass="math inline">\(n,k\)</span>，有一个长为 <spanclass="math inline">\(n\)</span> 的未知序列 <spanclass="math inline">\(\{a\}\)</span>，你需要通过最少次数的询问找出 <spanclass="math inline">\(\oplus_{i=1}^{n}a_i\)</span>。每次你可以询问一个长为<span class="math inline">\(k\)</span> 的子序列的异或和。</p><p><span class="math inline">\(1\le k\le n\le 500\)</span>，<spanclass="math inline">\(1\le a_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>如果一个下标被选中了两次，那么相当于没问过这个下标。也就是说每个位置都只有被问过和没被问过两种状态。</p><p>令 <span class="math inline">\(f_i\)</span> 表示 “知道了 <spanclass="math inline">\(i\)</span> 个位置的异或和” 这个状态，则连边：</p><ul><li><span class="math inline">\(\forall i\in[0,n-k]\)</span>，<spanclass="math inline">\(f_i\to f_{i+k}\)</span>。</li><li><span class="math inline">\(\forall i\in [1,n]\)</span>，<spanclass="math inline">\(\forall j\in[k-(n-i),\min(i,k)]\)</span>，<spanclass="math inline">\(f_i\to f_{i+k-2j}\)</span>。</li></ul><p>第一种连边好理解：如果还有 <span class="math inline">\(k\)</span>个位置没问，那就问。</p><p>第二种连边枚举了需要把 <span class="math inline">\(j\)</span>个已经问过的下标更新为 “没问过”，不仅失去了 <spanclass="math inline">\(j\)</span> 个已知的点，也只剩 <spanclass="math inline">\(k-j\)</span> 次去问其它未知点，故为 <spanclass="math inline">\(f_{i+k-2j}\)</span>。</p><p>题目要求询问次数最少，跑 <span class="math inline">\(f_0\)</span> 到<span class="math inline">\(f_n\)</span> 的最短路（或bfs）即可。若到达不了 <span class="math inline">\(f_n\)</span> 就是<spanclass="math inline">\(-1\)</span>，否则记下途径的点用于构造方案。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-type">int</span> x;cin &gt;&gt; x;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + k &lt;= n; i++) &#123;adj[i].<span class="hljs-built_in">push_back</span>(i + k);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>, k - (n - i)); j &lt;= <span class="hljs-built_in">min</span>(i, k); j++) &#123;<span class="hljs-type">int</span> x = i + k - <span class="hljs-number">2</span> * j;<span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= n) &#123;adj[i].<span class="hljs-built_in">push_back</span>(x);&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);vis[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span> (x == n) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!vis[y]) &#123;vis[y] = <span class="hljs-number">1</span>;pre[y] = x;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i != <span class="hljs-number">0</span>; i = pre[i]) &#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span>) &#123;cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<span class="hljs-keyword">return</span> ;&#125;path.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : path) &#123;<span class="hljs-type">int</span> back_cover = (cur + k - x) / <span class="hljs-number">2</span>;<span class="hljs-type">int</span> cover = k - back_cover;vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, A = <span class="hljs-number">0</span>, B = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; A &lt; cover) &#123;vis[i] = <span class="hljs-number">1</span>;a.<span class="hljs-built_in">push_back</span>(i);A++;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[i] &amp;&amp; B &lt; back_cover) &#123;vis[i] = <span class="hljs-number">0</span>;a.<span class="hljs-built_in">push_back</span>(i);B++;&#125;&#125;<span class="hljs-built_in">assert</span>(a.<span class="hljs-built_in">size</span>() == k);ans ^= <span class="hljs-built_in">query</span>(a);cur = x;&#125;cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-980F">J. Cactus toTree</a></p><p>题意：给定一个 <span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\(m\)</span> 条边的连通无向图。对每个 <spanclass="math inline">\(i\in[1,n]\)</span>，求若以最佳方式断边使得图变成树，<spanclass="math inline">\(\max\limits_{u\in leaf} dis(i,u)\)</span>最小是多少。</p><p><span class="math inline">\(1 \le n \le 5\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>考虑一个点 <span class="math inline">\(x\)</span>，以 <spanclass="math inline">\(x\)</span> 为根建出 bfs生成树，生成树上的边就是要保留的边。换句话说，题意等同于对每个点 <spanclass="math inline">\(i\)</span>，求 <spanclass="math inline">\(i\)</span> 到其它所有点最短距离的最大值。</p><p>我们任选一个环，钦定他为整个图的 “根”。同样约定 <spanclass="math inline">\(x\)</span> 在 <spanclass="math inline">\(y\)</span> 的子树中当且仅当 <spanclass="math inline">\(y\)</span> 在从根到 <spanclass="math inline">\(x\)</span> 的路径上。</p><p>定义 <spanclass="math inline">\(F[x]=\max\limits_{y}dis(x,y)\)</span>，其中 <spanclass="math inline">\(y\)</span> 在 <spanclass="math inline">\(x\)</span>的子树内。对于根来说，我们从根的每个点出发向子树内 bfs，可以 <spanclass="math inline">\(O(n)\)</span> 得到根上每个点的 <spanclass="math inline">\(F[x]\)</span>。</p><p>令 <span class="math inline">\(Cir[x]\)</span> 代表 <spanclass="math inline">\(x\)</span> 所在的环，特别地，单点看作一个环。定义<span class="math inline">\(G[x]\)</span> 代表从 <spanclass="math inline">\(x\)</span> 出发向 <spanclass="math inline">\(Cir[x]\)</span> 方向延伸出的最长距离，那么： <spanclass="math display">\[G[u]=\max_{v\in Cir[u]}(dis(u,v)+F[v])\]</span>这是一个典型的使用单调队列解决的式子。具体地，拆环成链，单调队列维护最大的<span class="math inline">\(F[i]-i\)</span>，窗口大小不超过 <spanclass="math inline">\(\frac{1}{2}\)</span>环长，顺时针逆时针扫两遍。</p><p>现在，在知道一个环所有 <span class="math inline">\(F[x]\)</span>的情况下，可以线性求出 <spanclass="math inline">\(G[x]\)</span>。而对于每个点 <spanclass="math inline">\(x\)</span>，答案就是 <spanclass="math inline">\(\max(F[x],G[x])\)</span>。于是问题转化为如何把<span class="math inline">\(F\)</span> 从根转移到图上的其它点。</p><p>这依然是典型的换根问题，每次转移时的 <spanclass="math inline">\(\text{UpValue}\)</span>选择非该当前子树的最大深度，并与当前点的 <spanclass="math inline">\(G\)</span> 取 <spanclass="math inline">\(\max\)</span>。</p><p>时间复杂度 <spanclass="math inline">\(O(n)\)</span>。实现时有若干细节等待你的探索（</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_combine</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123;    seed ^= <span class="hljs-built_in">hash</span>&lt;T&gt;()(val) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val)</span> </span>&#123;    <span class="hljs-built_in">hash_combine</span>(seed, val);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;val, <span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;    <span class="hljs-built_in">hash_combine</span>(seed, val);    <span class="hljs-built_in">hash_val</span>(seed, args...);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">hash_val</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;... args)</span> </span>&#123;    <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;    <span class="hljs-built_in">hash_val</span>(seed, args...);    <span class="hljs-keyword">return</span> seed;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">custom_hash</span> &#123;    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;T1, T2&gt; &amp;p)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash_val</span>(p.first, p.second);    &#125;&#125;;unordered_set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, custom_hash&gt; E;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">EBCC</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; dfn, low, stk, c;<span class="hljs-type">int</span> tim, top, cnt;<span class="hljs-built_in">EBCC</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; Adj) : <span class="hljs-built_in">n</span>(Adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>), <span class="hljs-built_in">adj</span>(Adj), <span class="hljs-built_in">dfn</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">low</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">stk</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">c</span>(n + <span class="hljs-number">1</span>) &#123;tim = top = cnt = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> par)</span> </span>&#123;dfn[x] = low[x] = ++tim;stk[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == par) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y, x);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);<span class="hljs-keyword">if</span> (low[y] &gt; dfn[x]) &#123;E.<span class="hljs-built_in">insert</span>(&#123;x, y&#125;);E.<span class="hljs-built_in">insert</span>(&#123;y, x&#125;);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!c[y] &amp;&amp; dfn[y] &lt; dfn[x]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; cnt++;<span class="hljs-keyword">do</span> &#123;now = stk[top--];c[now] = cnt;&#125; <span class="hljs-keyword">while</span> (x != now);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;<span class="hljs-built_in">tarjan</span>(rt, <span class="hljs-number">0</span>);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">EBCC <span class="hljs-title">T</span><span class="hljs-params">(adj)</span></span>;T.<span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>);vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; cirs;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cirID</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; cir;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;cir.<span class="hljs-built_in">push_back</span>(x);vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y] || E.<span class="hljs-built_in">count</span>(&#123;x, y&#125;)) &#123;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-built_in">self</span>(self, y);&#125;&#125;; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;cir.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">dfs</span>(dfs, i);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;cirID[x] = cirs.<span class="hljs-built_in">size</span>();&#125;cirs.<span class="hljs-built_in">push_back</span>(cir);&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">F</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">bfsDep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bfsFa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; bfsOrder;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);vis[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();bfsOrder.<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!vis[y]) &#123;vis[y] = <span class="hljs-literal">true</span>;bfsFa[y] = x;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-built_in">reverse</span>(bfsOrder.<span class="hljs-built_in">begin</span>(), bfsOrder.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : bfsOrder) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (bfsFa[y] == x) &#123;bfsDep[x] = <span class="hljs-built_in">max</span>(bfsDep[x], bfsDep[y] + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (E.<span class="hljs-built_in">count</span>(&#123;x, y&#125;)) &#123;F[x] = <span class="hljs-built_in">max</span>(F[x], bfsDep[y] + <span class="hljs-number">1</span>);&#125;&#125;&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">G</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> scanCircle = [&amp;] (<span class="hljs-type">int</span> id) &#123;vector&lt;<span class="hljs-type">int</span>&gt; cir = cirs[id];vector&lt;<span class="hljs-type">int</span>&gt; f;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;f.<span class="hljs-built_in">push_back</span>(F[x]);&#125;<span class="hljs-type">int</span> len = cir.<span class="hljs-built_in">size</span>();cir.<span class="hljs-built_in">insert</span>(cir.<span class="hljs-built_in">end</span>(), cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());f.<span class="hljs-built_in">insert</span>(f.<span class="hljs-built_in">end</span>(), f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>());deque&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * len; i++) &#123;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() &gt; len / <span class="hljs-number">2</span>) &#123;q.<span class="hljs-built_in">pop_front</span>();&#125;<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;G[cir[i]] = <span class="hljs-built_in">max</span>(G[cir[i]], f[q.<span class="hljs-built_in">front</span>()] + i - q.<span class="hljs-built_in">front</span>());&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; f[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt;= f[i] - i) &#123;q.<span class="hljs-built_in">pop_back</span>();&#125;q.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">reverse</span>(cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>());q.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * len; i++) &#123;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() &gt; len / <span class="hljs-number">2</span>) &#123;q.<span class="hljs-built_in">pop_front</span>();&#125;<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;G[cir[i]] = <span class="hljs-built_in">max</span>(G[cir[i]], f[q.<span class="hljs-built_in">front</span>()] + i - q.<span class="hljs-built_in">front</span>());&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; f[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt;= f[i] - i) &#123;q.<span class="hljs-built_in">pop_back</span>();&#125;q.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> up) -&gt; <span class="hljs-type">void</span> &#123;F[x] = <span class="hljs-built_in">max</span>(F[x], up);<span class="hljs-built_in">scanCircle</span>(cirID[x]);vector&lt;<span class="hljs-type">int</span>&gt; cir = cirs[cirID[x]];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;<span class="hljs-type">int</span> firMx = <span class="hljs-number">0</span>, secMx = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa || E.<span class="hljs-built_in">count</span>(&#123;x, y&#125;) == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (bfsDep[y] + <span class="hljs-number">1</span> &gt; firMx) &#123;secMx = firMx;firMx = bfsDep[y] + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bfsDep[y] + <span class="hljs-number">1</span> &gt; secMx) &#123;secMx = bfsDep[y] + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa || E.<span class="hljs-built_in">count</span>(&#123;x, y&#125;) == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> nup = <span class="hljs-built_in">max</span>(up, G[x]);<span class="hljs-keyword">if</span> (bfsDep[y] + <span class="hljs-number">1</span> == firMx) &#123;nup = <span class="hljs-built_in">max</span>(nup, secMx);&#125; <span class="hljs-keyword">else</span> &#123;nup = <span class="hljs-built_in">max</span>(nup, firMx);&#125;<span class="hljs-built_in">self</span>(self, y, x, nup + <span class="hljs-number">1</span>);&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; <span class="hljs-built_in">max</span>(F[i], G[i]) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="day-4">【2.18】 Day 4</h2><p><a href="https://vjudge.net/contest/694446">Virtual JudgeLink</a></p><p>前面都是一些很无聊的题…</p><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-534F">H. SimplifiedNonogram</a></p><p>题意：完成一个 <span class="math inline">\(5\times 20\)</span>的简易版数织。简易即你只知道每行/列有多少段黑色，而不知道每一段黑色具体长多少。</p>          </div><div class="note note-success">            <p>我们把同一行连续的一段黑色称为一个连通块。</p><p>令 <spanclass="math inline">\(dp[col][lst][p_1][p_2][p_3][p_4][p_5]=0/1\)</span>表示是否能到达 “已经填了 <span class="math inline">\(col\)</span>列，上一列填了 <span class="math inline">\(lst\)</span>，第 <spanclass="math inline">\(i\)</span> 行已经有 <spanclass="math inline">\(p_i\)</span> 个连通块” 这个状态。</p><p>其中 <span class="math inline">\(lst\)</span> 是一个长为 <spanclass="math inline">\(n\)</span> 的二进制串，第 <spanclass="math inline">\(i\)</span> 位为 <spanclass="math inline">\(0/1\)</span> 代表上一列第 <spanclass="math inline">\(i\)</span> 行是否涂黑。</p><p>由每一行连通块个数 <spanclass="math inline">\(p_i&lt;\lceil\frac{m}{2}\rceil\)</span>，此时的状态数有<span class="math inline">\(m\cdot 2^n\cdot(\lceil\frac{m}{2}\rceil)^n=6.4\cdot 10^7\)</span>，开成 bool类型的数组为 <span class="math inline">\(61\)</span>mB，爆不了。</p><p>考虑转移，我们枚举当前列的 <span class="math inline">\(2^n\)</span>种状态，遍历一遍看该状态是否满足纵向限制。若满足，再枚举每一行看是否“当前第 <span class="math inline">\(i\)</span> 行为 <spanclass="math inline">\(1\)</span> 且 <spanclass="math inline">\(lst\)</span> 第 <spanclass="math inline">\(i\)</span> 位为 <spanclass="math inline">\(0\)</span>”，若是，则对应行的连通块个数 <spanclass="math inline">\(+1\)</span>；否则不变。</p><p>于是对于当前列的每一种状态，纵向和横向的限制都能在 <spanclass="math inline">\(O(n)\)</span> 内 check out。</p><p>使用记忆化搜索转移，时间复杂度的上界是状态数乘上 <spanclass="math inline">\(n\)</span>。</p><p>实测仅使用最简单的剪枝就能跑进 150ms。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-type">bool</span> f[<span class="hljs-number">21</span>][<span class="hljs-number">32</span>][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;cin &gt;&gt; b[i];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-keyword">if</span> ((i &gt;&gt; j &amp; <span class="hljs-number">1</span>) &amp;&amp; (j == <span class="hljs-number">0</span> || (i &gt;&gt; (j - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)) &#123;cnt[i]++;&#125;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> lst, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; p) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (p[i] &gt; a[i] || p[i] + (m - col) &lt; a[i]) &#123; <span class="hljs-keyword">return</span> ;&#125;&#125;<span class="hljs-keyword">if</span> (col == m) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cout &lt;&lt; (ans[j] &gt;&gt; i &amp; <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;*&quot;</span> : <span class="hljs-string">&quot;.&quot;</span>); &#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">if</span> (f[col][lst][p[<span class="hljs-number">0</span>]][p[<span class="hljs-number">1</span>]][p[<span class="hljs-number">2</span>]][p[<span class="hljs-number">3</span>]][p[<span class="hljs-number">4</span>]]) &#123;<span class="hljs-keyword">return</span> ;&#125;f[col][lst][p[<span class="hljs-number">0</span>]][p[<span class="hljs-number">1</span>]][p[<span class="hljs-number">2</span>]][p[<span class="hljs-number">3</span>]][p[<span class="hljs-number">4</span>]] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<span class="hljs-keyword">if</span> (cnt[i] != b[col]) &#123;<span class="hljs-keyword">continue</span>;&#125;array&lt;<span class="hljs-type">int</span>, 5&gt; cur = p;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-keyword">if</span> ((i &gt;&gt; j &amp; <span class="hljs-number">1</span>) &amp;&amp; (lst &gt;&gt; j &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;cur[j]++;&#125;&#125;ans[col] = i;<span class="hljs-built_in">self</span>(self, col + <span class="hljs-number">1</span>, i, cur);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-538F">I. A Heap ofHeaps</a></p><p>题意：一棵 <span class="math inline">\(n\)</span>个节点的堆，点有点权，节点编号为 bfs 序。对 <spanclass="math inline">\(k\in[1,n-1]\)</span> 求当这个堆是 <spanclass="math inline">\(k\)</span> 叉堆时有多少个节点的权值比父亲小。</p><p><span class="math inline">\(2 \le n \le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>易知对于 <span class="math inline">\(k\)</span> 叉堆，节点 <spanclass="math inline">\(x\)</span> 的父亲编号为 <spanclass="math inline">\(\left\lfloor\dfrac{x-2}{k}\right\rfloor+1\)</span>。</p><p>可以发现对于许多 <span class="math inline">\(k\)</span>，节点 <spanclass="math inline">\(x\)</span> 的父亲都是相同的。</p><p>用数论分块对每一个节点 <span class="math inline">\(i\)</span>求出满足权值比父亲小的 <span class="math inline">\(k\)</span>的范围，差分一下即可。</p><p>时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>; l &lt;= i - <span class="hljs-number">2</span>; l = r + <span class="hljs-number">1</span>) &#123;r = <span class="hljs-built_in">min</span>(i - <span class="hljs-number">2</span>, (i - <span class="hljs-number">2</span>) / ((i - <span class="hljs-number">2</span>) / l));<span class="hljs-keyword">if</span> (a[i] &lt; a[(i - <span class="hljs-number">2</span>) / l + <span class="hljs-number">1</span>]) &#123;d[l]++;d[r + <span class="hljs-number">1</span>]--;&#125;&#125;<span class="hljs-keyword">if</span> (a[i] &lt; a[<span class="hljs-number">1</span>]) &#123;d[i - <span class="hljs-number">1</span>]++;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;d[i] += d[i - <span class="hljs-number">1</span>];cout &lt;&lt; d[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="day-5">【2.19】 Day 5</h2><p><a href="https://vjudge.net/contest/694757">Virtual JudgeLink</a></p><p>脑子经常不够用，代码经常调不出。</p><p>昨晚打 CF的时候明显脑子转不动啊，有点怀疑是不是最近写题太多了。感觉以后打比赛之前真的要放空一下自己。</p><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1023F">I. Mobile PhoneNetwork</a></p><p>题意：给定 <span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\(m\)</span> 条边的图，边有边权。另给定 <spanclass="math inline">\(k\)</span>条没有权值的边，你需要给每条边赋边权使得将这 <spanclass="math inline">\(k\)</span>条边加进图中后，这个图至少有一个最小生成树完全覆盖这 <spanclass="math inline">\(k\)</span> 条边。输出这 <spanclass="math inline">\(k\)</span> 条边边权和最大是多少。</p><p><span class="math inline">\(1 \le n,k,m\le 5\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>先将给定的 <span class="math inline">\(k\)</span>条边加进生成树里，再从 <span class="math inline">\(m\)</span>条边中选权值最小的几条连成一棵完整的生成树。</p><p>此时，对于一条非树边 <spanclass="math inline">\((x,y,w)\)</span>，相当于一个限制 “生成树上 <spanclass="math inline">\(x\leftrightarrow y\)</span>这条路径上的边的权值不能超过 <spanclass="math inline">\(w\)</span>”。因为超过了就可以把那条边断掉换成这条非树边。</p><p>相当于对于每条非树边，在生成树上将一段路径上的边权取 <spanclass="math inline">\(\min\)</span>。</p><p>按边权从小到大枚举非树边，此时每条树边只用访问一次，用并查集维护即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) &#123;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k, m;cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);map&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;, <span class="hljs-type">int</span>&gt; my;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;my[&#123;x, y&#125;] = my[&#123;y, x&#125;] = <span class="hljs-number">1</span>;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);dsu.<span class="hljs-built_in">merge</span>(x, y);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 4&gt;&gt; E;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;E.<span class="hljs-built_in">push_back</span>(&#123;w, x, y, i&#125;);<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">merge</span>(x, y)) &#123;f[i] = <span class="hljs-literal">true</span>;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, inf)</span>, <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (my.<span class="hljs-built_in">count</span>(&#123;x, fath&#125;) == <span class="hljs-number">0</span>) &#123;val[x] = <span class="hljs-number">0</span>;&#125; dep[x] = dep[fath] + <span class="hljs-number">1</span>;fa[x] = fath;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);dsu = <span class="hljs-built_in">DSU</span>(n);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y, i] : E) &#123;<span class="hljs-keyword">if</span> (f[i]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">while</span> (x != y) &#123;x = dsu.<span class="hljs-built_in">find</span>(x);y = dsu.<span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;val[x] = <span class="hljs-built_in">min</span>(val[x], w);dsu.<span class="hljs-built_in">merge</span>(fa[x], x);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (val[i] == inf) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;ans += val[i];&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="day-6">【2.20】 Day 6</h2><p><a href="https://vjudge.net/contest/695051">Virtual JudgeLink</a></p><p>A 题输出浮点数因为没设置精度一直 wa，lyc指导之后才知道直接输出来会是科学计数法，十分难绷。</p><div class="note note-info">            <p><a href="https://vjudge.net/problem/AtCoder-abc155_f">F - Perils inParallel</a></p><p>题意：有 <span class="math inline">\(n\)</span>个灯，给定每个灯的坐标 <span class="math inline">\(A_i\)</span>和初始状态 <span class="math inline">\(B_i\)</span>（亮或灭）。另有<span class="math inline">\(m\)</span> 个操作，形如 “将坐标在 <spanclass="math inline">\(L_i\)</span> 和 <spanclass="math inline">\(R_i\)</span>之间的灯的状态取反”，问是否能让所有灯全灭。若能，给出操作方案。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<spanclass="math inline">\(1\le m \le 2\cdot10^5\)</span>，<spanclass="math inline">\(1 \le A_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>离散化是必要的，我们按坐标从小到大给灯标号，然后预处理出每种操作对应灯的标号范围。</p><p>取反等价于异或 <spanclass="math inline">\(1\)</span>。设按坐标排序后的状态序列为 <spanclass="math inline">\(\{s\}\)</span>，求出其异或差分数组 <spanclass="math inline">\(\{t\}\)</span>（即 <spanclass="math inline">\(t[i]=s[i]\oplus s_[i-1]\)</span>）。那么操作 <spanclass="math inline">\((L_i,R_i)\)</span> 相当于将 <spanclass="math inline">\(t[L_i]\)</span> 和 <spanclass="math inline">\(t[R_i+1]\)</span> 取反，最终目标也转化为使 <spanclass="math inline">\(\{t\}\)</span> 全为 <spanclass="math inline">\(0\)</span>（<spanclass="math inline">\(t[n+1]\)</span> 除外）。</p><p>对每种操作连边 <span class="math inline">\(L_i \leftrightarrowR_{i}+1\)</span>，那么每次肯定是将一条边的两个端点同时取反。</p><p>对于每一个连通分量：从任意一个点（设为 <spanclass="math inline">\(A\)</span>）开始 dfs，回溯时可以贪心的将当前点与其dfs 树上的儿子进行操作，使得儿子全为 <spanclass="math inline">\(0\)</span>。这么做可以使除了 <spanclass="math inline">\(A\)</span> 之外的所有点为 <spanclass="math inline">\(0\)</span>。</p><p>接着，能够断言：无解当且仅当 <span class="math inline">\(A\)</span>的值为 <span class="math inline">\(1\)</span> 且 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(n+1\)</span> 不在一个连通分量。</p><p>因为若在一个连通分量内，可以直接沿着 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(n+1\)</span> 之间的路径一直操作，将 <spanclass="math inline">\(A\)</span> 的 <spanclass="math inline">\(1\)</span> 转移给 <spanclass="math inline">\(n+1\)</span>。</p><p>方案可以在 dfs 时顺便记录。时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) &#123;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;a[i] = &#123;x, y&#125;;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;b[i] = a[i][<span class="hljs-number">1</span>] ^ a[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];c[i] = a[i][<span class="hljs-number">0</span>];&#125;map&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;, <span class="hljs-type">int</span>&gt; mp;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">2</span>);<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">auto</span> itL = <span class="hljs-built_in">lower_bound</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">auto</span> itR = <span class="hljs-built_in">upper_bound</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), r);<span class="hljs-keyword">if</span> (itL == c.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> L = itL - c.<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> R = itR == c.<span class="hljs-built_in">end</span>() ? n : itR - c.<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>; <span class="hljs-keyword">if</span> (L &gt; R || mp[&#123;L, R + <span class="hljs-number">1</span>&#125;]) &#123;<span class="hljs-keyword">continue</span>;&#125;dsu.<span class="hljs-built_in">merge</span>(L, R + <span class="hljs-number">1</span>);mp[&#123;L, R + <span class="hljs-number">1</span>&#125;] = mp[&#123;R + <span class="hljs-number">1</span>, L&#125;] = i + <span class="hljs-number">1</span>;adj[L].<span class="hljs-built_in">push_back</span>(R + <span class="hljs-number">1</span>);adj[R + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(L);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;set&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> have_T = <span class="hljs-number">0</span>;vector&lt;<span class="hljs-type">int</span>&gt; son;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;pre[y] = x;<span class="hljs-built_in">self</span>(self, y);<span class="hljs-keyword">if</span> (y == n + <span class="hljs-number">1</span>) &#123;have_T = <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;son.<span class="hljs-built_in">push_back</span>(y);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : son) &#123;<span class="hljs-keyword">if</span> (b[y]) &#123;ans.<span class="hljs-built_in">insert</span>(mp[&#123;x, y&#125;]);b[y] = <span class="hljs-number">0</span>;b[x] ^= <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span> (b[x] &amp;&amp; have_T) &#123;ans.<span class="hljs-built_in">insert</span>(mp[&#123;x, n + <span class="hljs-number">1</span>&#125;]);b[x] = <span class="hljs-number">0</span>;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;<span class="hljs-built_in">dfs</span>(dfs, i);<span class="hljs-keyword">if</span> (b[i]) &#123;<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">same</span>(i, n + <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n + <span class="hljs-number">1</span>; j != i; j = pre[j]) &#123;<span class="hljs-type">int</span> id = mp[&#123;j, pre[j]&#125;];<span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">count</span>(id)) &#123;ans.<span class="hljs-built_in">erase</span>(id);&#125; <span class="hljs-keyword">else</span> &#123;ans.<span class="hljs-built_in">insert</span>(id);&#125;&#125;&#125;&#125;&#125;cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1332F">G - IndependentSet</a></p><p>题意：给定一棵 <span class="math inline">\(n\)</span>个点的树，求它的 <span class="math inline">\(2^{n-1}-1\)</span>种非空边导出子图的点独立集个数之和。</p><p><span class="math inline">\(2 \le n \le 3 \cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>任意选择一个根节点。</p><p>令 <span class="math inline">\(dp[x][0/1][0/1]\)</span> 表示 “以<span class="math inline">\(x\)</span> 为根的子树内，是否选 <spanclass="math inline">\(x\)</span> 上面的边（<spanclass="math inline">\(x\leftrightarrowfa[x]\)</span>）作为边导出子图的一部分，是否选 <spanclass="math inline">\(x\)</span> 作为点独立集中的一个元素” 的答案。</p><p>转移如下： <span class="math display">\[\begin{align}&amp;dp[x][0][0]=\prod_{y\inson[x]}dp[y][0][0]+dp[y][0][1]+dp[y][1][0]+dp[y][1][1]\\&amp;dp[x][1][0]=\prod_{y\inson[x]}dp[y][0][0]+dp[y][0][1]+dp[y][1][0]+dp[y][1][1]\\&amp;dp[x][1][1]=\prod_{y\inson[x]}dp[y][0][0]+dp[y][0][1]+dp[y][1][0]\\&amp;dp[x][0][1]=\left(\prod_{y\inson[x]}dp[y][0][0]+dp[y][0][1]+dp[y][1][0]\right)-\left(\prod_{y\inson[x]}dp[y][0][0]+dp[y][0][1]\right)\end{align}\]</span> 前三条根据独立集的定义好理解，最后一条 <spanclass="math inline">\(dp[x][0][1]\)</span> 代表 <spanclass="math inline">\(x\)</span>与其父亲不相连而自己又在独立集中，此时必须保证 <spanclass="math inline">\(x\)</span> 至少有一个儿子 <spanclass="math inline">\(y\)</span> 和 <spanclass="math inline">\(x\)</span> 有边相连。容斥一下就是总方案数减去“所有儿子都不与 <span class="math inline">\(x\)</span> 连边”的方案数。</p><p>因为要求边导出子图非空，答案还需要 <spanclass="math inline">\(-1\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector(<span class="hljs-number">2</span>, vector&lt;mint&gt;(<span class="hljs-number">2</span>)))</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;mint c1 = <span class="hljs-number">1</span>, c2 = <span class="hljs-number">1</span>, c3 = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);c1 *= dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[y][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];c2 *= dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + dp[y][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];c3 *= dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + dp[y][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];&#125;dp[x][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = c1;dp[x][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = c1;dp[x][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = c2;dp[x][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = c2 - c3;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);cout &lt;&lt; dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p><a href="https://vjudge.net/problem/CodeForces-1332G">H - No MonotoneTriples</a></p><p>题意：给定长为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(\{a\}\)</span>，定义三元组 <spanclass="math inline">\((i,j,k)\)</span> 单调当且仅当 <spanclass="math inline">\(i&lt;j&lt;k\)</span> 且 <spanclass="math inline">\(a_i\le a_j\le a_k\)</span> 或 <spanclass="math inline">\(a_i\ge a_j\ge a_k\)</span>。<spanclass="math inline">\(q\)</span> 次询问，每次询问 <spanclass="math inline">\(l,r\)</span>，你需要在 <spanclass="math inline">\(a[l,r]\)</span> 中找到一个长度至少为 <spanclass="math inline">\(3\)</span> 且不含单调三元组的子序列 <spanclass="math inline">\(\{b\}\)</span>。</p><p><span class="math inline">\(3\le n \le 2\cdot 10^5\)</span>，<spanclass="math inline">\(1 \le q\le 2\cdot 10^5\)</span>，<spanclass="math inline">\(1 \le a_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>对于长度 <span class="math inline">\(\ge 5\)</span>的任意数列，若元素互不相同，由 Erdős–Szekeres定理（详见文末）可知至少存在长为 <span class="math inline">\(3\)</span>的单调子序列；若有相同元素，单调条件更容易满足。故我们要找的 <spanclass="math inline">\(\{b\}\)</span> 长度只能是 <spanclass="math inline">\(3\)</span> 或者 <spanclass="math inline">\(4\)</span>。</p><p>先说如何找长为 <span class="math inline">\(3\)</span> 的 <spanclass="math inline">\(\{b\}\)</span>。对于 <spanclass="math inline">\(\{a\}\)</span> 中每个极长的元素相同段 <spanclass="math inline">\([L,R]\)</span>，若 <spanclass="math inline">\((L-1,L,R+1)\)</span> 不是单调三元组，就将 <spanclass="math inline">\(L-1\)</span> 放入 <spanclass="math inline">\(\{c\}\)</span> 中。接着还需要预处理 <spanclass="math inline">\(\text{nxt}[i]\)</span> 代表 <spanclass="math inline">\(i\)</span> 右侧第一个 <spanclass="math inline">\(\neq a[i]\)</span> 的元素的下标。对于每个询问<span class="math inline">\((l,r)\)</span>，二分出 <spanclass="math inline">\(\{c\}\)</span> 中第一个 <spanclass="math inline">\(\ge l\)</span> 的 <spanclass="math inline">\(L\)</span>，若 <spanclass="math inline">\(\text{nxt}[L+1] \le r\)</span>，则 <spanclass="math inline">\(\{b\}=\{L,L+1,\text{nxt}[L+1]\}\)</span>就是一组合法的答案。</p><p>麻烦的是长为 <span class="math inline">\(4\)</span> 的 <spanclass="math inline">\(\{b\}\)</span>。此时序列的特征是：<spanclass="math inline">\(b_2,b_3\)</span> 是极值，<spanclass="math inline">\(b_1,b_4\)</span> 落在值域中间且不等于极值。</p><p>倒着扫描序列，维护两个单调栈 <spanclass="math inline">\(mn,mx\)</span>分别存储当前位置往后的非严格前缀最小值和非严格前缀最大值。设当前位置就是<span class="math inline">\(b_1\)</span>，那么显然 <spanclass="math inline">\(b_2,b_3\)</span>一定分别在两个单调栈中，否则更劣。以及 <spanclass="math inline">\(b_4\)</span> 一定不在两个单调栈中，因为 <spanclass="math inline">\(b_4\)</span> 不是极值。</p><p>此时，我们有了一个能求出 “若当前位置 <spanclass="math inline">\(i\)</span> 作为 <spanclass="math inline">\(p_1\)</span>，<spanclass="math inline">\(p_4\)</span> 的最小合法取值（记为 <spanclass="math inline">\(res[i]\)</span>）” 的方法：</p><ul><li>维护一个 <code>std::set</code>存储不在任何一个单调栈中的元素的下标。</li><li>从两个单调栈中分别找出第一个 <span class="math inline">\(\neqa[i]\)</span> 的元素的下标 <spanclass="math inline">\(p_2,p_3\)</span>，这可以通过在单调栈上二分实现。</li><li>从 <code>std::set</code> 里二分出第一个 <spanclass="math inline">\(&gt;\max(p_2,p_3)\)</span> 的下标即为所求最小的<span class="math inline">\(p_4\)</span>（<spanclass="math inline">\(res[i]=p_4\)</span>）。</li></ul><p>我们把 <span class="math inline">\(res\)</span>数组放到线段树上。对于每个询问 <spanclass="math inline">\([l,r]\)</span>，在线段树上二分找到区间里第一个<span class="math inline">\(L\)</span> 满足 <spanclass="math inline">\(res[L]\le r\)</span>，再找到 <spanclass="math inline">\([L,res[L]]\)</span> 里最大最小值对于的下标 <spanclass="math inline">\(p_2,p_3(p_2&lt;p_3)\)</span>，则 <spanclass="math inline">\(\{b\}=\{L,p_2,p_3,res[L]\}\)</span>就是一组合法的答案。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;    <span class="hljs-type">int</span> n;    vector&lt;Info&gt; tr;    <span class="hljs-built_in">SegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;        n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;        tr.<span class="hljs-built_in">assign</span>((<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>, <span class="hljs-built_in">Info</span>());        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);    &#125;    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = a[l];            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(ls, l, m, a);        <span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        tr[p] = tr[ls] + tr[rs];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = x;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (pos &lt;= m) &#123;            <span class="hljs-built_in">modify</span>(ls, l, m, pos, x);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, pos, x);        &#125;        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, x);    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-keyword">return</span> tr[p];        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findFirst</span>(ls, l, m, ql, qr, pred);        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;            res = <span class="hljs-built_in">findFirst</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFirst</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findLast</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;            res = <span class="hljs-built_in">findLast</span>(ls, l, m, ql, qr, pred);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findLast</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);    &#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<span class="hljs-type">int</span> mn = inf;<span class="hljs-type">int</span> mx = -inf;<span class="hljs-type">int</span> res = inf;    <span class="hljs-built_in">Info</span>() &#123;&#125;    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;    mn = mx = x;    res = y;    &#125;&#125;;Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;    Info c;    c.mn = <span class="hljs-built_in">min</span>(a.mn, b.mn);    c.mx = <span class="hljs-built_in">max</span>(a.mx, b.mx);    c.res = <span class="hljs-built_in">min</span>(a.res, b.res);    <span class="hljs-keyword">return</span> c;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;<span class="hljs-type">int</span>&gt; s, f;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (a[i] != a[i - <span class="hljs-number">1</span>]) &#123;s.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">3</span>) &#123;<span class="hljs-type">int</span> lst = s.<span class="hljs-built_in">back</span>();<span class="hljs-type">int</span> mid = s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>];<span class="hljs-type">int</span> pre = s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>];<span class="hljs-keyword">if</span> (a[mid] &gt; a[lst] &amp;&amp; a[mid] &gt; a[pre]) &#123;f.<span class="hljs-built_in">push_back</span>(pre);&#125;<span class="hljs-keyword">if</span> (a[mid] &lt; a[lst] &amp;&amp; a[mid] &lt; a[pre]) &#123;f.<span class="hljs-built_in">push_back</span>(pre);&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;s.<span class="hljs-built_in">pop_back</span>();s.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-keyword">if</span> (a[i] == a[i + <span class="hljs-number">1</span>]) &#123;nxt[i] = nxt[i + <span class="hljs-number">1</span>];&#125; <span class="hljs-keyword">else</span> &#123;nxt[i] = i + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">auto</span> get3 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">if</span> (it == f.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-type">int</span> L = *it;<span class="hljs-keyword">if</span> (nxt[L + <span class="hljs-number">1</span>] &gt; r) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;3\n&quot;</span>;cout &lt;&lt; L &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; L + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; nxt[L + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;set&lt;<span class="hljs-type">int</span>&gt; outside;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;outside.<span class="hljs-built_in">insert</span>(i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, inf)</span>, <span class="hljs-title">tot</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; mn, mx;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-keyword">while</span> (!mn.<span class="hljs-built_in">empty</span>() &amp;&amp; a[mn.<span class="hljs-built_in">back</span>()] &gt; a[i]) &#123;<span class="hljs-keyword">if</span> (--tot[mn.<span class="hljs-built_in">back</span>()] == <span class="hljs-number">0</span>) &#123;outside.<span class="hljs-built_in">insert</span>(mn.<span class="hljs-built_in">back</span>());&#125;mn.<span class="hljs-built_in">pop_back</span>();&#125;<span class="hljs-keyword">while</span> (!mx.<span class="hljs-built_in">empty</span>() &amp;&amp; a[mx.<span class="hljs-built_in">back</span>()] &lt; a[i]) &#123;<span class="hljs-keyword">if</span> (--tot[mx.<span class="hljs-built_in">back</span>()] == <span class="hljs-number">0</span>) &#123;outside.<span class="hljs-built_in">insert</span>(mx.<span class="hljs-built_in">back</span>());&#125;mx.<span class="hljs-built_in">pop_back</span>();&#125;mn.<span class="hljs-built_in">push_back</span>(i);mx.<span class="hljs-built_in">push_back</span>(i);outside.<span class="hljs-built_in">erase</span>(i);tot[i] += <span class="hljs-number">2</span>;<span class="hljs-type">int</span> resmn = <span class="hljs-number">-1</span>, resmx = <span class="hljs-number">-1</span>;<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = mn.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (a[i] != a[mn[mid]]) &#123;resmn = mn[mid];l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;r = mid - <span class="hljs-number">1</span>;&#125;&#125; l = <span class="hljs-number">0</span>, r = mx.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (a[i] != a[mx[mid]]) &#123;resmx = mx[mid];l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;r = mid - <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span> (resmn == <span class="hljs-number">-1</span> || resmx == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">auto</span> it = outside.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">max</span>(resmn, resmx));<span class="hljs-keyword">if</span> (it == outside.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;res[i] = *it;&#125;<span class="hljs-function">vector&lt;Info&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;tmp[i] = <span class="hljs-built_in">Info</span>(a[i], res[i]);&#125;<span class="hljs-function">SegmentTree&lt;Info&gt; <span class="hljs-title">seg</span><span class="hljs-params">(tmp)</span></span>;<span class="hljs-keyword">auto</span> get4 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<span class="hljs-type">int</span> p1 = seg.<span class="hljs-built_in">findFirst</span>(l, r, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.res &lt;= r;&#125;);<span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-type">int</span> p4 = res[p1];<span class="hljs-type">int</span> mn = seg.<span class="hljs-built_in">query</span>(p1, p4).mn;<span class="hljs-type">int</span> mx = seg.<span class="hljs-built_in">query</span>(p1, p4).mx;<span class="hljs-type">int</span> p2 = seg.<span class="hljs-built_in">findFirst</span>(p1, p4, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.mn &lt;= mn;&#125;);<span class="hljs-type">int</span> p3 = seg.<span class="hljs-built_in">findFirst</span>(p1, p4, [&amp;] (<span class="hljs-keyword">auto</span> A) &#123;<span class="hljs-keyword">return</span> A.mx &gt;= mx;&#125;);<span class="hljs-keyword">if</span> (p2 &gt; p3) &#123;<span class="hljs-built_in">swap</span>(p2, p3);&#125;cout &lt;&lt; <span class="hljs-string">&quot;4\n&quot;</span>;cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p4 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get4</span>(l, r) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">get3</span>(l, r) == <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-primary">            <p><strong>Dilworth定理</strong>：任意有限偏序集中，最长链的长度等于最小的反链划分的数量。</p><ul><li>将序列中的每个值看成一个元素，定义偏序关系：对于集合中的两个元素<span class="math inline">\(a,b\)</span>，<spanclass="math inline">\(a≺b\)</span> 当且仅当 <spanclass="math inline">\(a&lt;b\)</span> 。Dilworth定理在此基础上给出的结论就是：<strong>一个序列的最长上升子序列的长度（LIS）等于将该序列划分成不上升子序列的最小数量</strong>。</li></ul><p>通俗来说，若序列的 LIS 长度为 <spanclass="math inline">\(k\)</span>，则至少需要 <spanclass="math inline">\(k\)</span>个不上升的子序列才能覆盖整个序列，且无法用更少的子序列完成覆盖。</p><ul><li>同样地，若定义偏序关系：对于集合中的两个元素 <spanclass="math inline">\(a,b\)</span>，<spanclass="math inline">\(a\preccurlyeq b\)</span> 当且仅当 <spanclass="math inline">\(a\leb\)</span>。则有：<strong>一个序列的最长不下降子序列的长度等于将该序列划分成严格下降子序列的最小数量</strong>。</li></ul><p><strong>Erdős–Szekeres 定理</strong>是 Dilworth定理的一个简单推论，内容是：</p><ul><li>对于 <span class="math inline">\(mn+1\)</span>个互不相同的实数组成的数列 <span class="math inline">\((m,n\in\text{N}^+)\)</span>，一定存在长为 <spanclass="math inline">\(m+1\)</span> 的递增子列或长为 <spanclass="math inline">\(n+1\)</span> 的递减子列。</li><li>二维欧式平面上任意 <span class="math inline">\(mn+1\)</span>个点总能构造出 <span class="math inline">\(m+1\)</span> 条正斜率线段或<span class="math inline">\(n+1\)</span>条负斜率线段。（只要该坐标系下任意两点横纵坐标都不同）</li></ul><p>对于第一条，设这个序列的 LIS 长度为 <spanclass="math inline">\(k\)</span>，若 <span class="math inline">\(k\gem+1\)</span>，成立；若 <spanclass="math inline">\(k&lt;m+1\)</span>，应用 Dilworth定理，将该序列划分成下降子序列的最小数量是 <spanclass="math inline">\(k\)</span>。序列被划分成了 <spanclass="math inline">\(k\)</span> 段，这样划分出最长的下降序列的长度<span class="math inline">\(l\)</span> 的最小值是 <spanclass="math inline">\(\lceil\frac{mn+1}{k}\rceil\)</span>（因为均分最优），又<span class="math inline">\(k&lt;m+1\)</span>，不难得出 <spanclass="math inline">\(l\ge n+1\)</span>，得证。</p>          </div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> UESTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】寒假训练日记</title>
      <link href="/posts/abc8fb81.html"/>
      <url>/posts/abc8fb81.html</url>
      
        <content type="html"><![CDATA[<p>寒假给自己定的要求是 vp 后补 *2500 以下的题，有些 &gt; 2500但我感兴趣的题也会补。</p><h2 id="cf2048f.-kevin-and-math-class"><ahref="https://codeforces.com/contest/2048/problem/F">CF2048F. Kevin andMath Class</a></h2><p>*2500 <ahref="https://codeforces.com/contest/2048/submission/300486188">Code</a></p><p>对于 <span class="math inline">\(b_x\)</span>，找到 <spanclass="math inline">\(b_x\)</span> 左侧第一个 <spanclass="math inline">\(l\)</span> 使得 <span class="math inline">\(b_l&lt; b_x\)</span>，右侧第一个 <span class="math inline">\(r\)</span>使得 <span class="math inline">\(b_r &lt; b_x\)</span>。</p><p>那么要让 <span class="math inline">\(b_x\)</span>当最小值，区间最大就是 <spanclass="math inline">\([l+1,r-1]\)</span>，又我们肯定是选尽可能大的区间，所以要除<span class="math inline">\(b_x\)</span> 时肯定是对区间 <spanclass="math inline">\([l+1,r-1]\)</span> 操作。</p><p>于是建出 <span class="math inline">\((i,b_i)\)</span>的小根笛卡尔树，我们一定是操作笛卡尔树上的区间。</p><p>又 <span class="math inline">\(b_i \ge2\)</span>，所以每个区间操作不会超过 <spanclass="math inline">\(64\)</span> 次。</p><p>令 <span class="math inline">\(dp[x][i]\)</span> 表示以 <spanclass="math inline">\(x\)</span> 为根的子树对应的区间，操作 <spanclass="math inline">\(i\)</span> 次后区间最大值最小是多少。 <spanclass="math display">\[\begin{align}dp[x][k] = \min_{k=i+j}(\max(dp[ls[x]][i],dp[rs[x]][j],a[x]))\\dp[x+1][k] =\min(dp[x+1][k],\left\lceil\frac{dp[x][k]}{b[x]}\right\rceil)\end{align}\]</span> 答案是使 <span class="math inline">\(dp[rt][i]=1\)</span>的最小的 <span class="math inline">\(i\)</span>。<spanclass="math inline">\(rt\)</span> 是笛卡尔树的根。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2w)\)</span>，<spanclass="math inline">\(w\)</span> 是值域。</p><p>题解说可以用 <span class="math inline">\(\min-\max\)</span>卷积优化到 <span class="math inline">\(O(n\logw)\)</span>，但我琢磨了一下不是很会。</p><p>实测双 <span class="math inline">\(\log\)</span> 跑了 1.1s &lt;2s。</p><h2 id="cf1976d.-invertible-bracket-sequences"><ahref="https://codeforces.com/contest/1976/problem/D">CF1976D. InvertibleBracket Sequences</a></h2><p>*2000 <ahref="https://codeforces.com/contest/1976/submission/300528983">Code</a></p><p>把左括号看成 <span class="math inline">\(1\)</span>，右括号看成 <spanclass="math inline">\(-1\)</span>，求前缀和，可以作出折线图。</p><p>一段折线如果要翻转后也形成合法括号序列，需要满足两个条件：</p><ul><li>两端纵坐标相等。</li><li>翻转后最高点不能越过 <span class="math inline">\(x\)</span>轴。</li></ul><p>第一个条件即 <span class="math inline">\(sum_l =sum_r\)</span>，第二个条件即 <spanclass="math inline">\(\max\limits_{l\le i\ler}sum_{i}\le2sum_l\)</span>。</p><p>最大值可以用 ST 表或线段树维护，然后沿 <spanclass="math inline">\(y\)</span> 轴做扫描线即可。注意对于同一 <spanclass="math inline">\(y\)</span> 坐标，若有三个点满足 <spanclass="math inline">\(sum_l=sum_m=sum_r\)</span>，且 <spanclass="math inline">\([l, m]\)</span> 和 <spanclass="math inline">\([m,r]\)</span> 满足要求，那么 <spanclass="math inline">\([l,r]\)</span>也满足要求。使用一个计数器累加即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1976e.-splittable-permutations"><ahref="https://codeforces.com/contest/1976/problem/E">CF1976E. SplittablePermutations</a></h2><p>*2500 <ahref="https://codeforces.com/contest/1976/submission/300596121">Code</a></p><p>这题最关键的观察：出现在 <spanclass="math inline">\(l[i]\)</span>，<spanclass="math inline">\(r[i]\)</span>中的所有数的相对位置是可以唯一确定的。</p><ul><li>首先对于一组 <span class="math inline">\((l, r)\)</span>，<spanclass="math inline">\(l\)</span> 肯定在 <spanclass="math inline">\(r\)</span>的左边。倒着扫描序列，每次相当于一次合并。设 <spanclass="math inline">\(l\)</span> 目前所在的序列为 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(r\)</span>目前所在的序列为 <spanclass="math inline">\(b\)</span>，那么合并后新序列的相对顺序一定是 <spanclass="math inline">\(b\)</span> 中的元素按顺序拼接在 <spanclass="math inline">\(a\)</span> 的后面。这个性质可以手玩出来。</li></ul><p>并查集记录这个数属于哪个连通块，再用双向链表连接，就能求出这个相对顺序。</p><p>接着还有一些数没在 <span class="math inline">\(l[i]\)</span>，<spanclass="math inline">\(r[i]\)</span> 中出现过，我们考虑把它们插进去。</p><p>又一个观察：一个数 <span class="math inline">\(x\)</span> 能插进<span class="math inline">\(A,B\)</span> 之间的必要条件是 <spanclass="math inline">\(x\le \max(A,B)\)</span>。</p><ul><li>比较显然。</li></ul><p>于是从大到小枚举要插的数，用一个计数器统计每次有多少空可以插，乘起来就是答案。</p><p>时间复杂度<span class="math inline">\(O(n\alpha)\)</span>。</p><h2 id="cf2055d.-scarecrow"><ahref="https://codeforces.com/contest/2055/problem/D">CF2055D.Scarecrow</a></h2><p>*2000 <ahref="https://codeforces.com/contest/2055/submission/301662039">Code</a></p><p>设当前使用的时间是 <span class="math inline">\(t\)</span>，乌鸦当前在<span class="math inline">\(p\)</span>。</p><p>首先离 <span class="math inline">\(0\)</span> 最近的稻草人要移到<span class="math inline">\(0\)</span>，那么令初值 <spanclass="math inline">\(t = a[0]\)</span>，<spanclass="math inline">\(p=k\)</span>。</p><p>一个观察是：你是被你左边最近的稻草人推着走的，与此同时右边最近的稻草人可以按情况选择左移，不动，或右移来减少你转移到它（也就是被它推着走）的时间。</p><p>那么从左到右扫描每个稻草人，做出如下分类讨论：</p><ul><li><spanclass="math inline">\(a[i]-t&gt;p\)</span>，即之前的时间都向左移都还在乌鸦的右边时，选择花时间继续向左，与此同时乌鸦也被它左边的稻草人推着向右，所以需要<span class="math inline">\(t&#39;=(a[i]-t-p)/2\)</span>。那么 <spanclass="math inline">\(t=t+t&#39;\)</span>，乌鸦转移到 <spanclass="math inline">\(p=p+t&#39;+k\)</span>。</li><li><span class="math inline">\(a[i]-t\le p\)</span> 时，分两种情况。<ul><li><span class="math inline">\(a[i]+t\lep\)</span>，也就是之前的时间一直向右移也在乌鸦的左边，那就取个 <spanclass="math inline">\(\max\)</span>，即 <spanclass="math inline">\(p=\max(p,a[i]+t+k)\)</span>。</li><li><spanclass="math inline">\(a[i]+t&gt;p\)</span>，也就是之前的时间足够右移到乌鸦右边了，此时肯定是恰好停在$ p$ 不用花额外的时间，所以 <span class="math inline">\(p =p+k\)</span>。</li></ul></li></ul><p>最后如果 <span class="math inline">\(p&lt;l\)</span>，就加上 <spanclass="math inline">\(l-p\)</span>，代表最后一个稻草人把它推向终点。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2057e1e2.-another-exercise-on-graphs"><ahref="https://codeforces.com/contest/2057/problem/E2">CF2057E1/E2.Another Exercise on Graphs</a></h2><p>*2300 <ahref="https://codeforces.com/contest/2057/submission/301679582">Code</a>（E1）</p><p>*2500 <ahref="https://codeforces.com/contest/2057/submission/301730095">Code1</a><ahref="https://codeforces.com/contest/2057/submission/301732253">Code2</a>（E2）</p><p>先考虑这样一个事情：我们将原图 copy一份，对于新图上的每条边，如果原图的边权 <span class="math inline">\(\lex\)</span>，则赋值为 <span class="math inline">\(0\)</span>，否则赋值为<span class="math inline">\(1\)</span>。那么 <spanclass="math inline">\(a\to b\)</span> 在新图上的最短路为 <spanclass="math inline">\(w \Longleftrightarrow\)</span> <spanclass="math inline">\(x\)</span> 为原图中 <spanclass="math inline">\(a\to b\)</span> 路径上第 <spanclass="math inline">\(w+1\)</span> 大的边。</p><p>那么得到一个暴力做法：从小到大枚举所有的边权 <spanclass="math inline">\(x\)</span>，按上述规则赋值跑最短路，直到第一个<span class="math inline">\(w\)</span> 满足 <spanclass="math inline">\(w+1\le k\)</span>，此时 <spanclass="math inline">\(x\)</span> 就是答案。</p><p>进一步地，<span class="math inline">\(x\)</span>每次增大都相当于把一些边（即边权等于新 <spanclass="math inline">\(x\)</span> 的边）由 <spanclass="math inline">\(1\to 0\)</span>，我们利用 floyd枚举这些边的两个端点为中转点就可以很快地更新答案。具体地，更新一次是<span class="math inline">\(O(n^2)\)</span>，更新不超过 <spanclass="math inline">\(m\)</span> 次。</p><p>至于多组询问，用 <span class="math inline">\(dis[a][b][x]\)</span>表示对 <span class="math inline">\(\le x\)</span> 的边赋值为 <spanclass="math inline">\(0\)</span>，否则赋值为 <spanclass="math inline">\(1\)</span> 后 <span class="math inline">\(a\tob\)</span> 的最短路，每次询问就对 <spanclass="math inline">\(dis[a][b][\cdot]\)</span> 二分出第一个 <spanclass="math inline">\(\le k-1\)</span> 的值对应的 <spanclass="math inline">\(x\)</span> 就是答案。</p><p>由于要枚举每个边权，时间复杂度 <spanclass="math inline">\(O(mn^2)\)</span>，能够通过 E1。</p><p>注意我们把一些边由 <span class="math inline">\(1\to0\)</span>的过程，如果对于所有边权为 <span class="math inline">\(x\)</span> 的边<span class="math inline">\((a,b)\)</span>，<spanclass="math inline">\(dis[a][b]\)</span> 都已经为 <spanclass="math inline">\(0\)</span>，那么此次更新就是不必要的，就能省下一个<span class="math inline">\(O(n^2)\)</span>。</p><p>实际上，可以证明这样的更新最多进行 <spanclass="math inline">\(n\)</span> 次：如果当前边 <spanclass="math inline">\((a,b)\)</span> 有 <spanclass="math inline">\(dis[a][b]\neq0\)</span>，那么 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>中的至少一个需要来自之前没更新过的点，而一共就 <spanclass="math inline">\(n\)</span> 个点，故得证。</p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>，能够通过E2。</p><p>事实上，回答询问的时候二分并不是必要的。一样是从小到大枚举边权 <spanclass="math inline">\(x\)</span> 并赋值，但你只需要在 floyd更新的时候顺便记一下就行了，细节可以阅读 jiangly 的代码。</p><h2 id="cf2060e.-graph-composition"><ahref="https://codeforces.com/contest/2060/problem/E">CF2060E. GraphComposition</a></h2><p>*1500 <ahref="https://codeforces.com/contest/2060/submission/301963287">Code</a></p><p>很容易想的很复杂，实际上只需要两步：</p><ul><li>把 <span class="math inline">\(F\)</span> 的一些边断掉使得 <spanclass="math inline">\(F\)</span> 的任意同一连通分量中的点都在 <spanclass="math inline">\(G\)</span> 中连通。</li><li>把 <span class="math inline">\(F\)</span> 的一些连通分量组合得到<span class="math inline">\(G\)</span>。</li></ul><p>第一步只用枚举 <span class="math inline">\(F\)</span> 的每条边 <spanclass="math inline">\(a\to b\)</span> 然后用并查集看在 <spanclass="math inline">\(G\)</span> 中 <spanclass="math inline">\(a,b\)</span> 是否连通，不连通需要花费 <spanclass="math inline">\(1\)</span> 的代价割掉。</p><p>第二步花费的代价一定是 <span class="math inline">\(F\)</span>的连通分量个数 <span class="math inline">\(-\)</span> <spanclass="math inline">\(G\)</span> 的连通分量个数。</p><p>时间复杂度 <span class="math inline">\(O(n\alpha)\)</span>。</p><h2 id="cf2061e.-kevin-and-and"><ahref="https://codeforces.com/contest/2061/problem/E">CF2061E. Kevin andAnd</a></h2><p>*2000 <ahref="https://codeforces.com/contest/2061/submission/302339557">Code</a></p><p>题目要让总和最小，一个容易想到的贪心是：每一步操作都让总和尽可能地变小，也就是每次都采取能让总和变化量最大的操作。在以下叙述中，把减少的量称为收益。</p><p>要说明这个贪心是对的，得先证明一个结论：对于一个固定的 <spanclass="math inline">\(a_i\)</span>，设 <spanclass="math inline">\(f(j)\)</span> 代表对 <spanclass="math inline">\(a_i\)</span> 使用 <spanclass="math inline">\(j\)</span> 次魔法能获得的最大的收益，那么 <spanclass="math inline">\(f(j)-f(j-1)\)</span> 递减（即 <spanclass="math inline">\(f(j)\)</span> 是凸的）。</p><ul><li>感性证明：“使用两次魔法相对于使用一次魔法” 带来的收益不可能超过“使用一次魔法相对于不使用魔法”带来的收益。否则此时使用一次魔法带来的收益并非是最大的。</li></ul><p>基于这个结论，我们可以对于每个 <spanclass="math inline">\(i\in[1,n]\)</span>，把所有的 <spanclass="math inline">\(f(j)-f(j-1),j\in[1,m]\)</span>记下来，排序之后选最大的 <span class="math inline">\(k\)</span>个值相加即最大收益。</p><p>代码实现过程中，把 <span class="math inline">\(m\)</span>个魔法是否使用压缩成一个状态，可以先 <spanclass="math inline">\(O(2^m\cdot m)\)</span>求出每种状态的累加效果（即按位与后的结果），再 <spanclass="math inline">\(O(n\cdot 2^m)\)</span> 对每个 <spanclass="math inline">\(a_i\)</span> 求出 <spanclass="math inline">\(f(1\sim m)\)</span>。</p><p>时间复杂度：<span class="math inline">\(O(n2^m+nm\lognm)\)</span>。</p><p>如果使用 <code>std::nth_element</code> 可以省去最后的 <spanclass="math inline">\(\log\)</span>。</p><h2 id="cf2061f1.-kevin-and-binary-string-easy-version"><ahref="https://codeforces.com/contest/2061/problem/F1">CF2061F1. Kevinand Binary String (Easy Version)</a></h2><p>*2100 <ahref="https://codeforces.com/contest/2061/submission/302357467">Code</a></p><p>对于串 <spanclass="math inline">\(\cdots011001\cdots\)</span>，交换中间的 <spanclass="math inline">\(11\)</span> 和 <spanclass="math inline">\(00\)</span>，会让交换后的 <spanclass="math inline">\(00\)</span> 与左边的 <spanclass="math inline">\(0\)</span> 粘连，<spanclass="math inline">\(11\)</span> 与右边的 <spanclass="math inline">\(1\)</span>粘连。而一旦粘连，只能一起移动，因此整块的 <spanclass="math inline">\(1\)</span> 是无法跨越另一个整块的 <spanclass="math inline">\(1\)</span> 的，整块的 <spanclass="math inline">\(0\)</span> 也无法跨越另一个整块的 <spanclass="math inline">\(0\)</span>。</p><p>这就说明了 <span class="math inline">\(s\)</span> 要想变成 <spanclass="math inline">\(t\)</span>，可以进行以下贪心：从左到右扫描，当<span class="math inline">\(s[i]\neq t[i]\)</span> 时，就从 <spanclass="math inline">\(i\)</span> 后边找最近的整块的 <spanclass="math inline">\(t[i]\)</span> 修补。</p><p>例如，<span class="math inline">\(s=001\color{Red}0\)</span><spanclass="math inline">\(1\color{Red}00\)</span><spanclass="math inline">\(101\)</span>，<spanclass="math inline">\(t=00\color{Green}000\)</span><spanclass="math inline">\(1111\)</span>。当 <spanclass="math inline">\(i=3\)</span> 时，<spanclass="math inline">\(s[i]\neq t[i]\)</span>，且 <spanclass="math inline">\(t\)</span> 此时还有连续 <spanclass="math inline">\(3\)</span> 个 <spanclass="math inline">\(0\)</span>，故要从 <spanclass="math inline">\(s[3]\)</span> 后边找 <spanclass="math inline">\(3\)</span> 个 <spanclass="math inline">\(0\)</span>。找到第一个 <spanclass="math inline">\(0\)</span> 块有 <spanclass="math inline">\(1\)</span> 个 <spanclass="math inline">\(0\)</span>，还需要找 <spanclass="math inline">\(2\)</span> 个，再往后找到下一个 <spanclass="math inline">\(0\)</span> 块就恰好找到 <spanclass="math inline">\(2\)</span> 个。</p><p>而 <span class="math inline">\(s=001\color{Red}0\)</span><spanclass="math inline">\(1\color{Red}00\)</span><spanclass="math inline">\(011\)</span>，<spanclass="math inline">\(t=00\color{Green}000\)</span><spanclass="math inline">\(1111\)</span> 就无法匹配上，因为往后找只能找到<span class="math inline">\(1\)</span> 个或 <spanclass="math inline">\(4\)</span> 个 <spanclass="math inline">\(0\)</span>，不能补上 <spanclass="math inline">\(3\)</span> 个 <spanclass="math inline">\(0\)</span> 的缺口。</p><p>具体实现时可以用容器把 <span class="math inline">\(1,0\)</span>的位置存起来以便快速向后查找，另有若干细节不再赘述。</p><p>时间复杂度：<span class="math inline">\(O(n)\)</span> 或 <spanclass="math inline">\(O(n\log n)\)</span>。（依据实现方式）</p><h2 id="cf2056d.-unique-median"><ahref="https://codeforces.com/contest/2056/problem/D">CF2056D. UniqueMedian</a></h2><p>*2200 <ahref="https://codeforces.com/contest/2056/submission/302570099">Code</a></p><p>容斥，用全集 <span class="math inline">\(\frac{n(n+1)}{2}\)</span>减去中位数不等的子串个数。</p><p>注意到值域很小，故枚举两个中位数中较小的那个（记为 <spanclass="math inline">\(x\)</span>）。将数组中 <spanclass="math inline">\(\le x\)</span> 的置为 <spanclass="math inline">\(-1\)</span>，<spanclass="math inline">\(&gt;x\)</span> 的置为 <spanclass="math inline">\(1\)</span> 求出前缀和 <spanclass="math inline">\(pre\)</span>，那么子串 <spanclass="math inline">\((i,j)\)</span> 中位数不等 <spanclass="math inline">\(\Longleftrightarrow\)</span> <spanclass="math inline">\(pre[i-1]=pre[j]\)</span>。</p><p>由于 <span class="math inline">\(pre[i-1]=pre[j]\)</span>时对应的串长定为偶数，所以不用考虑奇数长度的判断。</p><p>故我们只需要计数有多少个二元组 <spanclass="math inline">\((l,r)\)</span> 满足 <spanclass="math inline">\(pre[l]=pre[r]\)</span> 且区间 <spanclass="math inline">\([l+1,r]\)</span> 中有 <spanclass="math inline">\(x\)</span>。</p><p>一种方法是枚举 <span class="math inline">\(i=1\cdotsn\)</span>，以及一个指针 <span class="math inline">\(j\)</span>，初始<span class="math inline">\(j=0\)</span>。当 <spanclass="math inline">\(a[i]=x\)</span> 时，<spanclass="math inline">\(j\)</span> 就跟上 <spanclass="math inline">\(i\)</span> 并把路上的 <spanclass="math inline">\(pre[j]\)</span> 都加进桶里，然后累加桶里 <spanclass="math inline">\(pre[i]\)</span> 的数目。正确性显然，即这样两个<span class="math inline">\(x\)</span> 之间的 <spanclass="math inline">\(pre\)</span> 值无法造成贡献。</p><p>时间复杂度 <span class="math inline">\(O(wn\log n)\)</span>，<spanclass="math inline">\(w\)</span> 为值域。</p><h2 id="cf2056e.-nested-segments"><ahref="https://codeforces.com/contest/2056/problem/E">CF2056E. NestedSegments</a></h2><p>*2500 <ahref="https://codeforces.com/contest/2056/submission/302750497">Code</a></p><p>观察 <span class="math inline">\(1\)</span>：当 <spanclass="math inline">\(m=0\)</span> 时最多能向 <spanclass="math inline">\([1,n]\)</span> 中填 <spanclass="math inline">\(2n-1\)</span> 条线段。</p><ul><li>草稿纸画几笔易得。</li></ul><p>观察 <span class="math inline">\(2\)</span>：当 <spanclass="math inline">\(m=0\)</span> 时向 <spanclass="math inline">\([1,n]\)</span> 中填 <spanclass="math inline">\(2n-1\)</span> 条线段的方案数是 <spanclass="math inline">\(C_{n-1}\)</span>，其中 <spanclass="math inline">\(C\)</span> 为卡特兰数。</p><ul><li>考虑这样一个事情：把 <span class="math inline">\([1,n]\)</span>当作根节点，<span class="math inline">\([1, 1],[2,2],\cdots,[n,n]\)</span> 当作叶节点，若 <spanclass="math inline">\([L,R]\)</span> 包含 <spanclass="math inline">\([l,r]\)</span> 且 <span class="math inline">\([L,R]\)</span> 极小，就连一条边，最终连成一棵树。同时，当填满 <spanclass="math inline">\(2n-1\)</span>条线段时，这一定是一棵满位置二叉树（每个节点有 <spanclass="math inline">\(0\)</span> 个或 <spanclass="math inline">\(2\)</span> 个儿子），因为如果有 <spanclass="math inline">\(&gt;2\)</span>个儿子，我们一定可以取出两个为其添加一个父亲。</li><li>接着套用结论：有 <span class="math inline">\(n\)</span>个叶子的满位置二叉树数量为 <spanclass="math inline">\(C_{n-1}\)</span>。末尾的第二个参考链接附有示例。</li></ul><p>观察 <span class="math inline">\(3\)</span>：当 <spanclass="math inline">\(m\neq 0\)</span> 时，<spanclass="math inline">\([1,n]\)</span> 中仍然能填满 <spanclass="math inline">\(2n-1\)</span> 条线段。</p><ul><li>虽然题目预先给出了一些线段，但保证了已经给出的是好的。草稿纸再画几笔发现我们仍然能建出一个有<span class="math inline">\(n\)</span> 个儿子的满位置二叉树。</li></ul><p>我们可以先把题给线段构成的树建出来（如果没有 <spanclass="math inline">\([1,n]\)</span>的话就为它添加），这时的树有些节点（设为 <spanclass="math inline">\(x\)</span>）有 <spanclass="math inline">\(&gt;2\)</span> 个儿子，不妨将 <spanclass="math inline">\(x\)</span> 的儿子设为 <spanclass="math inline">\([l_1,r_1],[l_2,r_2],\cdots[l_k,r_k]\)</span>。对于<span class="math inline">\(\forall i\in[1,k)\)</span>，若 <spanclass="math inline">\(r_i \neq l_{i+1}\)</span>，那么一定可以添加线段<spanclass="math inline">\([r_i+1,r_i+1],[r_i+2,r_i+2],\cdots,[l_{i+1}-1,l_{i+1}-1]\)</span>在中间。</p><p>再设如此填充线段后 <span class="math inline">\(x\)</span> 有 <spanclass="math inline">\(p\)</span> 个儿子，我们的目标就是把这个以 <spanclass="math inline">\(x\)</span>为根的子树建成一棵满位置二叉树，而这么做的方案数恰好等价于有 <spanclass="math inline">\(p\)</span> 个叶子的满位置二叉树数量，即 <spanclass="math inline">\(C_{p-1}\)</span>。</p><p>于是对于每一条线段，它的贡献都是一个卡特兰数，累乘起来就是最终的方案数。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><p>一些卡特兰数模型：<ahref="https://zhuanlan.zhihu.com/p/31317307">Link1</a> <ahref="https://zhuanlan.zhihu.com/p/31526354">Link2</a> <ahref="https://zhuanlan.zhihu.com/p/609104268">Link3</a>。</p><p>记忆：<spanclass="math inline">\(C_{n}=\binom{2n}{n}-\binom{2n}{n-1}\)</span>。</p><h2 id="cf2063f1f2.-counting-is-not-fun"><ahref="https://codeforces.com/contest/2063/problem/F2">CF2063F1/F2.Counting Is Not Fun</a></h2><p>*2400 <ahref="https://codeforces.com/contest/2063/submission/302767057">Code</a>（F1）</p><p>*2700 <ahref="https://codeforces.com/contest/2063/submission/302848292">Code</a>（F2）</p><p>我们将一组 good pair <span class="math inline">\((l,r)\)</span>看成覆盖 <span class="math inline">\([l,r]\)</span>的线段，显然任何时候的任意两条线段都要么不交要么完全包含。和这篇文章的上一题及其相似，我们把具有包含关系的线段连边（对于<span class="math inline">\([l,r]\)</span>，若能找到极小的 <spanclass="math inline">\([L,R]\)</span> 使其包含 <spanclass="math inline">\([l,r]\)</span>，就在这两条线段间连一条边），会连成一棵森林。</p><p>令 <span class="math inline">\(f[i]\)</span> 表示第 <spanclass="math inline">\(i\)</span>条线段去掉两个端点后没有被其儿子覆盖的长度。这个长度内我们可以自由填。</p><p>定理：用 <span class="math inline">\(n\)</span> 对括号填满 <spanclass="math inline">\(2n\)</span> 个位置构成平衡括号序列的方案数为 <spanclass="math inline">\(C_{n}\)</span>（卡特兰数的第 <spanclass="math inline">\(n\)</span> 项） 。</p><p>于是答案即为 <span class="math inline">\(\prod\limits_{i=1}^mC_{f[i]/2}\)</span>，<span class="math inline">\(m\)</span>为当前添加的括号组数。</p><p>F1 中，我们可以每次添加括号后 <spanclass="math inline">\(O(n)\)</span> 地去扫这个序列，求出 <spanclass="math inline">\(f[i]\)</span>。</p><p>具体地，把非右括号装进栈，扫到右括号时计数弹出了多少元素。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><p>F2 需要动态地维护 <spanclass="math inline">\(f[i]\)</span>，题解给出了一种平衡树做法，但离线是简单的，这里只讲离线怎么做。</p><p>倒着操作，相当于每次拿走一组括号，此时只有这条线段本身和其父亲的贡献发生了变化。具体地，设当前为第<span class="math inline">\(i\)</span> 条线段，父亲为第 <spanclass="math inline">\(fa_i\)</span>条线段，那么答案只需要在之前答案的基础上加上 <spanclass="math inline">\(-C_{f[i]/2}-C_{f[fa_i]/2}+C_{(f[fa_i]+f[i]+2)/2}\)</span>。</p><p>快速定位到父亲是哪条线段可以用并查集，时间复杂度 <spanclass="math inline">\(O(n\log n + n\alpha)\)</span>。</p><h2 id="cf2063e.-triangle-tree"><ahref="https://codeforces.com/contest/2063/problem/E">CF2063E. TriangleTree</a></h2><p>*2300 <ahref="https://codeforces.com/contest/2063/submission/302994147">Code</a></p><p>草稿纸画一画，易知： <span class="math display">\[\begin{align}f(x,y)&amp;=2\min(\text{dis}(x,\text{lca}_{x,y}),\text{dis}(y,\text{lca}_{x,y}))-1\\&amp;= 2\min(\text{dep}_x,\text{dep}_y)-2\text{dep}_{\text{lca}_{x,y}}-1\end{align}\]</span> 前提是 <span class="math inline">\(x,y\)</span>没有祖先关系。</p><p>这样就把贡献拆成了三部分，可以分别计算：</p><ul><li><span class="math inline">\(\min(\text{dep}_x,\text{dep}_y)\)</span>：枚举 <spanclass="math inline">\(x\)</span>，则每个深度比 <spanclass="math inline">\(x\)</span> 大且不在 <spanclass="math inline">\(x\)</span> 子树中的 <spanclass="math inline">\(y\)</span> 有 <spanclass="math inline">\(\text{dep}_x\)</span> 的贡献。令 <spanclass="math inline">\(d_x\)</span> 表示深度 <spanclass="math inline">\(\ge x\)</span>的节点数（可以通过一个后缀和实现），分为两种情况。<ul><li><span class="math inline">\(\text{dep}_x &lt;\text{dep}_y\)</span>：贡献为 <spanclass="math inline">\((d_{dep_x+1}-(sz_x-1))\times dep_x\)</span>。</li><li><spanclass="math inline">\(\text{dep}_x=\text{dep}_y\)</span>：贡献为 <spanclass="math inline">\((d_{dep_x}-d_{dep_x+1}-1)\timesdep_x\)</span>，最后要除以 <span class="math inline">\(2\)</span>使无序对 <span class="math inline">\(\to\)</span> 有序对。</li></ul></li><li><spanclass="math inline">\(\text{dep}_{\text{lca}_{x,y}}\)</span>：枚举 <spanclass="math inline">\(\text{lca}\)</span>，对于当前点 <spanclass="math inline">\(x\)</span>，贡献为 <spanclass="math inline">\(\sum_{y\in son[x]}sz_y\times (sz_x-1-sz_y)\timesdep_x\)</span>。</li><li><span class="math inline">\(1\)</span>：即没有祖先关系的 <spanclass="math inline">\((x,y)\)</span> 组数。对于当前点 <spanclass="math inline">\(x\)</span>，贡献为 <spanclass="math inline">\(n-sz_x-dep_x+1\)</span>。</li></ul><p>第 <span class="math inline">\(2, 3\)</span> 部分最后也需要除以 <spanclass="math inline">\(2\)</span>，从而只计算有序对。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2060f.-multiplicative-arrays"><ahref="https://codeforces.com/contest/2060/problem/F">CF2060F.Multiplicative Arrays</a></h2><p>*2200 <ahref="https://codeforces.com/contest/2060/submission/303010975">Code</a></p><p>首先注意到构造出的 <span class="math inline">\(\{a\}\)</span> 中<span class="math inline">\(&gt; 1\)</span> 的数不超过 <spanclass="math inline">\(16\)</span> 个（因为 <spanclass="math inline">\(2^{17}&gt;10^5\)</span>）。</p><p>于是这个计数分为两步：</p><ol type="1"><li><p>算 <span class="math inline">\(&gt;1\)</span> 的数构成 <spanclass="math inline">\(x\)</span> 有多少种可能。</p></li><li><p>算剩下的 <span class="math inline">\(1\)</span>有多少种插空方法。</p></li></ol><p>令 <span class="math inline">\(dp[i][j]\)</span> 代表 <spanclass="math inline">\(i\)</span> 个 <spanclass="math inline">\(&gt;1\)</span> 的数构成 <spanclass="math inline">\(j\)</span> 的方案数。</p><ul><li>初态：<span class="math inline">\(\forall i\in[2,k]\)</span>，<spanclass="math inline">\(dp[1][i]=1\)</span>。</li><li>转移：<span class="math inline">\(dp[i][j] = \sum\limits_{k&gt;1}dp[i-1][\dfrac{j}{k}]\)</span>。</li></ul><p>令 <span class="math inline">\(ans[x]\)</span> 代表乘积为 <spanclass="math inline">\(x\)</span> 时的方案数，当 <spanclass="math inline">\(x=1\)</span> 时显然为 <spanclass="math inline">\(n\)</span>，当 <span class="math inline">\(x &gt;1\)</span> 时： <span class="math display">\[ans[x]=\sum_{i=1}^{n}\sum_{j=1}^{16} dp[j][x]\binom{i}{j}\]</span> 其中 <span class="math inline">\(i\)</span>为枚举的序列长度，<span class="math inline">\(\binom{i}{j}\)</span>代表选出 <span class="math inline">\(j\)</span> 个 <spanclass="math inline">\(&gt;1\)</span> 的数的位置，继续化简： <spanclass="math display">\[\begin{align}ans[x]&amp;=\sum_{j=1}^{16}\left(dp[j][x]\sum_{i=1}^{n}\binom{i}{j}\right)\\&amp;=\sum_{j=1}^{16}dp[j][x]\binom{n+1}{j+1}\end{align}\]</span> 这里运用了上指标求和公式：<spanclass="math inline">\(\sum\limits_{i=1}^{n}\binom{i}{j}=\binom{n+1}{j+1}\)</span>，可以借助杨辉三角记忆。</p><p>虽然 <span class="math inline">\(n\)</span> 比较大，但 <spanclass="math inline">\(\binom{n+1}{j+1}\)</span> 可以用定义 <spanclass="math inline">\(O(\log k)\)</span> 求得，故总时间复杂度 <spanclass="math inline">\(O(k\log^2k)\)</span>。</p><h2 id="cf2007e.-iris-and-the-tree"><ahref="https://codeforces.com/contest/2007/problem/E">CF2007E. Iris andthe Tree</a></h2><p>*1800 <ahref="https://codeforces.com/contest/2007/submission/303238809">Code</a></p><p>编号是 dfs 序，说明任意一条边都恰好被两条 <spanclass="math inline">\(i\to i+1\)</span>的路径经过（初次遍历时至上而下一条，回溯时至下而上一条）。</p><p>我们可以暴力地把每条 <span class="math inline">\(i\to i+1\)</span>的路径经过的点记录下来，由于总长度是 <spanclass="math inline">\(2n\)</span>，所以是线性的。</p><p>当我们给一条边赋值后，我们找到这条边对应的两条路径，此时这两条路径的边权和有两种情况：</p><ul><li>这条路径上仍然有边权不确定的点。此时可以把剩余的权值全部分配给那条边权不确定的边。</li><li>这条路径上所有边都被赋值了。此时边权和是固定的。</li></ul><p>我们可以记录两个信息以快速计算贡献，分别是已经赋值过的权值和 <spanclass="math inline">\(add\)</span> 以及未被全部赋值的路径条数 <spanclass="math inline">\(cnt\)</span>。</p><p>此时第二种情况和第一种情况的已赋值部分等价于 <spanclass="math inline">\(2\cdot add\)</span>，第一种情况的未赋值部分等价于<span class="math inline">\(cnt\cdot(w-add)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。带 <spanclass="math inline">\(\log\)</span> 是因为使用了 <code>std::set</code>来辅助计算 <span class="math inline">\(cnt\)</span>。</p><h2 id="cf2007f.-eri-and-expanded-sets"><ahref="https://codeforces.com/contest/2007/problem/F">CF2007F. Eri andExpanded Sets</a></h2><p>*2300 <ahref="https://codeforces.com/contest/2007/submission/303324539">Code</a></p><p>连续意味着排序后相邻两项的差是 <spanclass="math inline">\(1\)</span>，这引导我们思考差分数组。</p><p>结论：对于一个有序序列 <spanclass="math inline">\(\{a\}\)</span>，它不能再进行 expand当且仅当它的差分数组 <span class="math inline">\(\{b\}\)</span>全为奇数且相同。换句话说，<span class="math inline">\(\{a\}\)</span>是公差为奇数的等差数列。</p><ul><li>若 <span class="math inline">\(b_i=a_{i+1}-a_i\)</span>为偶数，则一定有 <spanclass="math inline">\(c=\frac{a_i+a_{i+1}}{2}\in(a_i,a_{i+1})\)</span>可以加进 set 里。</li><li>若存在相邻两项 <span class="math inline">\(b_i,b_{i+1}\)</span>为奇数但不同，则 <spanclass="math inline">\(b_i+b_{i+1}=a_{i+2}-a_{i}\)</span> 为偶数，且<spanclass="math inline">\(c=\frac{a_{i+2}+a_i}{2}\in(a_i,a_{i+1})\cup(a_{i+1},a_{i+2})\)</span>不在序列里，可以再 expand。</li></ul><p>进一步地，假定 <spanclass="math inline">\(g=\gcd\limits_{i\in[1,n)}(|a_{i}-a_{i+1}|)\)</span>，<spanclass="math inline">\(\{a\}\)</span> 的公差为 <spanclass="math inline">\(d\)</span>，则 <spanclass="math inline">\(d\)</span> 一定是 <spanclass="math inline">\(g\)</span> 除以 <spanclass="math inline">\(2\)</span> 的若干次幂得到。具体地，<spanclass="math inline">\(d=\dfrac{g}{\text{lowbit}(g)}\)</span>。</p><ul><li>因为任意两项的差要是公差 <span class="math inline">\(d\)</span>的倍数，故 <span class="math inline">\(d\)</span> 是相邻两项差的 <spanclass="math inline">\(\gcd\)</span> 的因数 。而 <spanclass="math inline">\(g\)</span> 能再分的前提是 <spanclass="math inline">\(g\)</span> 是偶数，故 <spanclass="math inline">\(g\)</span> 不断除以 <spanclass="math inline">\(2\)</span> 直到为奇数就得到 <spanclass="math inline">\(d\)</span>，写成公式就是上面那样。</li></ul><p>还需要注意的是这里引入了 <spanclass="math inline">\(\gcd\)</span>，根据其辗转相减的性质，结论对于无序数组依然成立。</p><p>回到题目的要求，连续即 <spanclass="math inline">\(d=1\)</span>，即：</p><p><span class="math display">\[d=\dfrac{g}{\text{lowbit}(g)}=1\Longrightarrowg=\text{lowbit}(g)\Longrightarrow g=0 \cup g=2^k,k\ge 0\]</span></p><p>转化为求 <span class="math inline">\(\{b\}\)</span> 有多少个子区间的<span class="math inline">\(\gcd\)</span> 为 <spanclass="math inline">\(0\)</span> 或 <spanclass="math inline">\(2\)</span> 的幂。</p><p>枚举左端点 <spanclass="math inline">\(L\)</span>，二分找到第一个右端点 <spanclass="math inline">\(R\)</span> 满足 <spanclass="math inline">\(\underline{\}\text{builtin}\underline{}\text{popcount}\left(\gcd\limits_{i\in[L,R]}b_i\right)=1\)</span>。则区间<span class="math inline">\([L,R], [L,R+1],[L,R+2],\cdots,[L,n]\)</span>的 <span class="math inline">\(\gcd\)</span> 均为 <spanclass="math inline">\(2\)</span> 的幂次。这是因为 <spanclass="math inline">\(2\)</span> 的幂次只有因数 <spanclass="math inline">\(2\)</span>，与任何数做 <spanclass="math inline">\(\gcd\)</span> 也只能得到 <spanclass="math inline">\(2\)</span> 的幂次。</p><p>还是通过二分找到最后一个右端点 <span class="math inline">\(R\)</span>满足 <spanclass="math inline">\(\gcd\limits_{i\in[L,R]}b_i=0\)</span>，则区间<span class="math inline">\([L,L],[L,L+1],[L,L+2],\cdots,[L,R]\)</span>的 <span class="math inline">\(\gcd\)</span> 均为 <spanclass="math inline">\(0\)</span>，原因显然。</p><p>区间 <span class="math inline">\(\gcd\)</span> 可以用 ST表实现，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2062d.-balanced-tree"><ahref="https://codeforces.com/contest/2062/problem/D">CF2062D. BalancedTree</a></h2><p>*2200 <ahref="https://codeforces.com/contest/2062/submission/303333922">Code</a></p><p>操作是：选定一个根，再让一个点的子树 <spanclass="math inline">\(+1\)</span>。</p><p>对于一条边，我们只会让它一侧的所有节点 <spanclass="math inline">\(+1\)</span>（因为两侧都加等价于整棵树加，是没有意义的）。</p><p>想象所有点都已经固定点权了，此时肯定是让点权小的一侧的所有点权 <spanclass="math inline">\(+1\)</span>。边的决策取决于两侧的节点，不妨先随意选定一个根，进行至下而上地贪心。</p><p>设 <span class="math inline">\(f[x]\)</span> 为节点 <spanclass="math inline">\(x\)</span> 的答案，并初始化一个 <spanclass="math inline">\(delta=0\)</span> 代表全局 tag。对于当前节点 <spanclass="math inline">\(x\)</span>，若为叶子，选 <spanclass="math inline">\(L[x]\)</span> 肯定不劣；否则有两种情况：</p><ul><li><span class="math inline">\(\forall y\in son[x]\)</span>，<spanclass="math inline">\(f[y]\le r[x]\)</span>。此时选 <spanclass="math inline">\(\max(l[x],\max\limits_{y\in son[x]} f[y])\)</span>肯定最优。因为可以让某一个儿子所在的子树变大，儿子之间互不影响。</li><li><span class="math inline">\(\exists y\inson[x],f[y]&gt;r[x]\)</span>。此时节点 <spanclass="math inline">\(x\)</span> 只能选 <spanclass="math inline">\(r[x]\)</span>，为了让所有节点权值一样只能让 <spanclass="math inline">\(x\)</span> 沿着根方向的子树 <spanclass="math inline">\(+1\)</span>。并且对于每个儿子所在的子树，造成的贡献是累加的，即<span class="math inline">\(delta \leftarrow delta + \sum\limits_{y\inson[x],f[y] &gt; r[x]} (f[y]-r[x])\)</span>。</li></ul><p>答案即 <span class="math inline">\(f[rt]+delta\)</span>，时间复杂度<span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2033g.-sakurako-and-chefir"><ahref="https://codeforces.com/contest/2033/problem/G">CF2033G. Sakurakoand Chefir</a></h2><p>*2200 <ahref="https://codeforces.com/contest/2033/submission/303354940">Code</a></p><p>对于一组询问 <span class="math inline">\((v,k)\)</span>，我们直接跳到<span class="math inline">\(v\)</span> 的 <spanclass="math inline">\(k\)</span> 级祖先（设为 <spanclass="math inline">\(x\)</span>）一定不劣。</p><p>那么询问等价于找 <span class="math inline">\(x\)</span> 的子树中距<span class="math inline">\(v\)</span> 最远的点。</p><p>这个最远的点一定是 <span class="math inline">\(x\)</span>的子树的两个直径端点之一。</p><p>问题转化为对树上的每个点 <spanclass="math inline">\(x\)</span>，求其子树的直径的两个端点。</p><p>这仍然是一个套路化的问题，回顾一下做法：</p><ul><li>至下而上考虑，设当前考虑的节点为 <spanclass="math inline">\(x\)</span>。</li><li>若 <span class="math inline">\(x\)</span>为叶子，两个直径端点都是它自身。</li><li>若 <span class="math inline">\(x\)</span> 恰有一个儿子 <spanclass="math inline">\(y\)</span>，考虑 <spanclass="math inline">\(x\)</span> 是否能与 <spanclass="math inline">\(y\)</span>的两个端点之一来作为新的直径，不能就直接继承 <spanclass="math inline">\(y\)</span> 的答案。</li><li>若 <span class="math inline">\(x\)</span> 有两个儿子 <spanclass="math inline">\(y_1,y_2\)</span>，答案为两种情况取 <spanclass="math inline">\(\max\)</span>：<ul><li>继承自 <span class="math inline">\(y_1\)</span> 或 <spanclass="math inline">\(y_2\)</span>。</li><li>穿过 <span class="math inline">\(x\)</span>将两段拼起来。此时新的直径端点肯定有一个来自 <spanclass="math inline">\(y_1\)</span> 的两个端点之一，另一个来自 <spanclass="math inline">\(y_2\)</span> 的两个端点之一。</li></ul></li><li>若 <span class="math inline">\(x\)</span> 有 <spanclass="math inline">\(&gt; 2\)</span>个儿子，按上一种情况每次合并两个子树，直到合并完为止。</li></ul><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1993d.-med-imize"><ahref="https://codeforces.com/contest/1993/problem/D">CF1993D.Med-imize</a></h2><p>*2200 <ahref="https://codeforces.com/contest/1993/submission/303478399">Code</a></p><p>答案具有二分性，设二分出的答案为 <spanclass="math inline">\(mid\)</span>。</p><p>中位数套路：<span class="math inline">\(\foralli\in[1,n]\)</span>，令 <spanclass="math inline">\(b[i]=\begin{cases}1&amp;,a[i]\ge mid \\-1&amp;,a[i]&lt;mid\end{cases}\ \)</span>，则 <spanclass="math inline">\(\sum b[i]&gt;0 \Longleftrightarrow mid\lemedian(a)\)</span>。</p><p>题目转化为：给定 <spanclass="math inline">\(\{b\}\)</span>，每次任选一个长为 <spanclass="math inline">\(k\)</span>的段删掉，直到不能删为止，剩下数的和是否 <spanclass="math inline">\(&gt;0\)</span>。</p><p>这里给出其中一种 dp 方案。</p><p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个数选了 <spanclass="math inline">\(j\)</span> 个长为 <spanclass="math inline">\(k\)</span> 的段删去后，剩下数和的最大值。</p><p>则 <span class="math inline">\(dp[i][j] =\max(dp[i-1][j]+b[i],dp[i-k][j - 1])\)</span>，答案为 <spanclass="math inline">\(dp[n][\left\lfloor\frac{n-1}{k}\right\rfloor]\)</span>。</p><p>考虑到 <span class="math inline">\(0\le i-jk\le k \Longrightarrowj\in\left[\left\lfloor\dfrac{i-1}{k}\right\rfloor,\left\lfloor\dfrac{i}{k}\right\rfloor\right]\)</span>，即<span class="math inline">\(j\)</span> 只有两种取值。</p><p>故不妨令 <span class="math inline">\(dp[i][j=0/1]\)</span> 表示前<span class="math inline">\(i\)</span> 个数选了 <spanclass="math inline">\(\left\lfloor\dfrac{i-1}{k}\right\rfloor+j\)</span>个长为 <span class="math inline">\(k\)</span>的段删去后，剩下数和的最大值。</p><p>使用记忆化搜索转移，时间复杂度 <span class="math inline">\(O(n\logw)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p><p>官方题解里是另一种dp，我花了半个小时仍未完全理解，希望有生之年能够参悟。</p><h2 id="cf1993f1f2.-dyn-scripted-robot"><ahref="https://codeforces.com/contest/1993/problem/F2">CF1993F1/F2.Dyn-scripted Robot</a></h2><p>*2400 <ahref="https://codeforces.com/contest/1993/submission/303822753">Code</a>（F1）</p><p>*2800 <ahref="https://codeforces.com/contest/1993/submission/303832230">Code</a>（F2）</p><p>我们假定一个在没有墙的二维平面中移动的机器人称作 <spanclass="math inline">\(B\)</span>，题中的机器人称作 <spanclass="math inline">\(A\)</span>。由于 <spanclass="math inline">\(B\)</span> 相比 <spanclass="math inline">\(A\)</span>取消了墙的限制，移动序列自然不会改变。</p><p>结论：<span class="math inline">\(A\)</span> 回到原点的次数 <spanclass="math inline">\(\Longleftrightarrow\)</span> <spanclass="math inline">\(B\)</span> 经过点 <spanclass="math inline">\((x,y),\begin{cases}x\equiv 0\pmod{2w} \\ y\equiv 0\pmod{2h} \end{cases}\)</span> 的次数。</p><ul><li>先考虑只存在沿 <span class="math inline">\(y\)</span>轴方向的移动，当 <span class="math inline">\(A\)</span> 撞到 <spanclass="math inline">\(y=h\)</span> 后，<spanclass="math inline">\(A,B\)</span> 运动轨迹沿 <spanclass="math inline">\(y=h\)</span> 轴对称；而 <spanclass="math inline">\(A\)</span> 再撞到 <spanclass="math inline">\(y=0\)</span>（<spanclass="math inline">\(B\)</span> 撞到 <spanclass="math inline">\(y=2h\)</span>）后，二者运动方向恢复一致。<spanclass="math inline">\(x\)</span>轴方向的运动同理，外推后不难得出该结论。</li></ul><p>故只需研究 <span class="math inline">\(B\)</span> 的运动即可。设<span class="math inline">\(x_i\ (i\in[1,n])\)</span> 表示 <spanclass="math inline">\(B\)</span> 从 <spanclass="math inline">\((0,0)\)</span> 开始，经过 <spanclass="math inline">\(i\)</span> 次移动后的横坐标（在 <spanclass="math inline">\(\bmod 2w\)</span> 同余系下）; <spanclass="math inline">\(y_i\ (i\in[1,n])\)</span> 表示 <spanclass="math inline">\(B\)</span> 从 <span class="math inline">\((0,0)\)</span> 开始，经过 <span class="math inline">\(i\)</span>次移动后的纵坐标（在 <span class="math inline">\(\bmod 2h\)</span>同余系下）。</p><p>假设 <span class="math inline">\(B\)</span> 已经执行了完整的移动序列<span class="math inline">\(i\in[0,k)\)</span> 次，并额外移动了 <spanclass="math inline">\(j\in[1,n]\)</span> 次，那么坐标为 <spanclass="math inline">\((ix_n+x_j,iy_n+y_j)\)</span>。题目转化为求有序对<span class="math inline">\((i,j)\)</span> 的数目，满足：</p><p><span class="math display">\[\begin{cases}x\equiv 0 \pmod{2w} \\y\equiv 0 \pmod{2h}\end{cases}\Longrightarrow\begin{cases}ix_n+x_j\equiv 0 \pmod{2w} \\iy_n+y_j\equiv 0 \pmod{2h}\end{cases}\]</span></p><p>对于 F1，将式子变形，得到：</p><p><span class="math display">\[\begin{cases}x_j\equiv -ix_n \pmod{2w} \\y_j\equiv -iy_n \pmod{2h}\end{cases}\]</span></p><p>我们可以把执行一次移动序列经过的点的坐标存到一个<code>std::map</code> 里，然后枚举 <spanclass="math inline">\(i\in[0,k)\)</span>，查一下 <code>std::map</code>中点 <span class="math inline">\((-ix_n,-iy_n)\)</span>的值即可。时间复杂度 <span class="math inline">\(O(k\logn)\)</span>。</p><p>对于 F2，将式子变形，得到：</p><p><span class="math display">\[\begin{cases}ix_n\equiv -x_j \pmod{2w} \\iy_n\equiv -y_j \pmod{2h}\end{cases}\]</span></p><p>在这个方程组中，除了 <span class="math inline">\(i\)</span>均为已知，于是可以枚举 <spanclass="math inline">\(x_j\)</span>，用中国剩余定理解 <spanclass="math inline">\(n\)</span> 遍即可。在此之前，还需要把方程转化为<span class="math inline">\(x\equiv a\pmod{p}\)</span> 的标准形式。</p><p>由于 <span class="math inline">\(a\)</span> 在 <spanclass="math inline">\(\bmod p\)</span> 下的逆元仅在 <spanclass="math inline">\(a,p\)</span> 互质时存在，故令 <spanclass="math inline">\(g=\gcd(2w,x_n)\)</span>，则：</p><p><span class="math display">\[\begin{align}ix_n&amp;\equiv -x_j \pmod{2w}\\i\cdot\frac{x_n}{g}&amp;\equiv -\frac{x_j}{g}\pmod{\frac{2w}{g}}\\i &amp;\equiv-\frac{x_j}{g}\left(\frac{x_n}{g}\right)^{-1}\pmod{\frac{2w}{g}}\end{align}\]</span></p><p>显然当 <span class="math inline">\(g \nmid x_j\)</span>时方程无解。另一个方程组同理。</p><p>对于一组 <span class="math inline">\((x_j,y_j)\)</span>，用 CRT解出最小的 <span class="math inline">\(i\)</span> 后，问题转化为 <spanclass="math inline">\(i,i+M,i+2M,\cdots\)</span> 中有几个在 <spanclass="math inline">\([0,k-1)\)</span> 范围内，答案是 <spanclass="math inline">\(\dfrac{k-1-i}{M}+1\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p><h2 id="cf1972d.-reverse-card-hard-version"><ahref="https://codeforces.com/contest/1972/problem/D2">CF1972D. ReverseCard (Hard Version)</a></h2><p>*2200 <ahref="https://codeforces.com/contest/1972/submission/303818473">Code</a></p><p>题目要求满足 <span class="math inline">\(a\in[1,n]\)</span>，<spanclass="math inline">\(b\in[1,m]\)</span>，<spanclass="math inline">\((a+b)\mid b\cdot\gcd(a,b)\)</span> 的有序对 <spanclass="math inline">\((a,b)\)</span> 的数量。</p><p>令 <span class="math inline">\(d=\gcd(a,b)\)</span>，<spanclass="math inline">\(a=pd\)</span>，<spanclass="math inline">\(b=qd\)</span>，则 <spanclass="math inline">\(\gcd(p,q)=1\)</span>。代入得： <spanclass="math display">\[\begin{align}a+b&amp;\mid b\cdot\gcd(a,b)\\\to (p+q)d&amp;\mid qd^2 \\\to \quad \ p+q&amp;\mid qd\\\to \quad\ p+q&amp;\mid d\end{align}\]</span> 最后一步是因为 <span class="math inline">\(\gcd(p,q)=1 \to\gcd(p+q,q)=1\)</span>。</p><p>又因为：</p><p><span class="math display">\[\begin{align}p+q\mid d \to p+q\le d\to p\le d=\dfrac{a}{p}\le \dfrac{n}{p}\end{align}\]</span></p><p>于是 <span class="math inline">\(p^2 \le n \top\in[1,\sqrt{n}]\)</span>，同理 <spanclass="math inline">\(q\in[1,\sqrt{m}]\)</span>。</p><p><span class="math inline">\(O(\sqrt{nm})\)</span> 枚举 <spanclass="math inline">\(p,q\)</span>，当 <spanclass="math inline">\(\gcd(p,q)=1\)</span> 时，贡献等价于有多少 <spanclass="math inline">\(d\)</span> 满足 <spanclass="math inline">\(p+q\mid d\)</span> 且 <spanclass="math inline">\(d\le \min(\dfrac{n}{p},\dfrac{m}{q})\)</span>，即<spanclass="math inline">\(\left\lfloor\dfrac{\min(\dfrac{n}{p},\dfrac{m}{q})}{p+q}\right\rfloor\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1824b2.-luotianyi-and-the-floating-islands-hard-version"><ahref="https://codeforces.com/contest/1824/problem/B2">CF1824B2.LuoTianyi and the Floating Islands (Hard Version)</a></h2><p>*2300 <ahref="https://codeforces.com/contest/1824/submission/304516792">Code</a></p><p>规定有人的点称为黑点，到所有黑点距离和最小的点称为目标点。</p><p>结论：目标点构成一个连通块。</p><ul><li>比较显然。</li></ul><p>结论：当 <span class="math inline">\(k\)</span> 为奇数时，答案为<span class="math inline">\(1\)</span>。</p><ul><li>对于任意一个有奇数个黑点的局面，假定我们已经找到了一个目标点 <spanclass="math inline">\(x\)</span>。若存在 <spanclass="math inline">\(x\)</span> 的一个邻居 <spanclass="math inline">\(y\)</span> 也是目标点，那么 <spanclass="math inline">\(x\to y\)</span>移动的过程中理应没有额外贡献，换句话说边 <spanclass="math inline">\((x,y)\)</span>两侧黑点数目相同。此时黑点个数定为偶数，矛盾。故对于任意一个奇数个黑点的局面有且仅有一个目标点。</li></ul><p>接下来考虑将点的贡献放到边上，好处是目标点构成连通块，边的数量总是目标点数量<span class="math inline">\(-1\)</span>，而且边的贡献容易计算。</p><p>当 <span class="math inline">\(k\)</span>为偶数时，根据上述分析，一条边当且仅当两侧黑点数目相同时有贡献，故贡献为两侧各选<span class="math inline">\(\dfrac{k}{2}\)</span> 个黑点的方案数。</p><p>任选根计算出 <span class="math inline">\(sz[x]\)</span>为子树大小，那么答案即 <spanclass="math inline">\(\dfrac{\sum\limits_{x=1}^{n}\sum\limits_{y\inson[x]}\dbinom{sz[y]}{\dfrac{k}{2}}\dbinom{n-sz[y]}{\dfrac{k}{2}}}{\dbinom{n}{k}}+1\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1989d.-smithing-skill"><ahref="https://codeforces.com/contest/1989/problem/D">CF1989D. SmithingSkill</a></h2><p>*1900 <ahref="https://codeforces.com/contest/1989/submission/304548337">Code</a></p><p>首先，不同 <span class="math inline">\(c_j\)</span>互不影响。其次，对于一个 <spanclass="math inline">\(c_j\)</span>，肯定是选满足 <spanclass="math inline">\(c_j\ge a_i\)</span> 的武器中 <spanclass="math inline">\(a_i-b_i\)</span>最小的武器，并不断地合成再焚毁直到 <span class="math inline">\(c_j &lt;a_i\)</span> 为止。</p><p>考虑阈值分治，令 <span class="math inline">\(A=\maxa_i\)</span>，可以先对每个 <spanclass="math inline">\(i\in[1,A]\)</span> 预处理出 <spanclass="math inline">\(res[i]\)</span> 表示 <spanclass="math inline">\(i\)</span> 个矿石能够获得的最大经验点数；而对于<span class="math inline">\(c_j &gt; A\)</span> 的询问，用最小的 <spanclass="math inline">\(a_i-b_i\)</span> 处理直到 <spanclass="math inline">\(c_j \le A\)</span>，就能直接查表查到 <spanclass="math inline">\(res[c_j]\)</span>。</p><p>其中 <span class="math inline">\(res[i]\)</span>的预处理仍然不简单，我们可以定义一个辅助数组 <spanclass="math inline">\(d[i]\)</span> 表示所有 <spanclass="math inline">\(a_i \le i\)</span> 的武器里面 <spanclass="math inline">\(a_i-b_i\)</span> 的最小值。在此基础上，有递推<span class="math inline">\(res[i]=2+res[i-d[i]]\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n+w+m)\)</span>，<spanclass="math inline">\(w\)</span> 为值域。</p><h2 id="cf1972e.-fenwick-tree"><ahref="https://codeforces.com/contest/1972/problem/E">CF1972E. FenwickTree</a></h2><p>*2300 <ahref="https://codeforces.com/contest/1972/submission/304751560">Code</a></p><p>首先要知道树状数组的结构是怎么样的，这里引用题解的一张图。</p><p><img src="/image/academic/fenwick.png" /></p><p>其中 <span class="math inline">\(c_1,c_2,\cdots c_{10}\)</span>就是迭代一次后的数组，即 <spanclass="math inline">\(f^{1}(a)\)</span>。</p><p>故每次迭代相当于把上一次迭代后的数组作为叶子，再向上合并一遍。</p><p>我们考虑对每个 <spanclass="math inline">\(c_i\)</span>，把它的贡献从它的祖先中除去。</p><p>例如，当 <span class="math inline">\(k=1\)</span> 时，对于 <spanclass="math inline">\(c_1\)</span>，要把 <spanclass="math inline">\(c_1\)</span> 从 <spanclass="math inline">\(c_2,c_4,c_8\)</span> 中除去，此时系数显然都是<span class="math inline">\(1\)</span>。（系数即 “减去几倍的 <spanclass="math inline">\(c_1\)</span>”）</p><p>当 <span class="math inline">\(k=2\)</span> 时，<spanclass="math inline">\(c_2\)</span> 在第一次迭代的基础上再累加了一遍<span class="math inline">\(c_1\)</span>，系数是 <spanclass="math inline">\(1+1=2\)</span>；<spanclass="math inline">\(c_4\)</span> 累加了 <spanclass="math inline">\(c_2\)</span>，系数是 <spanclass="math inline">\(1+2=3\)</span>；<spanclass="math inline">\(c_8\)</span> 累加了 <spanclass="math inline">\(c_4\)</span>，系数是 <spanclass="math inline">\(1+3=4\)</span>。</p><p>当 <span class="math inline">\(k=3\)</span> 时，<spanclass="math inline">\(c_2\)</span> 再累加一遍 <spanclass="math inline">\(c_1\)</span>，系数是 <spanclass="math inline">\(2+1=3\)</span>；<spanclass="math inline">\(c_4\)</span> 累加 <spanclass="math inline">\(c_2\)</span>，系数是 <spanclass="math inline">\(3+3=6\)</span>；<spanclass="math inline">\(c_8\)</span> 累加 <spanclass="math inline">\(c_4\)</span>，系数是 <spanclass="math inline">\(4+6=10\)</span>。</p><p>可以发现，对于相同的 <spanclass="math inline">\(k\)</span>，系数只和向上爬升的层数有关，列成一个表。</p><p><span class="math inline">\(k=1\to 1,1,1,1,1,\cdots\)</span></p><p><span class="math inline">\(k=2\to 2,3,4,5,\cdots\)</span></p><p><span class="math inline">\(k=3\to 3,6,10,\cdots\)</span></p><p><span class="math inline">\(k=4\to 4,10,\cdots\)</span></p><p>将这个三角形摆正，可以发现就是杨辉三角。</p><p>其中，第 <span class="math inline">\(i\)</span> 行第 <spanclass="math inline">\(j\)</span> 项表示 <spanclass="math inline">\(k=i\)</span> 时向上爬升 <spanclass="math inline">\(j\)</span> 层需要减去的系数，组合数写出来就是<span class="math inline">\(\dbinom{i+j-1}{j}\)</span>。</p><p>由于树状数组不超过 <span class="math inline">\(\log n\)</span>层，故时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1996g.-penacony"><ahref="https://codeforces.com/contest/1996/problem/G">CF1996G.Penacony</a></h2><p>*2200 <ahref="https://codeforces.com/contest/1996/submission/304762843">Code1</a><ahref="https://codeforces.com/contest/1996/submission/304805042">Code2</a></p><p><strong>solution1</strong>：对于一对朋友 <spanclass="math inline">\((a,b)\)</span>，他们之间有且仅有两条路径，并且这两条路径构成一个环。因此最为关键的观察是’“只要钦定某一条边是断开的，那么每一对朋友间的路径就是唯一的”。</p><p>建一棵 <span class="math inline">\(n\)</span>个点的线段树，每个位置的值代表对应的道路被几对朋友占用了。一开始，先将所有<span class="math inline">\([a,b)\)</span> 区间 <spanclass="math inline">\(+1\)</span>。从左到右枚举每条边并钦定为断开，如遇到左端点就将<span class="math inline">\([1,a),[b,n]+1\)</span>，<spanclass="math inline">\([a,b)-1\)</span>；如遇右端点就将 <spanclass="math inline">\([1,a),[b,n]-1\)</span>，<spanclass="math inline">\([a,b)+1\)</span>。每次修改完查询 <spanclass="math inline">\([1,n]\)</span> 中 <spanclass="math inline">\(0\)</span>出现的次数就是非必须保留的道路数目。</p><p>由于整个修改过程线段树保存的值非负，故 <spanclass="math inline">\(0\)</span> 出现的次数等价于最小值出现的次数。</p><p><strong>solution2</strong>：将这 <spanclass="math inline">\(n\)</span> 个点 <spanclass="math inline">\(n\)</span> 条边看成一个 <spanclass="math inline">\(n\)</span> 边形，对于一对朋友 <spanclass="math inline">\((a,b)\)</span>，在 <spanclass="math inline">\(a,b\)</span> 间连对角线。</p><p>断言：对于任意两条边，如果它们被相同的对角线集合覆盖，那么这两条边可以删去。</p><ul><li>你可以想象每条对角线都有正反面，正面对应多边形上的边和反面对应多边形上的边被认为是不同的。就一对朋友关系而言，你能且仅能选择两段其一。</li></ul><p>对于每条对角线，我们不妨把其任一侧的所有边异或上一个固定的值。</p><p>利用差分和前缀和，就能 <span class="math inline">\(O(n)\)</span>求出每条边在 “染色”后的权值。此时两条边权值相同就等价于被相同的对角线集合覆盖了。</p><p>最后，用一个 <code>std::map</code> 统计出现次数最多的权值即可。</p><p>两种方法时间复杂度均为 <span class="math inline">\(O(n\logn)\)</span>，后者常数小很多。</p><h2 id="cf1983e.-i-love-balls"><ahref="https://codeforces.com/contest/1983/problem/E">CF1983E. I LoveBalls</a></h2><p>*2300 <ahref="https://codeforces.com/contest/1983/submission/305424717">Code</a></p><p>数学题。令 <spanclass="math inline">\(special=\dfrac{\sum_{i=1}^{k}v_i}{k}\)</span>，<spanclass="math inline">\(normal=\dfrac{\sum_{i=k+1}^{n}v_i}{n-k}\)</span>，分别表示特殊球和普通球的期望价值。</p><p>考虑将 <span class="math inline">\(k\)</span> 特殊球插进 <spanclass="math inline">\(n-k+1\)</span> 个普通球的 gap 里面，每个 gap可以放多个特殊球，这么建立模型的好处是你选中一个 gap 就拿完这个 gap里的所有球，符合特殊球的机制。</p><p>Alice 会选中 <spanclass="math inline">\(\left\lceil\dfrac{n-k+1}{2}\right\rceil\)</span>个 gap，每个 gap 里特殊球期望有 <spanclass="math inline">\(\dfrac{k}{n-k+1}\)</span> 个，故 Alice选中特殊球价值的期望总和是 <spanclass="math inline">\(\dfrac{\lceil\frac{n-k+1}{2}\rceil \cdotk}{n-k+1}\cdot special\)</span>。</p><p>而 Alice 作为先手会选中 <spanclass="math inline">\(\left\lceil\dfrac{n-k}{2}\right\rceil\)</span>个普通球，故他选中普通球价值的期望总和是 <spanclass="math inline">\(\left\lceil\dfrac{n-k}{2}\right\rceil\cdotnormal\)</span>。</p><p>根据期望的线性性， 上述两个式子相加就是 Alice 的答案。Bob的答案即所有球的价值总和减去 Alice 的答案。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf1983f.-array-value"><ahref="https://codeforces.com/contest/1983/problem/F">CF1983F.array-value</a></h2><p>*2500 <ahref="https://codeforces.com/contest/1983/submission/305454555">Code</a></p><p>二分答案，设二分出的答案是 <spanclass="math inline">\(mid\)</span>，若至少有 <spanclass="math inline">\(k\)</span> 个区间的 value <spanclass="math inline">\(\le mid\)</span>，就往小二分，否则往大二分。</p><p>问题转化为判断求有多少个区间的 value <span class="math inline">\(\lemid\)</span>。</p><p>不妨枚举右端点 <spanclass="math inline">\(r\)</span>，此时只需找到最大的 <spanclass="math inline">\(l\)</span> 满足 <span class="math inline">\(a_l\oplus a_r \le mid\)</span>，那么左端点位于 <spanclass="math inline">\([1,l]\)</span> 内构成的区间均满足条件。</p><p>这是个经典的问题，使用一个 trie 就能维护，步骤如下：</p><ul><li>对每个 trie 树上的节点 <span class="math inline">\(p\)</span>维护一个 <span class="math inline">\(mx[p]\)</span>存储经过这个点的值中下标最大值。</li><li>假设当前对 <span class="math inline">\(a_i\)</span>进行查询，我们要返回一个最大的 <span class="math inline">\(j\)</span>满足 <span class="math inline">\(a_j\oplus a_i \lemid\)</span>。从大到小枚举每一位，设 <spanclass="math inline">\(a_i\)</span> 当前位为 <spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(mid\)</span> 当前位为 <spanclass="math inline">\(m\)</span>。<ul><li>若 <span class="math inline">\(m=0\)</span>，为了满足 <spanclass="math inline">\(\le mid\)</span> 的条件，<spanclass="math inline">\(a_j\)</span> 这一位应和 <spanclass="math inline">\(x\)</span> 相同，故只能向 <spanclass="math inline">\(x\)</span> 的方向走。</li><li>若 <spanclass="math inline">\(m=1\)</span>，那么两边都可以走：如果向 <spanclass="math inline">\(x\)</span> 一侧走，之后无论怎么走得到的 <spanclass="math inline">\(a_j\)</span> 都会满足 <spanclass="math inline">\(a_j \oplus a_i \le mid\)</span>，故直接累加 <spanclass="math inline">\(x\)</span> 一侧的 <spanclass="math inline">\(mx[p]\)</span>，并转而走向 <spanclass="math inline">\(x\)</span> 的对侧。</li></ul></li><li>最后走到底得到的 <span class="math inline">\(a_j\)</span>一样满足条件，故答案还要和末尾节点的 <spanclass="math inline">\(mx[p]\)</span> 取 <spanclass="math inline">\(\max\)</span>。</li></ul><p>时间复杂度 <span class="math inline">\(O(n\log^2w)\)</span>，<spanclass="math inline">\(w\)</span> 为值域。</p><h2 id="cf2004f.-make-a-palindrome"><ahref="https://codeforces.com/contest/2004/problem/F">CF2004F. Make aPalindrome</a></h2><p>*2600 <ahref="https://codeforces.com/contest/2004/submission/305497742">Code</a></p><p>结论：两种操作对最小操作次数的影响等价，即任选其中一种操作或两种操作都用得到的答案相同。</p><ul><li>考虑对于一个 <span class="math inline">\(\{b\}\)</span>，如何计算<span class="math inline">\(f(b)\)</span>。设 <spanclass="math inline">\(\{b\}\)</span> 中第一个元素是 <spanclass="math inline">\(b_1\)</span>，最后一个是 <spanclass="math inline">\(b_n\)</span>。首先若 <spanclass="math inline">\(b_1=b_n\)</span>，可以将它们从序列中拿掉，直到<span class="math inline">\(b_1 \neqb_n\)</span>。此时如果使用分裂操作肯定是选择将 <spanclass="math inline">\(b_1,b_n\)</span>中较大的那个分解成较小的那个，不妨设 <span class="math inline">\(b_1&lt; b_n\)</span>，则相当于耗费一次操作将 <spanclass="math inline">\(b_1,b_n\)</span> 去掉并在右侧添加一个 <spanclass="math inline">\(b_n-b_1\)</span>。此时若 <spanclass="math inline">\(b_n-b_1 \neqb_2\)</span>，那么此次分裂只是单纯把序列元素个数减少了一个，合并操作同样能做到。若<spanclass="math inline">\(b_n-b_1=b_2\)</span>，说明此时可以额外将最左侧的<span class="math inline">\(b_2\)</span> 和最右侧的 <spanclass="math inline">\(b_n-b_1\)</span>去掉，一次操作相当于减少了两个元素；但移项可知 <spanclass="math inline">\(b_1+b_2=b_n\)</span>，说明最开始我们如果在左侧用一次合并生成<span class="math inline">\(b_1+b_2\)</span> 再和右边的 <spanclass="math inline">\(b_n\)</span>抵掉，也是减少了两个元素。于是分裂和合并操作是等价的。</li></ul><p>接下来我们只讨论合并操作。在最极端的情况下，将长为 <spanclass="math inline">\(n\)</span> 的序列变成回文需要 <spanclass="math inline">\(n-1\)</span>次操作，考虑什么情况能减少操作次数。</p><p>结论：对于一个序列，如果其某一个非空前缀和某一个非空后缀的元素和相同，就能减少一次操作。</p><ul><li>设序列长为 <span class="math inline">\(n\)</span>，若 <spanclass="math inline">\([1,l]\)</span> 和 <spanclass="math inline">\([r,n]\)</span>的元素和相同，说明从两端移去数的过程进行到只剩 <spanclass="math inline">\(\sum\limits_{i=1}^{l-1}a_i,a_l,a_{l+1},\cdots,a_{r-1},\sum\limits_{i=r}^{n}a_i\)</span>或 <spanclass="math inline">\(\sum\limits_{i=1}^{l}a_i,a_{l+1},\cdots,a_{r-1},a_r,\sum\limits_{i=r+1}^{n}a_i\)</span>时，头两个元素合并或后两个元素合并就能额外减少一个元素，换句话说少用了一次操作，并且操作后序列的结构和操作前一致，可以继续寻找最近的非空前缀和最近的非空后缀。</li></ul><p>特别地，找到的非空前缀和非空后缀可以相交，如何理解？若有 <spanclass="math inline">\([1,l]\)</span> 和 <spanclass="math inline">\([r,n]\)</span> 元素和相等但 <spanclass="math inline">\(l&gt;r\)</span>，说明一定有 <spanclass="math inline">\([1,r]\)</span> 和 <spanclass="math inline">\([l,n]\)</span> 元素和相等而中间 <spanclass="math inline">\([r,l]\)</span> 的部分共用，此时 <spanclass="math inline">\([r,l]\)</span> 一定构成回文串而不用删掉。</p><p>回到原本的问题上来，我们要计算 <spanclass="math inline">\(\{a\}\)</span> 所有非空子数组 <spanclass="math inline">\(\{b\}\)</span> 的 <spanclass="math inline">\(f(b)\)</span> 之和。假若我们在 <spanclass="math inline">\(\{a\}\)</span> 中发现了一组 <spanclass="math inline">\([l_1,r_1]\)</span>，<spanclass="math inline">\([l_2,r_2]\)</span>元素和相等，那么这两段如果要作为前后缀只能是对 <spanclass="math inline">\([l_1,r_2]\)</span> 有 <spanclass="math inline">\(-1\)</span>的贡献，对其它区间都没有贡献，故对整个序列的贡献就是 <spanclass="math inline">\(-1\)</span>。</p><p>故题目转化为求 <span class="math inline">\(\{a\}\)</span>中有多少对非空子区间相等，枚举每个区间存到 <code>std::map</code>里统计即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p><h2 id="cf1821d.-black-cells"><ahref="https://codeforces.com/contest/1821/problem/D">CF1821D. BlackCells</a></h2><p>*1900 <ahref="https://codeforces.com/contest/1821/submission/305852685">Code1</a><ahref="https://codeforces.com/contest/1821/submission/305851032">Code2</a></p><p><strong>solution1</strong>：通过观察能得出结论：选择长度 <spanclass="math inline">\(\ge 2\)</span> 的区间一定不劣。</p><ul><li>随便举个例子：假设 <span class="math inline">\(k=4\)</span>，对于<span class="math inline">\([1,1]\)</span> 和 <spanclass="math inline">\([4,7]\)</span>，选择两个区间最少消耗 <spanclass="math inline">\(10\)</span> 次操作，如果只选 <spanclass="math inline">\([4,7]\)</span> 则最少只消耗 <spanclass="math inline">\(9\)</span> 次。但若是 <spanclass="math inline">\([1,2]\)</span> 和 <spanclass="math inline">\([4,7]\)</span>，无论选择两个区间还是只选 <spanclass="math inline">\([4,7]\)</span>，最少都是消耗 <spanclass="math inline">\(9\)</span> 次操作。</li></ul><p>于是我们记录 <span class="math inline">\(\text{one}\)</span> 和 <spanclass="math inline">\(\text{sum}\)</span> 分别代表长为 <spanclass="math inline">\(1\)</span> 的区间个数和长度 <spanclass="math inline">\(\ge 2\)</span> 的区间的长度和。从左到右扫，分<span class="math inline">\(\text{sum}\ge k\)</span> 和 <spanclass="math inline">\(\text{sum}+\text{one}\ge k\)</span> 讨论即可。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><strong>solution2：</strong>显然选长度尽可能大的区间更优，故使用反悔贪心。</p><p>压入堆中的是已经选择的区间的长度。每当堆中元素和 <spanclass="math inline">\(\ge k\)</span>，就把最小的元素弹出来。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf1821e.-rearrange-brackets"><ahref="https://codeforces.com/contest/1821/problem/E">CF1821E. RearrangeBrackets</a></h2><p>*2100 <ahref="https://codeforces.com/contest/1821/submission/305857599">Code</a></p><p>题意差评，一堆能让人误会的地方。</p><p>首先，对于给定的平衡括号序列，得到最小 cost的方式是每次移除最右侧的相邻括号对。</p><p>对于两对括号 <span class="math inline">\(A,B\)</span>，如果 <spanclass="math inline">\(A\)</span> 包含 <spanclass="math inline">\(B\)</span>，就连一条 <spanclass="math inline">\(A\to B\)</span> 的边，建出括号森林。不妨设节点<span class="math inline">\(1\)</span> 是虚根，这样得到一棵括号树。</p><p>那么移除节点 <span class="math inline">\(x\)</span> 的代价就是 <spanclass="math inline">\(x\)</span> 的非 <spanclass="math inline">\(1\)</span>祖先数目。换句话说，对于任意一个点，它子树内的每个点都有 <spanclass="math inline">\(1\)</span> 的贡献，即这组括号序列的最小 cost 是<span class="math inline">\(\sum\limits_{i=2} sz[i]-1\)</span>。</p><p>考虑移动一个括号，可行的移动方式是 <spanclass="math inline">\(A(B)C\to A()BC\)</span>，这等价于把一个点 <spanclass="math inline">\(x\)</span> 的儿子接到父亲上，再把 <spanclass="math inline">\(x\)</span>删去。不难发现这个过程是无序的（即只要删除的点集是一样的得到的括号树就一样），你只要将<span class="math inline">\(sz[i]-1\)</span> 排序后选最大的 <spanclass="math inline">\(k\)</span> 个删去就行。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。<spanclass="math inline">\(k\)</span> 的范围十分诈骗。</p><h2 id="cf2022e2.-billetes-mxhard-version"><ahref="https://codeforces.com/contest/2022/problem/E2">CF2022E2. BilletesMX（Hard Version）</a></h2><p>*2600 <ahref="https://codeforces.com/contest/2022/submission/305865364">Code</a></p><p>结论：对于一个 beautiful 的 <span class="math inline">\(n\timesm\)</span> 网格，一定存在长为 <span class="math inline">\(n\)</span>的序列 <span class="math inline">\(\{X\}\)</span> 和长为 <spanclass="math inline">\(m\)</span> 的序列 <spanclass="math inline">\(\{Y\}\)</span> 满足 <spanclass="math inline">\(a[i][j]=X[i]\oplus Y[j]\)</span>。</p><ul><li>容易说明，对于一个 beautiful的网格，我们将任意一行异或上任意一个数后得到的新网格仍然beautiful。于是我们进行如下操作：将每一行都异或上那行的第一个数，每一列都异或上那列的第一个数。这样我们得到了一个第一行、第一列全为<span class="math inline">\(0\)</span> 的网格，它仍然 beautiful。</li><li>此时 <span class="math inline">\(\foralli\in[2,n],j\in[2,m]\)</span>，有 <span class="math inline">\(a[i][j]\oplus a[1][j]\oplus a[i][1] \oplus a[1][1]=0\)</span>，由于后三项均为<span class="math inline">\(0\)</span>，则 <spanclass="math inline">\(a[i][j]=0\)</span>。我们取第一列为序列 <spanclass="math inline">\(\{X\}\)</span>，第一行为序列 <spanclass="math inline">\(\{Y\}\)</span>，由 <spanclass="math inline">\(a[i][j]\)</span> 在异或完 <spanclass="math inline">\(X[i]\)</span> 和 <spanclass="math inline">\(Y[j]\)</span> 后为 <spanclass="math inline">\(0\)</span>，可知 <spanclass="math inline">\(a[i][j]=X[i]\oplus Y[j]\)</span>。</li></ul><p>那么，<span class="math inline">\(a[i][j]\)</span> 给定意味着 <spanclass="math inline">\(X[i] \oplus Y[j]\)</span>给定，我们建立一个图论模型：一个 <spanclass="math inline">\(n+m\)</span> 个点的图，点 <spanclass="math inline">\(1\sim n\)</span> 代表对应的行，点 <spanclass="math inline">\(n+1\sim n+m\)</span> 代表对应的列，给定 <spanclass="math inline">\(a[i][j]\)</span> 就连一条 <spanclass="math inline">\(i \to n+j\)</span> 边权为 <spanclass="math inline">\(a[i][j]\)</span> 的边。</p><p>根据异或的性质，在这个图中所有的环都要满足 “环上的边权异或和为 <spanclass="math inline">\(0\)</span>”。若不满足，答案就是 <spanclass="math inline">\(0\)</span>。否则方案数是什么呢？考虑一个没填数的格子，不妨设它的坐标是<span class="math inline">\((r, c)\)</span>，将它填上相当于将点 <spanclass="math inline">\(r\)</span> 和点 <spanclass="math inline">\(n+c\)</span> 连起来了，分两种情况：</p><ul><li>连之前 <span class="math inline">\(r\)</span> 和 <spanclass="math inline">\(n+c\)</span>就在一个连通块里了。此时新加进的这条边能构成一个新环，由于一个环上的边异或和要为<span class="math inline">\(0\)</span>，这条新边权值自然是固定的，答案<span class="math inline">\(\times 1\)</span>。</li><li>连之前 <span class="math inline">\(r\)</span> 和 <spanclass="math inline">\(n+c\)</span>不在一个连通块中。此时新加进的这条边不组成任何一个环，边权就能取任何一个<span class="math inline">\([0,2^{30}-1]\)</span> 中的值，故答案 <spanclass="math inline">\(\times 2^{30}\)</span>。</li></ul><p>也就是说，对于当前的一个局面，有 <spanclass="math inline">\(cnt\)</span> 个连通块，且所有环都满足边权异或和为<span class="math inline">\(0\)</span>，答案就是 <spanclass="math inline">\(2^{30\cdot cnt}\)</span>。</p><p>连通块数目用并查集容易维护，只用考虑如何每次修改后都 check 异或和为<span class="math inline">\(0\)</span> 的条件。</p><p>实际上这个问题同样能用并查集维护：我们对图上每个点 <spanclass="math inline">\(x\)</span> 记录一个 <spanclass="math inline">\(g[x]\)</span> 表示 <spanclass="math inline">\(x\)</span>到它所在连通块的根的距离（这个根也就是并查集里 find得到的点）。那么并查集 merge 的时候如果发现 <spanclass="math inline">\(x,y\)</span> 在一个连通块中且 <spanclass="math inline">\(g[x]\oplus g[y] \neqw\)</span>，就说明我们发现了异或和 <spanclass="math inline">\(&gt;0\)</span> 的环。</p><p><span class="math inline">\(g[x]\)</span> 则通过以下操作维护：</p><ul><li>find 函数回溯时 <span class="math inline">\(g[x] =g[x]\oplusg[fa[x]]\)</span>。</li><li>merge 时假定 <span class="math inline">\(fa[rt_y]=rt_x\)</span>，则<span class="math inline">\(g[rt_y]=(g[x] \oplus g[y]\oplusw)\)</span>。</li></ul><p>给一幅图帮助理解，不再赘述。</p><p><img src="/image/academic/dsu.png" /></p><p>时间复杂度 <span class="math inline">\(O((n+q)\alpha)\)</span>。</p><h2 id="cf1972f.-long-way-to-be-non-decreasing"><ahref="https://codeforces.com/contest/1972/problem/F">CF1972F. Long Wayto be Non-decreasing</a></h2><p>*2800 <ahref="https://codeforces.com/contest/1972/submission/306070777">Code</a></p><p>建图：<span class="math inline">\(\forall i\in [1, m]\)</span>，<spanclass="math inline">\(i\to b_i\)</span>。</p><p>问题转化为：求最小的 <span class="math inline">\(k\)</span>，使得每个<span class="math inline">\(a_i\)</span> 最多能在图上走 <spanclass="math inline">\(k\)</span> 步，得到的序列单调不降。</p><p>容易发现答案单调，于是二分答案，设二分出的答案是 <spanclass="math inline">\(mid\)</span>。</p><p>考虑一个贪心，对于第一个数而言，肯定是选 <spanclass="math inline">\(mid\)</span> 步内的权值最小点；第二个数肯定是选<span class="math inline">\(mid\)</span>步内权值大于等于第一个数的最小点，以此类推。我们从小到大枚举权值判定能否走到，若能走到，就跳到下一个数；否则继续往大了枚举。</p><p>具体地，我们用一个三元组 <spanclass="math inline">\((S,T,mid)\)</span> 表示一个判定：判定 <spanclass="math inline">\(S\)</span> 走不超过 <spanclass="math inline">\(mid\)</span> 步是否能走到 <spanclass="math inline">\(T\)</span>。 <spanclass="math inline">\(T\)</span> 显然单调不降，于是我们只需判定 <spanclass="math inline">\(O(m)\)</span> 次。</p><p>判定很简单，只是需要一些码力。首先 <span class="math inline">\(i\tob_i\)</span>能得到一棵基环内向树，两点间的距离分为环上的一段和子树的一段，维护是朴素的。记录每个点属于哪个环对应的子树以及深度，就能<span class="math inline">\(O(1)\)</span> 得到距离，再和 <spanclass="math inline">\(mid\)</span> 比较即可。无解情况是：</p><ol type="1"><li><span class="math inline">\(S, T\)</span> 不在同一棵子树内并且 <spanclass="math inline">\(T\)</span> 不在环上。</li><li><span class="math inline">\(S,T\)</span> 在同一棵子树内但 <spanclass="math inline">\(T\)</span> 深度大于 <spanclass="math inline">\(S\)</span> 或二者不是祖先关系。</li></ol><p>时间复杂度 <span class="math inline">\(O(n\log m)\)</span>。</p><h2 id="cf1969d.-shop-game"><ahref="https://codeforces.com/contest/1969/problem/D">CF1969D. ShopGame</a></h2><p>*1900 <ahref="https://codeforces.com/contest/1969/submission/306110742">Code</a></p><p>Bob 会从 Alice 选的物品里选 <span class="math inline">\(k\)</span> 个for free，那他肯定会选 <span class="math inline">\(b[i]\)</span> 最大的<span class="math inline">\(k\)</span> 个。</p><p>我们不妨将物品按 <span class="math inline">\(b[i]\)</span>降序排序，这样相当于我们要选一个长至少为 <spanclass="math inline">\(k\)</span> 的子序列，然后把长为 <spanclass="math inline">\(k\)</span> 的前缀舍去。</p><p>这样的好处是要舍去的物品和剩下 Bob 要从 Alice手里买来的物品有了分界线。我们枚举这个分界线，分界线前我们选 <spanclass="math inline">\(k\)</span> 个舍去，贪心来讲一定是选 <spanclass="math inline">\(a[i]\)</span> 最小的 <spanclass="math inline">\(k\)</span>个；分界线后我们要获得最大的利润，一定是选所有 <spanclass="math inline">\(b[i]&gt;a[i]\)</span> 的物品。</p><p>分界线前用一个优先队列维护，分界线后预处理一个后缀和作为贡献。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2067e.-white-magic"><ahref="https://codeforces.com/contest/2067/problem/E">CF2067E. WhiteMagic</a></h2><p>*1900 <ahref="https://codeforces.com/contest/2067/submission/306114621">Code</a></p><p>首先，答案序列中最多出现一个 <spanclass="math inline">\(0\)</span>。</p><ul><li>若出现两个 <span class="math inline">\(0\)</span>，设下标分别为<span class="math inline">\(i,j\)</span>。则 <spanclass="math inline">\(\min(a_1,\cdots,a_i)=0&lt;1\le\text{mex}(a_{i+1},\cdots,a_j=0,\cdots,a_n)\)</span>，矛盾。</li></ul><p>并且，如果答案序列中有 <span class="math inline">\(0\)</span>，这个<span class="math inline">\(0\)</span> 一定是左数第一个 <spanclass="math inline">\(0\)</span>。</p><ul><li>贪心的想，这样可以让尽可能长的后缀 <spanclass="math inline">\(\text{mex}\)</span> 为 <spanclass="math inline">\(0\)</span>，不劣。</li></ul><p>最后，所有非 <span class="math inline">\(0\)</span>的数构成的序列一定 magical。</p><p>设有 <span class="math inline">\(cnt\)</span> 个 <spanclass="math inline">\(i\)</span> 满足 <spanclass="math inline">\(a_i&gt;0\)</span>，我们只需检查含有第一个 <spanclass="math inline">\(0\)</span> 和所有非 <spanclass="math inline">\(0\)</span> 数的序列。若其 magical，答案是 <spanclass="math inline">\(cnt+1\)</span>；否则答案是 <spanclass="math inline">\(cnt\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><h2 id="cf2067f.-bitwise-slides"><ahref="https://codeforces.com/contest/2067/problem/F">CF2067F. BitwiseSlides</a></h2><p>*2300 <ahref="https://codeforces.com/contest/2067/submission/306240933">Code</a></p><p>记 <spanclass="math inline">\(pre_i=\oplus_{j=1}^{i}a_j\)</span>。</p><p>首先，操作 <span class="math inline">\(i\)</span> 次后，有 <spanclass="math inline">\(P\oplus Q\oplus R=pre_i\)</span>。三个变量 notpairwise distinct意味着至少有两个变量相等。然而无论有两个还是三个变量相等，都会有至少一个变量等于<span class="math inline">\(pre_i\)</span>。</p><p>不妨设相等的两个变量为 <span class="math inline">\(x\)</span>，操作<span class="math inline">\(i\)</span> 次后的状态只能是 <spanclass="math inline">\((pre_i,x,x),(x,pre_i,x),(x,x,pre_i)\)</span>中的一种。</p><p>令 <span class="math inline">\(dp[i][x]\)</span> 表示操作 <spanclass="math inline">\(i\)</span> 次后达到上述三种状态的方案数。它可以从<span class="math inline">\((pre_i\oplus a_i,x,x),(x\oplusa_i,pre_i,x),(x\oplus a_i,x,pre_i)\)</span>转移而来，我们研究转移方程应该长什么样。</p><ul><li>上一个状态是 <span class="math inline">\((pre_i\oplusa_i,x,x)=(pre_{i-1},x,x)\)</span>。<ul><li>若 <span class="math inline">\(pre_{i-1} \neq x\)</span>，<spanclass="math inline">\(dp[i][x]=dp[i-1][x]\)</span>。</li><li>否则，<span class="math inline">\(dp[i][x]=3\cdotdp[i-1][x]\)</span>。</li></ul></li><li>上一个状态是 <span class="math inline">\((x\oplusa_i,pre_i,x)\)</span>。由其中两个元素相同得到 <spanclass="math inline">\(pre_i=x\)</span> 或 <spanclass="math inline">\(pre_i=x\oplus a_i\to pre_{i-1}=x\)</span>。<ul><li>若 <span class="math inline">\(pre_i=x\)</span>，<spanclass="math inline">\((x\oplus a_i,pre_i,x)=(pre_{i-1},x,x)\)</span>，故<span class="math inline">\(dp[i][x]=dp[i-1][x]\)</span>。</li><li>若 <span class="math inline">\(pre_{i-1}=x\)</span>，<spanclass="math inline">\((x\oplusa_i,pre_i,x)=(pre_i,pre_i,pre_{i-1})\)</span>。故 <spanclass="math inline">\(dp[i][x]=dp[i-1][pre_i]\)</span>。</li></ul></li><li>上一个状态是 <span class="math inline">\((x\oplusa_i,x,pre_i)\)</span>，同上一种。</li></ul><p>综上，只有 <span class="math inline">\(pre_{i-1}=x\)</span> 时 <spanclass="math inline">\(dp[i][x]\)</span> 不从 <spanclass="math inline">\(dp[i-1][x]\)</span> 转移而来。</p><p>此时 <span class="math inline">\(dp[i][x]=3\cdot dp[i-1][x]+2\cdotdp[i-1][pre_i]\)</span>。</p><p>把第一维压掉，第二维 <span class="math inline">\(x\)</span> 换成<span class="math inline">\(pre_{i-1}\)</span>，得到转移方程： <spanclass="math display">\[dp[pre_{i-1}]=3\cdot dp[pre_{i-1}]+2\cdot dp[pre_i]\]</span> 初始 <span class="math inline">\(dp[0]=1\)</span>，用<code>std::map</code> 作容器，时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2064e.-mycraft-sand-sort"><ahref="https://codeforces.com/contest/2064/problem/E">CF2064E. MycraftSand Sort</a></h2><p>*2400 <ahref="https://codeforces.com/contest/2064/submission/307300383">Code</a></p><p>首先注意到 <span class="math inline">\(\{c\}\)</span>的顺序不能换，因为第一列是不会下落的，换了之后第一列肯定不同。</p><p>结论：对于一组 <spanclass="math inline">\(p_i,p_j\)</span>，它们能交换位置当且仅当 <spanclass="math inline">\(c_i=c_j\)</span> 且 <spanclass="math inline">\(\max\limits_{k\in (i,j),c_k \neq c_i}p_k &lt;\min(p_i,p_j)\)</span>。</p><ul><li>若 <span class="math inline">\(c_i \neqc_j\)</span>，交换会改变颜色的相对顺序，一定不合法。</li><li>若 <span class="math inline">\(\max\limits_{k\in (i,j),c_k \neqc_i}p_k &gt; \min(p_i,p_j)\)</span>，令 <spanclass="math inline">\(p_m=\max\limits_{k\in (i,j),c_k \neqc_i}p_k\)</span>，不难想象交换前后在 <spanclass="math inline">\(p_m\)</span> 上侧颜色 <spanclass="math inline">\(c_i\)</span> 的数目肯定不同。</li></ul><p>那么如何计数呢？考虑 <span class="math inline">\(1\sim n\)</span>的一个排列，每次删去一个数相当于固定的 <spanclass="math inline">\(\{p\}\)</span>的一位，删除序列和原排列构成双射，因此我们只用对删数的方式进行计数。</p><p>将 <span class="math inline">\(p_i\)</span>从小到大枚举，统计完之后把 <span class="math inline">\(i\)</span>这个位置删掉，两端用双向链表连接。这么做的好处是统计到 <spanclass="math inline">\(p_i\)</span> 时能与 <spanclass="math inline">\(p_i\)</span>交换的行一定相邻（不相邻只能是中间夹着更短的，但更短的已经在这之前被删掉了），形成一个连通块。假设此时<span class="math inline">\(p_i\)</span> 所在的连通块大小是 <spanclass="math inline">\(t_i\)</span>，依据乘法原理最终答案就是 <spanclass="math inline">\(\prod t_i\)</span>。</p><p>用并查集维护连通块大小。时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2069e.-a-b-ab-and-ba"><ahref="https://codeforces.com/contest/2069/problem/E">CF2069E. A, B, ABand BA</a></h2><p>*2300 <ahref="https://codeforces.com/contest/2069/submission/307315231">Code</a></p><p>“AA” 和 “BB” 是不被允许的。我们在相邻的两个 “A”，相邻的两个 “B”中间划一刀，这样整个序列被分割成若干子串，每个子串是下列四种之一：</p><ul><li>ABAB…AB;</li><li>BABA…BA;</li><li>ABAB…ABA;</li><li>BABA…BAB.</li></ul><p>对于长为 <span class="math inline">\(l\)</span>的第三第四类子串，可以用 <spanclass="math inline">\(\frac{l-1}{2}\)</span> 个 AB 或 BA填充，剩下的一定是一个 A（如果是第三类）或者一个 B（如果是第四类）。此时AB 和 BA 的地位等价。</p><p>对于长为 <span class="math inline">\(l\)</span> 的第一类子串，可以用<span class="math inline">\(\frac{l}{2}\)</span> 个 AB 完全填充，或<span class="math inline">\(\frac{l}{2}-1\)</span> 个 BA 外加一个 A和一个 B。此时 AB 的地位显然高于 BA。同理对于第二类子串，BA 的地位高于AB。</p><p>对于第一第二类子串，只有用 AB（或BA）完全填满才不会浪费，所以我们的决策顺序是：</p><ul><li>用 AB 填充长度最小的第一类串，直到 AB 不足或没有第一类串了。</li><li>用 BA 填充长度最小的第二类串，直到 BA 不足或没有第二类串了。</li><li>用 BA，A，B 填充第一类串的剩余部分。</li><li>用 AB，A，B 填充第二类串的剩余部分。</li><li>用剩下的 AB，BA，A，B 填充第三第四类串。</li></ul><p>若填充过程缺材料了，就是 NO。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="cf2069f.-graph-inclusion"><ahref="https://codeforces.com/contest/2069/problem/F">CF2069F. GraphInclusion</a></h2><p>*2800 <ahref="https://codeforces.com/contest/2069/submission/307327089">Code</a></p><p>断言：任何时刻，答案是 <span class="math inline">\(A\)</span>的连通块数减去 <span class="math inline">\(A\cup B\)</span>的连通块数。</p><ul><li>挺显然的。</li></ul><p>然后就是线段树分治板子了。</p><p>时间复杂度 <span class="math inline">\(O(q\log^2 q)\)</span>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【教程】使用 DOMjudge 从零搭建一场比赛</title>
      <link href="/posts/4cf2169a.html"/>
      <url>/posts/4cf2169a.html</url>
      
        <content type="html"><![CDATA[<p>本文使用的环境：全新 Ubuntu24.04 LTS。</p><p>Domjudge 版本：8.3.1。</p><p>本文主要参考了：</p><p><ahref="https://vingying.github.io/2024/09/04/domjudge-icpctool/">Vingying| 关于搭建 domjudge 还有其他一些 ICPC Tool 之类的事</a></p><p><a href="https://zhuanlan.zhihu.com/p/258024151">HeRaNO | 计算机 ·DOMjudge Docker 配置</a></p><p>文中的所有流程经过了从头验证，十分感谢 vy 和 hrdg 的耐心指导QAQ。</p><h3 id="安装-domjudge-和相关依赖">1. 安装 DOMjudge 和相关依赖</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update<span class="hljs-built_in">sudo</span> apt-get upgrade</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install acl zip unzip mariadb-server nginx \        php-fpm php-gd php-cli php-intl php-mbstring php-mysql \        php-curl php-json php-xml php-zip composer ntp<span class="hljs-built_in">sudo</span> apt install make gcc g++ debootstrap libcgroup-dev lsof \        procps libcurl4-gnutls-dev libjsoncpp-dev libmagic-dev</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/<span class="hljs-built_in">sudo</span> wget https://www.domjudge.org/releases/domjudge-8.3.1.tar.gz<span class="hljs-built_in">sudo</span> tar -zxvf domjudge-8.3.1.tar.gz</code></pre></div><p>如果 <code>wget</code> 太慢可以点链接进去下再<code>sudo mv ./domjudge-8.3.1.tar.gz /opt/</code>。</p><h3 id="编译-domjudge配置数据库和-web-服务器">2. 编译DOMjudge，配置数据库和 web 服务器</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/domjudge-8.3.1<span class="hljs-built_in">sudo</span> ./configure --prefix=/opt/domjudge --with-domjudge-user=root --with-baseurl=127.0.0.1</code></pre></div><p>这一步如果警告缺少 <code>pkg-config</code> 就<code>sudo apt install pkg-config</code>。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> make domserver</code></pre></div><p>这一步会弹出一个询问，直接 <code>yes</code>。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> make install-domserver<span class="hljs-built_in">cd</span> /opt/domjudge/domserver<span class="hljs-built_in">sudo</span> bin/dj_setup_database -s install<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /opt/domjudge/domserver/etc/nginx-conf /etc/nginx/sites-enabled/domjudge<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /opt/domjudge/domserver/etc/domjudge-fpm.conf /etc/php/8.3/fpm/pool.d/domjudge.conf<span class="hljs-built_in">sudo</span> service php8.3-fpm reload</code></pre></div><p>最后两句 php 要换成对应的版本，我这里是 php8.3。</p><p>最后一句如果警告说要<code>systemctl daemon-reload</code>，按它说的执行就行。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/nginx/sites-enabled<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> default<span class="hljs-built_in">sudo</span> service nginx reload<span class="hljs-built_in">cd</span> /opt/domjudge/domserver<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> www-data:www-data -R webapp/public/*</code></pre></div><p>接着访问 <code>127.0.0.1/domjudge</code> 就有 web界面了（云服务器就换成公网地址）。</p><p><a href="https://kisuraop.github.io/image/academic/d1.png"><imgsrc="https://kisuraop.github.io/image/academic/d1.png" /></a></p><p>如果没按前两句把 <code>default</code> 删掉你就会收获 404的好结果。</p><p>如果还没有 web 界面就看看服务器 80 端口有没有打开。</p><p>接着在网页里 login，账号填 admin，密码通过以下命令获取：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cat</span> /opt/domjudge/domserver/etc/initial_admin_password.secret</code></pre></div><h3 id="配置-php-和-mysql">3. 配置 php 和 mysql</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/php/8.3/fpm/pool.d<span class="hljs-built_in">sudo</span> vim domjudge.conf</code></pre></div><p>如果提示没有 vim，就 <code>sudo apt install vim</code>。</p><p>打开配置文件后找到 <code>php_admin_value[memory_limit]</code>一栏，改成：</p><div class="code-wrapper"><pre><code class="hljs bash">php_admin_value[memory_limit] = 1024M</code></pre></div><p>再找到 <code>php_admin_value[date.timezone]</code> 一栏，改成：</p><div class="code-wrapper"><pre><code class="hljs bash">php_admin_value[date.timezone] = Asia/Shanghai</code></pre></div><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> service php8.3-fpm reload<span class="hljs-built_in">sudo</span> vim /etc/mysql/conf.d/mysql.cnf</code></pre></div><p>你会看到一行 <code>[mysql]</code>，删掉。接着粘贴以下内容：</p><div class="code-wrapper"><pre><code class="hljs bash">[mysqld]max_connections = 1000max_allowed_packet = 512MBinnodb_log_file_size = 2560MB</code></pre></div><p>这只是示例，实际 <code>max_allowed_packet</code>要改成两倍于题目测试数据文件的大小；<code>innodb_log_file_size</code>要改成十倍于题目测试数据文件的大小。</p><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/mysql/mariadb.conf.d/50-server.cnf</code></pre></div><p>找到 <code>max_allowed_packet = 1G</code>，取消这一行的注释。</p><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart mysql</code></pre></div><p>如果一切正常，刷新 DOMjudge 的 web 页面，点进 configchecker，你会看到：</p><p><a href="https://kisuraop.github.io/image/academic/d2.png"><imgsrc="https://kisuraop.github.io/image/academic/d2.png" /></a></p><p><a href="https://kisuraop.github.io/image/academic/d3.png"><imgsrc="https://kisuraop.github.io/image/academic/d3.png" /></a></p><h3 id="配置-judgehost-docker">4. 配置 judgehost (docker)</h3><p>首先要下载 docker，如果是云服务器，可以找到对应的文档。</p><p>我则是查阅了一些博客和文章，以下命令可能有不妥之处。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update<span class="hljs-built_in">sudo</span> apt-get -y install apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | <span class="hljs-built_in">sudo</span> apt-key add -<span class="hljs-built_in">sudo</span> add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><span class="hljs-built_in">sudo</span> apt-get update</code></pre></div><p>这里可能会提示<code>密钥存储在过时的 trusted.gpg 密钥环中</code>，我的解决方法是：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/apt<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> trusted.gpg trusted.gpg.d<span class="hljs-built_in">sudo</span> apt-get update</code></pre></div><p>然后就可以安装 docker 了。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install docker-ce<span class="hljs-built_in">cd</span> /etc/docker<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">touch</span> daemon.json<span class="hljs-built_in">sudo</span> vim daemon.json</code></pre></div><p>粘贴以下内容：</p><div class="code-wrapper"><pre><code class="hljs bash">&#123;    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.1ms.run&quot;</span>]&#125;</code></pre></div><p>其中国内镜像源是我从 <ahref="https://cloud.tencent.com/developer/article/2454486">Link</a>里面找的。</p><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> service docker restart</code></pre></div><p>接着设置 cgroups。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/default/grub</code></pre></div><p>找到 <code>GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"</code>一行（引号里可能初始是空），改成：</p><div class="code-wrapper"><pre><code class="hljs bash">GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet cgroup_enable=memory swapaccount=1 systemd.unified_cgroup_hierarchy=0&quot;</span></code></pre></div><p>保存退出。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> update-grub<span class="hljs-built_in">sudo</span> reboot</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker run -d -it --privileged -v /sys/fs/cgroup:/sys/fs/cgroup --name judgehost-new0 --hostname localhost --network=<span class="hljs-string">&quot;host&quot;</span> -e DAEMON_ID=0 -e CONTAINER_TIMEZONE=Asia/Shanghai -e JUDGEDAEMON_PASSWORD=&lt;domserver password&gt; -e DOMSERVER_BASEURL=http://localhost/domjudge/ domjudge/judgehost:8.3.1BASH</code></pre></div><p>其中 <code>&lt;domserver password&gt;</code> 通过以下命令获取：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cat</span> /opt/domjudge/domserver/etc/restapi.secret</code></pre></div><p>如果一切正常，那么：</p><p><a href="https://kisuraop.github.io/image/academic/d4.png"><imgsrc="https://kisuraop.github.io/image/academic/d4.png" /></a></p><p><a href="https://kisuraop.github.io/image/academic/d5.png"><imgsrc="https://kisuraop.github.io/image/academic/d5.png" /></a></p><p>如果起多个 judgehost，需要修改 <code>--name</code> 参数和<code>DAEMON_ID</code> 参数。后者是核编号，不能超过机子的核心数。</p><p>例如起第 2 个 judgehost 的话，命令得是：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker run -d -it --privileged -v /sys/fs/cgroup:/sys/fs/cgroup --name judgehost-new1 --hostname localhost --network=<span class="hljs-string">&quot;host&quot;</span> -e DAEMON_ID=1 -e CONTAINER_TIMEZONE=Asia/Shanghai -e JUDGEDAEMON_PASSWORD=&lt;domserver password&gt; -e DOMSERVER_BASEURL=http://localhost/domjudge/ domjudge/judgehost:8.3.1</code></pre></div><p>起第 3 个的话，得是：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker run -d -it --privileged -v /sys/fs/cgroup:/sys/fs/cgroup --name judgehost-new2 --hostname localhost --network=<span class="hljs-string">&quot;host&quot;</span> -e DAEMON_ID=2 -e CONTAINER_TIMEZONE=Asia/Shanghai -e JUDGEDAEMON_PASSWORD=&lt;domserver password&gt; -e DOMSERVER_BASEURL=http://localhost/domjudge/ domjudge/judgehost:8.3.1</code></pre></div><h3 id="配置比赛">5. 配置比赛</h3><p>从这里开始就看个人喜好了。</p><p>以下配置均以 UESTC 第十五届趣味程序设计竞赛为例。</p><p>Configuration settings <span class="math inline">\(\to\)</span>External systems <span class="math inline">\(\to\)</span> configurationdata external。</p><p>Configuration settings <span class="math inline">\(\to\)</span>Scoring <span class="math inline">\(\to\)</span> Results remap: 将<code>output-limit</code> 和 <code>no-output</code> 定向为<code>wrong-answer</code>。</p><p>save 之后如果提示你 Recalculate caches now，就点进去，之后同理。</p><p>Configuration settings <span class="math inline">\(\to\)</span>Judging <span class="math inline">\(\to\)</span> Enable parallel judging关闭。</p><p>Configuration settings <span class="math inline">\(\to\)</span>Display <span class="math inline">\(\to\)</span> Show flags 关闭。</p><p>Configuration settings <span class="math inline">\(\to\)</span>Display <span class="math inline">\(\to\)</span> Allow team submissiondownload 开启。</p><p>Configuration settings <span class="math inline">\(\to\)</span>Display <span class="math inline">\(\to\)</span> Show language versions开启。</p><p>回到主页，进 Team Categories。</p><p>把 visible 的三个组别的 external ID 改成<code>beginner</code>，<code>advanced</code> 和<code>observer</code>，代表零基础组，有基础组，和打星组。然后把这三个组的SortOrder 改成同一个数字（这样榜单上才不会割裂显示）。</p><p>接着导入队伍，依据 <ahref="https://www.domjudge.org/docs/manual/8.3/import.html#importing-team-affiliations">Link</a>完成 accounts.yaml，teams.json 和 organizations.json。</p><ul><li>teams.json 中 display_name 虽然是[option]，但如果不写这一项会默认设成空串，很神秘，所以还是加上。</li></ul><p>以下是我用到的脚本：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># gen_accounts.py</span><span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> string<span class="hljs-comment"># 生成账号的数量</span>account_number = <span class="hljs-number">452</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_team_data</span>():    data_list = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, account_number + <span class="hljs-number">1</span>):        team_id = <span class="hljs-string">f&quot;team<span class="hljs-subst">&#123;i:03d&#125;</span>&quot;</span>        <span class="hljs-built_in">id</span> = <span class="hljs-string">f&quot;account<span class="hljs-subst">&#123;i:03d&#125;</span>&quot;</span>        username = team_id        password = <span class="hljs-string">&#x27;&#x27;</span>.join(random.choices(string.ascii_letters + string.digits, k=<span class="hljs-number">10</span>))        data_list.append(<span class="hljs-string">f&quot;- id: <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>&#125;</span>\n  username: <span class="hljs-subst">&#123;username&#125;</span>\n  password: <span class="hljs-subst">&#123;password&#125;</span>\n  type: team\n  team_id: &#x27;<span class="hljs-subst">&#123;team_id&#125;</span>&#x27;\n\n&quot;</span>)    <span class="hljs-keyword">return</span> data_listteam_data = generate_team_data()<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;accounts.yaml&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:    file.writelines(team_data)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># gen_organizations.py</span><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> json<span class="hljs-comment"># 读取表格第 10 列的内容（学校名称）</span>df = pd.read_excel(<span class="hljs-string">&#x27;name.xlsx&#x27;</span>, usecols=[<span class="hljs-number">9</span>], skiprows=<span class="hljs-number">1</span>)<span class="hljs-comment"># 去重</span>universities = df.iloc[:, <span class="hljs-number">0</span>].dropna().unique()organizations = [&#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>), <span class="hljs-string">&quot;name&quot;</span>: university, <span class="hljs-string">&quot;formal_name&quot;</span>: university, <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;CHN&quot;</span>&#125; <span class="hljs-keyword">for</span> i, university <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(universities) <span class="hljs-keyword">if</span> university]<span class="hljs-comment"># 本校</span>organizations.append(&#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&#x27;电子科技大学&#x27;</span>, <span class="hljs-string">&quot;formal_name&quot;</span>: <span class="hljs-string">&#x27;电子科技大学&#x27;</span>, <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;CHN&quot;</span>&#125;)<span class="hljs-comment"># 没填学校名字的</span>organizations.append(&#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&#x27;未填写&#x27;</span>, <span class="hljs-string">&quot;formal_name&quot;</span>: <span class="hljs-string">&#x27;未填写&#x27;</span>, <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;CHN&quot;</span>&#125;)<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;organizations.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:    json.dump(organizations, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)PYTHON</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># gen_teams.py</span><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_data</span>():    excel_data = pd.read_excel(<span class="hljs-string">&quot;name.xlsx&quot;</span>, sheet_name=<span class="hljs-number">0</span>)    organizations = &#123;&#125;    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;organizations.json&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:        organizations = json.load(f)    result = []    id_counter = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> excel_data.iterrows():        <span class="hljs-keyword">if</span> pd.isna(row[<span class="hljs-number">1</span>]):            <span class="hljs-keyword">break</span>        <span class="hljs-comment"># row[2]: 是否为本校选手</span>        <span class="hljs-comment"># row[5]: 是否正式参赛</span>        <span class="hljs-comment"># row[6]: 年级</span>        <span class="hljs-comment"># row[8]: 是否有信息竞赛基础</span>        <span class="hljs-comment"># row[9]: 学校（外校）</span>        <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;否&quot;</span> <span class="hljs-keyword">or</span> row[<span class="hljs-number">5</span>] == <span class="hljs-string">&quot;否（不参与评奖）&quot;</span>:            X = <span class="hljs-string">&quot;observer&quot;</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> row[<span class="hljs-number">6</span>] == <span class="hljs-string">&quot;大一&quot;</span> <span class="hljs-keyword">and</span> row[<span class="hljs-number">8</span>] == <span class="hljs-string">&quot;否&quot;</span>:                X = <span class="hljs-string">&quot;beginner&quot;</span>            <span class="hljs-keyword">else</span>:                X = <span class="hljs-string">&quot;advanced&quot;</span>        <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;否&quot;</span>:            S = row[<span class="hljs-number">9</span>]            org_id = <span class="hljs-built_in">next</span>((org[<span class="hljs-string">&quot;id&quot;</span>] <span class="hljs-keyword">for</span> org <span class="hljs-keyword">in</span> organizations <span class="hljs-keyword">if</span> org[<span class="hljs-string">&quot;name&quot;</span>] == S), <span class="hljs-literal">None</span>)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> org_id:                org_id = <span class="hljs-number">101</span>                <span class="hljs-comment"># raise ValueError(f&quot;组织名称 &#x27;&#123;S&#125;&#x27; 未在 organizations.json 中找到！&quot;)</span>        <span class="hljs-keyword">else</span>:            org_id = <span class="hljs-number">100</span>        item = &#123;            <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">f&quot;team<span class="hljs-subst">&#123;id_counter:03d&#125;</span>&quot;</span>,            <span class="hljs-string">&quot;group_ids&quot;</span>: [<span class="hljs-built_in">str</span>(X)],            <span class="hljs-string">&quot;name&quot;</span>: row[<span class="hljs-number">1</span>],            <span class="hljs-string">&quot;display_name&quot;</span>: row[<span class="hljs-number">1</span>],            <span class="hljs-string">&quot;organization_id&quot;</span>: <span class="hljs-built_in">str</span>(org_id)        &#125;        result.append(item)        id_counter += <span class="hljs-number">1</span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;teams.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> outfile:        json.dump(result, outfile, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    generate_data()PYTHON</code></pre></div><p>生成完毕后回到主页，点进 import / export，找到 Teams &amp; groups<span class="math inline">\(\to\)</span> Import JSON / YAML。</p><p>将上述三个文件按 organizations.json，teams.json，accounts.yaml的顺序传上去（务必注意顺序，Type 也要随着改动）。</p><p>不同大学的校徽可以在 <ahref="https://github.com/CSGrandeur/CCPCOJ/tree/master/ojweb/public/static/image/school_badge">Link</a>或 <a href="https://www.urongda.com/logos">Link</a> 里下载，再到主页进Team Affiliations 里编辑上传。</p><p>接着建立 Contests。回到主页点进 Contests，demo 删掉，Add newcontest，External ID 随便填一个，剩下的选项都有注释，不再赘述。</p><ul><li>注意时间格式的 <code>timezone</code> 应该填<code>Asia/Shanghai</code> 而不是 <code>UTC+8</code>。</li></ul><p>可以利用 Problemset document 选项上传题面，在 Polygon 导出 Chinese题面 PDF 的方法： * 右边栏 Properties/File，找到statements.ftl，Edit。</p><ul><li>开头粘贴<code>\usepackage {CJK}</code>，<code>\begin{document}</code> 之后粘贴<code>\begin{CJK}{UTF8}{gbsn}</code>，结尾 <code>\end{document}</code>前粘贴 <code>\end {CJK}</code>。</li></ul><p>接着上传题目。需要借助 <ahref="https://github.com/cn-xcpc-tools/Polygon2DOMjudge/blob/master/README.cn.md">Link</a>。</p><p>Polygon 点进 Contest，右边栏找到 Build full packages (+verify)，点(+verify)，之后点进每个题目的 Package 界面下载 Linux 版本的package。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install pipxpipx install p2dpipx ensurepath</code></pre></div><p>关掉这个终端，重新开一个。</p><p>对每一题执行以下命令：</p><div class="code-wrapper"><pre><code class="hljs bash">p2d --code A --color <span class="hljs-string">&quot;#FF0000&quot;</span> -o /path/to/domjudge-package.zip /path/to/polygon-package.zip</code></pre></div><p>其中 code 是题目的 short name，color 是题目在 DOMjudge中的颜色，更多设置项可以点进链接里试。</p><ul><li><code>--external-id</code> 也建议设置成 ABCD。</li></ul><p>得到的 domjudge-package.zip 就可以在 Import and export <spanclass="math inline">\(\to\)</span> Problems 里上传了。</p><p>补一个邮件收集脚本：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> yaml<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_accounts_yaml</span>(<span class="hljs-params">file_path</span>):    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:        accounts = yaml.safe_load(file)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(accounts, <span class="hljs-built_in">list</span>):        accounts_dict = &#123;item[<span class="hljs-string">&#x27;username&#x27;</span>]: item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> accounts&#125;    <span class="hljs-keyword">else</span>:        accounts_dict = accounts    <span class="hljs-keyword">return</span> accounts_dict<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_mail_xlsx</span>(<span class="hljs-params">name_file, accounts_yaml</span>):    df = pd.read_excel(name_file)    accounts = load_accounts_yaml(accounts_yaml)    data = []    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> df.iterrows():        <span class="hljs-keyword">if</span> pd.isna(row[<span class="hljs-number">1</span>]):            <span class="hljs-keyword">break</span>        name = row[<span class="hljs-number">1</span>]        <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;是&#x27;</span>:            <span class="hljs-built_in">id</span> = <span class="hljs-built_in">int</span>(row[<span class="hljs-number">4</span>])            email = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>) + <span class="hljs-string">&quot;@std.uestc.edu.cn&quot;</span>            email2 = <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">else</span>:            email = <span class="hljs-built_in">str</span>(row[<span class="hljs-number">10</span>])            <span class="hljs-keyword">if</span> pd.isna(row[<span class="hljs-number">11</span>]):                email2 = <span class="hljs-string">&quot;&quot;</span>            <span class="hljs-keyword">else</span>:                email2 = <span class="hljs-built_in">str</span>(row[<span class="hljs-number">11</span>])        username = <span class="hljs-string">f&quot;team<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>:03d&#125;</span>&quot;</span>        password = accounts.get(username, &#123;&#125;).get(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == <span class="hljs-string">&quot;否&quot;</span> <span class="hljs-keyword">or</span> row[<span class="hljs-number">5</span>] == <span class="hljs-string">&quot;否（不参与评奖）&quot;</span>:            user_type = <span class="hljs-string">&quot;打星组&quot;</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> row[<span class="hljs-number">6</span>] == <span class="hljs-string">&quot;大一&quot;</span> <span class="hljs-keyword">and</span> row[<span class="hljs-number">8</span>] == <span class="hljs-string">&quot;否&quot;</span>:                user_type = <span class="hljs-string">&quot;初学组&quot;</span>            <span class="hljs-keyword">else</span>:                user_type = <span class="hljs-string">&quot;进阶组&quot;</span>        data.append([name, email, email2, username, password, user_type])    mail_df = pd.DataFrame(data, columns=[<span class="hljs-string">&quot;姓名&quot;</span>, <span class="hljs-string">&quot;邮箱1&quot;</span>, <span class="hljs-string">&quot;邮箱2&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;组别&quot;</span>])    mail_df.to_excel(<span class="hljs-string">&#x27;mail.xlsx&#x27;</span>, index=<span class="hljs-literal">False</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    create_mail_xlsx(<span class="hljs-string">&#x27;name.xlsx&#x27;</span>, <span class="hljs-string">&#x27;accounts.yaml&#x27;</span>)</code></pre></div><h3 id="比赛结束后">6. 比赛结束后</h3><p>结束的时候马上点进 Contest 界面把 Allow submit 选项关掉。</p><p>接着导出榜单和提交。</p><p>榜单直接在浏览器界面右键打印，选择打印到PDF。如果预览出来是黑白的，就在更多设置里面找到 “背景图形” 打上勾。</p><p>导出提交需要用到 <ahref="https://github.com/HeRaNO/ChickenRibs/blob/master/ICPCToy/DOMjudge/dj_download_submissions.py">Link</a>。命令如下：</p><div class="code-wrapper"><pre><code class="hljs bash">py dj_download_submissions.py http://localhost/domjudge/ &lt;contest-external-id&gt;</code></pre></div><p>其中 <code>&lt;contest-external-id&gt;</code> 是 contest 页面的external ID。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Note </tag>
            
            <tag> DOMjudge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【游记】2024 CCPC 网络预选赛</title>
      <link href="/posts/a57ce1e5.html"/>
      <url>/posts/a57ce1e5.html</url>
      
        <content type="html"><![CDATA[<p>UESTC_EndlessEmbrace 第一场正式的比赛。</p><p>快到九点才起床，本来昨晚和同样晕车的 kkaaxxrrdxing4c商量好了一起做地铁去，但起床一刷消息发现被鸽了，只好重新买上了九点半的车票，赶忙跑去东门把模板印了。</p><p>很困，昨晚临时补了一些板子，两点才睡。车上很颠，没睡着，意料之中。</p><p>12点整，PTA 准时开崩。以前只是有所耳闻，这下身临其境了。</p><p>队友和我上去打了点板子，期间刷新出了一道签L，马上秒了（伏笔），继续敲板子。</p><p>大概 44min 终于能交题了，交，WA，字符串读的 0-index 写的1-index，气晕了，47minL2A。</p><p>接着签 B，WA。wbc 签K，63minK1A，随后发现我少了个特判，加上过了，64minB2A。</p><p>队友开 D，我开其它的，两个队友都是 dp 糕手，讨论出了一个区间dp，115minD1A。</p><p>PTA 发了延时通知，延了 1h，很难评价。</p><p>看榜 UESTC_PenaltyAutomaton 过了不到 10 个队过的 C，大为震撼。</p><p>于是看了 C，跟 wp说了一个贪心，不知道对不对就上去写了，WA，换了一个贪心策略又 WA了两发，耻辱换题。按榜看了 J，写了两发线性基，还是 WA，红了。</p><p>这期间队友一直在攻 E，两个多小时终于找对了方向，283minE2A。</p><p>冷静了一下，改了一下线性基的逻辑，终于 287minJ3A。</p><p>时间不多了，一起看 I，wp 很快就会 dp 了，就让他上去写，我在研究C。</p><p>跟队友简单说了一下我的做法，觉得很对啊，就打印了一下肉眼查错，后来发现假完了。</p><p>最后半小时 I 题狂 T，一起帮着 wp卡常，可惜的是直到比赛结束也没卡过。</p><p>6 题 Rank360/9 收尾，有点沮丧。赛后发现 C，G，I都不应该丢，但马后炮也意义不大，只能希望下周 ICPC 打得好一点。</p><p>FunFact：赛后把 I 题 clone下来开大了时限把赛时代码交了上去，1952msAccepted，赛时时限是 1s。</p><hr /><h3 id="a.-军训-i">A. 军训 I</h3><div class="note note-success">            <p>可以预见的是合法的状态数很少。</p><p>实际上可以证明 <span class="math inline">\(k &gt; 13\)</span>时无解：把所有人移到一个角，这些人在这个角最多只有 <spanclass="math inline">\(2\)</span>种方案，移到一个角之后向另外三个角移动一共 <spanclass="math inline">\(2\cdot 4=8\)</span> 种。四个方向单移动一次共 <spanclass="math inline">\(4\)</span> 种，再加上原状态 <spanclass="math inline">\(1\)</span> 种共 <spanclass="math inline">\(13\)</span> 种。</p><p>对 <span class="math inline">\(k\in [1,13]\)</span> 打表发现 <spanclass="math inline">\(k=8,10,12\)</span> 时无解，同时还能很快打出 <spanclass="math inline">\(\min(n,m)&lt;3\)</span> 的情况进行特判。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        打表程序    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">20</span>; k++) &#123;<span class="hljs-function">vector <span class="hljs-title">a</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(m))</span></span>;<span class="hljs-keyword">auto</span> do_L = [&amp;] () &#123;vector b = a;b.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cnt += a[i][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; j++) &#123;b[i][j] = <span class="hljs-number">1</span>;&#125;&#125;a = b;&#125;;<span class="hljs-keyword">auto</span> do_R = [&amp;] () &#123;vector b = a;b.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cnt += a[i][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= m - cnt; j--) &#123;b[i][j] = <span class="hljs-number">1</span>;&#125;&#125;a = b;&#125;;<span class="hljs-keyword">auto</span> do_U = [&amp;] () &#123;vector b = a;b.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cnt += a[i][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;b[i][j] = <span class="hljs-number">1</span>;&#125;&#125;a = b;&#125;;<span class="hljs-keyword">auto</span> do_D = [&amp;] () &#123;vector b = a;b.<span class="hljs-built_in">assign</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cnt += a[i][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= n - cnt; i--) &#123;b[i][j] = <span class="hljs-number">1</span>;&#125;&#125;a = b;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; (n * m)); i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; m; l++) &#123;<span class="hljs-type">int</span> o = j * m + l;<span class="hljs-keyword">if</span> (i &gt;&gt; o &amp; <span class="hljs-number">1</span>) &#123;a[j][l] = <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;a[j][l] = <span class="hljs-number">0</span>;&#125;&#125;&#125;map&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> step) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (res &gt; k) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (!mp[a]) &#123;mp[a] = <span class="hljs-number">1</span>;res++;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (step &gt; <span class="hljs-number">100</span>) &#123;<span class="hljs-keyword">return</span> ;&#125;vector b = a;<span class="hljs-built_in">do_U</span>();<span class="hljs-built_in">self</span>(self, step + <span class="hljs-number">1</span>);a = b;<span class="hljs-built_in">do_D</span>();<span class="hljs-built_in">self</span>(self, step + <span class="hljs-number">1</span>);a = b;<span class="hljs-built_in">do_L</span>();<span class="hljs-built_in">self</span>(self, step + <span class="hljs-number">1</span>);a = b;<span class="hljs-built_in">do_R</span>();<span class="hljs-built_in">self</span>(self, step + <span class="hljs-number">1</span>);&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (res == k) &#123;cout &lt;&lt; <span class="hljs-string">&quot;k = &quot;</span> &lt;&lt; k &lt;&lt; <span class="hljs-string">&quot; is ok&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; m; l++) &#123;<span class="hljs-type">int</span> o = j * m + l;<span class="hljs-keyword">if</span> (i &gt;&gt; o &amp; <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;0&quot;</span>;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>当 <span class="math inline">\(n,m \ge 3\)</span>时，分出以下情况，打表找规律（听着难，实际上打出字典序最小的一个就能看出来）：</p><ul><li><p><spanclass="math inline">\(k=1\)</span>，把所有格子填满。</p></li><li><p><span class="math inline">\(k=2\)</span>，把第一行填满。</p></li><li><p><span class="math inline">\(k=3\)</span>，把第二行填满。</p></li><li><p><span class="math inline">\(k=4\)</span>，填 <spanclass="math inline">\((1,1)\)</span>。</p></li><li><p><spanclass="math inline">\(k=5\)</span>，此时合法的局面需要满足移动一次后向任意方向移动都没意义。当<span class="math inline">\(n=m\)</span>时填满任意一条对角线是好想的。<span class="math inline">\(n \neqm\)</span> 时考虑把 <span class="math inline">\(n\times m\)</span>分成若干个 <span class="math inline">\(x\times x\)</span>的子矩阵，每个子矩阵填满一条对角线。此时可取 <spanclass="math inline">\(x = \gcd(n, m)\)</span>。</p></li><li><p><span class="math inline">\(k=6\)</span>， 填 <spanclass="math inline">\((1, 2)\)</span>。</p></li><li><p><span class="math inline">\(k=7\)</span>，填 <spanclass="math inline">\((2, 1)\land (1,x),x\in[2, m]\)</span>。</p></li><li><p><span class="math inline">\(k=9\)</span>，填 <spanclass="math inline">\((1, 2)\land (2, 1)\)</span>。</p></li><li><p><span class="math inline">\(k=11\)</span>，填 <spanclass="math inline">\((1, 3)\land (2, 1)\)</span>。</p></li><li><p><span class="math inline">\(k=13\)</span>，填 <spanclass="math inline">\((1, 3)\land (3, 1)\)</span>。</p></li></ul><p>代码写的比较 shit，如果把 <span class="math inline">\(n=2\)</span> 和<span class="math inline">\(m=2\)</span>单独列出来会直观很多，但我懒得改 shit 了。</p><p>时间复杂度 <span class="math inline">\(O(nm)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NO (void)(cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>)</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cout &lt;&lt; <span class="hljs-string">&#x27;*&#x27;</span>;&#125;&#125;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">auto</span> print = [&amp;] (vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;&gt; a) -&gt; <span class="hljs-type">void</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : a) &#123;<span class="hljs-keyword">if</span> (x == i + <span class="hljs-number">1</span> &amp;&amp; y == j + <span class="hljs-number">1</span>) &#123;ok = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;cout &lt;&lt; (ok ? <span class="hljs-string">&#x27;*&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>);&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> printl = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">void</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-keyword">if</span> ((x &amp;&amp; x == i + <span class="hljs-number">1</span>) || (y &amp;&amp; y == j + <span class="hljs-number">1</span>)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;&#125;&#125;&#125;&#125;;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> &amp;&amp; m == <span class="hljs-number">1</span>) &#123;NO;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(n, m) == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">max</span>(n, m) == <span class="hljs-number">2</span>) &#123;k == <span class="hljs-number">2</span> ? <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;) : NO;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(n, m) == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) &#123;n == <span class="hljs-number">1</span> ? <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;) : <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> &amp;&amp; m == <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">5</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> &amp;&amp; m == <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">6</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">7</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">9</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span> &amp;&amp; m == <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">6</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">7</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">9</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printl</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) &#123;n &gt; m ? <span class="hljs-built_in">printl</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) : <span class="hljs-built_in">printl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">5</span>) &#123;<span class="hljs-keyword">if</span> (__gcd(n, m) == <span class="hljs-number">1</span>) &#123;NO;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-type">int</span> g = __gcd(n, m);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> x = i % g;<span class="hljs-type">int</span> y = j % g;<span class="hljs-keyword">if</span> (x == y) &#123;cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;&#125;&#125;&#125;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">6</span>) &#123;n &lt; m ? <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;) : <span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">7</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-keyword">if</span> ((i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">0</span>) || (i == <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;&#125;&#125;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">9</span>) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">11</span>) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">13</span>) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || m == <span class="hljs-number">2</span>) &#123;NO;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">print</span>(&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;&#125;);&#125;&#125; <span class="hljs-keyword">else</span> &#123;NO;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="b.-军训-ii">B. 军训 II</h3><div class="note note-success">            <p>感性地，排序后不整齐度最小。</p><p><span class="math inline">\(ans1\)</span> 可以单 <spanclass="math inline">\(\log\)</span> 求，但允许 <spanclass="math inline">\(O(n^2)\)</span> 就没必要自讨苦吃。</p><p>接着设每个连续段长 <span class="math inline">\(cnt_i\)</span>，那么<span class="math inline">\(ans2=2\prodcnt_i\)</span>。系数来自升序排序和降序排序两种。</p><p>特判：所有数都相同时，升序和降序看作一种，<spanclass="math inline">\(ans2=\prod cnt_i\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fac</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;fac[i] = fac[i - <span class="hljs-number">1</span>] * i % modp;&#125; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> ans1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> mx = a[i], mn = a[i];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; j++) &#123;mx = <span class="hljs-built_in">max</span>(mx, a[j]);mn = <span class="hljs-built_in">min</span>(mn, a[j]);ans1 += mx - mn;&#125;&#125;<span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, ans2 = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (a[i] != a[i - <span class="hljs-number">1</span>]) &#123;ans2 *= fac[cnt];ans2 %= modp;cnt = <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;cnt++;&#125;&#125;ans2 *= fac[cnt];ans2 %= modp;vector b = a;<span class="hljs-built_in">reverse</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span> (a != b) &#123;ans2 *= <span class="hljs-number">2</span>;ans2 %= modp;&#125;cout &lt;&lt; ans1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="c.-种树">C. 种树</h3><div class="note note-success">            <p>将已经种了树的点称为黑点，否则白点。</p><p>两种<strong>错误</strong>的贪心举例： * 两个黑点间夹 <spanclass="math inline">\(k\)</span> 个白点，<spanclass="math inline">\(k\)</span> 为偶数时用 <spanclass="math inline">\(\dfrac{k}{2}\)</span> 次操作填满。</p><ul><li>以两个或以上相连的黑点为界，每个连通块贡献为 <spanclass="math inline">\(\left\lceil\dfrac{白点个数}{2}\right\rceil\)</span>。</li></ul><p>反例对应如下。</p><p><a href="https://kisuraop.github.io/image/academic/CCPC1.png"><imgsrc="https://kisuraop.github.io/image/academic/CCPC1.png" /></a></p><p><strong>正确</strong>的贪心：任选一黑点为根dfs，自下而上贪心，每次填两个。对于一个黑点：</p><ul><li><p>若当前子树中白点数为偶数，填满。</p></li><li><p>否则考虑是否能把多余的一个涂色操作摊给当前黑点的父亲。</p></li></ul><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> rt = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[x] = <span class="hljs-literal">true</span>;rt = x;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;sz[x] = a[x] == <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);sz[x] += sz[y];&#125;<span class="hljs-keyword">if</span> (a[x]) &#123;ans += sz[x] / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (sz[x] % <span class="hljs-number">2</span>) &#123;ans++;<span class="hljs-keyword">if</span> (fath &amp;&amp; a[fath] == <span class="hljs-number">0</span>) &#123;a[fath] = <span class="hljs-number">1</span>;sz[fath]--;&#125;&#125;sz[x] = <span class="hljs-number">0</span>;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-疯狂星期六">G. 疯狂星期六</h3><div class="note note-success">            <p>yyq 需要尽可能花多的钱，而他花的最多的钱数是可以处理出来的，即 <spanclass="math inline">\(X=\min(\sum \text{能摊到 yyq上的菜钱}+T_1,a_1)\)</span>。</p><p>令 <span class="math inline">\(mx_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个人能花在菜上的最多钱数，首先 <spanclass="math inline">\(mx_1=X-T_1\)</span>，那么 <spanclass="math inline">\(mx_i=\min(a_i,mx_1-1)\)</span>。</p><p>接着只需 check 是否存在一种满足上述条件的方案。</p><p>转化为网络流问题： * 源点向每个菜连容量为菜钱的边。</p><ul><li><p>每个菜向付它钱的两个人连容量为菜钱的边。</p></li><li><p>每个人向汇点连容量为 <span class="math inline">\(mx_i\)</span>的边。</p></li></ul><p>check 成功当且仅当最大流 <span class="math inline">\(=\)</span>总菜钱。</p><p>时间复杂度 <span class="math inline">\(O(n\sqrt{m})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span> &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<span class="hljs-type">int</span> x, cap;<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cap) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">cap</span>(cap) &#123;&#125; &#125;;<span class="hljs-type">int</span> n;vector&lt;Edge&gt; e;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; dep, cur;<span class="hljs-built_in">Dinic</span>(<span class="hljs-type">int</span> size) &#123;<span class="hljs-keyword">this</span>-&gt;n = size;adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cap)</span> </span>&#123;adj[x].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;y, cap&#125;);adj[y].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>&#125;);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;dep.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(S);dep[S] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : adj[x]) &#123;<span class="hljs-keyword">auto</span> [y, cap] = e[i];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == <span class="hljs-number">-1</span>) &#123;dep[y] = dep[x] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (y == T) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> T, <span class="hljs-type">int</span> limit)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == T) &#123;<span class="hljs-keyword">return</span> limit;&#125;<span class="hljs-type">int</span> r = limit;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i = cur[x]; i &lt; adj[x].<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-type">const</span> <span class="hljs-type">int</span> j = adj[x][i];<span class="hljs-keyword">auto</span> [y, cap] = e[j];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == dep[x] + <span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> t = <span class="hljs-built_in">dfs</span>(y, T, <span class="hljs-built_in">min</span>(r, cap));e[j].cap -= t;e[j ^ <span class="hljs-number">1</span>].cap += t;r -= t;<span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> limit;&#125;&#125;&#125;<span class="hljs-keyword">return</span> limit - r;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(S, T)) &#123;cur.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);flow += <span class="hljs-built_in">dfs</span>(S, T, inf); &#125; <span class="hljs-keyword">return</span> flow;&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">Taxi</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i] &gt;&gt; Taxi[i];&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">dish</span>(m + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mxcost</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> all = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;dish[i] = &#123;x, y, w&#125;;all += w;<span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span> || y == <span class="hljs-number">1</span>) &#123;mxcost[<span class="hljs-number">1</span>] += w;&#125;&#125;mxcost[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(a[<span class="hljs-number">1</span>], mxcost[<span class="hljs-number">1</span>] + Taxi[<span class="hljs-number">1</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;mxcost[i] = <span class="hljs-built_in">min</span>(a[i], mxcost[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) - Taxi[i];<span class="hljs-keyword">if</span> (mxcost[i] &lt; <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;mxcost[<span class="hljs-number">1</span>] -= Taxi[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> S = m + n + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> T = m + n + <span class="hljs-number">2</span>;<span class="hljs-function">Dinic <span class="hljs-title">G</span><span class="hljs-params">(T)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-keyword">auto</span> [x, y, w] = dish[i];G.<span class="hljs-built_in">add</span>(S, i, w);G.<span class="hljs-built_in">add</span>(i, m + x, w);G.<span class="hljs-built_in">add</span>(i, m + y, w);&#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;G.<span class="hljs-built_in">add</span>(m + i, T, mxcost[i]);&#125;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dinic</span>(S, T) == all) &#123;cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="j.-找最小">J. 找最小</h3><div class="note note-success">            <p>令 <span class="math inline">\(c_i=a_i\oplus b_i\)</span>，<spanclass="math inline">\(A=\oplus_{i=1}^{n} a_i\)</span>，<spanclass="math inline">\(B=\oplus_{i=1}^{n} b_i\)</span>。</p><p>根据异或运算的自反性，题目转化为需要选一些 <spanclass="math inline">\(c_i\)</span>（设选出的 <spanclass="math inline">\(c_i\)</span> 的异或和为 <spanclass="math inline">\(C\)</span>）使得 <spanclass="math inline">\(\max(A\oplus C,B\oplus C)\)</span> 最小。</p><p>联想到线性基，其能解决这样一类问题：从一堆数中选出若干个数，它们的异或和最大/最小。</p><p>插入操作不用修改，查询时不妨将 <spanclass="math inline">\(\max(A,B)\)</span>作为初值，代表已经选出这么多。</p><p>随后从高位向低位贪心，判断到某位异或之后 <spanclass="math inline">\(\max\)</span> 变小就更新即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<spanclass="math inline">\(w\)</span> 为值域。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; p;<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">p</span>(_n + <span class="hljs-number">1</span>) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (!(x &gt;&gt; i)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (!p[i]) &#123;p[i] = x;<span class="hljs-keyword">break</span>;&#125;x ^= p[i];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> st1, <span class="hljs-type">int</span> st2)</span> </span>&#123;<span class="hljs-type">int</span> res = <span class="hljs-built_in">max</span>(st1, st2);<span class="hljs-type">int</span> X = st1, Y = st2;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(X ^ p[i], Y ^ p[i]) &lt; res) &#123;X ^= p[i];Y ^= p[i];res = <span class="hljs-built_in">max</span>(X, Y);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> val1 = <span class="hljs-number">0</span>, val2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];val1 ^= a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; b[i];val2 ^= b[i];&#125;<span class="hljs-function">Node <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;t.<span class="hljs-built_in">insert</span>(a[i] ^ b[i]);&#125;cout &lt;&lt; t.<span class="hljs-built_in">getans</span>(val1, val2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-取沙子游戏">K. 取沙子游戏</h3><div class="note note-success">            <p>当 <span class="math inline">\(n\)</span> 为奇数时，先手拿 <spanclass="math inline">\(1\)</span>，之后后手和先手都只能轮流拿 <spanclass="math inline">\(1\)</span>，先手必胜。</p><p>否则，先手只能拿偶数，一种策略是每次拿 <spanclass="math inline">\(\text{lowbit(n)}\)</span>，之后后手无论拿什么，先手跟着拿就行。</p><p>故当 <span class="math inline">\(\text{lowbit(n)}\le k\)</span>时，先手必胜。否则无论拿 <span class="math inline">\(1\sim k\)</span>中的多少，<span class="math inline">\(\text{lowbit(n)}\)</span> 都会落到<span class="math inline">\(k\)</span> 以内，让后手取得胜利。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;<span class="hljs-keyword">if</span> ((n &amp; -n) &lt;= k) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> CCPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】2024 UESTC 暑假集训 第二轮</title>
      <link href="/posts/70be1dc7.html"/>
      <url>/posts/70be1dc7.html</url>
      
        <content type="html"><![CDATA[<p>收录了二轮集训的部分题解。</p><hr /><p>先抛点链接，方便日后跳转。</p><p>7.31 https://codeforces.com/gym/537696（2024 HDU 多校 6）</p><p>8.1 https://codeforces.com/gym/539789（SEERC 2020）</p><p>8.2 https://codeforces.com/gym/540037（2023 江苏省赛/ CCPCHunan）</p><p>8.3 https://codeforces.com/gym/540187（2020 CCPC Weihai）</p><p>8.4 https://codeforces.com/gym/105173（2024 东北四省赛 / CCPCNortheast）</p><p>8.5 https://codeforces.com/gym/540735（2023 Nanjing Regional / Ucup2-11）</p><p>8.6 https://codeforces.com/gym/541036（UKIEPC 2023）</p><p>8.7 https://codeforces.com/gym/541235（NEERC 2019-2020）</p><p>8.8 https://codeforces.com/gym/541365（2024 上海市赛）</p><p>8.9 https://codeforces.com/gym/541786（2024 陕西省赛）</p><p>8.10 https://codeforces.com/gym/541891（2024 吉林省赛 / CCPCChangchun）</p><p>8.11 https://codeforces.com/gym/104976（2023 Hangzhou Regional / Ucup2-22）</p><p>8.12 https://codeforces.com/gym/542320（毒瘤 psk / 998244353）</p><p>8.13 https://codeforces.com/gym/541594（SEERC 2022）</p><p>8.14 https://codeforces.com/gym/542837（ECNA 2022）</p><p>8.15 https://codeforces.com/gym/543029（2022 CCPC Weihai）</p><p>8.16 https://codeforces.com/gym/543323（NWERC 2019）</p><p>8.17 https://codeforces.com/gym/543433（2020 CCPC Changchun）</p><p>8.18 被赶出清水河</p><p>8.22 https://codeforces.com/gym/105231（2024 江西省赛）</p><p>8.23 https://codeforces.com/gym/102822（2020 CCPC Mianyang）</p><p>8.24 https://codeforces.com/gym/102769（2020 CCPC Qinhuangdao）</p><p>8.25 https://codeforces.com/gym/104252（2022-2023 Latin AmericanRegional）</p><p>8.26 https://codeforces.com/gym/103081（SWERC 2020）</p><p>8.27 晓山瑞希生日</p><p>8.28 https://codeforces.com/gym/104064（NWERC 2021）</p><p>8.29 https://codeforces.com/gym/104787（2023 CCPC Qinhuangdao / Ucup2-9）</p><p>8.30 https://codeforces.com/gym/104945（SWERC 2023）</p><h2 id="hdu-多校-第6场">2024 HDU 多校 第6场</h2><h3 id="b.-造花困难版分类讨论">B. 造花（困难版）【分类讨论】</h3><div class="note note-info">            <p>给定一张无重边无自环不保证联通的无向图，若删去某个点后整个图被分为若干菊花图，则称这个点为混沌点。升序输出所有混沌点编号，或报告不存在。</p><p><span class="math inline">\(1 \le n, m \le 2\cdot 10^6\)</span>。</p>          </div><div class="note note-success">            <p>首先可以暴力check（通过度数判断）这张图的每个连通分量是不是菊花图。若有两个及以上的连通分量不是菊花图，则无解；否则我们只考虑不是菊花图的那个连通分量。</p><p>分两种情况考虑：</p><ul><li>这个连通分量是一棵树。通过以下步骤可以 <spanclass="math inline">\(O(n)\)</span> check 每个点是不是混沌点：<ul><li>对于每个点 <span class="math inline">\(x\)</span>，新建变量<code>sum = 0</code>，遍历 <span class="math inline">\(x\)</span>的邻接点 <span class="math inline">\(y\)</span>。若 <spanclass="math inline">\(y\)</span> 的度数为 <spanclass="math inline">\(2\)</span>，则继续遍历 <spanclass="math inline">\(y\)</span> 的邻接点 <spanclass="math inline">\(z\)</span>（<span class="math inline">\(z \neqx\)</span>），<code>sum += deg[z] + 1</code>；否则<code>sum += deg[y]</code>。若删去 <spanclass="math inline">\(x\)</span>该树被分为两个菊花图，那么此时度数统计完全，应有<code>sum == n - 1</code>。这里 <span class="math inline">\(n\)</span>是连通分量的大小。</li></ul></li><li>这个联通分量不是树（有环）。此时有两个性质可以手玩出来：<ol type="1"><li>若存在混沌点，该连通分量所有环的大小最多是四元环。</li><li>若有多个环，混沌点只能是所有环的交集。</li></ol></li></ul><p>由结论 <spanclass="math inline">\(2\)</span>，我们只需要随便从这个连通分量中找一个环，此时所有可能的混沌点都在这个环上。又由结论<span class="math inline">\(1\)</span>，可以暴力 check这些可能的混沌点，最多 check 不超过 <spanclass="math inline">\(4\)</span> 次。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ori_rd</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);ori_rd[x]++;ori_rd[y]++;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cir</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; need_to_check;<span class="hljs-type">int</span> cnt_circle = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> find_circle = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;cir[x] = <span class="hljs-literal">true</span>;fa[x] = fath;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (cir[y]) &#123;fa[y] = x;<span class="hljs-keyword">if</span> (cnt_circle == <span class="hljs-number">0</span>) &#123;cnt_circle = <span class="hljs-number">1</span>;need_to_check.<span class="hljs-built_in">push_back</span>(y);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = fa[y]; i != y; i = fa[i]) &#123;cnt_circle++;need_to_check.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[y] = <span class="hljs-literal">true</span>;<span class="hljs-built_in">self</span>(self, y, x);&#125;cir[x] = <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">auto</span> ok = [&amp;] (<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> A = <span class="hljs-number">0</span>) &#123;vector&lt;<span class="hljs-type">int</span>&gt; rd = ori_rd;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">if</span> (A == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;rd[x]--;&#125;rd[rt] = <span class="hljs-number">0</span>;vis[rt] = <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> rdn;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-literal">true</span>;rdn += rd[x] &gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y);&#125;&#125;;<span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;<span class="hljs-keyword">if</span> (!vis[x]) &#123;rdn = <span class="hljs-number">0</span>;<span class="hljs-built_in">dfs</span>(dfs, x);<span class="hljs-keyword">if</span> (rdn &gt; <span class="hljs-number">1</span>) &#123;flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> flag;&#125;;<span class="hljs-type">int</span> block = <span class="hljs-number">0</span>, block_id = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>(i, <span class="hljs-number">1</span>)) &#123;block++;block_id = i;&#125;cnt_circle = <span class="hljs-number">0</span>;<span class="hljs-built_in">find_circle</span>(find_circle, i, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (cnt_circle &gt; <span class="hljs-number">4</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (block &gt;= <span class="hljs-number">2</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">if</span> (need_to_check.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> check_tree = [&amp;] (<span class="hljs-type">int</span> A) &#123;vector&lt;<span class="hljs-type">int</span>&gt; b;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;b.<span class="hljs-built_in">push_back</span>(x);vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, A, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (ori_rd[y] == <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> o : adj[y]) &#123;<span class="hljs-keyword">if</span> (o == x) &#123;<span class="hljs-keyword">continue</span>;&#125;res += ori_rd[o] + <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;res += ori_rd[y];&#125;&#125;<span class="hljs-keyword">if</span> (res == b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;ans.<span class="hljs-built_in">push_back</span>(x);&#125;&#125;&#125;;<span class="hljs-keyword">if</span> (block_id == <span class="hljs-number">-1</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;<span class="hljs-built_in">check_tree</span>(i);&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">check_tree</span>(block_id);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : need_to_check) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>(x)) &#123;ans.<span class="hljs-built_in">push_back</span>(x);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="g.-树上-mex-问题dp">G. 树上 MEX 问题【dp】</h3><div class="note note-info">            <p>定义一张图的 MEX为：图中所有点的点权构成的集合中，最小的没有出现过的非负整数。</p><p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，点有点权<spanclass="math inline">\(a_i\)</span>，保证<strong>点权互不相同</strong>。求这棵树的所有联通导出子图的MEX 之和，对 998244353 取模。</p><p><span class="math inline">\(1 \le n \le 10 ^6\)</span>，<spanclass="math inline">\(0 \le a_i  &lt; n\)</span>。</p>          </div><div class="note note-success">            <p>设 <span class="math inline">\(T_i\)</span> 为由点权为 <spanclass="math inline">\(0\sim i\)</span> 的点构成的极小联通子图，<spanclass="math inline">\(cnt_i\)</span> 为包含 <spanclass="math inline">\(T_i\)</span> 的联通子图个数。</p><p>则有结论：<span class="math inline">\(ans = \sum_\limits{i = 0}^{n -1}cnt_i\)</span>。</p><ul><li>证明：子图 <span class="math inline">\(T_i\)</span> 的 mex 为 <spanclass="math inline">\(i + 1\)</span>，且 <spanclass="math inline">\(T_i\)</span> 一定包含 <spanclass="math inline">\(T_0\sim T_{i - 1}\)</span>，故 mex 恰好为 <spanclass="math inline">\(i + 1\)</span> 的联通子图个数为 <spanclass="math inline">\(cnt_i - cnt_{i + 1}\)</span>，有： <spanclass="math display">\[\large \begin{align}ans &amp;=\sum_{i = 0}^{n - 1}(i + 1)(cnt_i-cnt_{i + 1})\\&amp;=(cnt_{0}-cnt_{1})+2(cnt_1 - cnt_2)+3(cnt_2-cnt_3)+\cdots \\&amp;=\sum_{i = 0}^{n - 1}cnt_i\end{align}\]</span></li></ul><p>于是仅需求出 <span class="math inline">\(cnt_i\)</span>。</p><p>接下来考虑如何对连通子图进行计数。</p><p>令 <span class="math inline">\(f_i\)</span> 代表节点 <spanclass="math inline">\(i\)</span> 可选可不选时以 <spanclass="math inline">\(i\)</span> 为根的子树中以 <spanclass="math inline">\(i\)</span> 为根的联通子图个数；</p><p>令 <span class="math inline">\(g_i\)</span> 代表限定节点 <spanclass="math inline">\(i\)</span> 必须选时以 <spanclass="math inline">\(i\)</span> 为根的子树中以 <spanclass="math inline">\(i\)</span> 为根的联通子图个数，则： <spanclass="math display">\[\large \begin{cases}g_x = \prod_{y\in son_x}f_y\\f_x = g_x + 1\end{cases}\]</span> 显然 <span class="math inline">\(cnt_0=g_0\)</span>。</p><p>再考虑如何从 <span class="math inline">\(cnt_{i - 1}\)</span> 转移到<span class="math inline">\(cnt_i\)</span>。发现每次由 <spanclass="math inline">\(T_{i - 1}\)</span> 变为 <spanclass="math inline">\(T_i\)</span>时，原来必选的点现在仍然必选，同时多出来了一些必选的点，称为目标点集。不难发现目标点集构成一条链，即点权为<span class="math inline">\(0\sim {i}\)</span> 的路径上 <spanclass="math inline">\(T_{i - 1}\)</span> 中的非必选点。</p><p>我们用一个 <code>vis</code> 数组标记已经访问过的点，遍历到 <spanclass="math inline">\(i\)</span> 时，若<code>!vis[i]</code>，就一直跳父亲（以点权为 <spanclass="math inline">\(0\)</span> 的点为根），直到 <code>vis</code> 为<span class="math inline">\(1\)</span>。途径的点即目标点集。</p><p>每次新增一个必选点 <span class="math inline">\(x\)</span> 时，有<span class="math inline">\(cnt \leftarrow cnt \times\dfrac{g_x}{f_x}\)</span>，对目标点集中的每个点更新即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log m)\)</span>，<spanclass="math inline">\(m\)</span> 为模数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];id[a[i]] = i;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;fa[x] = fath;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fath) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);dp[x] *= (<span class="hljs-number">1</span> + dp[y]);dp[x] %= modp;&#125;&#125;;<span class="hljs-type">int</span> rt = id[<span class="hljs-number">0</span>];<span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vis[rt] = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> ans = dp[rt], cur = ans;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> u = id[i];<span class="hljs-keyword">if</span> (!vis[u]) &#123;vector&lt;<span class="hljs-type">int</span>&gt; b; <span class="hljs-keyword">while</span> (!vis[u]) &#123;b.<span class="hljs-built_in">push_back</span>(u);u = fa[u];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;vis[x] = <span class="hljs-literal">true</span>;cur *= dp[x] * <span class="hljs-built_in">qpow</span>(<span class="hljs-number">1</span> + dp[x], modp - <span class="hljs-number">2</span>) % modp;cur %= modp;&#125;&#125;ans += cur;ans %= modp;&#125; cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="k.-天天爱跑步基环树单调队列线段树">K.天天爱跑步【基环树，单调队列，线段树】</h3><div class="note note-info">            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的基环树。对<span class="math inline">\(i\in[1, n]\)</span>求<strong>经过</strong>第 <span class="math inline">\(i\)</span>个点的最长简单路径长度。</p><p><span class="math inline">\(1 \le n \le 5\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>基环树的结构可概括为：一个环，然后环上的每个点向下延伸出子树。</p><p>以下是一些约定：</p><p>令 <span class="math inline">\(h_i\)</span> 代表点 <spanclass="math inline">\(i\)</span> 属于环上哪个点的子树。</p><p>令 <span class="math inline">\(dep_i\)</span> 代表点 <spanclass="math inline">\(i\)</span> 在子树内的深度。（<spanclass="math inline">\(h_i\)</span> 深度为 <spanclass="math inline">\(1\)</span>）</p><p>令 <span class="math inline">\(a_i\)</span> 代表环上的点 <spanclass="math inline">\(i\)</span> 向下延伸出的最长链长度。</p><p>令 <span class="math inline">\(len_i\)</span> 代表经过点 <spanclass="math inline">\(i\)</span> 且仅在 <spanclass="math inline">\(h_i\)</span> 子树内的最长链长度。</p><p>令 <span class="math inline">\(f_{i, 0/1}\)</span> 代表点 <spanclass="math inline">\(i\)</span> 向子树内延伸出的最长链/次长链长度。</p><p>令 <span class="math inline">\(g_{i, 0/1}\)</span> 代表点 <spanclass="math inline">\(i\)</span>向子树内延伸出的最长链/次长链对应的子节点。</p><p>令 <span class="math inline">\(\text{ano}\text{side}_i\)</span>代表环上的点 <span class="math inline">\(i\)</span>向该点子树外延伸出的最长链长度。（包括环上的一段以及环上另一点向其子树延伸出的最长链）</p><p>根据点 <span class="math inline">\(i\)</span>在基环树中的位置可以分为两种情况：点 <spanclass="math inline">\(i\)</span> 在环上和点 <spanclass="math inline">\(i\)</span> 在子树中。</p><p>点 <span class="math inline">\(i\)</span> 在环上时，我们要找的是<spanclass="math inline">\(\max(a_i+\text{anoside}_i)=\max(a_i+a_j+i-j)\)</span>。破环成链，则<span class="math inline">\(i-j\)</span> 代表环上的一段满足 <spanclass="math inline">\(i-j&lt;m\)</span> 的 <spanclass="math inline">\([j, i]\)</span>。</p><p>首先，我们可以用单调队列求出这个最大值。具体地，按顺序遍历环，每次往双端队列中压入<span class="math inline">\(i\)</span>，弹出队首不满足 <spanclass="math inline">\(i-j&lt; m\)</span> 的 <spanclass="math inline">\(j\)</span>，弹出队尾不满足 <spanclass="math inline">\(a_j-j\ge a_i-i\)</span> 的 <spanclass="math inline">\(j\)</span>。</p><p>求出最大值后，我们可以用线段树维护对应区间 <spanclass="math inline">\([j,i]\)</span>上的答案，每次用最大值与这个区间的值取 <spanclass="math inline">\(\max\)</span>。</p><p>注意，对环上的两个方向都要分别跑单调队列，同样更新答案。</p><p>点 <span class="math inline">\(i\)</span> 在子树中时，答案为： <spanclass="math display">\[\large \max(len_i,f_{i, 0}+dep_i-1+\text{anoside}_{h_i})\]</span> 前者为不经过环上的点的答案，后者为经过环上的点的答案。</p><p>对于一个子树，<span class="math inline">\(f_{i,0/1}\)</span> 可以一次dfs 求出，同时处理出 <span class="math inline">\(g_{i,0/1}\)</span>用于换根，求出 <span class="math inline">\(len_i\)</span>。</p><p>具体地，换根时令 <span class="math inline">\(d_i\)</span> 代表 <spanclass="math inline">\(i\)</span> 所在的子树外不经过环的最长链，有：<span class="math display">\[\large d_x=\max\begin{cases}d_{fa}+1\\f_{fa,0}+1 &amp;,g_{fa,0}\neq x\\f_{fa,1}+1 &amp;,g_{fa,0}=x\end{cases}\]</span> <span class="math display">\[\large len_x=f_{x,0}+\max(f_{x,1},d_x)\]</span></p><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sgt</span>&#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; tr;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span><span class="hljs-built_in">Sgt</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;tr.<span class="hljs-built_in">assign</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;tr[p] = <span class="hljs-built_in">max</span>(tr[p], x);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;<span class="hljs-built_in">update</span>(ls, l, mid, ql, qr, x);&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;<span class="hljs-built_in">update</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr, x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;l++; r++;<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">return</span> tr[p];&#125;<span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p], <span class="hljs-built_in">query</span>(ls, l, mid, pos));&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p], <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, pos));&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;pos++;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);deg[x]++;deg[y]++;&#125;<span class="hljs-keyword">auto</span> find_cir = [&amp;] () &#123;queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">1</span>) &#123;q.<span class="hljs-built_in">push</span>(i);&#125;&#125;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (--deg[y] == <span class="hljs-number">1</span>) &#123;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; o;<span class="hljs-keyword">auto</span> get_cir = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> rt) -&gt; <span class="hljs-type">void</span> &#123;o.<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa || y == rt || deg[y] &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x, rt);<span class="hljs-keyword">return</span> ;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (deg[i] &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">get_cir</span>(get_cir, i, <span class="hljs-number">0</span>, i);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> o;&#125;;vector cir = <span class="hljs-built_in">find_cir</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">h</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>); <span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> rt) -&gt; <span class="hljs-type">void</span> &#123; h[x] = rt; dep[x] = dep[fa] + <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123; <span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">continue</span>; &#125; <span class="hljs-built_in">self</span>(self, y, x, rt); <span class="hljs-keyword">if</span> (f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &gt; f[x][<span class="hljs-number">0</span>]) &#123; f[x][<span class="hljs-number">0</span>] = f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>; g[x][<span class="hljs-number">0</span>] = y; &#125; &#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123; <span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span> || y == g[x][<span class="hljs-number">0</span>]) &#123; <span class="hljs-keyword">continue</span>; &#125; <span class="hljs-keyword">if</span> (f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &gt; f[x][<span class="hljs-number">1</span>]) &#123; f[x][<span class="hljs-number">1</span>] = f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>; g[x][<span class="hljs-number">1</span>] = y; &#125; &#125;&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">len</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (fa) &#123;d[x] = d[fa] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (g[fa][<span class="hljs-number">0</span>] != x) &#123;d[x] = <span class="hljs-built_in">max</span>(d[x], f[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;d[x] = <span class="hljs-built_in">max</span>(d[x], f[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);&#125;&#125;len[x] = <span class="hljs-built_in">max</span>(f[x][<span class="hljs-number">0</span>] + f[x][<span class="hljs-number">1</span>], f[x][<span class="hljs-number">0</span>] + d[x]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;<span class="hljs-built_in">dfs1</span>(dfs1, x, <span class="hljs-number">0</span>, x);<span class="hljs-built_in">dfs2</span>(dfs2, x, <span class="hljs-number">0</span>);&#125;<span class="hljs-type">int</span> m = cir.<span class="hljs-built_in">size</span>();cir.<span class="hljs-built_in">insert</span>(cir.<span class="hljs-built_in">end</span>(), cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;a[i] = f[cir[i]][<span class="hljs-number">0</span>];&#125;<span class="hljs-function">Sgt <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">2</span> * m)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ano_side</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;deque&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span> &gt; m) &#123;q.<span class="hljs-built_in">pop_front</span>();&#125;<span class="hljs-type">int</span> j = q.<span class="hljs-built_in">front</span>();seg.<span class="hljs-built_in">update</span>(j, i, a[i] + a[j] + i - j);ano_side[cir[i]] = <span class="hljs-built_in">max</span>(ano_side[cir[i]], a[j] + i - j);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt; a[i] - i) &#123;q.<span class="hljs-built_in">pop_back</span>();&#125;q.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;ans[cir[i]] = <span class="hljs-built_in">max</span>(ans[cir[i]], seg.<span class="hljs-built_in">query</span>(i));&#125;<span class="hljs-built_in">reverse</span>(cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());q.<span class="hljs-built_in">clear</span>();q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span> &gt; m) &#123;q.<span class="hljs-built_in">pop_front</span>();&#125;<span class="hljs-type">int</span> j = q.<span class="hljs-built_in">front</span>();seg.<span class="hljs-built_in">update</span>(<span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - i, <span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - j, a[i] + a[j] + i - j);ano_side[cir[i]] = <span class="hljs-built_in">max</span>(ano_side[cir[i]], a[j] + i - j);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt; a[i] - i) &#123;q.<span class="hljs-built_in">pop_back</span>();&#125;q.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;ans[cir[i]] = <span class="hljs-built_in">max</span>(ans[cir[i]], seg.<span class="hljs-built_in">query</span>(<span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - i));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ans[i] = <span class="hljs-built_in">max</span>(&#123;ans[i], len[i], f[i][<span class="hljs-number">0</span>] + dep[i] - <span class="hljs-number">1</span> + ano_side[h[i]]&#125;);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="seerc-2020">SEERC 2020</h2><h3 id="b.-reverse-game博弈逆序对">B. Reverse Game【博弈，逆序对】</h3><div class="note note-info">            <p>给定一个 <span class="math inline">\(01\)</span> 串 <spanclass="math inline">\(s\)</span>，<spanclass="math inline">\(\text{Alice}\)</span> 和 <spanclass="math inline">\(\text{Bob}\)</span>进行回合制博弈。轮到一个人时，该名玩家可以从 <spanclass="math inline">\(s\)</span> 中任选一个恰为 <spanclass="math inline">\(10,110,100\)</span> 或 <spanclass="math inline">\(1010\)</span>的子串，并将其翻转。无法进行操作的玩家输，问先手是否有必胜策略。</p><p><span class="math inline">\(1 \le |s| \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>很考验 Insight 的题。</p><p>注意到 <span class="math inline">\(s\)</span> 的最后形态必然为 <spanclass="math inline">\(0\cdots01\cdots1\)</span>（因为有 <spanclass="math inline">\(10\)</span> 就可以翻转），特点是逆序对为 <spanclass="math inline">\(0\)</span>。</p><p>而每次翻转操作可以将 <span class="math inline">\(s\)</span>的逆序对数减少 <span class="math inline">\(1\)</span> 或 <spanclass="math inline">\(2\)</span>，并且手玩发现若 <spanclass="math inline">\(s\)</span> 的逆序对数 <spanclass="math inline">\(\ge 2\)</span>，则子串中一定有 <spanclass="math inline">\(110,100,1010\)</span> 中的一种。</p><p>根据必胜必败态定理，后手总存在策略使得一个轮次中 <spanclass="math inline">\(s\)</span> 的逆序对数减少 <spanclass="math inline">\(3\)</span>（即先手减 <spanclass="math inline">\(1\)</span> 后手减 <spanclass="math inline">\(2\)</span>，先手减 <spanclass="math inline">\(2\)</span> 后手减 <spanclass="math inline">\(1\)</span>）。</p><p>因此当 <span class="math inline">\(s\)</span> 的逆序对数 <spanclass="math inline">\(\bmod 3 = 0\)</span>时，后手必胜；否则先手必胜。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s;cin &gt;&gt; s;<span class="hljs-type">int</span> tot0 = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;tot0++;&#125; <span class="hljs-keyword">else</span> &#123;res += tot0;&#125;&#125;<span class="hljs-keyword">if</span> (res % <span class="hljs-number">3</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="a.-archeologists反悔贪心">A. Archeologists【反悔贪心】</h3><div class="note note-info">            <p>你在玩一个寻宝类游戏，一共有 <span class="math inline">\(n\)</span>个格子，编号为 <span class="math inline">\(1 \sim n\)</span>。你每在第<span class="math inline">\(i\)</span> 号格子上下挖一层便会获得 <spanclass="math inline">\(a_i\)</span>的价值，你需要保证每个格子与其相邻格子的下挖深度不超过 <spanclass="math inline">\(1\)</span>（注意此时 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(n\)</span> 号点最多只能挖一层），求最大价值。</p><p><span class="math inline">\(1 \le n \le 2.5\cdot 10^5\)</span>，<spanclass="math inline">\(-10^6 \le a_i \le 10^6\)</span>。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/jalyemdz.png" /></p>          </div><div class="note note-success">            <p>有一类用反悔贪心解决的经典问题：有一样物品，第 <spanclass="math inline">\(i\)</span> 天价值为 <spanclass="math inline">\(v_i\)</span>，每一天你可以买入一件或卖出一件，问最大收益。</p><p>解决步骤是维护一个小根堆，然后遍历 <spanclass="math inline">\(v_i\)</span>，若 <spanclass="math inline">\(v_i\)</span> 比堆顶 <spanclass="math inline">\(v_u\)</span> 大，则收益加上 <spanclass="math inline">\(v_i - v_u\)</span>，弹出堆顶，并再向堆中塞入一个<span class="math inline">\(v_i\)</span>。这样下次再卖出时（假设为第<span class="math inline">\(j\)</span> 天），若定位到为第 <spanclass="math inline">\(i\)</span> 天买入，就赚了 <spanclass="math inline">\(v_j - v_i\)</span>，加上之前赚的 <spanclass="math inline">\(v_i-v_u\)</span>，一共赚了 <spanclass="math inline">\(v_j-v_u\)</span>，等价于在第 <spanclass="math inline">\(u\)</span> 天买入第 <spanclass="math inline">\(j\)</span>天卖出。以此涵盖了在任意天买入和卖出的情况。</p><div class="code-wrapper"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">top</span>() &lt; a[i]) &#123;ans += a[i] - q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();q.<span class="hljs-built_in">push</span>(a[i]);&#125;q.<span class="hljs-built_in">push</span>(a[i]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</code></pre></div><p>对于本题，令 <span class="math inline">\(b_i\)</span> 为第 <spanclass="math inline">\(i\)</span> 个格子的下挖深度，由于相邻项相差不超过<span class="math inline">\(1\)</span>，因此其差分数组的每一项只可能是<span class="math inline">\(-1, 0, 1\)</span>。</p><p>将 <span class="math inline">\(1\)</span> 看成一次买入，<spanclass="math inline">\(-1\)</span> 看成一次卖出，就与经典题等价了。</p><p>将题给的 <span class="math inline">\(a_i\)</span>求前缀和作为物品的价值，跑反悔贪心即可。</p><p>时间复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];&#125;priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">top</span>() &lt; sum[i]) &#123;ans += sum[i] - q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();q.<span class="hljs-built_in">push</span>(sum[i]);&#125;q.<span class="hljs-built_in">push</span>(sum[i]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="h.-and-or线段树位运算">H. AND = OR【线段树，位运算】</h3><div class="note note-info">            <p>对于一个序列 <span class="math inline">\(\{b\}\)</span>，若可以将<span class="math inline">\(\{b\}\)</span>划分为两个非空的子序列，满足其中一个子序列中所有元素的 <spanclass="math inline">\(\text{And}\)</span> 与另一个子序列中所有元素的<span class="math inline">\(\text{OR}\)</span> 相等，则称 <spanclass="math inline">\(\{b\}\)</span> 是 good 的。</p><p>给定一个长为 <span class="math inline">\(n\)</span> 的数组 <spanclass="math inline">\(\{a\}\)</span>，以及 <spanclass="math inline">\(q\)</span> 次询问。每次询问 <spanclass="math inline">\(\{a\}\)</span> 的一个区间 <spanclass="math inline">\([l, r]\)</span> 是否 good。</p><p><span class="math inline">\(1 \le n,q \le 10^5\)</span>，<spanclass="math inline">\(0\le a_i &lt; 2^{30}\)</span>。</p>          </div><div class="note note-success">            <p>先考虑单个询问。设 <span class="math inline">\([l,r]\)</span>中的数被划分成 <span class="math inline">\(A,B\)</span> 两个集合，<spanclass="math inline">\(A\)</span> 集合的 <spanclass="math inline">\(\text{OR}\)</span> 和 <spanclass="math inline">\(B\)</span> 集合的 <spanclass="math inline">\(\text{And}\)</span> 相等，均为 <spanclass="math inline">\(X\)</span>。</p><p>那么宏观上有：<span class="math inline">\(A\)</span> 中的所有数 <spanclass="math inline">\(\le X\)</span>，<spanclass="math inline">\(B\)</span> 中的所有数 <spanclass="math inline">\(\ge X\)</span>。因此把 <spanclass="math inline">\([l,r]\)</span> 内的所有数升序排序，<spanclass="math inline">\(A\)</span> 中的数一定是一段前缀，<spanclass="math inline">\(B\)</span>中的数一定是一段后缀，枚举分段点即可。</p><p>还能按位来看：设 <spanclass="math inline">\(p(x)=\text{popcount}(x)\)</span>，<spanclass="math inline">\(p(X)=k\)</span>，那么 <spanclass="math inline">\(\forall x\in A,p(x)\le k\)</span>，<spanclass="math inline">\(\forall x \in B,p(x)\ge k\)</span>。</p><p>此时可以枚举分段点 <spanclass="math inline">\(g\)</span>，两种情况：</p><p><span class="math display">\[\Large\begin{cases}\text{And}_{x\in[l, r],p(x)\le g} = \text{Or}_{x\in[l,r],p(x)&gt;g}&amp;, g\in [0,30)\\\text{And}_{x\in[l, r],p(x)\le g}= \text{Or}_{x \in[l,r], p(x)\ge g}&amp;, g \in[0,30]\end{cases}\]</span></p><p>对于第二种情况，可以证明若能划分，那么满足 <spanclass="math inline">\(p(x)=g\)</span> 的所有 <spanclass="math inline">\(x\)</span> 必须相等。<spanclass="math inline">\((\alpha)\)</span></p><ul><li>证明：假设存在 <span class="math inline">\(a,b\)</span> 满足 <spanclass="math inline">\(p(a)=g,p(b)=g\)</span>，且 <spanclass="math inline">\(a\)</span> 被划分进 <spanclass="math inline">\(A\)</span>，<span class="math inline">\(b\)</span>被划分进 <span class="math inline">\(B\)</span>。那么：</li></ul><p><span class="math display">\[\Large\begin{cases}a \text{ | }X=X \\b \text{ \&amp; } X = X\end{cases}\to a \text{ \&amp; } b = b \xrightarrow{p(a)=p(b)} a= b\]</span></p><p>至此，我们可以用 <span class="math inline">\(30\)</span> 个线段树或<span class="math inline">\(30\)</span> 个 st 表维护二进制下每一位 <spanclass="math inline">\(\{a\}\)</span>的区间按位或和区间按位与。对于一个询问 <spanclass="math inline">\([l,r]\)</span>，查询这个区间每一位的 <spanclass="math inline">\(\text{Or}\)</span> 值（<spanclass="math inline">\(\text{Or}[g]\)</span>）和 <spanclass="math inline">\(\text{And}\)</span> 值（<spanclass="math inline">\(\text{And}[g]\)</span>），并对前者做前缀和，后者做后缀和（即<span class="math inline">\(\text{SOr}[g]\)</span> 代表区间内满足 <spanclass="math inline">\(p(x)\in[0,g]\)</span> 的所有 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(\text{Or}\)</span> 值，<spanclass="math inline">\(\text{SAnd}[g]\)</span> 代表区间内满足 <spanclass="math inline">\(p(x)\in[g,30]\)</span> 的所有 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(\text{And}\)</span> 值），对上文两种情况分别 <spanclass="math inline">\(\text{check}\)</span> 即可。</p><p>此外还要注意 <span class="math inline">\(\text{check}\)</span>两个集合必须非空，可以对每一位额外维护一个前缀和相同处理。</p><p>而 <span class="math inline">\((\alpha)\)</span> 条件等价于判断 <spanclass="math inline">\(\text{Or}[g]=\text{And}[g]\)</span>，不用额外处理。</p><p>最开始写的 st 表没卡过，换了线段树过的。时间复杂度 <spanclass="math inline">\(O(30n+30q\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; And, Or;<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size) &#123;n = size;And.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);Or.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;And[p] = And[ls] &amp; And[rs];Or[p] = Or[ls] | Or[rs];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">int</span>&gt; &amp;po, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;<span class="hljs-keyword">if</span> (po[l] == k) &#123;And[p] = Or[p] = nums[l];&#125; <span class="hljs-keyword">else</span> &#123;And[p] = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>; Or[p] = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">in_build</span>(ls, l, mid, nums, po, k);<span class="hljs-built_in">in_build</span>(rs, mid + <span class="hljs-number">1</span>, r, nums, po, k);<span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query_And</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> And[p];&#125;<span class="hljs-type">int</span> res = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;res &amp;= <span class="hljs-built_in">range_query_And</span>(ls, l, mid, ql, qr);&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;res &amp;= <span class="hljs-built_in">range_query_And</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query_Or</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> Or[p];&#125;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;res |= <span class="hljs-built_in">range_query_Or</span>(ls, l, mid, ql, qr);&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;res |= <span class="hljs-built_in">range_query_Or</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">int</span>&gt; &amp;po, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-built_in">in_build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, nums, po, k);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_And</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query_And</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_Or</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query_Or</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];p[i] = __builtin_popcount(a[i]);&#125;<span class="hljs-function">vector <span class="hljs-title">st_Sum</span><span class="hljs-params">(<span class="hljs-number">31</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">30</span>; k++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;st_Sum[k][i] = st_Sum[k][i - <span class="hljs-number">1</span>] + (p[i] == k ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);&#125;&#125;<span class="hljs-function">vector&lt;SegmentTree&gt; <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">31</span>, SegmentTree(n))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;seg[i].<span class="hljs-built_in">build</span>(a, p, i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span>, <span class="hljs-title">And</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span>, <span class="hljs-title">Or</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span></span>; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span>, <span class="hljs-title">preOr</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span>, <span class="hljs-title">sufAnd</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span>;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;Sum[i] = st_Sum[i][r] - st_Sum[i][l - <span class="hljs-number">1</span>];And[i] = seg[i].<span class="hljs-built_in">query_And</span>(l, r);Or[i] = seg[i].<span class="hljs-built_in">query_Or</span>(l, r);&#125;preSum[<span class="hljs-number">0</span>] = Sum[<span class="hljs-number">0</span>];preOr[<span class="hljs-number">0</span>] = Or[<span class="hljs-number">0</span>];sufAnd[<span class="hljs-number">31</span>] = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;preSum[i] = preSum[i - <span class="hljs-number">1</span>] + Sum[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;preOr[i] = preOr[i - <span class="hljs-number">1</span>] | Or[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;sufAnd[i] = sufAnd[i + <span class="hljs-number">1</span>] &amp; And[i];&#125;<span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<span class="hljs-keyword">if</span> (preOr[i] == sufAnd[i + <span class="hljs-number">1</span>] &amp;&amp; preSum[i] &amp;&amp; preSum[i] &lt; preSum[<span class="hljs-number">30</span>]) &#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (!flag) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<span class="hljs-keyword">if</span> (preOr[i] == sufAnd[i] &amp;&amp; Or[i] == And[i] &amp;&amp; Sum[i] &gt; <span class="hljs-number">1</span>) &#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES\n&quot;</span> : <span class="hljs-string">&quot;NO\n&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="江苏省赛-ccpc-hunan">2023 江苏省赛/ CCPC Hunan</h2><h3 id="b.-honkai-in-taikula拆点缩点全源最短路">B. Honkai inTAIKULA【拆点，缩点，全源最短路】</h3><div class="note note-info">            <p>给定一张 <span class="math inline">\(n\)</span> 个节点 <spanclass="math inline">\(m\)</span>条边的有向带权图，对每个节点，报告是否存在经过该点的奇权圈（可经过重复顶点、重复边、若经过重复边，边权计多次）。若存在，输出最小奇权圈的权值（或报告为负无穷）。</p><p><span class="math inline">\(1\le n \le 1000\)</span>，<spanclass="math inline">\(1 \le m \le 10^4\)</span>，<spanclass="math inline">\(0\le x_i,y_i &lt; n\)</span>，<spanclass="math inline">\(|w_i| \le 10^7\)</span>。</p>          </div><div class="note note-success">            <p>处理带权图的边权奇偶性问题常用缩点：把一个点 <spanclass="math inline">\(x\)</span> 拆成一个奇点 <spanclass="math inline">\(\text{Odd}_x\)</span>、一个偶点 <spanclass="math inline">\(\text{Even}_x\)</span>。</p><ul><li>若存在 <span class="math inline">\(x\xrightarrow{w}y\)</span>，<span class="math inline">\(w\)</span> 为奇数。则连 <spanclass="math inline">\(\text{Odd}_x \to \text{Even}_y\)</span>，<spanclass="math inline">\(\text{Even}_x \to \text{Odd}_y\)</span>。</li><li>若存在 <span class="math inline">\(x \xrightarrow{w}y\)</span>，<span class="math inline">\(w\)</span> 为偶数。则连 <spanclass="math inline">\(\text{Odd}_x\to \text{Odd}_y\)</span>，<spanclass="math inline">\(\text{Even}_x\to \text{Even}_y\)</span>。</li></ul><p>若存在一个经过点 <span class="math inline">\(x\)</span>的奇权圈，等价于存在一条 <span class="math inline">\(\text{Odd}_x \to\text{Even}_x\)</span> 的路径。（或 <spanclass="math inline">\(\text{Even}_x \to\text{Odd}_x\)</span>，钦定一种即可）</p><p>接着，由于环只存在于单个强连通分量内，所以考虑缩点得到一张有向无环图<span class="math inline">\(G\)</span>。</p><p>注意到只要存在一条路径从 <span class="math inline">\(x\)</span>出发，经过负环，再回到 <spanclass="math inline">\(x\)</span>。那么最小奇权圈的权值就是负无穷，因为可以再负环上无限绕再返回<span class="math inline">\(x\)</span>。所以对 <spanclass="math inline">\(G\)</span> 中每个点代表的子图都跑 SPFA算法判断负环。</p><p>设 <span class="math inline">\(\text{Odd}_x\)</span> 和 <spanclass="math inline">\(\text{Even}_x\)</span> 所在的 SCC 编号分别为 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>。利用 dfs 判断 <spanclass="math inline">\(G\)</span> 中是否存在 <spanclass="math inline">\(A\to B\)</span>的路径，路径上又是否有标记为负环的点即可完成无解和负无穷解的判断。</p><p>接下来是有解的情况。在未缩点的原图上跑 Johnson全源最短路即可，注意避开 “位于被标记负环的 SCC 中” 的所有点。</p><p>时间复杂度 <span class="math inline">\(O(nm\log m)\)</span>。</p>          </div><div class="note note-warning">            <p>Funfact：有人拓扑图上 dfs 不用标记数组标记走过的点，狂 T两小时QAQ。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _node vector<span class="hljs-string">&lt;vector&lt;array&lt;int, 2&gt;</span>&gt;&gt;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Johnson</span> &#123;<span class="hljs-type">int</span> n;_node adj;vector&lt;<span class="hljs-type">int</span>&gt; h, dis, A;<span class="hljs-built_in">Johnson</span>(_node Adj, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B) &#123;adj = Adj;A = B;<span class="hljs-keyword">this</span>-&gt;n = Adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-built_in">init</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;h.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);dis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;adj[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;i, <span class="hljs-number">0</span>&#125;);&#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">circle</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;h.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);queue&lt;<span class="hljs-type">int</span>&gt; q;vis[s] = <span class="hljs-literal">true</span>;h[s] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();vis[x] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (!A[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span>(h[y] &gt; h[x] + w) &#123;h[y] = h[x] + w;<span class="hljs-keyword">if</span>(!vis[y]) &#123;<span class="hljs-keyword">if</span>(++circle[y] &gt;= n + <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;vis[y] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;priority_queue&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; q;dis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;dis[s] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>()[<span class="hljs-number">1</span>];q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (!A[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span>(dis[y] &gt; dis[x] + w) &#123;dis[y] = dis[x] + w;q.<span class="hljs-built_in">push</span>(&#123;-dis[y], y&#125;);&#125;&#125;&#125;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">work</span>() &#123;<span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, -inf))</span></span>;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>)) &#123;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[y, w] : adj[x]) &#123;w += h[x] - h[y];&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-built_in">dijkstra</span>(i);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<span class="hljs-keyword">if</span> (dis[j] == inf) &#123;ans[i][j] = inf; &#125; <span class="hljs-keyword">else</span> &#123;ans[i][j] = dis[j] + (h[j] - h[i]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; E;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;x++; y++;<span class="hljs-keyword">if</span> (w % <span class="hljs-number">2</span>) &#123;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y + n, w&#125;);adj[x + n].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);E.<span class="hljs-built_in">push_back</span>(&#123;x, y + n, w&#125;);E.<span class="hljs-built_in">push_back</span>(&#123;x + n, y, w&#125;);&#125; <span class="hljs-keyword">else</span> &#123;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);adj[x + n].<span class="hljs-built_in">push_back</span>(&#123;y + n, w&#125;);E.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);E.<span class="hljs-built_in">push_back</span>(&#123;x + n, y + n, w&#125;);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">VIS</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x] = low[x] = ++tim;VIS[x] = <span class="hljs-literal">true</span>;stack_[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VIS[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span> &#123;now = stack_[top--];VIS[now] = <span class="hljs-literal">false</span>;c[now] = cnt;scc[cnt].<span class="hljs-built_in">push_back</span>(now);&#125; <span class="hljs-keyword">while</span>(x != now);&#125;&#125;;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">Adj</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> shrinkPoint = [&amp;]() &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">2</span> * n; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : adj[x]) &#123;<span class="hljs-keyword">if</span> (c[x] == c[y]) <span class="hljs-keyword">continue</span>;Adj[c[x]].<span class="hljs-built_in">push_back</span>(c[y]);&#125;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++)<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-built_in">shrinkPoint</span>();vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">G</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>; <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">auto</span> spfa = [&amp;](<span class="hljs-type">int</span> s) &#123;dis.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, inf);vis.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);num.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);dis[s] = <span class="hljs-number">0</span>;vis[s] = <span class="hljs-literal">true</span>;priority_queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(s);num[s]++;<span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();vis[x] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, z] : G[x]) &#123;<span class="hljs-keyword">if</span>(dis[y] &gt; dis[x] + z) &#123;dis[y] = dis[x] + z;<span class="hljs-keyword">if</span> (!vis[y]) &#123;vis[y] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(y);<span class="hljs-keyword">if</span> (++num[y] &gt; scc[c[s]].<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">have_circle</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> rt : scc[i]) &#123;exist[rt] = <span class="hljs-number">1</span>;&#125;G.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : E) &#123;<span class="hljs-keyword">if</span> (exist[x] &amp;&amp; exist[y]) &#123;G[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);&#125;&#125;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(scc[i][<span class="hljs-number">0</span>])) &#123;have_circle[i] = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-type">int</span> T, success;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis2</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> flag) -&gt; <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">if</span> (have_circle[x]) &#123;flag = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (x == T) &#123;<span class="hljs-keyword">if</span>(flag) &#123;success = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;<span class="hljs-keyword">if</span> (vis2[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis2[y] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>(self, y, flag)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;T = c[i + n];success = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> res = <span class="hljs-built_in">dfs</span>(dfs, c[i], <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (!res) &#123;ans[i] = <span class="hljs-number">-1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (success) &#123;ans[i] = inf;&#125; &#125; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<span class="hljs-keyword">if</span> (!have_circle[i]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : scc[i]) &#123;A[x] = <span class="hljs-literal">true</span>;&#125;&#125;&#125;<span class="hljs-function">Johnson <span class="hljs-title">H</span><span class="hljs-params">(adj, A)</span></span>;vector diss = H.<span class="hljs-built_in">work</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (ans[i] == <span class="hljs-number">-1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Battle with the crazy Honkai\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans[i] == inf) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Haha, stupid Honkai\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; diss[i][i + n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="l.-architect思维扫描线">L. Architect【思维，扫描线】</h3><div class="note note-info">            <p>给定 <span class="math inline">\(n\)</span>个长方体，询问其是否能拼接成一个 <span class="math inline">\(W\timesH\times L\)</span> 的立方体，没有重叠和空隙，所有长方体都要用到。</p><p><span class="math inline">\(1\le  n \le 10^5\)</span>，<spanclass="math inline">\(1\le W, H, L \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>一种绝世聪明的想法是 “只需判断 <span class="math inline">\(n\)</span>个立方体的体积和是否 <span class="math inline">\(=\)</span> <spanclass="math inline">\(W\times H\timesL\)</span>，且八个角的出现次数是否是偶数次即可”。</p><p>体积一样限定了这 <span class="math inline">\(n\)</span>个立方体不能有重叠。</p><p>八个角出现了偶数次限定了这 <span class="math inline">\(n\)</span>个立方体与大立方体间没有空隙。</p><p>注意 <span class="math inline">\(10^9\cdot 10^9\cdot10^9=10^{27}\)</span>，需要开 <code>__int128</code>。</p><p>时间复杂度 <span class="math inline">\(O(8n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int __int128</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, __int128 &amp;n) &#123;    string s;    is &gt;&gt; s;    n = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;     n = n * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);    &#125;    <span class="hljs-keyword">return</span> is;&#125;ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, __int128 n) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-number">0</span>;&#125;string s;<span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123; s += <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;0&#x27;</span> + n % <span class="hljs-number">10</span>); n /= <span class="hljs-number">10</span>;&#125;<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">return</span> os &lt;&lt; s;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> W, H, L, n;cin &gt;&gt; W &gt;&gt; H &gt;&gt; L &gt;&gt; n;<span class="hljs-type">int</span> All = W * H * L, all = <span class="hljs-number">0</span>;map&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">auto</span> ins = [&amp;] (<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> z0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> z1) &#123;mp[&#123;x0, y0, z0&#125;]++;mp[&#123;x0, y0, z1&#125;]++;mp[&#123;x0, y1, z0&#125;]++;mp[&#123;x0, y1, z1&#125;]++;mp[&#123;x1, y0, z0&#125;]++;mp[&#123;x1, y0, z1&#125;]++;mp[&#123;x1, y1, z0&#125;]++;mp[&#123;x1, y1, z1&#125;]++;&#125;;<span class="hljs-built_in">ins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, L);<span class="hljs-keyword">while</span> (n--) &#123;<span class="hljs-type">int</span> x0, y0, z0, x1, y1, z1;cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; z0 &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1;all += (x1 - x0) * (y1 - y0) * (z1 - z0);<span class="hljs-built_in">ins</span>(x0, y0, z0, x1, y1, z1);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, x] : mp) &#123;<span class="hljs-keyword">if</span> (x &amp; <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;cout &lt;&lt; (all == All ? <span class="hljs-string">&quot;Yes\n&quot;</span> : <span class="hljs-string">&quot;No\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>另一种朴素但也颇具技巧性的方法是扫描线。</p><p>先将 <span class="math inline">\(n\)</span> 个小立方体的底面看作<span class="math inline">\(1\)</span>，顶面看作 <spanclass="math inline">\(-1\)</span>；大立方体的底面看作 <spanclass="math inline">\(-1\)</span>，顶面看作 <spanclass="math inline">\(1\)</span>。</p><p>如果每个表面紧紧贴合，那么代数和为 <spanclass="math inline">\(0\)</span>。</p><p>接着不断降维，同样的思想能判断线是否紧密贴合，点是否紧密贴合。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check2</span><span class="hljs-params">(vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; a)</span> </span>&#123;map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x1, x2, flag] : a) &#123;mp[x1] += flag;mp[x2] += -flag;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;<span class="hljs-keyword">if</span> (v) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt;&gt; a)</span> </span>&#123;map&lt;<span class="hljs-type">int</span>, vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt;&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x1, y1, x2, y2, flag] : a) &#123;mp[y1].<span class="hljs-built_in">push_back</span>(&#123;x1, x2, flag&#125;);mp[y2].<span class="hljs-built_in">push_back</span>(&#123;x1, x2, -flag&#125;);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check2</span>(v)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> W, H, L;cin &gt;&gt; W &gt;&gt; H &gt;&gt; L;map&lt;<span class="hljs-type">int</span>, vector&lt;array&lt;<span class="hljs-type">int</span>, 5&gt;&gt;&gt; mp;mp[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, <span class="hljs-number">-1</span>&#125;);mp[L].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, <span class="hljs-number">1</span>&#125;);<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x1, y1, z1, x2, y2, z2;cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2;mp[z1].<span class="hljs-built_in">push_back</span>(&#123;x1, y1, x2, y2, <span class="hljs-number">1</span>&#125;);mp[z2].<span class="hljs-built_in">push_back</span>(&#123;x1, y1, x2, y2, <span class="hljs-number">-1</span>&#125;);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(v)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="ccpc-weihai">2020 CCPC Weihai</h2><h3 id="b.-labyrinthbfs">B. Labyrinth【bfs】</h3><div class="note note-info">            <p>给定一个 <span class="math inline">\(n\times m\)</span> 的网格图，有<span class="math inline">\(k\)</span> 个格子有障碍不能通行。<spanclass="math inline">\(q\)</span>次询问，每次询问两点间的最短路长度。</p><p><span class="math inline">\(1\le n,m\le2\cdot 10^5\)</span>，<spanclass="math inline">\(1\le n\cdot m\le 2\cdot 10^5\)</span>，<spanclass="math inline">\(0\le k \le 42\)</span>，<spanclass="math inline">\(1\le q\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>对于一组询问，假设询问的两个点是 <spanclass="math inline">\((x_1,y_1)\)</span> 和 <spanclass="math inline">\((x_2, y_2)\)</span>。</p><p>那么当 <span class="math inline">\((x_1,y_1)\)</span> 和 <spanclass="math inline">\((x_2,y_2)\)</span>作为对角线的两个端点围成的矩形中没有一个障碍时，答案就是这两点间的曼哈顿距离；否则可以想象到最短路一定经过某个障碍周围四格中的某一格。</p><p>把所有障碍的四联通预处理出来并去重，以每个点为起点跑 bfs求出其到所有格子的最短路。</p><p>询问时枚举一下这 <span class="math inline">\(O(4k)\)</span>个点作为中转点的最短路，取 <span class="math inline">\(\min\)</span>即可。</p><p>时间复杂度 <span class="math inline">\(O(knm)-O(k)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(<span class="hljs-string">&quot;Ofast&quot;</span>)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k, Q;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; Q;<span class="hljs-function">vector <span class="hljs-title">bomb</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;bomb[x][y] = <span class="hljs-number">1</span>;&#125;vector sum = bomb;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;sum[i][j] += sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">auto</span> query = [&amp;] (<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy) &#123;<span class="hljs-keyword">return</span> sum[fx][fy] - sum[sx - <span class="hljs-number">1</span>][fy] - sum[fx][sy - <span class="hljs-number">1</span>] + sum[sx - <span class="hljs-number">1</span>][sy - <span class="hljs-number">1</span>];&#125;;<span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; waiting;<span class="hljs-function">vector <span class="hljs-title">VIS</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">if</span> (bomb[i][j]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<span class="hljs-type">int</span> x = i + dx[k];<span class="hljs-type">int</span> y = j + dy[k];<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">1</span> || x &gt; n || y &gt; m || bomb[x][y] || VIS[x][y]) &#123;<span class="hljs-keyword">continue</span>;&#125;VIS[x][y] = <span class="hljs-literal">true</span>;waiting.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);&#125;&#125;&#125;&#125;<span class="hljs-type">int</span> all = waiting.<span class="hljs-built_in">size</span>();<span class="hljs-function">vector <span class="hljs-title">dis</span><span class="hljs-params">(all, vector(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, inf)))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>; id &lt; all; id++) &#123;<span class="hljs-keyword">auto</span> [sx, sy] = waiting[id];queue&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; q;q.<span class="hljs-built_in">push</span>(&#123;sx, sy, <span class="hljs-number">0</span>&#125;);<span class="hljs-function">vector <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;vis[sx][sy] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> [x, y, lst_dis] = q.<span class="hljs-built_in">front</span>();dis[id][x][y] = lst_dis;q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-type">int</span> xx = x + dx[i];<span class="hljs-type">int</span> yy = y + dy[i];<span class="hljs-keyword">if</span> (xx &lt; <span class="hljs-number">1</span> || yy &lt; <span class="hljs-number">1</span> || xx &gt; n || yy &gt; m || bomb[xx][yy] || vis[xx][yy]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[xx][yy] = <span class="hljs-literal">true</span>;<span class="hljs-type">int</span> cur_dis = lst_dis + <span class="hljs-number">1</span>;q.<span class="hljs-built_in">push</span>(&#123;xx, yy, cur_dis&#125;);&#125;&#125;&#125;<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy) &#123;&#125;;<span class="hljs-keyword">while</span> (Q--) &#123;<span class="hljs-type">int</span> sx, sy, fx, fy;cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;<span class="hljs-keyword">if</span> (bomb[sx][sy] || bomb[fx][fy]) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (sx == fx &amp;&amp; sy == fy) &#123;cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> lx = <span class="hljs-built_in">min</span>(sx, fx);<span class="hljs-type">int</span> ly = <span class="hljs-built_in">min</span>(sy, fy);<span class="hljs-type">int</span> rx = <span class="hljs-built_in">max</span>(sx, fx);<span class="hljs-type">int</span> ry = <span class="hljs-built_in">max</span>(sy, fy);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">query</span>(lx, ly, rx, ry)) &#123;cout &lt;&lt; <span class="hljs-built_in">abs</span>(sx - fx) + <span class="hljs-built_in">abs</span>(sy - fy) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; all; i++) &#123;<span class="hljs-keyword">if</span> (dis[i][sx][sy] == inf || dis[i][fx][fy] == inf) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = dis[i][sx][sy] + dis[i][fx][fy];ans = <span class="hljs-built_in">min</span>(ans, res);&#125;<span class="hljs-keyword">if</span> (ans == inf) &#123;ans = <span class="hljs-number">-1</span>;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="c.-rencontre结论期望">C. Rencontre【结论，期望】</h3><div class="note note-info">            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，边有边权<spanclass="math inline">\(w_i\)</span>。给定三个点集，从三个点集中分别随机选出<span class="math inline">\(u_1,u_2,u_3\)</span>，问以下式子的期望：<span class="math display">\[f(u_1,u_2,u_3)=\min_{i\in[1,n]}(dis(u_1,i)+dis(u_2,i)+dis(u_3,i))\]</span> 其中 <span class="math inline">\(dis(x,y)\)</span> 代表点<span class="math inline">\(x,y\)</span> 间的树上距离。</p><p><span class="math inline">\(1\le n \le 2 \cdot 10^5\)</span>，<spanclass="math inline">\(1\le w \le 1000\)</span>。</p>          </div><div class="note note-success">            <p>结论题。所给式子等价于： <span class="math display">\[f(u_1,u_2,u_3)=\frac{1}{2}(dis(u_1,u_2)+dis(u_2,u_3)+dis(u_1,u_3))\]</span> 根据期望的线性性，只需分别求出这三项每一项的期望再相加。</p><p>以 <span class="math inline">\(dis(u_1,u_2)\)</span>举例，考虑拆贡献：对于一条边 <spanclass="math inline">\(x\xleftrightarrow{w}y\)</span>，设 <spanclass="math inline">\(x\)</span> 一侧有 <spanclass="math inline">\(A_x\)</span> 个点属于点集一，<spanclass="math inline">\(B_x\)</span> 个点属于点集二；<spanclass="math inline">\(y\)</span> 一侧有 <spanclass="math inline">\(A_y\)</span> 个点属于点集一，<spanclass="math inline">\(B_y\)</span> 个点属于点集二。</p><p>那么该条边的贡献为 <span class="math inline">\(w\cdot \dfrac{A_xB_y+A_yB_x}{|A||B|}\)</span>，<span class="math inline">\(|A|\)</span>和 <span class="math inline">\(|B|\)</span>分别为点集一和点集二的大小。最终贡献就是所有边的贡献之和。</p><p>dfs 简单处理，时间复杂度 <spanclass="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);&#125;vector&lt;<span class="hljs-type">int</span>&gt; A, B, C;<span class="hljs-type">int</span> An, Bn, Cn;cin &gt;&gt; An;<span class="hljs-keyword">while</span> (An--) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;A.<span class="hljs-built_in">push_back</span>(x);&#125;cin &gt;&gt; Bn;<span class="hljs-keyword">while</span> (Bn--) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;B.<span class="hljs-built_in">push_back</span>(x);&#125;cin &gt;&gt; Cn;<span class="hljs-keyword">while</span> (Cn--) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;C.<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">auto</span> calc = [&amp;] (vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">isa</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">isb</span>(n + <span class="hljs-number">1</span>);<span class="hljs-type">int</span> asz = <span class="hljs-number">0</span>, bsz = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;isa[x] = <span class="hljs-literal">true</span>;asz++;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;isb[x] = <span class="hljs-literal">true</span>;bsz++;&#125;vector f = isa, g = isb;<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);f[x] += f[y];g[x] += g[y];&#125;&#125;;<span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">double</span> t = <span class="hljs-number">1.0</span> * f[y] * (bsz - g[y]);t += <span class="hljs-number">1.0</span> * g[y] * (asz - f[y]);res += <span class="hljs-number">1.0</span> * w * t;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);res /= (asz * bsz);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;ans += <span class="hljs-built_in">calc</span>(A, B);ans += <span class="hljs-built_in">calc</span>(B, C);ans += <span class="hljs-built_in">calc</span>(A, C);ans /= <span class="hljs-number">2</span>;cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>) &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-caesar-cipher线段树维护哈希值">G. CaesarCipher【线段树维护哈希值】</h3><div class="note note-info">            <p>维护一个序列 <spanclass="math inline">\(\{a\}\)</span>，支持两种操作：</p><ul><li><code>1 l r</code>：<span class="math inline">\(\forall i\in[l,r]\)</span>，<span class="math inline">\(a_i=(a_i+1)\bmod65536\)</span>.</li><li><code>2 x y L</code>：询问区间 <spanclass="math inline">\([x,x+L-1]\)</span> 和区间 <spanclass="math inline">\([y,y+L-1]\)</span> 是否完全相同。</li></ul><p><span class="math inline">\(1\le n,q\le 5\cdot10^5\)</span>。</p>          </div><div class="note note-success">            <p>经典题，线段树维护哈希值。</p><p>预处理出 <code>pow[i]</code> 代表 <spanclass="math inline">\(\text{base}^i\)</span>，<code>pre[i]</code> 代表<span class="math inline">\(\sum_{j=0}^{i}\text{base}^j\)</span>。</p><p>区间合并时，左区间的哈希值需要乘 <code>pow[r - mid]</code>再加上右区间的哈希值。</p><p>区间修改时，相当于区间加 <code>pre[r - l]</code>。</p><p>区间查询时，合并答案需要左区间答案乘<code>pow[max(0, min(r, qr) - mid)]</code> 再加上右区间答案。</p><p>这道题的创新点是操作一需要模一个数。</p><p>注意到值溢出（即 <span class="math inline">\(\ge65536\)</span>）的次数不超过 <spanclass="math inline">\(\frac{nq}{65536}\approx 4\cdot10^6\)</span>次，可以维护区间最大值，每次定位到那个溢出的点然后单点修改。</p><p>时间复杂度 <span class="math inline">\(O(\frac{nq\log n}{65536}+q\logn)\)</span>。时限给了 10s，实际上 1s 多一点就跑完了。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> base = <span class="hljs-number">65536</span>;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1145141</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sgt</span>&#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; h, mx, Add;vector&lt;<span class="hljs-type">int</span>&gt; pow, pre;<span class="hljs-built_in">Sgt</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">h</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), <span class="hljs-built_in">mx</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), <span class="hljs-built_in">Add</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), <span class="hljs-built_in">pow</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">pre</span>(n + <span class="hljs-number">1</span>) &#123;pow[<span class="hljs-number">0</span>] = pre[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;pow[i] = pow[i - <span class="hljs-number">1</span>] * base % mod;pre[i] = (pre[i - <span class="hljs-number">1</span>] + pow[i]) % mod;&#125;&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;h[p] = (h[ls] * pow[r - mid] % mod + h[rs]) % mod;mx[p] = <span class="hljs-built_in">max</span>(mx[ls], mx[rs]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (Add[p]) &#123;h[ls] = (h[ls] + Add[p] * pre[mid - l] % mod) % mod; h[rs] = (h[rs] + Add[p] * pre[r - mid - <span class="hljs-number">1</span>] % mod) % mod;mx[ls] += Add[p];mx[rs] += Add[p];Add[ls] += Add[p];Add[rs] += Add[p];Add[p] = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) &#123;h[p] = a[l];mx[p] = a[l];<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">build</span>(ls, l, mid, a);<span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r, a);<span class="hljs-built_in">pushup</span>(p, l, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;h[p] = (h[p] + pre[r - l]) % mod;Add[p]++;mx[p]++;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">pushdown</span>(p, l, r);<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;<span class="hljs-built_in">update</span>(ls, l, mid, ql, qr);&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;<span class="hljs-built_in">update</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);&#125;<span class="hljs-built_in">pushup</span>(p, l, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_mod</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (mx[p] &lt; base) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (l == r) &#123;h[p] -= base;mx[p] -= base;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">pushdown</span>(p, l, r);<span class="hljs-keyword">if</span> (mx[ls] &gt;= base) &#123;<span class="hljs-built_in">update_mod</span>(ls, l, mid);&#125;<span class="hljs-keyword">if</span> (mx[rs] &gt;= base) &#123;<span class="hljs-built_in">update_mod</span>(rs, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-built_in">pushup</span>(p, l, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_mod</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">update_mod</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> h[p];&#125;<span class="hljs-built_in">pushdown</span>(p, l, r);<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;<span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, <span class="hljs-built_in">min</span>(r, qr) - mid);res = (res + <span class="hljs-built_in">query</span>(ls, l, mid, ql, qr) * pow[len] % mod) % mod;&#125;<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;res = (res + <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr)) % mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-function">Sgt <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;seg.<span class="hljs-built_in">build</span>(a);<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> opt;cin &gt;&gt; opt;<span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;seg.<span class="hljs-built_in">update</span>(l, r);seg.<span class="hljs-built_in">update_mod</span>();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x, y, L;cin &gt;&gt; x &gt;&gt; y &gt;&gt; L;<span class="hljs-type">int</span> h1 = seg.<span class="hljs-built_in">query</span>(x, x + L - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> h2 = seg.<span class="hljs-built_in">query</span>(y, y + L - <span class="hljs-number">1</span>);cout &lt;&lt; (h1 == h2 ? <span class="hljs-string">&quot;yes\n&quot;</span> : <span class="hljs-string">&quot;no\n&quot;</span>);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="j.-steinsgame博弈sg函数线性基">J.Steins;Game【博弈，SG函数，线性基】</h3><div class="note note-info">            <p>现定义一种博弈游戏：有 <span class="math inline">\(n\)</span>堆石子，每堆石子被涂成了黑色或白色。双方轮流从以下两种取石子方式中选择一种并操作：</p><ul><li>从石子数最少的黑色堆中取任意个石子。这里“最少”是与其它黑色堆比较。</li><li>从任意白色堆中取任意个石子。</li></ul><p>轮到某一方时无石子可取则败。</p><p>现在这 <span class="math inline">\(n\)</span> 堆石子每一堆的数量<span class="math inline">\(a_i\)</span> 固定，但并未上色。</p><p>求有多少种上色方案，使得先手必败。方案数对 <spanclass="math inline">\(10^9+7\)</span> 取模。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<spanclass="math inline">\(1 \le a_i \le 10^{18}\)</span>。</p>          </div><div class="note note-success">            <p>将白色堆和黑色堆分开来看，称为白色游戏和黑色游戏。</p><p>当白色游戏的 SG 值和黑色游戏的 SG 值异或为 <spanclass="math inline">\(0\)</span> 时，先手必败。</p><p>白色游戏即 nim 游戏——当所有白色堆石子数目的异或和为 <spanclass="math inline">\(0\)</span> 时，先手必败。</p><p>接着尝试求出黑色游戏的 SG 值，可以打表找规律。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        bruteforce    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> node priority_queue<span class="hljs-string">&lt;int, vector&lt;int&gt;</span>, greater<span class="hljs-string">&lt;int&gt;</span>&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n = <span class="hljs-number">7</span>, mx = <span class="hljs-number">8</span>;map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">auto</span> sg = [&amp;] (<span class="hljs-keyword">auto</span> self, node q) -&gt; <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;vector&lt;<span class="hljs-type">int</span>&gt; A;node o_q = q;<span class="hljs-keyword">while</span> (!o_q.<span class="hljs-built_in">empty</span>()) &#123;A.<span class="hljs-built_in">push_back</span>(o_q.<span class="hljs-built_in">top</span>());o_q.<span class="hljs-built_in">pop</span>();&#125;<span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(A)) &#123;<span class="hljs-keyword">return</span> mp[A];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();vis[<span class="hljs-built_in">self</span>(self, q)] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; x; i++) &#123;<span class="hljs-keyword">auto</span> tmp = q;tmp.<span class="hljs-built_in">push</span>(i);vis[<span class="hljs-built_in">self</span>(self, tmp)] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;<span class="hljs-keyword">return</span> mp[A] = i;&#125;&#125;&#125;;vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> lst) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (dep == n) &#123;node q;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;q.<span class="hljs-built_in">push</span>(x);cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; <span class="hljs-string">&quot; sg = &quot;</span> &lt;&lt; <span class="hljs-built_in">sg</span>(sg, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lst; i &lt;= mx; i++) &#123;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;a.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-built_in">self</span>(self, dep + <span class="hljs-number">1</span>, i);<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;a.<span class="hljs-built_in">pop_back</span>();&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>结论是： <span class="math display">\[\text{SG}_{黑色游戏}=\text{最小堆石子数量}-(有多少堆石子数最少+[所有堆石子数相同])\bmod2\]</span> 然后是计数。将 <span class="math inline">\(a_i\)</span>排序，预处理出前缀异或和 <spanclass="math inline">\(\text{pre}_i\)</span>，后缀异或和 <spanclass="math inline">\(\text{suf}_i\)</span>，有 <spanclass="math inline">\(\text{tot}_i\)</span> 堆石子数为 <spanclass="math inline">\(i\)</span>，以及第 <spanclass="math inline">\(i\sim n\)</span> 堆中有 <spanclass="math inline">\(\text{same}_i\)</span> 堆石子数为 <spanclass="math inline">\(a_i\)</span>。在以下过程中，相同石子数的堆可以先被当成无标号来做，最后再乘上组合数转为有标号。</p><p>从后向前扫 <span class="math inline">\(\{a\}\)</span>，设当前扫到第<span class="math inline">\(i\)</span> 堆，钦定第 <spanclass="math inline">\(i\)</span>堆为黑色且在黑色堆中石子数量最少。此时第 <spanclass="math inline">\(1\sim (i-1)\)</span> 堆只能是黑色，异或和为 <spanclass="math inline">\(X=\text{pre}_{i-1}\)</span>。然后分“所有黑色堆石子数是否相同” 来讨论第 <span class="math inline">\((i + 1)\sim n\)</span> 堆。</p><p>若选出的黑色堆要满足石子数相同，则第 <spanclass="math inline">\(i\sim (i+\text{same}_i-1)\)</span>堆为黑色（因为是从后往前扫，所以涵盖了该连续段所有后缀为黑色堆的情况），第<span class="math inline">\((i+\text{same}_i)\sim n\)</span>堆为白色。它们的 SG 值可以用上述公式以及后缀异或和快速求。</p><p>若选出的黑色堆不需要满足石子数相同，那么黑色游戏的 SG 为 <spanclass="math inline">\(Y=a_{i}-\text{same}_i \bmod2\)</span>。此时需要从后面的堆中选出若干白色堆使得它们的异或和是 <spanclass="math inline">\(X\oplus Y\)</span>，方案数可以用线性基求出。</p><p>具体地，设线性基 <span class="math inline">\(S\)</span> 的大小为<span class="math inline">\(|S|\)</span>，此前插入了 <spanclass="math inline">\(x\)</span> 个数。若 <spanclass="math inline">\(X\oplus Y\)</span> 能被线性基表示出来，则方案数为<span class="math inline">\(2^{x-|S|}\)</span>。</p><p>最后，别忘了乘组合数 <spanclass="math inline">\(\dbinom{\text{tot}_i}{\text{same}_i}\)</span>再累加到答案中。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<spanclass="math inline">\(w\)</span> 为值域。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> n, tot, all;vector&lt;<span class="hljs-type">int</span>&gt; p;<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tot</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">all</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">p</span>(_n + <span class="hljs-number">1</span>) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;all++;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (!(x &gt;&gt; i)) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (!p[i]) &#123;p[i] = x;tot++;<span class="hljs-keyword">break</span>;&#125;x ^= p[i];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> ((res ^ p[i]) &gt; res) &#123;res ^= p[i];&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (x &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;x ^= p[i];&#125;&#125;<span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getways</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">count</span>(x)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, all - tot);&#125;&#125;;  vector&lt;<span class="hljs-type">int</span>&gt; frac, inv;  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  frac.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);  inv.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);    frac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  frac[i] = frac[i - <span class="hljs-number">1</span>] * i % modp;  &#125;  inv[n] = <span class="hljs-built_in">qpow</span>(frac[n], modp - <span class="hljs-number">2</span>);  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;  inv[i - <span class="hljs-number">1</span>] = inv[i] * i % modp;  &#125;&#125;  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;  <span class="hljs-keyword">if</span> (n &lt; m || m &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;  <span class="hljs-keyword">return</span> frac[n] * inv[m] % modp * inv[n - m] % modp;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// SG = 最小堆的石子数 - (最小堆数量 + [所有堆石子数相同]) % 2</span><span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-built_in">init</span>(n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];mp[a[i]]++;&#125; <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">same</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;pre[i] = pre[i - <span class="hljs-number">1</span>] ^ a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;suf[i] = suf[i + <span class="hljs-number">1</span>] ^ a[i];same[i] = (a[i] == a[i + <span class="hljs-number">1</span>] ? same[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);&#125;<span class="hljs-function">Node <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">60</span>)</span></span>;<span class="hljs-type">int</span> ans = (pre[n] == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> X = pre[i - <span class="hljs-number">1</span>];<span class="hljs-type">int</span> Y = a[i] - (same[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<span class="hljs-type">int</span> Z = suf[i + same[i]];<span class="hljs-keyword">if</span> ((X ^ Y ^ Z) == <span class="hljs-number">0</span>) &#123;res++;res %= modp;&#125;Y = a[i] - same[i] % <span class="hljs-number">2</span>;<span class="hljs-type">int</span> need = X ^ Y;res += t.<span class="hljs-built_in">getways</span>(need);<span class="hljs-keyword">if</span> ((need ^ Z) == <span class="hljs-number">0</span>) &#123;res = (res - <span class="hljs-number">1</span> + modp) % modp;&#125;<span class="hljs-keyword">if</span> (same[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; same[i]; j++) &#123;t.<span class="hljs-built_in">insert</span>(a[i]);&#125;&#125;res *= <span class="hljs-built_in">C</span>(mp[a[i]], same[i]);res %= modp;ans += res;ans %= modp;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="东北四省赛-ccpc-northeast">2024 东北四省赛 / CCPC Northeast</h2><h3 id="h.-meet树上差分分类讨论">H. Meet【树上差分，分类讨论】</h3><div class="note note-info">            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，以及 <spanclass="math inline">\(m\)</span> 组点对构成的集合 <spanclass="math inline">\(S\)</span>。你需要选定一个点作为根节点，使得 <spanclass="math inline">\(\max_\limits{(x, y)\in S} \max(\text{dis}(x,\text{lca}_{x, y}), \text{dis}(y, \text{lca}_{x, y}))\)</span>最小，输出这个最小值。</p><p><span class="math inline">\(1 \le n, m \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>二分答案，设二分出的答案为 <spanclass="math inline">\(d\)</span>。</p><p>对于每一组点对 <span class="math inline">\((x,y)\)</span>，可以确定一个点集（一个树上连通块），使得以该点集中的点为根时，答案<span class="math inline">\(\le d\)</span>。接着只需要用树上差分判断这<span class="math inline">\(m\)</span> 个点集是否有交即可。</p><p>需要纸上分几种情况讨论，红温了挺久。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optmize(<span class="hljs-string">&quot;Ofast&quot;</span>)</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RMQ_LCA</span> &#123;<span class="hljs-type">int</span> n, tim;vector&lt;<span class="hljs-type">int</span>&gt; dfn, lg, twdep;vector&lt;<span class="hljs-type">int</span>&gt; dep, st;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj, fa, A, B;<span class="hljs-built_in">RMQ_LCA</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;Adj) &#123;<span class="hljs-keyword">this</span>-&gt;n = Adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;adj = Adj;<span class="hljs-built_in">init</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;dfn.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);lg.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);twdep.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);dep.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);st.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);tim = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;lg[i] = lg[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath, <span class="hljs-type">int</span> d)</span> </span>&#123;st[x] = ++tim;dfn[tim] = x;twdep[tim] = d;dep[x] = dep[fath] + <span class="hljs-number">1</span>;fa[x][<span class="hljs-number">0</span>] = fath;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lg[dep[x]] + <span class="hljs-number">1</span>; i++) &#123;fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!st[y]) &#123;<span class="hljs-built_in">dfs</span>(y, x, d + <span class="hljs-number">1</span>);dfn[++tim] = x;twdep[tim] = d;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;fa.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>));<span class="hljs-built_in">dfs</span>(rt, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);A.<span class="hljs-built_in">resize</span>(<span class="hljs-number">25</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>));B.<span class="hljs-built_in">resize</span>(<span class="hljs-number">25</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= tim; i++) &#123;A[<span class="hljs-number">0</span>][i] = twdep[i];B[<span class="hljs-number">0</span>][i] = dfn[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lg[tim]; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j + (<span class="hljs-number">1LL</span> &lt;&lt; i) - <span class="hljs-number">1</span> &lt;= tim; j++) &#123;<span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>][j] &lt; A[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)]) &#123;A[i][j] = A[i - <span class="hljs-number">1</span>][j];B[i][j] = B[i - <span class="hljs-number">1</span>][j];&#125; <span class="hljs-keyword">else</span> &#123;A[i][j] = A[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)];B[i][j] = B[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)];&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-type">int</span> l = <span class="hljs-built_in">min</span>(st[x], st[y]);<span class="hljs-type">int</span> r = <span class="hljs-built_in">max</span>(st[x], st[y]);<span class="hljs-type">int</span> k = lg[r - l + <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (A[k][l] &lt; A[k][r + <span class="hljs-number">1</span> - (<span class="hljs-number">1LL</span> &lt;&lt; k)]) &#123;<span class="hljs-keyword">return</span> B[k][l];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> B[k][r + <span class="hljs-number">1</span> - (<span class="hljs-number">1LL</span> &lt;&lt; k)];&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> dep[x] + dep[y] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">LCA</span>(x, y)];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> len)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">24</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (len &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;x = fa[x][i];&#125;&#125;<span class="hljs-keyword">return</span> x;&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">RMQ_LCA <span class="hljs-title">G</span><span class="hljs-params">(adj)</span></span>;G.<span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>);vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">people</span>(m);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;people[i] = &#123;x, y&#125;;&#125;<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> goal) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : people) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * goal &lt; G.<span class="hljs-built_in">dist</span>(x, y)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">del</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> A = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : people) &#123;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, y) &lt;= goal) &#123;A++;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> lca = G.<span class="hljs-built_in">LCA</span>(x, y);<span class="hljs-type">int</span> tx, ty;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(lca, x) &gt;= goal) &#123;tx = G.<span class="hljs-built_in">jump</span>(x, goal);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> res = goal - G.<span class="hljs-built_in">dist</span>(lca, x);tx = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(lca, y) - res);&#125;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(lca, y) &gt;= goal) &#123;ty = G.<span class="hljs-built_in">jump</span>(y, goal);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> res = goal - G.<span class="hljs-built_in">dist</span>(lca, y);ty = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(lca, x) - res);&#125;<span class="hljs-type">int</span> <span class="hljs-type">lca_t</span> = G.<span class="hljs-built_in">LCA</span>(tx, ty);<span class="hljs-keyword">if</span> (lca == x || lca == y) &#123;del[<span class="hljs-type">lca_t</span>]++;<span class="hljs-type">int</span> son;<span class="hljs-keyword">if</span> (lca == x) &#123;son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, <span class="hljs-type">lca_t</span> == tx ? ty : tx) - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, <span class="hljs-type">lca_t</span> == tx ? ty : tx) - <span class="hljs-number">1</span>);&#125;del[son]--;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (lca == <span class="hljs-type">lca_t</span>) &#123;del[<span class="hljs-number">1</span>]++;<span class="hljs-type">int</span> son_x, son_y;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, tx) &lt;= G.<span class="hljs-built_in">dist</span>(x, ty)) &#123;son_x = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, tx) - <span class="hljs-number">1</span>);son_y = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, ty) - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;son_x = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, ty) - <span class="hljs-number">1</span>);son_y = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, tx) - <span class="hljs-number">1</span>);&#125;del[son_x]--;del[son_y]--;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> son;<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, tx) &lt;= G.<span class="hljs-built_in">dist</span>(x, lca)) &#123;<span class="hljs-keyword">if</span> (G.dep[tx] &lt; G.dep[ty]) &#123;del[tx]++;son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, ty) - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;del[ty]++;son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, tx) - <span class="hljs-number">1</span>);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (G.dep[tx] &lt; G.dep[ty]) &#123;del[tx]++;son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, ty) - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;del[ty]++;son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, tx) - <span class="hljs-number">1</span>);&#125;&#125;del[son]--;&#125;&#125;&#125;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;del[x] += del[fa];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (del[i] == m - A) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, ans = <span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;ans = mid;r = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;l = mid + <span class="hljs-number">1</span>;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-tasks贪心">K. Tasks【贪心】</h3><div class="note note-info">            <p>有 <span class="math inline">\(n\)</span>个区间，定义一个区间的烦躁度等于所有包含它的区间的最大烦躁值 <spanclass="math inline">\(+1\)</span>（如果没有包含它的区间，则烦躁值为<span class="math inline">\(0\)</span>）。</p><p>现在你知道这 <span class="math inline">\(n\)</span> 个区间的左端点<span class="math inline">\(l_i\)</span> 和烦躁值 <spanclass="math inline">\(b_i\)</span>，你需要构造对应的右端点以满足条件，或报告<span class="math inline">\(-1\)</span>。</p><p>特别规定给出的构造需要满足没有两个完全相同的区间且没有一个右端点<span class="math inline">\(&gt; 10^6\)</span>。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<spanclass="math inline">\(1 \le l_i \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>把 <span class="math inline">\(b_i\)</span> 相同的区间看作一层，从<span class="math inline">\(b_i=0\)</span> 开始从低层向高层构造。</p><p>对于同一层，若存在两个区间左端点相同，那么无解；否则必要条件是每个区间都要被一个上一层的区间包含。</p><p>那么有如下贪心的构造：从右向左考虑当前层的左端点，设当前左端点为<span class="math inline">\(l\)</span>，那肯定是选上一层中左端点 <spanclass="math inline">\(&lt;l\)</span> 且离 <spanclass="math inline">\(l\)</span>最近的区间来被包含。若有多个左端点满足，则选右端点最靠右的，这样能给下一层留够最多的空间。这个过程可以通过<code>std::lower_bound</code> 简单实现。</p><p>如遇区间完全相同，右端点向左缩一位即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> l, b;cin &gt;&gt; l &gt;&gt; b;a[b + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(&#123;l, i&#125;);&#125;a[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;r[<span class="hljs-number">0</span>] = <span class="hljs-number">1e6</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-built_in">sort</span>(a[i].<span class="hljs-built_in">begin</span>(), a[i].<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j + <span class="hljs-number">1</span> &lt; a[i].<span class="hljs-built_in">size</span>(); j++) &#123;<span class="hljs-keyword">if</span> (a[i][j][<span class="hljs-number">0</span>] == a[i][j + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;<span class="hljs-type">int</span> R = <span class="hljs-number">1e6</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [l, id] : a[i]) &#123;<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>(), array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;&#123;l + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);<span class="hljs-keyword">if</span> (it == a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;it = <span class="hljs-built_in">prev</span>(it);<span class="hljs-keyword">auto</span> [lstL, lstid] = *it;R = <span class="hljs-built_in">min</span>(R, r[lstid]);<span class="hljs-keyword">if</span> (l == lstL &amp;&amp; R == r[lstid]) &#123;R--;&#125;<span class="hljs-keyword">if</span> (R &lt; l) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;r[id] = R;R--;&#125;<span class="hljs-built_in">sort</span>(a[i].<span class="hljs-built_in">begin</span>(), a[i].<span class="hljs-built_in">end</span>());&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; r[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="b.-charging-station最大权闭合子图">B. ChargingStation【最大权闭合子图】</h3><div class="note note-info">            <p>有 <span class="math inline">\(3n\)</span> 个能源站，分为三级，每级<span class="math inline">\(n\)</span> 个，从高级向低级编号为 <spanclass="math inline">\(1\sim n\)</span>，<spanclass="math inline">\(n\sim 2n\)</span>，<spanclass="math inline">\(2n\sim 3n\)</span>。</p><p>每个能源站有三种状态：不工作、供能、吸能。供能有供能功率 <spanclass="math inline">\(a_i\)</span>，吸能有吸能功率 <spanclass="math inline">\(b_i\)</span>。</p><p>有 <span class="math inline">\(m\)</span> 个限制关系，每一条形如“能源站 <span class="math inline">\(x\)</span>要处于供能状态当且仅当低一级的能源站 <spanclass="math inline">\(y\)</span> 在吸能状态”。</p><p>问最大总供能功率。</p><p><span class="math inline">\(1\le n, m\le 10^5\)</span>，<spanclass="math inline">\(1\le a_i,b_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>假设只有两级，并且低级能源站都处于吸能状态，那么就是经典的最大权闭合子图问题。</p><p>具体地，将供能站视作左部点，吸能站视作右部点。</p><p>源点 <span class="math inline">\(S\)</span>向左部点连收益大小的边，左部点向右部点连正无穷的边，右部点向汇点 <spanclass="math inline">\(T\)</span> 连代价大小的边，最大供能功率就是<strong>左部点权值之和 <span class="math inline">\(-\)</span>最小割</strong>。</p><p>现在考虑这个三级模型。最高级的能源站只能处在供能或不工作状态，最低级的能源站只能处在供能或吸能状态（不工作还不如供能），中级能源站的状态则取决于上下两级。</p><p>假设这么一个初始状态：中级能源站供能，高级能源站不工作，低级能源站吸能。</p><p>当低级能源站由吸能 <span class="math inline">\(\to\)</span>供能时，中级能源站只能供能 <span class="math inline">\(\to\)</span>不工作；当高级能源站由不工作 <span class="math inline">\(\to\)</span>供能时，中级能源站只能不工作 <span class="math inline">\(\to\)</span>吸能。</p><p>于是我们把中级能源站拆成两个点，分别为 “供能 <spanclass="math inline">\(\to\)</span> 不工作” 和 “不工作 <spanclass="math inline">\(\to\)</span> 吸能”，对应的代价恰好为 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(b_i\)</span>。建图如下：</p><p><img src="/image/academic/111.png" alt="id" style="zoom:50%;" /></p><p>其中，<span class="math inline">\(S\)</span> 向低级能源站连 <spanclass="math inline">\(a_i+b_i\)</span>的边是因为只考虑从吸能状态转换为供能状态带来的总收益。</p><p>时间复杂度 <span class="math inline">\(O(m\sqrt{n})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span> &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<span class="hljs-type">int</span> x, cap;<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cap) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">cap</span>(cap) &#123;&#125; &#125;;<span class="hljs-type">int</span> n;vector&lt;Edge&gt; e;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; dep, cur;<span class="hljs-built_in">Dinic</span>(<span class="hljs-type">int</span> size) &#123;<span class="hljs-keyword">this</span>-&gt;n = size;adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cap)</span> </span>&#123;adj[x].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;y, cap&#125;);adj[y].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>&#125;);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;dep.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(S);dep[S] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : adj[x]) &#123;<span class="hljs-keyword">auto</span> [y, cap] = e[i];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == <span class="hljs-number">-1</span>) &#123;dep[y] = dep[x] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (y == T) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;q.<span class="hljs-built_in">push</span>(y);&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> T, <span class="hljs-type">int</span> limit)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == T) &#123;<span class="hljs-keyword">return</span> limit;&#125;<span class="hljs-type">int</span> r = limit;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i = cur[x]; i &lt; adj[x].<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-type">const</span> <span class="hljs-type">int</span> j = adj[x][i];<span class="hljs-keyword">auto</span> [y, cap] = e[j];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == dep[x] + <span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> t = <span class="hljs-built_in">dfs</span>(y, T, <span class="hljs-built_in">min</span>(r, cap));e[j].cap -= t;e[j ^ <span class="hljs-number">1</span>].cap += t;r -= t;<span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> limit;&#125;&#125;&#125;<span class="hljs-keyword">return</span> limit - r;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(S, T)) &#123;cur.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);flow += <span class="hljs-built_in">dfs</span>(S, T, inf); &#125; <span class="hljs-keyword">return</span> flow;&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span> * n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span> * n; i++) &#123;cin &gt;&gt; b[i];&#125;<span class="hljs-comment">// 1 ~ n：一级3n ~ 4n：三级</span><span class="hljs-comment">// n ~ 2n：二级供能 -&gt; 不工作</span><span class="hljs-comment">// 2n ~ 3n：二级不工作 -&gt; 吸能</span><span class="hljs-type">int</span> S = <span class="hljs-number">4</span> * n + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> T = <span class="hljs-number">4</span> * n + <span class="hljs-number">2</span>;<span class="hljs-function">Dinic <span class="hljs-title">G</span><span class="hljs-params">(T)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;G.<span class="hljs-built_in">add</span>(S, i, a[i]);G.<span class="hljs-built_in">add</span>(S, i + <span class="hljs-number">3</span> * n, a[i + <span class="hljs-number">2</span> * n] + b[i + <span class="hljs-number">2</span> * n]);G.<span class="hljs-built_in">add</span>(i + n, T, a[i + n]);G.<span class="hljs-built_in">add</span>(i + <span class="hljs-number">2</span> * n, T, b[i + n]);&#125;<span class="hljs-type">int</span> m;cin &gt;&gt; m;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;<span class="hljs-keyword">if</span> (x &lt;= n) &#123;G.<span class="hljs-built_in">add</span>(x, y, inf);G.<span class="hljs-built_in">add</span>(x, y + n, inf);&#125; <span class="hljs-keyword">else</span> &#123;G.<span class="hljs-built_in">add</span>(y + n, x, inf);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0ll</span>);ans -= G.<span class="hljs-built_in">dinic</span>(S, T);cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="g.-diamond根号分治">G. Diamond【根号分治】</h3><div class="note note-info">            <p>给定一个长为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(\{a\}\)</span>。有 <spanclass="math inline">\(m\)</span> 次询问，每次指定 <spanclass="math inline">\(l, r, p, q\)</span> 四个参数，问若只保留下标在<span class="math inline">\([l, r]\)</span> 内且值为 <spanclass="math inline">\(p\)</span> 或者 <spanclass="math inline">\(q\)</span>的数，其它数全部删除，此时剩下序列的逆序对数量。询问间相互独立。</p><p><span class="math inline">\(2\le n \le 10^5\)</span>，<spanclass="math inline">\(1 \le m \le 10^5\)</span>，<spanclass="math inline">\(1\le a_i \le n\)</span>。</p>          </div><div class="note note-success">            <p>较为明显的根号分治。把每个数的出现位置存到 <code>std::vector</code>中，记为 <code>pos</code>。</p><p>若 <span class="math inline">\(p,q\)</span> 的出现次数都 <spanclass="math inline">\(\le\sqrt{n}\)</span>，直接在 <code>pos</code>上暴跳计算贡献，<span class="math inline">\(O(\sqrt{n})\)</span>。</p><p>否则 <span class="math inline">\(p, q\)</span> 中至少有一个出现次数<span class="math inline">\(&gt;\sqrt{n}\)</span>。由于这样的数（设为<span class="math inline">\(X\)</span>）不超过 <spanclass="math inline">\(\dfrac{n}{\sqrt{n}}=\sqrt{n}\)</span>个，我们可以对 <span class="math inline">\(1\sim n\)</span> 的每一个位置<span class="math inline">\(i\)</span> 处理出 <code>count[i][j]</code>代表 <span class="math inline">\(1\sim i\)</span> 中值 <spanclass="math inline">\(j\in X\)</span> 出现了多少次。</p><p>那么对于一个区间 <span class="math inline">\([l, r]\)</span>，不妨设<span class="math inline">\(p&lt;q\)</span>，答案就是： <spanclass="math display">\[\left(\sum_{i\in[l,r],a[i]=p}\text{count}[i][q]\right)-\text{occ}[l-1][q]\times\left(\text{occ}[r][p]-\text{occ}[l-1][p]\right)\]</span> 其中 <code>occ[i][j]</code> 代表 <spanclass="math inline">\(1\sim i\)</span> 中 <spanclass="math inline">\(j\in[1,n]\)</span>的出现次数，这里只是为方便说明，实际存不下，可修改为 <code>occ[i]</code>代表 <span class="math inline">\(1\sim i\)</span> 中 <spanclass="math inline">\(a[i]\)</span> 的出现次数，然后二分查询。</p><p>至于第一项，可以预处理出 <code>count[i][j]</code>的前缀和，然后二分出 <span class="math inline">\(j\)</span> 在 <spanclass="math inline">\([l, r]\)</span> 中第一次出现和最后一次出现的位置<span class="math inline">\(O(1)\)</span> 回答。</p><p>那如果 <span class="math inline">\(p&gt;q\)</span> 且 <spanclass="math inline">\(q\)</span> 的出现次数 <spanclass="math inline">\(\le \sqrt{n}\)</span> 呢？我们没处理出这样的<code>count[i][q]</code>，但可以把 <spanclass="math inline">\(p,q\)</span> swap一下求出顺序对的数量，然后容斥。</p><p>时间复杂度 <spanclass="math inline">\(O((n+q)\sqrt{n})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> Block = <span class="hljs-number">320</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pos</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];cnt[a[i]]++;pos[a[i]].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (cnt[i] &gt; Block) &#123;id[i] = ++tim;&#125;&#125;<span class="hljs-function">vector <span class="hljs-title">count</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;count[i] = count[i - <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (cnt[a[i]] &gt; Block) &#123;count[i][id[a[i]]]++;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (pos[i].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; pos[i].<span class="hljs-built_in">size</span>(); j++) &#123;pre[pos[i][j]] = pos[i][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">occ</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;occ[i] = occ[pre[i]] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= tim; j++) &#123;count[i][j] += count[pre[i]][j];&#125;&#125;<span class="hljs-keyword">auto</span> calc_1 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q) &#123;<span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">lower_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">lower_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">if</span> (it1 == pos[p].<span class="hljs-built_in">end</span>() || it2 == pos[q].<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;&#125;<span class="hljs-type">int</span> A = it1 - pos[p].<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> B = it2 - pos[q].<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">if</span> (pos[p][A] &gt; r || pos[q][B] &gt; r) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;&#125;<span class="hljs-type">int</span> big = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-type">int</span> posA = (A &gt;= pos[p].<span class="hljs-built_in">size</span>() ? r + <span class="hljs-number">1</span> : pos[p][A]);<span class="hljs-type">int</span> posB = (B &gt;= pos[q].<span class="hljs-built_in">size</span>() ? r + <span class="hljs-number">1</span> : pos[q][B]);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(posA, posB) &gt; r) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (posA &lt; posB) &#123;res += big;A++;&#125; <span class="hljs-keyword">else</span> &#123;big++;B++;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-keyword">auto</span> calc_2 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q) &#123;<span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">lower_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">upper_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), r);<span class="hljs-keyword">auto</span> it3 = <span class="hljs-built_in">lower_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), l);<span class="hljs-keyword">auto</span> it4 = <span class="hljs-built_in">upper_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), r);<span class="hljs-keyword">if</span> (it1 == pos[p].<span class="hljs-built_in">end</span>() || it3 == pos[q].<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;&#125;<span class="hljs-type">int</span> A = it1 - pos[p].<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> B = it2 - pos[p].<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<span class="hljs-type">int</span> C = it3 - pos[q].<span class="hljs-built_in">begin</span>();<span class="hljs-type">int</span> D = it4 - pos[q].<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (pos[p][A] &gt; r || pos[q][C] &gt; r) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;&#125;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (cnt[q] &gt; Block) &#123;res += count[pos[p][B]][id[q]] - (A &gt; <span class="hljs-number">0</span> ? count[pos[p][A - <span class="hljs-number">1</span>]][id[q]] : <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (C &gt; <span class="hljs-number">0</span>) &#123;res -= (occ[pos[p][B]] - (A &gt; <span class="hljs-number">0</span> ? occ[pos[p][A - <span class="hljs-number">1</span>]] : <span class="hljs-number">0</span>)) * occ[pos[q][C - <span class="hljs-number">1</span>]];&#125;&#125; <span class="hljs-keyword">else</span> &#123;res += count[pos[q][D]][id[p]] - (C &gt; <span class="hljs-number">0</span> ? count[pos[q][C - <span class="hljs-number">1</span>]][id[p]] : <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (A &gt; <span class="hljs-number">0</span>) &#123;res -= (occ[pos[q][D]] - (C &gt; <span class="hljs-number">0</span> ? occ[pos[q][C - <span class="hljs-number">1</span>]] : <span class="hljs-number">0</span>)) * occ[pos[p][A - <span class="hljs-number">1</span>]];&#125;<span class="hljs-type">int</span> all = B - A + <span class="hljs-number">1</span> + D - C + <span class="hljs-number">1</span>;all = all * (all - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;all -= (B - A + <span class="hljs-number">1</span>) * (B - A) / <span class="hljs-number">2</span>;all -= (D - C + <span class="hljs-number">1</span>) * (D - C) / <span class="hljs-number">2</span>;res = all - res;&#125;<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> l, r, p, q;cin &gt;&gt; l &gt;&gt; r &gt;&gt; p &gt;&gt; q;<span class="hljs-keyword">if</span> (cnt[p] &lt;= Block &amp;&amp; cnt[q] &lt;= Block) &#123;cout &lt;&lt; <span class="hljs-built_in">calc_1</span>(l, r, p, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-built_in">calc_2</span>(l, r, p, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="nanjing-regional-ucup-2-11">2023 Nanjing Regional / Ucup2-11</h2><h3 id="m.-trapping-rain-water吉司机线段树">M. Trapping RainWater【吉司机线段树】</h3><div class="note note-info">            <p>给定长为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(\{a\}\)</span>，有 <spanclass="math inline">\(q\)</span> 次修改，每次将 <spanclass="math inline">\(a_{x_i}\)</span> 加上 <spanclass="math inline">\(v_i\)</span>。令 <spanclass="math inline">\(f_i=\max(a_1,a_2,\cdots,a_i)\)</span>，<spanclass="math inline">\(g_i=\max(a_i,a_{i +1},\cdots,a_n)\)</span>，你需要在每次修改后回答： <spanclass="math display">\[\sum_{i=1}^{n}(\min(f_i,g_i)-a_i)\]</span> <span class="math inline">\(1\le n, q \le 10^6\)</span>，<spanclass="math inline">\(1\le a_i \le 10^6\)</span>，<spanclass="math inline">\(1\le v_i \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>这题最关键的观察是 <span class="math inline">\(\max(f_i,g_i)=\maxa_i\)</span>，即 <span class="math inline">\(\min(f_i,g_i)=f_i+g_i-\maxa_i\)</span>。</p><p>于是式子化为 <span class="math inline">\(\sum f_i+\sum g_i-n\cdot\max a_i-\sum a_i\)</span>.</p><p>后两项在修改时很容易维护，主要考虑前两项，这里以 <spanclass="math inline">\(\sum f_i\)</span> 为例。</p><p>根据 <span class="math inline">\(f_i\)</span> 的定义，设当前将 <spanclass="math inline">\(a_i\)</span> 增加至 <spanclass="math inline">\(x\)</span>，则相当于给 <spanclass="math inline">\(f_{i\sim n}\)</span> 中的每一项与 <spanclass="math inline">\(x\)</span> 取 <spanclass="math inline">\(\max\)</span>。</p><p>吉司机线段树处理即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; sum, mx, mn;vector&lt;<span class="hljs-type">int</span>&gt; tc, ta, L, R;<span class="hljs-meta">#<span class="hljs-keyword">define</span> N 4 * n + 5</span><span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">sum</span>(N), <span class="hljs-built_in">mx</span>(N), <span class="hljs-built_in">mn</span>(N), <span class="hljs-built_in">tc</span>(N), <span class="hljs-built_in">ta</span>(N), <span class="hljs-built_in">L</span>(N), <span class="hljs-built_in">R</span>(N) &#123;&#125; <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (L[p] + R[p] &gt;&gt; 1)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;sum[p] = sum[ls] + sum[rs];mx[p] = <span class="hljs-built_in">max</span>(mx[ls], mx[rs]);mn[p] = <span class="hljs-built_in">min</span>(mn[ls], mn[rs]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cover</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> w)</span> </span>&#123;sum[p] = (R[p] - L[p] + <span class="hljs-number">1</span>) * w;mx[p] = mn[p] = tc[p] = w;ta[p] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> w)</span> </span>&#123;sum[p] += (R[p] - L[p] + <span class="hljs-number">1</span>) * w;mx[p] += w;mn[p] += w;ta[p] += w;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">if</span> (tc[p] != inf) &#123;<span class="hljs-built_in">Cover</span>(ls, tc[p]);<span class="hljs-built_in">Cover</span>(rs, tc[p]);tc[p] = inf;&#125;<span class="hljs-keyword">if</span> (ta[p]) &#123;<span class="hljs-built_in">Add</span>(ls, ta[p]);<span class="hljs-built_in">Add</span>(rs, ta[p]);ta[p] = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;L[p] = l;R[p] = r;tc[p] = inf;<span class="hljs-keyword">if</span> (l == r) &#123;sum[p] = mx[p] = mn[p] = a[l];<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">build</span>(ls, l, mid, a);<span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r, a);<span class="hljs-built_in">pushup</span>(p);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &lt;= L[p] &amp;&amp; r &gt;= R[p]) &#123;<span class="hljs-keyword">return</span> sum[p];&#125;<span class="hljs-built_in">pushdown</span>(p);<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (l &lt;= mid) &#123;res += <span class="hljs-built_in">get_sum</span>(ls, l, r);&#125;<span class="hljs-keyword">if</span> (r &gt; mid) &#123;res += <span class="hljs-built_in">get_sum</span>(rs, l, r);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_max</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> w)</span> </span>&#123;<span class="hljs-keyword">if</span> (mn[p] &gt;= w) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span> (l &lt;= L[p] &amp;&amp; r &gt;= R[p] &amp;&amp; mx[p] &lt;= w) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Cover</span>(p, w);&#125;<span class="hljs-built_in">pushdown</span>(p);<span class="hljs-keyword">if</span> (l &lt;= mid) &#123;<span class="hljs-built_in">modify_max</span>(ls, l, r, w);&#125;<span class="hljs-keyword">if</span> (r &gt; mid) &#123;<span class="hljs-built_in">modify_max</span>(rs, l, r, w);&#125;<span class="hljs-built_in">pushup</span>(p);&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-type">int</span> q;cin &gt;&gt; q;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">qry</span>(q);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> pos, x;cin &gt;&gt; pos &gt;&gt; x;qry[i] = &#123;pos, x&#125;;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">g</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;f[i] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>], a[i]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;g[i] = <span class="hljs-built_in">max</span>(g[i + <span class="hljs-number">1</span>], a[i]);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ansf</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ansg</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ans_mx</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ans_sum</span><span class="hljs-params">(q)</span></span>;<span class="hljs-type">int</span> Sum = <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);<span class="hljs-type">int</span> Mx = *<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());vector b = a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-keyword">auto</span> [pos, x] = qry[i];a[pos] += x;Sum += x;ans_sum[i] = Sum;Mx = <span class="hljs-built_in">max</span>(Mx, a[pos]);ans_mx[i] = Mx;&#125;a = b;<span class="hljs-function">Node <span class="hljs-title">t</span><span class="hljs-params">(n)</span></span>;t.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, f);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-keyword">auto</span> [pos, x] = qry[i];a[pos] += x;t.<span class="hljs-built_in">modify_max</span>(<span class="hljs-number">1</span>, pos, n, a[pos]);ansf[i] = t.<span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);&#125;a = b;t = <span class="hljs-built_in">Node</span>(n);t.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, g);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-keyword">auto</span> [pos, x] = qry[i];a[pos] += x;t.<span class="hljs-built_in">modify_max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, pos, a[pos]);ansg[i] = t.<span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> res = ansf[i] + ansg[i] - n * ans_mx[i] - ans_sum[i];cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="d.-red-black-treedp凸序列">D. Red Black Tree【dp，凸序列】</h3><p>现存网上的任何一篇题解都看得不是很明白，占坑。</p><hr /><h3 id="e.-extending-distance网络流对偶图">E. ExtendingDistance【网络流，对偶图】</h3><div class="note note-info">            <p>有一个 <span class="math inline">\(n\)</span> 行 <spanclass="math inline">\(m\)</span>列的网格图，相邻格点之间有边，边有边权。</p><p>你可以进行任意次操作，每次操作可以使某条边的边权增加 <spanclass="math inline">\(1\)</span>。</p><p>求一种操作次数最少的方案使得从第一列任意一个点出发到最后一列任意一个点的最短路恰好增加<span class="math inline">\(K\)</span>，输出方案。</p><p><span class="math inline">\(1 \le n\cdot m \le 5000\)</span>，<spanclass="math inline">\(1 \le K\le 100\)</span>。</p>          </div><div class="note note-success">            <p>网格图是一种特殊的平面图。所谓平面图，是指能画在平面上，满足任何两条边没有交叉。</p><p>将平面图 <span class="math inline">\(G\)</span>的每个面看作一个点，<span class="math inline">\(G\)</span>中每条边两侧的两个面（可以是同一个面）进行连边，就得到了一个对偶图。</p><p>一个经典的题目是 “P4001狼抓兔子”，它展示了一种<strong>平面图最小割</strong>转<strong>对偶图最短路</strong>的思想，不再赘述。</p><p>同样地，对本题中的网格图进行对偶，那么<strong>原图的最短路</strong>等价于<strong>对偶图的最小割</strong>。</p><p>建图，将原图中的边费用设为 <spanclass="math inline">\(0\)</span>，流量设为边权；再对每条边建费用为 <spanclass="math inline">\(1\)</span>，流量为 <spanclass="math inline">\(+\infin\)</span> 的额外边。</p><p>此时题目等价于找一条流量为 <span class="math inline">\(D+K\)</span>的费用最小的流，其中 <span class="math inline">\(D\)</span>为原图的最短路。</p><p>分两步处理：</p><ul><li>先只连费用为 <span class="math inline">\(0\)</span>的边，不连额外边。跑从源点 <span class="math inline">\(S\)</span>流向汇点 <span class="math inline">\(T\)</span> 的最大流。</li><li>对每条边连额外边，再连一条从 super 源点 <spanclass="math inline">\(P\)</span> 向源点 <spanclass="math inline">\(S\)</span> 费用为 <spanclass="math inline">\(0\)</span> 流量为 <spanclass="math inline">\(K\)</span> 的边。跑从 super 源点 <spanclass="math inline">\(P\)</span> 流向汇点 <spanclass="math inline">\(T\)</span>的最大流。此时跑出来的费用即为最小操作次数。</li></ul><p>至于方案，可以遍历残量网络上费用为 <spanclass="math inline">\(1\)</span>的边，检查剩余流量。这条边的操作次数就是原始流量和剩余流量的差。</p><p>时间复杂度 <span class="math inline">\(O(n^2m^2k)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span> &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<span class="hljs-type">int</span> x, cap, cost, all;<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> cost) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">cap</span>(cap), <span class="hljs-built_in">cost</span>(cost), <span class="hljs-built_in">all</span>(cap) &#123;&#125;&#125;;<span class="hljs-type">int</span> n;vector&lt;Edge&gt; e;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; dis, pre, vis;vector&lt;<span class="hljs-type">int</span>&gt; h;<span class="hljs-built_in">Dinic</span>(<span class="hljs-type">int</span> size) &#123;<span class="hljs-keyword">this</span>-&gt;n = size;adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> f)</span> </span>&#123;adj[x].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;y, w, f&#125;);adj[y].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());e.<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>, -f&#125;);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;dis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);pre.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<span class="hljs-meta">#<span class="hljs-keyword">define</span> Pair pair<span class="hljs-string">&lt;int, int&gt;</span></span>priority_queue&lt;Pair, vector&lt;Pair&gt;, greater&lt;Pair&gt;&gt; q;dis[S] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>().second;q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span> (vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : adj[x]) &#123;<span class="hljs-keyword">auto</span> [y, cap, cost, _] = e[i];<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dis[y] &gt; dis[x] + h[x] - h[y] + cost) &#123;dis[y] = dis[x] + h[x] - h[y] + cost;pre[y] = i;q.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);&#125;&#125;&#125;<span class="hljs-keyword">return</span> (dis[T] != inf);&#125;<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>, cost = <span class="hljs-number">0</span>;h.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">while</span> (<span class="hljs-built_in">dijkstra</span>(S, T)) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;h[i] += dis[i];&#125;<span class="hljs-type">int</span> res = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>].x) &#123;res = <span class="hljs-built_in">min</span>(res, e[pre[i]].cap);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>].x) &#123;e[pre[i]].cap -= res;e[pre[i] ^ <span class="hljs-number">1</span>].cap += res;&#125;flow += res;cost += res * h[T];&#125;<span class="hljs-keyword">return</span> &#123;flow, cost&#125;;&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<span class="hljs-type">int</span> S = (n - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> T = S + <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> id = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> S;&#125; <span class="hljs-keyword">if</span> (x == n) &#123;<span class="hljs-keyword">return</span> T;&#125;<span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + y;&#125;;<span class="hljs-function">vector <span class="hljs-title">A</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m))</span></span>;<span class="hljs-function">vector <span class="hljs-title">B</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-function">Dinic <span class="hljs-title">G</span><span class="hljs-params">(T)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> w;cin &gt;&gt; w;A[i][j] = w;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);G.<span class="hljs-built_in">add</span>(x, y, w, <span class="hljs-number">0</span>);G.<span class="hljs-built_in">add</span>(y, x, w, <span class="hljs-number">0</span>);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-type">int</span> w;cin &gt;&gt; w;B[i][j] = w;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);G.<span class="hljs-built_in">add</span>(x, y, w, <span class="hljs-number">0</span>);G.<span class="hljs-built_in">add</span>(y, x, w, <span class="hljs-number">0</span>);&#125;&#125;<span class="hljs-keyword">auto</span> res1 = G.<span class="hljs-built_in">dinic</span>(S, T);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);G.<span class="hljs-built_in">add</span>(x, y, inf, <span class="hljs-number">1</span>);G.<span class="hljs-built_in">add</span>(y, x, inf, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);G.<span class="hljs-built_in">add</span>(x, y, inf, <span class="hljs-number">1</span>);G.<span class="hljs-built_in">add</span>(y, x, inf, <span class="hljs-number">1</span>);&#125;&#125;G.<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, S, k, <span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> res2 = G.<span class="hljs-built_in">dinic</span>(<span class="hljs-number">0</span>, T);cout &lt;&lt; res2[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-function">vector <span class="hljs-title">flow</span><span class="hljs-params">(T + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(T + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt;= T; x++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> id : G.adj[x]) &#123;<span class="hljs-keyword">auto</span> [y, cap, cost, all] = G.e[id];cap = all - cap;<span class="hljs-keyword">if</span> (cost == <span class="hljs-number">1</span> &amp;&amp; cap) &#123;flow[x][y] += cap;&#125;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);A[i][j] += flow[x][y] + flow[y][x];cout &lt;&lt; A[i][j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);B[i][j] += flow[x][y] + flow[y][x];&#125;cout &lt;&lt; B[i][j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p>一种较为简洁的网格图转对偶图建图方法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> id = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> S;&#125; <span class="hljs-keyword">if</span> (x == n) &#123;<span class="hljs-keyword">return</span> T;&#125;<span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + y;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);        <span class="hljs-comment">// x -&gt; y</span>&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);        <span class="hljs-comment">// x -&gt; y</span>&#125;&#125;</code></pre></div>          </div><h2 id="ukiepc-2023">UKIEPC 2023</h2><h3 id="g.-glacier-travel计算几何">G. Glacier Travel【计算几何】</h3><div class="note note-info">            <p>给定平面上 <span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\((x_i,y_i)\)</span>，按顺序依次连成折线段。两个人一前一后沿着折线移动，它们的路程差固定为<span class="math inline">\(s\)</span>，问移动过程中两人的最短距离。</p><p><span class="math inline">\(2\le n\le 10^6\)</span>，<spanclass="math inline">\(-10^6\le x_i,y_i\le 10^6\)</span>，<spanclass="math inline">\(1\le s \le 1000\)</span>。</p>          </div><div class="note note-success">            <p>可以从折线段的起点开始维护一对双指针，每次从状态 <spanclass="math inline">\(\{(x_A,y_A),(x_B,y_B)\}\)</span> 转移到状态 <spanclass="math inline">\(\{(x_A&#39;,y_A&#39;),(x_B&#39;,y_B&#39;)\}\)</span>当且仅当 <span class="math inline">\((x_A&#39;,y_A&#39;)\)</span> 或<span class="math inline">\((x_B&#39;,y_B&#39;)\)</span>为某条线段的一个端点。</p><p>至于计算距离，有一个能使码量简单许多的转化：相对速度。</p><p>首先，两个人在同一条线段上移动肯定不优。否则假定 <spanclass="math inline">\(A\)</span> 不动，根据速度的合成法则，此时 <spanclass="math inline">\(B\)</span>的运动轨迹是一条线段，于是可以三分或直接运用点到线段的距离公式计算。</p><p>具体地，答案是点 <span class="math inline">\((0,0)\)</span> 到线段<spanclass="math inline">\((x_B-x_A,y_B-y_A)\sim(x_B&#39;-x_A&#39;,y_B&#39;-y_A&#39;)\)</span>的距离。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    T x, y;    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;    <span class="hljs-keyword">operator</span> <span class="hljs-built_in">Point</span>&lt;U&gt;() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>&lt;U&gt;(<span class="hljs-built_in">U</span>(x), <span class="hljs-built_in">U</span>(y));    &#125;    Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;        x += p.x;        y += p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;        x -= p.x;        y -= p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;        x *= v;        y *= v;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a += b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a -= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;        <span class="hljs-keyword">return</span> a *= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;        <span class="hljs-keyword">return</span> b *= a;    &#125;    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;    &#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, Point &amp;p) &#123;        <span class="hljs-keyword">return</span> is &gt;&gt; p.x &gt;&gt; p.y;    &#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Point p) &#123;        <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">dot</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.x + a.y * b.y;&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dist</span><span class="hljs-params">(Point&lt;T&gt; p1, Point&lt;T&gt; p2)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrtl</span>(<span class="hljs-number">1.0</span> * (p<span class="hljs-number">1.</span>x - p<span class="hljs-number">2.</span>x) * (p<span class="hljs-number">1.</span>x - p<span class="hljs-number">2.</span>x) + <span class="hljs-number">1.0</span> * (p<span class="hljs-number">1.</span>y - p<span class="hljs-number">2.</span>y) * (p<span class="hljs-number">1.</span>y - p<span class="hljs-number">2.</span>y));&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;    Point&lt;T&gt; a, b;    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distToLine</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">cross</span>(p - l.a, l.b - l.a)) / <span class="hljs-built_in">dist</span>(l.a, l.b);&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; </span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distToSegment</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;    <span class="hljs-keyword">if</span> (l.a == l.b) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.a, p);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(p - l.a, l.b - l.a) &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.a, p);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(p - l.b, l.b - l.a) &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.b, p);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">distToLine</span>(p, l);&#125;<span class="hljs-keyword">using</span> P = Point&lt;<span class="hljs-type">double</span>&gt;;<span class="hljs-keyword">using</span> L = Line&lt;<span class="hljs-type">double</span>&gt;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">double</span> s;    cin &gt;&gt; s;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-function">vector&lt;P&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        cin &gt;&gt; a[i];    &#125;    P X = a[<span class="hljs-number">0</span>], Y = a[<span class="hljs-number">0</span>];    <span class="hljs-type">int</span> ptr_x = <span class="hljs-number">1</span>, ptr_y = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (s &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">double</span> d = <span class="hljs-built_in">dist</span>(a[ptr_y], Y);        <span class="hljs-keyword">if</span> (d &lt; s) &#123;            s -= d;            Y = a[ptr_y++];        &#125; <span class="hljs-keyword">else</span> &#123;            Y += (a[ptr_y] - Y) * s * (<span class="hljs-number">1.0</span> / <span class="hljs-built_in">dist</span>(a[ptr_y], Y));            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-type">double</span> ans = <span class="hljs-built_in">dist</span>(X, Y);    <span class="hljs-keyword">while</span> (ptr_y &lt; n) &#123;        <span class="hljs-type">double</span> d1 = <span class="hljs-built_in">dist</span>(a[ptr_x], X);        <span class="hljs-type">double</span> d2 = <span class="hljs-built_in">dist</span>(a[ptr_y], Y);        P nxt_X, nxt_Y;        <span class="hljs-keyword">if</span> (d1 &lt; d2) &#123;            nxt_X = a[ptr_x++];            nxt_Y = Y + (a[ptr_y] - Y) * d1 * (<span class="hljs-number">1.0</span> / d2);            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">distToSegment</span>(P&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, L&#123;Y - X, nxt_Y - nxt_X&#125;));        &#125; <span class="hljs-keyword">else</span> &#123;            nxt_X = X + (a[ptr_x] - X) * d2 * (<span class="hljs-number">1.0</span> / d1);            nxt_Y = a[ptr_y++];            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">distToSegment</span>(P&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, L&#123;Y - X, nxt_Y - nxt_X&#125;));        &#125;        X = nxt_X;        Y = nxt_Y;    &#125;       cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">7</span>) &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (T--) &#123;        <span class="hljs-built_in">solve</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="h.-history-in-numbers线段树">H. History inNumbers【线段树】</h3><div class="note note-info">            <p>维护长为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(\{a\}\)</span>，并有 <spanclass="math inline">\(m\)</span> 次操作，每次可能是以下两种之一。</p><p><code>update l r d</code>：<span class="math inline">\(\forall i\in[l, r]\)</span>，<span class="math inline">\(a_i := a_i+d\)</span>。</p><p><code>check l r</code>：查询 <span class="math inline">\([l,r]\)</span> 中的局部最小值是否严格递增。</p><p>区间 <span class="math inline">\([l,r]\)</span>的局部最小值序列被定义为将 <span class="math inline">\([l, r]\)</span>中相邻且相同的元素只保留一个后，数值上小于两侧元素的数构成的集合。</p><p><span class="math inline">\(1 \le n,m \le 3\cdot 10^5\)</span>，<spanclass="math inline">\(-10^8\le a_i,d\le 10^8\)</span>。</p>          </div><div class="note note-success">            <p>线段树板题，就是维护起来细节比较多。</p><p>线段树维护七个值：</p><ul><li><code>l1</code>：区间左起第一个数。</li><li><code>l2</code>：区间左起和 <code>l1</code> 不同的第二个数。</li><li><code>r1</code>：区间右起第一个数。</li><li><code>r2</code>：区间右起和 <code>r1</code> 不同的第二个数。</li><li><code>f1</code>：区间左起第一个局部最小值的值。</li><li><code>f2</code>：区间右起第一个局部最小值的值。</li><li><code>ok</code>：该区间的局部最小值序列是否递增。</li></ul><p>然后就是分类讨论了，代码里我分区间去重后只有一个值，只有两个值，超过两个值讨论了一下。</p><p>注意区间左右两侧的边界情况需要特判。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazySegmentTree</span> &#123;    <span class="hljs-type">int</span> n;    vector&lt;Info&gt; tr;    vector&lt;Tag&gt; tag;    <span class="hljs-built_in">LazySegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;        n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;        <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = (<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>;        tr.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Info</span>());        tag.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Tag</span>());        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);    &#125;    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = a[l];            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(ls, l, m, a);        <span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        tr[p] = tr[ls] + tr[rs];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        tr[p].<span class="hljs-built_in">apply</span>(x);        tag[p].<span class="hljs-built_in">apply</span>(x);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-built_in">apply</span>(ls, tag[p]);        <span class="hljs-built_in">apply</span>(rs, tag[p]);        tag[p] = <span class="hljs-built_in">Tag</span>();    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;            tr[p] = x;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-keyword">if</span> (pos &lt;= m) &#123;            <span class="hljs-built_in">modify</span>(ls, l, m, pos, x);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, pos, x);        &#125;        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, x);    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-keyword">return</span> tr[p];        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (qr &lt;= m) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ql &gt;= m + <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);        &#125;    &#125;    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;            <span class="hljs-built_in">apply</span>(p, x);            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">modify</span>(ls, l, m, ql, qr, x);        <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, x);        <span class="hljs-built_in">pushup</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, x);    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findFirst</span>(ls, l, m, ql, qr, pred);        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;            res = <span class="hljs-built_in">findFirst</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFirst</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (l == r) &#123;            <span class="hljs-keyword">return</span> l;        &#125;        <span class="hljs-built_in">pushdown</span>(p);        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findLast</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;            res = <span class="hljs-built_in">findLast</span>(ls, l, m, ql, qr, pred);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findLast</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);    &#125;&#125;; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tag</span> &#123;    <span class="hljs-type">int</span> add = <span class="hljs-number">0</span>;    <span class="hljs-built_in">Tag</span>() &#123;&#125;    <span class="hljs-built_in">Tag</span>(<span class="hljs-type">int</span> A) &#123;        add = A;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;        add += t.add;    &#125;&#125;; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> l1 = inf;    <span class="hljs-type">int</span> l2 = inf;    <span class="hljs-type">int</span> r1 = inf;    <span class="hljs-type">int</span> r2 = inf;    <span class="hljs-type">int</span> f1 = inf;    <span class="hljs-type">int</span> f2 = inf;<span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">Info</span>() &#123;&#125;    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B) &#123;        l1 = r1 = A;        l = r = B;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;        l1 += t.add;        r1 += t.add;        <span class="hljs-keyword">if</span> (l2 != inf) &#123;            l2 += t.add;        &#125;        <span class="hljs-keyword">if</span> (r2 != inf) &#123;            r2 += t.add;        &#125;        <span class="hljs-keyword">if</span> (f1 != inf) &#123;            f1 += t.add;        &#125;        <span class="hljs-keyword">if</span> (f2 != inf) &#123;            f2 += t.add;        &#125;    &#125;&#125;;pair&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;, <span class="hljs-type">bool</span>&gt; <span class="hljs-built_in">check</span>(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> b1, <span class="hljs-type">int</span> b2) &#123;    <span class="hljs-keyword">if</span> (d == inf) &#123;        <span class="hljs-keyword">if</span> (a1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;b1, b2&#125;, <span class="hljs-literal">true</span>&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;a1, a2&#125;, <span class="hljs-literal">true</span>&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> &#123;&#123;a1, b2&#125;, a2 &lt; b1&#125;;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (a1 == inf &amp;&amp; b1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;d, d&#125;, <span class="hljs-literal">true</span>&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;d, b2&#125;, d &lt; b1&#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b1 == inf) &#123;            <span class="hljs-keyword">return</span> &#123;&#123;a1, d&#125;, a2 &lt; d&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> &#123;&#123;a1, b2&#125;, a2 &lt; d &amp;&amp; d &lt; b1&#125;;        &#125;    &#125;&#125;Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;    Info c;    <span class="hljs-keyword">if</span> (a.l2 == inf &amp;&amp; b.l2 == inf) &#123;        <span class="hljs-keyword">if</span> (a.l1 == b.l1) &#123;            c = a;        &#125; <span class="hljs-keyword">else</span> &#123;            c.l1 = a.l1;            c.l2 = b.l1;            c.r1 = b.r1;            c.r2 = a.r1;        &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.l2 == inf) &#123;        c = b;        <span class="hljs-keyword">if</span> (a.r1 != b.l1) &#123;            c.l1 = a.r1;            c.l2 = b.l1;            <span class="hljs-keyword">if</span> (a.r1 &gt; b.l1 &amp;&amp; b.l1 &lt; b.l2) &#123;                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, b.l1, b.f1, b.f2);                c.f1 = res[<span class="hljs-number">0</span>];                c.f2 = res[<span class="hljs-number">1</span>];                c.ok &amp;= t;            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b.l2 == inf) &#123;        c = a;        <span class="hljs-keyword">if</span> (a.r1 != b.l1) &#123;            c.r1 = b.l1;            c.r2 = a.r1;            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; a.r1 &lt; b.l1) &#123;                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, a.r1, b.f1, b.f2);                c.f1 = res[<span class="hljs-number">0</span>];                c.f2 = res[<span class="hljs-number">1</span>];                c.ok &amp;= t;            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        c.l1 = a.l1;        c.l2 = a.l2;        c.r1 = b.r1;        c.r2 = b.r2;        c.ok = (a.ok &amp;&amp; b.ok);        <span class="hljs-type">int</span> d = inf;        <span class="hljs-keyword">if</span> (a.r1 == b.l1) &#123;            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; b.l1 &lt; b.l2) &#123;                d = a.r1;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; a.r1 &lt; b.l1) &#123;                d = a.r1;            &#125;            <span class="hljs-keyword">if</span> (a.r1 &gt; b.l1 &amp;&amp; b.l1 &lt; b.l2) &#123;                d = b.l1;            &#125;        &#125;        <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, d, b.f1, b.f2);        c.f1 = res[<span class="hljs-number">0</span>];        c.f2 = res[<span class="hljs-number">1</span>];        c.ok &amp;= t;    &#125;    c.l = <span class="hljs-built_in">min</span>(a.l, b.l);    c.r = <span class="hljs-built_in">max</span>(a.r, b.r);    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;Info&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[i] = <span class="hljs-built_in">Info</span>(x, i);&#125;<span class="hljs-function">LazySegmentTree&lt;Info, Tag&gt; <span class="hljs-title">seg</span><span class="hljs-params">(a)</span></span>;<span class="hljs-type">int</span> q;cin &gt;&gt; q;<span class="hljs-keyword">while</span> (q--) &#123;string s;<span class="hljs-type">int</span> l, r;cin &gt;&gt; s &gt;&gt; l &gt;&gt; r;<span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;update&quot;</span>) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;            seg.<span class="hljs-built_in">modify</span>(l, r, Tag&#123;x&#125;);&#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">auto</span> cur = seg.<span class="hljs-built_in">query</span>(l, r);            <span class="hljs-keyword">if</span> (cur.l1 &lt; cur.l2) &#123;                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(inf, inf, cur.l1, cur.f1, cur.f2);                cur.f1 = res[<span class="hljs-number">0</span>];                cur.f2 = res[<span class="hljs-number">1</span>];                cur.ok &amp;= t;            &#125;            <span class="hljs-keyword">if</span> (cur.r1 &lt; cur.r2) &#123;                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(cur.f1, cur.f2, cur.r1, inf, inf);                cur.f1 = res[<span class="hljs-number">0</span>];                cur.f2 = res[<span class="hljs-number">1</span>];                cur.ok &amp;= t;            &#125;            cur.ok |= cur.l2 == inf;            cout &lt;&lt; (cur.ok ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="neerc-2019-2020">NEERC 2019-2020</h2><h3 id="l.-lengths-and-periods后缀自动机">L. Lengths andPeriods【后缀自动机】</h3><p>SAM 真是人类智慧的结晶啊！占坑。</p><h2 id="上海市赛">2024 上海市赛</h2><h3 id="f.-羁绊大师bitset-优化背包">F. 羁绊大师【bitset 优化背包】</h3><div class="note note-info">            <p>有 <span class="math inline">\(n\)</span> 个英雄，每个英雄有 <spanclass="math inline">\(a_i,b_i\)</span> 两种羁绊，且不存在 <spanclass="math inline">\(i,j\in[1,n]\)</span> 使得 <spanclass="math inline">\(a_i=a_j\and b_i=b_j\)</span>。</p><p>共有 <span class="math inline">\(m\)</span>种羁绊，每种羁绊至多只有两个英雄拥有。当上阵英雄中有两个英雄拥有此羁绊时，该羁绊为激活状态。</p><p>对 <span class="math inline">\(k\in[1,n]\)</span> 分别回答当有 <spanclass="math inline">\(k\)</span> 个英雄上阵时，激活羁绊的最大数量。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<spanclass="math inline">\(n \le m \le 2n\)</span>，<spanclass="math inline">\(1\le a_i &lt; b_i \le m\)</span>。</p>          </div><div class="note note-success">            <p>将英雄看成点，羁绊看成边，拥有相同羁绊的两个英雄连边，问题转化为对<span class="math inline">\(k\in [1,n]\)</span> 分别回答选中 <spanclass="math inline">\(k\)</span> 个点时导出子图的最大边数。</p><p>这个图具有特殊性质——每个点的度数至多是 <spanclass="math inline">\(2\)</span>，因此图中只包含环或链。</p><p>对于同样数目的点，选环比选链更具性价比，而对于两条链，优先选更长的链肯定也不劣。于是推断出以下策略：</p><ul><li>选择一些环使得这些环的总点数 <span class="math inline">\(x\lek\)</span> 且 <span class="math inline">\(x\)</span> 尽可能大。</li><li>按链的长度降序选择直到剩下的 <spanclass="math inline">\(k-x\)</span> 个点用完。</li></ul><p>第一步可以做 <span class="math inline">\(01\)</span> 背包 <spanclass="math inline">\(O(n^2)\)</span>地解决。又因为这是存在性背包，于是可以用 <code>std::bitset</code> 优化到<span class="math inline">\(O(\frac{n^2}{w})\)</span>。</p><p>第二步用一个指针维护当前选择的边数即可。</p><p>时间复杂度 <spanclass="math inline">\(O(\frac{n^2}{w})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">bel</span>(m + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;bel[x].<span class="hljs-built_in">push_back</span>(i);bel[y].<span class="hljs-built_in">push_back</span>(i);&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-keyword">if</span> (bel[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<span class="hljs-type">int</span> x = bel[i][<span class="hljs-number">0</span>];<span class="hljs-type">int</span> y = bel[i][<span class="hljs-number">1</span>];adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; cir, line;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> len) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">bool</span> end = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[y] = <span class="hljs-literal">true</span>;end = <span class="hljs-literal">false</span>;<span class="hljs-built_in">self</span>(self, y, len + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (end) &#123;<span class="hljs-keyword">if</span> (adj[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;line.<span class="hljs-built_in">push_back</span>(len - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;cir.<span class="hljs-built_in">push_back</span>(len);&#125;&#125;&#125;; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; adj[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;vis[i] = <span class="hljs-literal">true</span>;<span class="hljs-built_in">dfs</span>(dfs, i, <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; adj[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;vis[i] = <span class="hljs-literal">true</span>;<span class="hljs-built_in">dfs</span>(dfs, i, <span class="hljs-number">1</span>);&#125;&#125;bitset&lt;N&gt; dp;dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;dp |= dp &lt;&lt; x;&#125;<span class="hljs-built_in">sort</span>(line.<span class="hljs-built_in">begin</span>(), line.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());<span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);<span class="hljs-type">int</span> ptr = <span class="hljs-number">0</span>, ex = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (dp[i]) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;ex = <span class="hljs-number">0</span>;res = i;<span class="hljs-keyword">continue</span>;&#125;ex++;<span class="hljs-keyword">if</span> (i &lt;= sum) &#123;cout &lt;&lt; (ex &gt;= <span class="hljs-number">2</span> ? i - <span class="hljs-number">1</span> : res) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (ptr &gt;= line.<span class="hljs-built_in">size</span>()) &#123;cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (ex &gt; line[ptr]) &#123;res += line[ptr];ptr++;ex = <span class="hljs-number">0</span>;&#125;cout &lt;&lt; res + (ex &gt;= <span class="hljs-number">2</span> ? ex - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h3 id="d.-咸鱼跑酷线段树">D. 咸鱼跑酷【线段树】</h3><div class="note note-info">            <p>长为 <span class="math inline">\(n\)</span>的操作序列，每个位置有两种操作，形如 <code>+x</code> 或<code>*x</code>。</p><p>给定 <span class="math inline">\(q\)</span> 组询问，每次给定<code>u l r</code>，问以初值 <spanclass="math inline">\(u\)</span>，执行 <span class="math inline">\(l\tor\)</span>的操作序列，每个位置可以选择两种给定操作中的一种，最后能得到的最大数值。答案对998244353 取模。</p><p><span class="math inline">\(1\le n,q \le 10^5\)</span>，<spanclass="math inline">\(1\le x,u \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>对于一个位置，如果都是 <code>+</code> 或都是<code>*</code>，那么一定选数字大的那个；否则一加一乘，且只有乘的数 <spanclass="math inline">\(&gt;1\)</span>时才有选择的可能，我们称这样的位置为关键位置。</p><p>注意到 <span class="math inline">\(1\le x \le 10^9\)</span>，故当当前<span class="math inline">\(u&gt;10^9\)</span>时，选乘一定比选加更优。</p><p>又因为每次经过一个关键位置，数字大小至少<spanclass="math inline">\(\times 2\)</span>，故经过 <spanclass="math inline">\(O(\log W)\)</span>个关键位置之后当前数字就会超过临界值。</p><p>于是我们预处理出下一个关键位置的坐标，暴力跳 <spanclass="math inline">\(O(\log W)\)</span> 个段。由于段间都为<code>+</code> 操作，故维护一个前缀和即可。</p><p>当跳到数值 <spanclass="math inline">\(&gt;10^9\)</span>，之后的选择就固定了。用线段树维护一段区间累计乘了多少，累计加了多少，就能快速计算。</p><p>pushup 的方式：</p><div class="code-wrapper"><pre><code class="hljs c++">Mul[p] = Mul[p &lt;&lt; <span class="hljs-number">1</span>] * Mul[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]Add[p] = Add[p &lt;&lt; <span class="hljs-number">1</span>] * Mul[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] + Add[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]</code></pre></div><p>时间复杂度 <span class="math inline">\(O(n\logn+q\log(nW))\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; Add, Mul;<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size) &#123;n = size;Add.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);Mul.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;Mul[p] = Mul[ls] * Mul[rs] % modp;Add[p] = (Add[ls] * Mul[rs] + Add[rs]) % modp;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &amp;val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l == r) &#123;        Mul[p] = val[<span class="hljs-number">0</span>];        Add[p] = val[<span class="hljs-number">1</span>];            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;        <span class="hljs-built_in">modify</span>(ls, l, mid, pos, val);        &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">modify</span>(rs, mid + <span class="hljs-number">1</span>, r, pos, val);        &#125;        <span class="hljs-built_in">pushup</span>(p);    &#125;<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r) &#123;<span class="hljs-keyword">return</span> &#123;Mul[p], Add[p]&#125;;&#125;array&lt;<span class="hljs-type">int</span>, 2&gt; res = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">if</span>(ql &lt;= mid) &#123;<span class="hljs-keyword">auto</span> o = <span class="hljs-built_in">query</span>(ls, l, mid, ql, qr);res[<span class="hljs-number">0</span>] = res[<span class="hljs-number">0</span>] * o[<span class="hljs-number">0</span>] % modp;res[<span class="hljs-number">1</span>] = (res[<span class="hljs-number">1</span>] * o[<span class="hljs-number">0</span>] + o[<span class="hljs-number">1</span>]) % modp;&#125;<span class="hljs-keyword">if</span>(qr &gt; mid) &#123;<span class="hljs-keyword">auto</span> o = <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);res[<span class="hljs-number">0</span>] = res[<span class="hljs-number">0</span>] * o[<span class="hljs-number">0</span>] % modp;res[<span class="hljs-number">1</span>] = (res[<span class="hljs-number">1</span>] * o[<span class="hljs-number">0</span>] + o[<span class="hljs-number">1</span>]) % modp;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; val)</span> </span>&#123;        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, val);    &#125;<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);&#125;&#125;;<span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;string s;cin &gt;&gt; s;<span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;add[i] = <span class="hljs-built_in">max</span>(add[i], <span class="hljs-built_in">stoll</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>)));&#125; <span class="hljs-keyword">else</span> &#123;mul[i] = <span class="hljs-built_in">max</span>(mul[i], <span class="hljs-built_in">stoll</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>)));&#125;&#125;&#125;<span class="hljs-function">SegmentTree <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (mul[i] == <span class="hljs-number">1</span>) &#123;seg.<span class="hljs-built_in">modify</span>(i, &#123;<span class="hljs-number">1</span>, add[i]&#125;);&#125; <span class="hljs-keyword">else</span> &#123;seg.<span class="hljs-built_in">modify</span>(i, &#123;mul[i], <span class="hljs-number">0</span>&#125;);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;pre[i] = pre[i - <span class="hljs-number">1</span>] + add[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;nxt[i] = mul[i] &gt; <span class="hljs-number">1</span> ? i : nxt[i + <span class="hljs-number">1</span>];&#125;<span class="hljs-type">int</span> q;cin &gt;&gt; q;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> u, l, r;cin &gt;&gt; u &gt;&gt; l &gt;&gt; r;<span class="hljs-type">int</span> pl = l;<span class="hljs-keyword">while</span> (pl &lt;= r &amp;&amp; u &lt; <span class="hljs-number">1e9</span>) &#123;<span class="hljs-type">int</span> pr = <span class="hljs-built_in">min</span>(r, nxt[pl] - <span class="hljs-number">1</span>);u += pre[pr] - pre[pl - <span class="hljs-number">1</span>];pl = pr + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (u &gt;= <span class="hljs-number">1e9</span> || pl &gt; r) &#123;<span class="hljs-keyword">break</span>;&#125;u = <span class="hljs-built_in">max</span>(u + add[pl], u * mul[pl]);pl++;&#125;<span class="hljs-keyword">auto</span> [Mul, Add] = seg.<span class="hljs-built_in">query</span>(pl, r);<span class="hljs-type">int</span> ans = (u % modp * Mul % modp + Add) % modp;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="seerc-2022">SEERC 2022</h2><h3 id="i.-inadequate-operation贪心单调栈">I. InadequateOperation【贪心、单调栈】</h3><div class="note note-info">            <p>给定长为 <span class="math inline">\(n\)</span> 的非负序列 <spanclass="math inline">\(\{a\}\)</span>，每次操作你可以选择一个 <spanclass="math inline">\(i\in[1,n)\)</span>，满足 <spanclass="math inline">\(\max(a_i,a_{i+1}) &gt;0\)</span>，然后用 <spanclass="math inline">\(\max(a_i,a_{i + 1})-1\)</span> 替换 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(a_{i+1}\)</span>。问使得序列所有元素变为 <spanclass="math inline">\(0\)</span> 的最小操作次数。</p><p><span class="math inline">\(2 \le n \le 2\cdot 10^5\)</span>，<spanclass="math inline">\(0\le a_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>略微诈骗。因为这个操作每次最多让两个位置 <spanclass="math inline">\(-1\)</span>（即 <spanclass="math inline">\(a_i=a_{i+1}\)</span> 时），就算你让一个位置 <spanclass="math inline">\(-1\)</span>，另一个位置被拉高，你继续操作这个下标操作次数也不会更劣。于是策略就是贪心地从大到小删。</p><p>对于一个相同高度长为 <span class="math inline">\(L\)</span>的连续段，删掉它需要 <span class="math inline">\(\lceil\frac{L}{2}\rceil\)</span> 次操作。形式化地，答案是： <spanclass="math display">\[\sum_{i=1}^{mx}\left(\left\lceil\frac{L_{i1}}{2}\right\rceil +\left\lceil\frac{L_{i2}}{2}\right\rceil +\cdots\right)\]</span> 其中 <span class="math inline">\(L_i\)</span> 是指考虑所有<span class="math inline">\(\ge i\)</span>的元素，它们形成的若干连续段长度。</p><p>进一步地，记 <span class="math inline">\(l_i\)</span> 为 <spanclass="math inline">\(i\)</span> 左侧第一个 <spanclass="math inline">\(&lt;a_i\)</span> 的位置，<spanclass="math inline">\(r_i\)</span> 为 <spanclass="math inline">\(i\)</span> 右侧第一个 <spanclass="math inline">\(&lt;a_i\)</span> 的位置。式子可以化成： <spanclass="math display">\[\sum_{i=1}^{n}\left\lceil\frac{r_i-l_i-1}{2}\right\rceil(a_i-\max(a_{l_i},a_{r_i}))\]</span> 实现的时候，可以维护一个内部递增的单调栈，扫一遍就能求出 <spanclass="math inline">\(l_i\)</span> 和 <spanclass="math inline">\(r_i\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        并查集ver.    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i][<span class="hljs-number">0</span>];a[i][<span class="hljs-number">1</span>] = i;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n, lst = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-type">int</span> j = i;<span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j][<span class="hljs-number">0</span>] == a[i][<span class="hljs-number">0</span>]) &#123;j--;&#125;<span class="hljs-type">int</span> len = lst;<span class="hljs-type">int</span> del = a[i][<span class="hljs-number">0</span>] - (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : a[j][<span class="hljs-number">0</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt;= i; k++) &#123;<span class="hljs-type">int</span> pos = a[k][<span class="hljs-number">1</span>];vis[pos] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (vis[pos - <span class="hljs-number">1</span>]) &#123;len -= (dsu.<span class="hljs-built_in">size</span>(pos - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;dsu.<span class="hljs-built_in">merge</span>(pos, pos - <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (vis[pos + <span class="hljs-number">1</span>]) &#123;len -= (dsu.<span class="hljs-built_in">size</span>(pos + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;dsu.<span class="hljs-built_in">merge</span>(pos, pos + <span class="hljs-number">1</span>);&#125;len += (dsu.<span class="hljs-built_in">size</span>(pos) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;ans += len * del;lst = len;i = j + <span class="hljs-number">1</span>;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        单调栈ver.    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stk</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; a[stk.<span class="hljs-built_in">back</span>()] &gt;= a[i]) &#123;r[stk.<span class="hljs-built_in">back</span>()] = i;stk.<span class="hljs-built_in">pop_back</span>();&#125;<span class="hljs-keyword">if</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;l[i] = stk.<span class="hljs-built_in">back</span>();&#125;stk.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ans += (r[i] - l[i]) / <span class="hljs-number">2</span> * (a[i] - <span class="hljs-built_in">max</span>(a[l[i]], a[r[i]]));&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="k.-knowledge-testing-problem整体二分">K. Knowledge TestingProblem【整体二分】</h3><div class="note note-info">            <p>给定一个 <span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\(m\)</span> 条边的无向图，边有边权 <spanclass="math inline">\(w_i\)</span>。其中任意一条边 <spanclass="math inline">\(x_i\to y_i\)</span> 都满足 <spanclass="math inline">\(|x_i-y_i|\le 10\)</span>。给定 <spanclass="math inline">\(q\)</span> 组询问，每次询问两个点问最短路。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<spanclass="math inline">\(1\le m \le 2\cdot 10^5\)</span>，<spanclass="math inline">\(1\le q \le 2.5\cdot 10^4\)</span>，<spanclass="math inline">\(1 \le w_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>考虑整体二分。</p><p>对于当前区间 <span class="math inline">\([l, r]\)</span>，设中点为<span class="math inline">\(m\)</span>，取中点周围 <spanclass="math inline">\([m-4,m+5]\)</span> 共 <spanclass="math inline">\(10\)</span>个点，并以这些点为起点跑单源最短路（经过的点必须在 <spanclass="math inline">\([l,r]\)</span> 内，即只连两个端点都在 <spanclass="math inline">\([l, r]\)</span>内的边），然后再以这些点为中转点分治下去。</p><p>对于一个询问 <span class="math inline">\(x,y\)</span>，若 <spanclass="math inline">\(\max(x,y)&lt;m-4\)</span>，就把它放到 <spanclass="math inline">\([l,m-4)\)</span> 里继续更新；若 <spanclass="math inline">\(\min(x,y)&gt;m+5\)</span>，就把它放到 <spanclass="math inline">\((m+5,r]\)</span>里继续更新；否则此次更新完后不用继续更新，因为必然以 <spanclass="math inline">\(x,y\)</span>中的至少一个点为起点跑了单源最短路。</p><p>保证正确性的根据是：对于一个询问 <spanclass="math inline">\(x,y\)</span>（不妨设 <spanclass="math inline">\(x&lt;y&lt;m-4\)</span>），如果最短路需要经过 <spanclass="math inline">\(m+5\)</span> 右侧的点，就必然经过 <spanclass="math inline">\([m-4,m+5]\)</span>中的某一个（因为任意一条边两侧的点编号相差 <spanclass="math inline">\(\le 10\)</span>），故以这 <spanclass="math inline">\(10\)</span>个点为中转点更新出的最短路能覆盖所有的情况。</p><p>假设 <span class="math inline">\(n,m\)</span> 同级，时间复杂度 <spanclass="math inline">\(O(nd\log^2n)\)</span>，<spanclass="math inline">\(d=10\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, q;cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; E, Q;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;E.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;Q.<span class="hljs-built_in">push_back</span>(&#123;x, y, i&#125;);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q, inf)</span></span>;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, inf)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dijkstra = [&amp;] (<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;dis[i] = inf;vis[i] = <span class="hljs-literal">false</span>;&#125;<span class="hljs-meta">#<span class="hljs-keyword">define</span> P pair<span class="hljs-string">&lt;int, int&gt;</span></span>priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq;pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);dis[S] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> [dist, x] = pq.<span class="hljs-built_in">top</span>();pq.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span> (vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;<span class="hljs-keyword">if</span> (dis[y] &gt; dist + w) &#123;dis[y] = dist + w;pq.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);&#125;&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; &amp;vE, vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; &amp;vQ) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (l &gt; r) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;adj[i].<span class="hljs-built_in">clear</span>();&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : vE) &#123;adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">max</span>(l, mid - <span class="hljs-number">4</span>); i &lt;= <span class="hljs-built_in">min</span>(r, mid + <span class="hljs-number">5</span>); i++) &#123;<span class="hljs-built_in">dijkstra</span>(i, l, r);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, id] : vQ) &#123;ans[id] = <span class="hljs-built_in">min</span>(ans[id], dis[x] + dis[y]);&#125;&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; lE, rE, lQ, rQ;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : vE) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(x, y) &lt;= mid - <span class="hljs-number">5</span>) &#123;lE.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(x, y) &gt;= mid + <span class="hljs-number">6</span>) &#123;rE.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, id] : vQ) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(x, y) &lt;= mid - <span class="hljs-number">5</span>) &#123;lQ.<span class="hljs-built_in">push_back</span>(&#123;x, y, id&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(x ,y) &gt;= mid + <span class="hljs-number">6</span>) &#123;rQ.<span class="hljs-built_in">push_back</span>(&#123;x, y, id&#125;);&#125;&#125;<span class="hljs-built_in">self</span>(self, l, mid - <span class="hljs-number">5</span>, lE, lQ);<span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">6</span>, r, rE, rQ);&#125;;<span class="hljs-built_in">calc</span>(calc, <span class="hljs-number">1</span>, n, E, Q);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; (x == inf ? <span class="hljs-number">-1</span> : x) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="nwerc2021">NWERC2021</h2><h3 id="h.-heating-up双向链表">H. Heating Up【双向链表】</h3><div class="note note-info">            <p>有 <span class="math inline">\(n\)</span> 个辣椒，第 <spanclass="math inline">\(i\)</span> 个辣度为 <spanclass="math inline">\(a_i\)</span>，排成环形（即 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(n\)</span>看作相邻）。你要吃光这些辣椒，你可以任意选择一个辣椒开始，并在之后每一步选择”已选择辣椒”中的一个相邻辣椒吃下。你初始有忍耐度<span class="math inline">\(f\)</span>，你吃下一个辣度为 <spanclass="math inline">\(k\)</span> 的辣椒当且仅当 <spanclass="math inline">\(f\ge k\)</span>，并且当你吃掉它后你的忍耐值会增加<span class="math inline">\(k\)</span>个单位。问吃光所有辣椒所需的最小初始忍耐值。<spanclass="math inline">\(3\le n \le 5\cdot 10^5\)</span>，<spanclass="math inline">\(0\le a_i \le 10^{13}\)</span>。</p>          </div><div class="note note-success">            <p>二分答案，设二分出的答案为 <spanclass="math inline">\(s\)</span>，问题转化为判定初始忍耐值为 <spanclass="math inline">\(s\)</span> 时是否能吃完所有辣椒。</p><p>拆环成链，用一个双向链表操作以下过程：</p><ul><li><p>遍历 <span class="math inline">\(i\in[1,2n]\)</span>，若 <spanclass="math inline">\(a_i&gt;s\)</span>，跳过；否则以点 <spanclass="math inline">\(i\)</span> 为中心向两侧尝试扩张。</p></li><li><p>对每一个连续段维护这个段 <span class="math inline">\(a_i\)</span>的最小值 <spanclass="math inline">\(b\)</span>，当忍耐值不小于这个值时，就可以吞并这个段，新的<span class="math inline">\(b\)</span> 即两段取 <spanclass="math inline">\(\min\)</span>。</p></li><li><p>这个被合并的段有贡献 <span class="math inline">\(\suma_i\)</span>，合并时可以另开一个数组 <spanclass="math inline">\(c\)</span> 维护。</p></li><li><p>判定成功当且仅当链表合并到最后只剩一个元素，即删除了 <spanclass="math inline">\(2n-1\)</span> 个元素。</p></li></ul><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<spanclass="math inline">\(w\)</span> 为二分值域。具体实现见代码。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];a[i + n] = a[i];&#125;a[<span class="hljs-number">0</span>] = a[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>] = inf;<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> st) &#123;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">L</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>), <span class="hljs-built_in">R</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;L[i] = i - <span class="hljs-number">1</span>;R[i] = i + <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> cnt = <span class="hljs-number">2</span> * n;<span class="hljs-keyword">auto</span> del = [&amp;] (<span class="hljs-keyword">auto</span> pos) &#123;L[R[pos]] = L[pos];R[L[pos]] = R[pos];cnt--;&#125;;vector b = a, c = a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i = R[i]) &#123;<span class="hljs-keyword">if</span> (b[i] &gt; st) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> cur = st + b[i];<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> ((L[i] &lt; <span class="hljs-number">1</span> || b[L[i]] &gt; cur) &amp;&amp; (R[i] &gt; <span class="hljs-number">2</span> * n || b[R[i]] &gt; cur)) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (L[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; b[L[i]] &lt;= cur) &#123;cur += c[L[i]];c[i] += c[L[i]];b[i] = <span class="hljs-built_in">min</span>(b[i], b[L[i]]);<span class="hljs-built_in">del</span>(L[i]);&#125;<span class="hljs-keyword">if</span> (R[i] &lt;= <span class="hljs-number">2</span> * n &amp;&amp; b[R[i]] &lt;= cur) &#123;cur += c[R[i]];c[i] += c[R[i]];b[i] = <span class="hljs-built_in">min</span>(b[i], b[R[i]]);<span class="hljs-built_in">del</span>(R[i]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> cnt == <span class="hljs-number">1</span>;&#125;;<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e13</span>, ans = <span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;ans = mid;r = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;l = mid + <span class="hljs-number">1</span>;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="swerc-2023">SWERC 2023</h2><h3 id="g.-favourite-dish凸包">G. Favourite Dish【凸包】</h3><div class="note note-info">            <p>有 <span class="math inline">\(n\)</span> 道菜，第 <spanclass="math inline">\(i\)</span> 道菜有属性 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(b_i\)</span>。有 <spanclass="math inline">\(m\)</span> 个客人，第 <spanclass="math inline">\(i\)</span> 个人有属性 <spanclass="math inline">\(c_{i}\)</span> 和 <spanclass="math inline">\(d_i\)</span>。</p><p>第 <span class="math inline">\(i\)</span> 个人对第 <spanclass="math inline">\(j\)</span> 道菜的喜爱度为 <spanclass="math inline">\(\dfrac{c_ia_j+d_ib_j}{c_i+d_i}\)</span>，即加权平均值。你需要对每个人求出他最喜欢的菜品编号（若对两道菜的喜爱度相同，取编号较小者）。保证有序对<span class="math inline">\((a_i,b_i)\)</span> 两两不同，<spanclass="math inline">\((c_i,d_i)\)</span> 两两不同。</p><p><span class="math inline">\(1\le n,m\le 5\cdot 10^5\)</span>，<spanclass="math inline">\(0\le a_i,b_i,c_i,d_i\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>把每个人看作一个询问。对于单个询问，<spanclass="math inline">\(c+d\)</span> 固定，衡量指标是 <spanclass="math inline">\(ac+bd\)</span>。</p><p>问题转化为给定 <span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\((a, b)\)</span>，每次询问一个 <spanclass="math inline">\((c, d)\)</span>，问 <spanclass="math inline">\(ac+bd\)</span> 取到最大值时对应点的编号。</p><p>这是一个经典问题。令 <spanclass="math inline">\(w=ac+bd\)</span>，两边除以 <spanclass="math inline">\(d\)</span>： <span class="math display">\[\frac{w}{d}=\frac{ac}{d}+b\longrightarrow b=(-\frac{c}{d})a+\frac{w}{d}\]</span></p><p>这是一个 <span class="math inline">\(y=kx+b\)</span>形式的直线方程，让 <span class="math inline">\(w\)</span>最大，即让这条直线的截距 <spanclass="math inline">\(\left(\dfrac{w}{d}\right)\)</span> 最大。</p><p>由于 <span class="math inline">\(a,b,c,d\)</span>均为非负整数，我们可以求出这 <span class="math inline">\(n\)</span> 个点<span class="math inline">\((a, b)\)</span>在第一象限的上凸壳，将询问按斜率 <spanclass="math inline">\(\left(-\dfrac{c}{d}\right)\)</span>排序，用一对双指针即可维护。（一个在凸壳上顺时针扫，一个按直线斜率从大到小扫）时间复杂度 <span class="math inline">\(O(n\log n+m\log m)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">//-------------- templates above --------------</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">a</span>(n);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;a[i] = &#123;x, y, i&#125;;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), [&amp;] (array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; i, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; j) &#123;<span class="hljs-keyword">return</span> i[<span class="hljs-number">0</span>] == j[<span class="hljs-number">0</span>] ? i[<span class="hljs-number">1</span>] &gt; j[<span class="hljs-number">1</span>] : i[<span class="hljs-number">0</span>] &lt; j[<span class="hljs-number">0</span>];&#125;);<span class="hljs-keyword">auto</span> getk = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<span class="hljs-built_in">return</span> (<span class="hljs-type">double</span>)(a[j][<span class="hljs-number">1</span>] - a[i][<span class="hljs-number">1</span>]) / (a[j][<span class="hljs-number">0</span>] - a[i][<span class="hljs-number">0</span>]);&#125;;vector&lt;<span class="hljs-type">int</span>&gt; h&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">while</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getk</span>(h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>], h.<span class="hljs-built_in">back</span>()) &lt; <span class="hljs-built_in">getk</span>(h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>], i)) &#123;h.<span class="hljs-built_in">pop_back</span>();&#125;h.<span class="hljs-built_in">push_back</span>(i);&#125;vector&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt; l;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> c, d;cin &gt;&gt; c &gt;&gt; d;l.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">-1.0L</span> * c / d, i&#125;);&#125;<span class="hljs-built_in">sort</span>(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, res = inf; i &lt; m; i++) &#123;<span class="hljs-keyword">auto</span> [k, id] = l[i];<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; k == l[i - <span class="hljs-number">1</span>].first) &#123;ans[id] = res;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; h.<span class="hljs-built_in">size</span>() &amp;&amp; k &lt; <span class="hljs-built_in">getk</span>(h[j], h[j + <span class="hljs-number">1</span>])) &#123;j++;&#125;res = a[h[j]][<span class="hljs-number">2</span>];<span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; h.<span class="hljs-built_in">size</span>() &amp;&amp; k == <span class="hljs-built_in">getk</span>(h[j], h[j + <span class="hljs-number">1</span>])) &#123;j++;res = <span class="hljs-built_in">min</span>(res, a[h[j]][<span class="hljs-number">2</span>]);&#125;ans[id] = res;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p><span class="math inline">\(1.0\cdot\text{int}=\text{double}\)</span></p><p><span class="math inline">\(1.0L\cdot \text{int}=\text{longdouble}\)</span></p><p>望周知 (QwQ)。</p>          </div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> UESTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【游记】2024 UESTC 暑假集训 第一轮</title>
      <link href="/posts/61a1a0ca.html"/>
      <url>/posts/61a1a0ca.html</url>
      
        <content type="html"><![CDATA[<p>半年没写过游记了，因为懒。</p><p>感觉还是要写点什么才行。</p><h3 id="day--2">【7.5】 Day -2</h3><p>我暑假呢？</p><h3 id="day--1">【7.6】 Day -1</h3><p>我暑假呢？我暑假呢？</p><h3 id="day-0">【7.7】 Day 0</h3><p>我暑假呢？我暑假呢？我暑假呢？</p><h3 id="day-1">【7.8】 Day 1</h3><p>前一晚因为不可抗力没睡着。</p><p>本来预定的是早上 7 点 10分的校车，结果开窗一看下了很大的雨，倒霉！</p><p>干脆取消了改成 8点的校车，好在雨停了，但我有衣服还没干，唉先上车再说。</p><p>到清水河了，脑浆都要颠出来了，体验最差的一次班车，还贼堵。</p><p>到宿舍了，6 楼，累晕了，光是上楼就满身汗。</p><p>早上 10 点，有 yp讲话。到了立人楼发现里面又挤又热，直接把凳子搬出来坐门边了。</p><p>刚坐出来，怎么专题开了鸭，看了一眼感觉都好难鸭qwq。</p><p>听 yp 讲零基础逆袭故事，有点自卑。</p><p>继续听，更自卑了。</p><p>下午的开盒环节提前了，要说自己有没有高中信息学基础。思索了一下，挺可笑的，参加了几次csp 和 noip结果只是稍微会写签到题，甚至不会写签到题的水平，这能叫有基础么。</p><p>于是说了零基础，但大家好像不是很理解我。</p><p>听 yp 讲暑假集训有多残酷，感觉要拿到 div.1 的资格我还差得远。</p><p>不知不觉真的讲了一个半小时，期间 lyc还率先开卷。我把所有题都阅览了一遍，感觉都入手不能，遂放弃。</p><p>后面合照不知道为什么不拍了，商量了一下去朝阳吃午饭。</p><p>朝阳二楼吃的 ¥17原汤五谷牛肉，淡而无味。而且这粉我吃不惯，不知道是不是地域原因，这种细而溜的像粉丝一样的东西能有啥味？不理解。</p><p>当时阿姨本来想多给一块牛肉，结果夹了三次夹不上她直接放弃了，可惜！</p><p>如果能打 1~5 星的话这玩意最多 2 星。</p><p>回宿舍吹空调，但只吹了 15 分钟，又要赶 1 点的车回沙河搬东西。</p><p>不过好在这一来一回比上午那班车体验好多了，补了一点觉，但又感觉没补。</p><p>6 点，终于把行李搬上 6楼了，虽然我带的行李应该是最少的，但这也太为难大胖子了。</p><p>床板质量令人堪忧，感觉一踩上去就会裂成几大块，不过铺上凉席之后感觉还行鸭。</p><p>7 点收到了波波王的果茶！好喝捏，幸福捏。</p><p>然后不知道干什么了，不知道是专题启动还是 tr 启动。</p><p>室友是不是都在学阿！打成共识，开泰！</p><p>怎么群号被群主复读了，这下似摸Q了。</p><h3 id="day-2">【7.9】 Day 2</h3><p>8 点 05准时起床，看了眼专题过题情况，大家都好努力。但不计一血，我也不急。</p><p>早餐没吃，感觉以后也没什么必要。</p><p>xcy 讲课，感觉 ppt做的好认真鸭，出乎意料的除了势能分析都听懂了，虽然讲的是最基础的kmp。</p><p>接着 lxy 讲课，我爆了，z函数听不懂一点，上面板书也小小的看不清。讲到后面写的更小了，这我听集贸啊，就不听了。</p><p>翻了下oiwiki，写的一般鸭，更加认真地看了看，还是放弃了，去翻洛谷题解了。</p><p>稍微会了点，果然有点图示会好很多。</p><p>提前下课！好也不好，外卖点了个 ¥20的猪脚饭。时间还早，冒雨去便利店买了点物资，这便利店完爆沙河。</p><p>外卖被偷了。骑手找了半天，说一分钟前刚放。我不知道该说什么，到了清水河这边干啥都不顺，心态感觉不出几天就垮完了。</p><p>中午补了一下课件上提到的四题。</p><hr /><div class="note note-info">            <p>【CF1200E Compress Words】</p><p>题意：给定 <span class="math inline">\(n\)</span>个单词，需要依次合并他们，使得最终单词尽可能短。</p><p><span class="math inline">\(\sum|S|\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>需要尽可能短，那对于合并后的母串 <spanclass="math inline">\(S\)</span> 和待并入的子串 <spanclass="math inline">\(T\)</span>，要找到 <spanclass="math inline">\(S\)</span> 的最长后缀使之和 <spanclass="math inline">\(T\)</span> 相应长度的前缀等同。</p><p>不难发现所求即为 <span class="math inline">\(T + S\)</span> 的border。</p><p>对于每一个串都要对 <span class="math inline">\(T+S\)</span> 做一次KMP 是不能接受的，因为 <span class="math inline">\(S\)</span>会随着合并越来越长。</p><p>由于我们只关心 border，所以只需要截取 <spanclass="math inline">\(S[\max(0,|S|-|T|),|S|]\)</span>。</p><p>故每回合用来跑 KMP 的串为 <span class="math inline">\(T + @ +S[\max(0,|S|-|T|),|S|]\)</span>。</p><p>中间的特殊字符是用来防止相交的，例如 <span class="math inline">\(S=aba\)</span>，<span class="math inline">\(T = aaba\)</span>，若使用<span class="math inline">\(aabaaba\)</span>，border 是 <spanclass="math inline">\(4\)</span>，而 <spanclass="math inline">\(1\)</span> 是正确的，所以使用 <spanclass="math inline">\(aaba@aba\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;string ans = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">while</span> (n--) &#123;string s;cin &gt;&gt; s;string t = <span class="hljs-string">&quot; &quot;</span> + s + <span class="hljs-string">&quot;@&quot;</span> + ans.<span class="hljs-built_in">substr</span>(ans.<span class="hljs-built_in">size</span>() - <span class="hljs-built_in">min</span>(ans.<span class="hljs-built_in">size</span>(), s.<span class="hljs-built_in">size</span>()));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(t.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; t[i] != t[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (t[i] == t[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;&#125;ans += s.<span class="hljs-built_in">substr</span>(fail[t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P2375 [NOI2014] 动物园】</p><p>题意：求出一个 <span class="math inline">\(\text{num}\)</span>数组，<span class="math inline">\(\text{num}[i]\)</span> 代表字符串<span class="math inline">\(S[1,i]\)</span>的子串中既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重合。</p><p><span class="math inline">\(1 \le |S| \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>暴力做法是跑 KMP，对每个 <span class="math inline">\(i\)</span> 跳fail，找出所有的 border。跳了几次 <spanclass="math inline">\(\text{num[i]}\)</span> 就是多少。</p><p>不重叠也就是只把长度小于原串一半的 border 计入答案。</p><p>倍增优化，<span class="math inline">\(jp[i][j]\)</span> 代表字符串第<span class="math inline">\(i\)</span> 个位置跳了 <spanclass="math inline">\(2^j\)</span> 次后的 border 长度。</p><p>时间复杂度 <span class="math inline">\(O(|S|\log |S|)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s;cin &gt;&gt; s;s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function">vector <span class="hljs-title">jp</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;jp[i][<span class="hljs-number">0</span>] = fail[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">25</span>; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;jp[i][j] = jp[ jp[i][j - <span class="hljs-number">1</span>] ][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x = i;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">24</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (jp[x][j] * <span class="hljs-number">2</span> &gt; i) &#123;x = jp[x][j];&#125;&#125;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">24</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (jp[x][j]) &#123;res += <span class="hljs-number">1LL</span> &lt;&lt; j;x = jp[x][j];&#125;&#125;ans *= (res + <span class="hljs-number">1</span>) % modp;ans %= modp;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><p>但这个跳了几次的问题在预处理时就能记录。</p><p>因为每转移一次相当于跳了的次数 <spanclass="math inline">\(+1\)</span>，假如更新了<code>fail[i] = p</code>，那么直接 <code>num[i] = num[p] + 1</code>即可。</p><p>不重叠同上处理，跳到长度符合要求为止。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s;cin &gt;&gt; s;s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n)</span>, <span class="hljs-title">num</span><span class="hljs-params">(n)</span></span>;num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;num[i] = num[p] + <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;<span class="hljs-keyword">while</span> (p * <span class="hljs-number">2</span> &gt; i) &#123;p = fail[p];&#125;ans *= (num[p] + <span class="hljs-number">1</span>) % modp;ans %= modp;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P3435 [POI2006] OKR-Periods of Words】</p><p>题意：给定字符串 <span class="math inline">\(S\)</span>，对于字符串<span class="math inline">\(T\)</span>，称 <spanclass="math inline">\(T\)</span> 是 <spanclass="math inline">\(S\)</span> 的周期当且仅当 <spanclass="math inline">\(T\)</span> 是 <spanclass="math inline">\(S\)</span> 的真前缀且 <spanclass="math inline">\(S\)</span> 是 <span class="math inline">\(T +T\)</span> 的前缀。</p><p>求给定 <span class="math inline">\(S\)</span>的所有前缀的最大周期长度之和。</p><p><span class="math inline">\(1 \le |S| \le 10^6\)</span>。</p>          </div><div class="note note-success">            <p><span class="math inline">\(S\)</span> 是 <spanclass="math inline">\(T+T\)</span> 的前缀可以理解为把 <spanclass="math inline">\(S\)</span> 的一个前缀复制一份之后能完全包含 <spanclass="math inline">\(S\)</span>。</p><p>设这个前缀为 <span class="math inline">\(S[1,i]\)</span>，那么 <spanclass="math inline">\(S[i+1,|S|]\)</span> 必然和 <spanclass="math inline">\(S[1,|S|-i]\)</span>相等，即把前缀拿走之后剩余的部分必须是原串的一个 border。</p><p>这个前缀又要最长，那么就是最短 border。</p><p>根据 fail 数组的性质，一直跳到空串之前即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;string s;cin &gt;&gt; n &gt;&gt; s;s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> p = i;<span class="hljs-keyword">while</span> (fail[p]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (fail[i]) &#123;fail[i] = p;&#125;ans += i - p;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P5829 【模板】失配树】</p><p>题意：给定一个字符串 <span class="math inline">\(S\)</span>，<spanclass="math inline">\(m\)</span> 组询问。每次给定 <spanclass="math inline">\(p,q\)</span>，求 <spanclass="math inline">\(S\)</span> 的 <spanclass="math inline">\(p\)</span> 前缀和 <spanclass="math inline">\(q\)</span> 前缀的最长公共 border 的长度。</p><p><span class="math inline">\(1\le p,q\le |S| \le 10^6\)</span>，<spanclass="math inline">\(1\le m \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>fail 树，顾名思义就是连边 <span class="math inline">\(fail[i] \toi\)</span> 形成的树，不断往上跳父亲跳到根就能得到这个字符串所有的border。</p><p>那题目所求相当于 fail 树上点 <span class="math inline">\(p\)</span>和点 <span class="math inline">\(q\)</span> 的 <spanclass="math inline">\(\text{LCA}\)</span>。</p><p>特别注意：如果求出来的 <spanclass="math inline">\(\text{LCA}\)</span> 是 <spanclass="math inline">\(p\)</span> 或者 <spanclass="math inline">\(q\)</span>，那么还要往上跳一格，因为自己不是自己的border。</p><p>时间复杂度 <span class="math inline">\(O(m\log |S|)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string s;cin &gt;&gt; s;<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();s = <span class="hljs-string">&quot; &quot;</span> + s;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);adj[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;p = fail[p];&#125;<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;p++;&#125;fail[i] = p;adj[fail[i]].<span class="hljs-built_in">push_back</span>(i);&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fa</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>, <span class="hljs-number">0</span>));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">depth</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;fa[x][<span class="hljs-number">0</span>] = fath;depth[x] = depth[fath] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= __lg(depth[x]) + <span class="hljs-number">1</span>; i++) &#123;fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y != fath) &#123;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span> (depth[x] &lt; depth[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;<span class="hljs-keyword">while</span> (depth[x] &gt; depth[y]) &#123;x = fa[x][__lg(depth[x] - depth[y])];&#125;<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(depth[x]); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i]) &#123;x = fa[x][i];y = fa[y][i];&#125;&#125;<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> m;cin &gt;&gt; m;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;<span class="hljs-type">int</span> res = <span class="hljs-built_in">LCA</span>(x, y);<span class="hljs-keyword">if</span> (res == x || res == y) &#123;res = fa[res][<span class="hljs-number">0</span>];&#125;cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>下午 QHJ 讲计算几何，没睡过，但雨一直下，走过去还要 20 分钟，摆！</p><p>看了看集训计划确认了每个专题第一节不点名，就呆在宿舍听了。</p><p>然后就后悔了，声音断断续续的，基本就是看 PPT。</p><p>怎么感觉都是套板子鸭，很符合我之前对计算几何的印象。</p><p>但我怎么例题都不会做鸭（</p><p>正好有一段声音几乎没了，估计是在黑板上涂涂写写，我听着也难受，就去做了两个PPT 上的题。</p><p>感觉下午亏麻了鸭！</p><hr /><div class="note note-info">            <p>【2024 四川省赛】F. Isoball: 2D Version</p><p>题意：给定一个圆和一个平行坐标轴的矩形，现给定一组方向向量，该圆开始沿此方向运动，问是否存在一个时刻使得圆完全包含在给定矩形中。</p>          </div><div class="note note-success">            <p>当圆完全被矩形包含时，圆心到该矩形四条边的距离均 <spanclass="math inline">\(\ge r\)</span>。</p><p>那么我们可以把这个矩形的四条边向彼此均移动 <spanclass="math inline">\(r\)</span>，得到一个缩小版矩形。</p><p>此时只需要判断圆心是否在这个缩小版矩形中。</p><p>圆心的轨迹是一条射线，题目也转化为该射线是否和矩形的某一条边有交点。</p><p>射线求交即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    T x, y;    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;    <span class="hljs-keyword">operator</span> <span class="hljs-built_in">Point</span>&lt;U&gt;() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>&lt;U&gt;(<span class="hljs-built_in">U</span>(x), <span class="hljs-built_in">U</span>(y));    &#125;    Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;        x += p.x;        y += p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;        x -= p.x;        y -= p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;        x *= v;        y *= v;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a += b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a -= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;        <span class="hljs-keyword">return</span> a *= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;        <span class="hljs-keyword">return</span> b *= a;    &#125;    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;    Point&lt;T&gt; a, b;    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">lineIntersection</span><span class="hljs-params">(Line&lt;T&gt; l1, Line&lt;T&gt; l2)</span> </span>&#123;    <span class="hljs-keyword">return</span> l<span class="hljs-number">1.</span>a + (l<span class="hljs-number">1.</span>b - l<span class="hljs-number">1.</span>a) * (<span class="hljs-built_in">cross</span>(l<span class="hljs-number">2.</span>b - l<span class="hljs-number">2.</span>a, l<span class="hljs-number">1.</span>a - l<span class="hljs-number">2.</span>a) / <span class="hljs-built_in">cross</span>(l<span class="hljs-number">2.</span>b - l<span class="hljs-number">2.</span>a, l<span class="hljs-number">1.</span>a - l<span class="hljs-number">1.</span>b));&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pointOnSegment</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">cross</span>(p - l.a, l.b - l.a) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">min</span>(l.a.x, l.b.x) &lt;= p.x &amp;&amp; p.x &lt;= <span class="hljs-built_in">max</span>(l.a.x, l.b.x)    &amp;&amp; <span class="hljs-built_in">min</span>(l.a.y, l.b.y) &lt;= p.y &amp;&amp; p.y &lt;= <span class="hljs-built_in">max</span>(l.a.y, l.b.y);&#125;<span class="hljs-comment">// 0 : not intersect</span><span class="hljs-comment">// 1 : strictly intersect</span><span class="hljs-comment">// 2 : overlap</span><span class="hljs-comment">// 3 : intersect at endpoint</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;tuple&lt;<span class="hljs-type">int</span>, Point&lt;T&gt;, Point&lt;T&gt;&gt; <span class="hljs-built_in">segmentIntersection</span>(Line&lt;T&gt; l1, Line&lt;T&gt; l2) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(l<span class="hljs-number">1.</span>a.x, l<span class="hljs-number">1.</span>b.x) &lt; <span class="hljs-built_in">min</span>(l<span class="hljs-number">2.</span>a.x, l<span class="hljs-number">2.</span>b.x)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(l<span class="hljs-number">1.</span>a.x, l<span class="hljs-number">1.</span>b.x) &gt; <span class="hljs-built_in">max</span>(l<span class="hljs-number">2.</span>a.x, l<span class="hljs-number">2.</span>b.x)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(l<span class="hljs-number">1.</span>a.y, l<span class="hljs-number">1.</span>b.y) &lt; <span class="hljs-built_in">min</span>(l<span class="hljs-number">2.</span>a.y, l<span class="hljs-number">2.</span>b.y)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(l<span class="hljs-number">1.</span>a.y, l<span class="hljs-number">1.</span>b.y) &gt; <span class="hljs-built_in">max</span>(l<span class="hljs-number">2.</span>a.y, l<span class="hljs-number">2.</span>b.y)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cross</span>(l<span class="hljs-number">1.</span>b - l<span class="hljs-number">1.</span>a, l<span class="hljs-number">2.</span>b - l<span class="hljs-number">2.</span>a) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cross</span>(l<span class="hljs-number">1.</span>b - l<span class="hljs-number">1.</span>a, l<span class="hljs-number">2.</span>a - l<span class="hljs-number">1.</span>a) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">auto</span> maxx1 = <span class="hljs-built_in">max</span>(l<span class="hljs-number">1.</span>a.x, l<span class="hljs-number">1.</span>b.x);            <span class="hljs-keyword">auto</span> minx1 = <span class="hljs-built_in">min</span>(l<span class="hljs-number">1.</span>a.x, l<span class="hljs-number">1.</span>b.x);            <span class="hljs-keyword">auto</span> maxy1 = <span class="hljs-built_in">max</span>(l<span class="hljs-number">1.</span>a.y, l<span class="hljs-number">1.</span>b.y);            <span class="hljs-keyword">auto</span> miny1 = <span class="hljs-built_in">min</span>(l<span class="hljs-number">1.</span>a.y, l<span class="hljs-number">1.</span>b.y);            <span class="hljs-keyword">auto</span> maxx2 = <span class="hljs-built_in">max</span>(l<span class="hljs-number">2.</span>a.x, l<span class="hljs-number">2.</span>b.x);            <span class="hljs-keyword">auto</span> minx2 = <span class="hljs-built_in">min</span>(l<span class="hljs-number">2.</span>a.x, l<span class="hljs-number">2.</span>b.x);            <span class="hljs-keyword">auto</span> maxy2 = <span class="hljs-built_in">max</span>(l<span class="hljs-number">2.</span>a.y, l<span class="hljs-number">2.</span>b.y);            <span class="hljs-keyword">auto</span> miny2 = <span class="hljs-built_in">min</span>(l<span class="hljs-number">2.</span>a.y, l<span class="hljs-number">2.</span>b.y);            <span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">p1</span><span class="hljs-params">(max(minx1, minx2), max(miny1, miny2))</span></span>;            <span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(min(maxx1, maxx2), min(maxy1, maxy2))</span></span>;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pointOnSegment</span>(p1, l1)) &#123;                <span class="hljs-built_in">swap</span>(p<span class="hljs-number">1.</span>y, p<span class="hljs-number">2.</span>y);            &#125;            <span class="hljs-keyword">if</span> (p1 == p2) &#123;                <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">3</span>, p1, p2&#125;;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">2</span>, p1, p2&#125;;            &#125;        &#125;    &#125;    <span class="hljs-keyword">auto</span> cp1 = <span class="hljs-built_in">cross</span>(l<span class="hljs-number">2.</span>a - l<span class="hljs-number">1.</span>a, l<span class="hljs-number">2.</span>b - l<span class="hljs-number">1.</span>a);    <span class="hljs-keyword">auto</span> cp2 = <span class="hljs-built_in">cross</span>(l<span class="hljs-number">2.</span>a - l<span class="hljs-number">1.</span>b, l<span class="hljs-number">2.</span>b - l<span class="hljs-number">1.</span>b);    <span class="hljs-keyword">auto</span> cp3 = <span class="hljs-built_in">cross</span>(l<span class="hljs-number">1.</span>a - l<span class="hljs-number">2.</span>a, l<span class="hljs-number">1.</span>b - l<span class="hljs-number">2.</span>a);    <span class="hljs-keyword">auto</span> cp4 = <span class="hljs-built_in">cross</span>(l<span class="hljs-number">1.</span>a - l<span class="hljs-number">2.</span>b, l<span class="hljs-number">1.</span>b - l<span class="hljs-number">2.</span>b);        <span class="hljs-keyword">if</span> ((cp1 &gt; <span class="hljs-number">0</span> &amp;&amp; cp2 &gt; <span class="hljs-number">0</span>) || (cp1 &lt; <span class="hljs-number">0</span> &amp;&amp; cp2 &lt; <span class="hljs-number">0</span>) || (cp3 &gt; <span class="hljs-number">0</span> &amp;&amp; cp4 &gt; <span class="hljs-number">0</span>) || (cp3 &lt; <span class="hljs-number">0</span> &amp;&amp; cp4 &lt; <span class="hljs-number">0</span>)) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;    &#125;        Point p = <span class="hljs-built_in">lineIntersection</span>(l1, l2);    <span class="hljs-keyword">if</span> (cp1 != <span class="hljs-number">0</span> &amp;&amp; cp2 != <span class="hljs-number">0</span> &amp;&amp; cp3 != <span class="hljs-number">0</span> &amp;&amp; cp4 != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, p, p&#125;;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">3</span>, p, p&#125;;    &#125;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">double</span> x, y, r, vx, vy;cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; vx &gt;&gt; vy;<span class="hljs-type">double</span> lx, ly, rx, ry;cin &gt;&gt; lx &gt;&gt; ly &gt;&gt; rx &gt;&gt; ry;lx += r;rx -= r;ly += r;ry -= r;<span class="hljs-keyword">if</span> (lx &gt; rx || ly &gt; ry) &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">double</span> mx = <span class="hljs-number">1e7</span>;<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(&#123;x, y&#125;, &#123;x + vx * mx, y + vy * mx&#125;)</span></span>;vector&lt;Line&lt;<span class="hljs-type">double</span>&gt;&gt; lines = &#123;&#123;&#123;lx, ly&#125;, &#123;rx, ly&#125;&#125;,&#123;&#123;rx, ly&#125;, &#123;rx, ry&#125;&#125;,&#123;&#123;rx, ry&#125;, &#123;lx, ry&#125;&#125;,&#123;&#123;lx, ry&#125;, &#123;lx, ly&#125;&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> line : lines) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-built_in">segmentIntersection</span>(l, line)) &gt; <span class="hljs-number">0</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>晚饭还是点外卖，一雪前耻。点了个 ¥27的麻辣香锅，好吃捏好吃捏，分量也足，能有 4 星半（?）</p><p>专题还是不想做，动力全无。</p><p>研究了一下 PPT，本来想搞一套自己的板子，最后还是直接扒的 jiangly的，因为哥哥写的代码实在是太好看了鸭。不过流传的版本缺失了很多内容，我照葫芦画瓢补了点上去。</p><p>专题有几题过了挺多人了，跟下榜？</p><p>十分钟写了个签到 pick 定理，然后坐了两小时牢。</p><p>菜输了，感觉还没到能徒手干专题的水平，先放着好了。</p><h3 id="day-3">【7.10】 Day 3</h3><p>起床，洗漱。</p><p>然后发现不对。</p><p>我趣，怎么我 8 点 05 的闹钟定成 7 点 05 了，太难崩了。</p><p>不知道舍友是不是被我吵醒了，脑子越来越不好使了，完蛋。</p><p>不想睡回笼觉，溜了一遍昨天学的 z 函数和 manacher。</p><p>到教室了，感觉今天讲的内容挺重要的，就坐在了前排。</p><p>结果中间想爆一下群巨被抓包了qwq。</p><p>徐神讲课还是讲得超级棒口牙，都听懂了（吗？）</p><p>甚至细到现写代码，好贴心鸭/se/se/se</p><p>后面 lxy讲课一如既往的听不懂：讲序列自动机，嗯，开始听，讲完了？讲最小表示法，开始听，听不懂，讲完了？到Lyndon 分解，讲完了？问我们听没听懂，此时的我belike：<del>（数据删除）</del></p><p>中午想着要不要去图书馆借个词典，但懒了，希望下午不要伏笔回收。</p><p>又点了一次昨天那个麻辣香锅，只不过换了个口味，爽爽爽。</p><p>今天还是不想睡午觉，正好 xjj 问我第二次队内赛的H，我想起那题之前我线段树优化建图被卡爆了，就稍微写了写。</p><p>对着题解搓了一发前后缀优化建图，直接 AC，爽！</p><hr /><div class="note note-info">            <p>【2024 - 暑假前集训队内赛 2 - H. 金铲铲，启动！】</p><p><ahref="https://121-48-165-90.vpn.uestc.edu.cn:8118/contest/253/problem/H">Link</a></p>          </div><div class="note note-success">            <p>和图论专题 L 很类似，看题识 2sat，对于拥有小羁绊的奕子 <spanclass="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span>，有 <span class="math inline">\(u \lorv\)</span>。</p><p>而对于拥有相同大羁绊的奕子集合 <spanclass="math inline">\(s\)</span>，<span class="math inline">\(\forallx,y\in s\)</span>，<span class="math inline">\(\lnot x \lor \lnoty\)</span>。</p><p>可以线段树优化建图，每个集合中的第 <spanclass="math inline">\(i\)</span> 个点向第 <spanclass="math inline">\([1,i-1]\)</span> 和第 <spanclass="math inline">\([i+1,|s|]\)</span> 的点连边。</p><p>但这样连的边还是太多了，需要采用前后缀优化建图。</p><p><img src="https://kisuraop.github.io/image/academic/5.png" alt="1" />如图连边即可。第一次见到，很智慧。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        线段树优化建图    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf INT_MAX</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegEdge</span> &#123;<span class="hljs-type">int</span> n, K, all;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; id;<span class="hljs-built_in">SegEdge</span>() &#123;&#125;<span class="hljs-built_in">SegEdge</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;K = <span class="hljs-number">4</span> * n;all = <span class="hljs-number">8</span> * n;adj.<span class="hljs-built_in">resize</span>(all + <span class="hljs-number">1</span>);id.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;adj[id[i]].<span class="hljs-built_in">push_back</span>(&#123;id[i] + K, <span class="hljs-number">0</span>&#125;);adj[id[i] + K].<span class="hljs-built_in">push_back</span>(&#123;id[i], <span class="hljs-number">0</span>&#125;);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> id[l] = p, <span class="hljs-built_in">void</span>();adj[p].<span class="hljs-built_in">push_back</span>(&#123;p &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);adj[p].<span class="hljs-built_in">push_back</span>(&#123;p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);adj[(p &lt;&lt; <span class="hljs-number">1</span>) + K].<span class="hljs-built_in">push_back</span>(&#123;p + K, <span class="hljs-number">0</span>&#125;);adj[(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>) + K].<span class="hljs-built_in">push_back</span>(&#123;p + K, <span class="hljs-number">0</span>&#125;);<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> rx, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> opt)</span> </span>&#123;<span class="hljs-keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;<span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) adj[x + K].<span class="hljs-built_in">push_back</span>(&#123;p, w&#125;);<span class="hljs-keyword">else</span> adj[p + K].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (lx &lt;= mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, lx, rx, x, w, opt);<span class="hljs-keyword">if</span> (rx &gt; mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, lx, rx, x, w, opt);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtoP</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;adj[id[x] + K].<span class="hljs-built_in">push_back</span>(&#123;id[y], w&#125;);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtoS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> w)</span> </span>&#123;<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, id[x], w, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StoP</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> w)</span> </span>&#123;<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, id[x], w, <span class="hljs-number">2</span>);&#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoSat</span> &#123;<span class="hljs-type">int</span> n;<span class="hljs-built_in">TwoSat</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addbind</span><span class="hljs-params">(SegEdge &amp;seg, <span class="hljs-type">int</span> x, <span class="hljs-type">bool</span> ok1, <span class="hljs-type">int</span> y, <span class="hljs-type">bool</span> ok2)</span> </span>&#123;seg.<span class="hljs-built_in">PtoP</span>(x + n / <span class="hljs-number">8</span> * (!ok1), y + n / <span class="hljs-number">8</span> * ok2, <span class="hljs-number">1</span>);seg.<span class="hljs-built_in">PtoP</span>(y + n / <span class="hljs-number">8</span> * (!ok2), x + n / <span class="hljs-number">8</span> * ok1, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">(SegEdge &amp;seg)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x] = low[x] = ++tim;vis[x] = <span class="hljs-literal">true</span>;stack_[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : seg.adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span>&#123;now = stack_[top--];vis[now] = <span class="hljs-literal">false</span>;c[now] = cnt;&#125; <span class="hljs-keyword">while</span> (x != now);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / <span class="hljs-number">8</span>; i++) &#123;<span class="hljs-keyword">if</span> (c[seg.id[i]] == c[seg.id[i + n / <span class="hljs-number">8</span>]]) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[i] = &#123;x, i&#125;;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ys</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">R</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;R[a[i][<span class="hljs-number">0</span>]] = <span class="hljs-built_in">max</span>(R[a[i][<span class="hljs-number">0</span>]], i);ys[a[i][<span class="hljs-number">1</span>]] = i;&#125;<span class="hljs-function">SegEdge <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;<span class="hljs-function">TwoSat <span class="hljs-title">ts</span><span class="hljs-params">(<span class="hljs-number">8</span> * n)</span></span>;<span class="hljs-keyword">auto</span> Add = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;seg.<span class="hljs-built_in">PtoS</span>(x + n, l, r, <span class="hljs-number">1</span>);seg.<span class="hljs-built_in">StoP</span>(l + n, r + n, x, <span class="hljs-number">1</span>);&#125;;<span class="hljs-type">int</span> now = n;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (R[a[i][<span class="hljs-number">0</span>]] != i) &#123;<span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> r = R[a[i][<span class="hljs-number">0</span>]];<span class="hljs-built_in">Add</span>(i, l, r);&#125;&#125;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;x = ys[x];y = ys[y];ts.<span class="hljs-built_in">addbind</span>(seg, x, <span class="hljs-number">1</span>, y, <span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> ans = ts.<span class="hljs-built_in">work</span>(seg);<span class="hljs-keyword">if</span> (ans) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Teamfight Tactics\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Crown Legends: Battlefury\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// fre(test);</span>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        前后缀优化建图    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf INT_MAX</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoSat</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-built_in">TwoSat</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;adj.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);ans.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addbind</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">bool</span> ok1, <span class="hljs-type">int</span> y, <span class="hljs-type">bool</span> ok2)</span> </span>&#123;adj[x + n * (!ok1)].<span class="hljs-built_in">push_back</span>(y + n * ok2);adj[y + n * (!ok2)].<span class="hljs-built_in">push_back</span>(x + n * ok1);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x] = low[x] = ++tim;vis[x] = <span class="hljs-literal">true</span>;stack_[++top] = x;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;<span class="hljs-type">int</span> now; ++cnt;<span class="hljs-keyword">do</span>&#123;now = stack_[top--];vis[now] = <span class="hljs-literal">false</span>;c[now] = cnt;scc[cnt].<span class="hljs-built_in">push_back</span>(now);&#125; <span class="hljs-keyword">while</span> (x != now);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (c[i] == c[i + n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;ans[i] = c[i] &gt; c[i + n] ? <span class="hljs-number">1ll</span> : <span class="hljs-number">0ll</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getans</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ans;&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(k + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];b[a[i]].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-function">TwoSat <span class="hljs-title">ts</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<span class="hljs-keyword">if</span> (b[i].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; b[i].<span class="hljs-built_in">size</span>(); j++) &#123;ts.adj[b[i][j] + <span class="hljs-number">2</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j] + <span class="hljs-number">3</span> * n);ts.adj[b[i][j] + n].<span class="hljs-built_in">push_back</span>(b[i][j]);<span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; b[i].<span class="hljs-built_in">size</span>()) &#123;ts.adj[b[i][j] + <span class="hljs-number">3</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j + <span class="hljs-number">1</span>] + <span class="hljs-number">3</span> * n);&#125;<span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;ts.adj[b[i][j] + n].<span class="hljs-built_in">push_back</span>(b[i][j - <span class="hljs-number">1</span>] + n);&#125;<span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; b[i].<span class="hljs-built_in">size</span>()) &#123;ts.adj[b[i][j] + <span class="hljs-number">3</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j + <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;ts.adj[b[i][j] + <span class="hljs-number">2</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j - <span class="hljs-number">1</span>] + n);&#125;&#125;&#125;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;ts.<span class="hljs-built_in">addbind</span>(x, <span class="hljs-number">1</span>, y, <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span> (ts.<span class="hljs-built_in">work</span>()) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Teamfight Tactics\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Crown Legends: Battlefury\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>下午队内赛，寄完了，3/10（Rank 5）</p><p>一开始随机开题，感觉 C一眼，然后开始写，然后就不会写了，最后也没写出来。</p><p>F 题意挂了一个半小时，最后终于读懂了是“开始和移动过程可能在同一个位置，最后不能在同一个位置，也就是一串连续的坐标，然后除了递增还可能是递减”。</p><p>E 题意至少读了 10遍，还是搞不懂这题想求什么。我怎么感觉只有每个字符串的首字母有用，样例我也搞不懂。</p><p>挺唐的，赛时感觉很多题都能猜到是怎么做的，但写不出来。</p><p>菜。</p><hr /><p>晚饭在商业街吃了个炸鸡，一般，三星。</p><p>回到宿舍 emo 完洗完澡就 10 点了（？？？中间干了什么？？？）。</p><p>补了两题就过 12 点了，AC 自动机的例题还没看（</p><p>完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了。</p><hr /><div class="note note-info">            <p>【队内赛 1E - gym104022 K. Browser Games】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个字符串 <spanclass="math inline">\(\{s\}\)</span>，对于每个 <spanclass="math inline">\(i\in[1, n]\)</span>回答最少用几个字符串组成字符串集 <spanclass="math inline">\(T\)</span>，才能使第 <spanclass="math inline">\(1\sim i\)</span> 个字符串在 <spanclass="math inline">\(T\)</span> 中都至少有一个前缀，且第 <spanclass="math inline">\(i + 1\sim n\)</span> 个字符串的所有前缀在 <spanclass="math inline">\(T\)</span> 中不存在。</p><p><span class="math inline">\(1 \le n \le 5\cdot 10^4\)</span>，<spanclass="math inline">\(|s| \le 50\)</span>，字符串含 <spanclass="math inline">\(a\sim z\)</span>，小数点和斜杠。</p>          </div><div class="note note-success">            <p>考虑增加了一个字符串，那么这个字符串在增加之前造成的限制消失了，消失了多少？</p><p>我们把字符串放到 trie树上考虑，记录每个节点最近一次的访问来自于哪个字符串（<code>flag</code>）以及字符串末尾标记（<code>id</code>）。增加字符串<span class="math inline">\(i\)</span> 时，可以从 <code>id[i]</code>不断向上跳父亲，直到节点 <code>flag</code> 不为 <spanclass="math inline">\(i\)</span>为止，目前这段链就是使得答案增加的罪魁祸首。</p><p>为了统计增加了多少，我们再为 trie 树上的每个节点引入标记<code>cnt</code>。意为该节点确认作为 <spanclass="math inline">\(T\)</span>中的一个答案：每次跳父亲之后，所在的满足 <code>flag</code> 不为<code>i</code> 的节点就确认作为一个前缀，因此<code>cnt++</code>；而每次答案也减少了这条链上的 <code>cnt</code>个数。</p><p>时间复杂度 <span class="math inline">\(O(n|s|)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">28</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> fa, flag, cnt;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, flag&#123;<span class="hljs-number">-1</span>&#125;, cnt&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">Trie</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);t[<span class="hljs-number">1</span>].fa = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> i)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;x = <span class="hljs-number">26</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;x = <span class="hljs-number">27</span>;&#125; <span class="hljs-keyword">else</span> &#123;x = c - <span class="hljs-string">&#x27;a&#x27;</span>;&#125;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].fa = p;&#125;p = t[p].nxt[x];t[p].flag = i;&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].flag;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].cnt;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fa;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;Trie tr;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;cin &gt;&gt; s;id[i] = tr.<span class="hljs-built_in">add</span>(s, i);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> j = id[i];<span class="hljs-keyword">while</span> (i == tr.<span class="hljs-built_in">flag</span>(j)) &#123;res += tr.<span class="hljs-built_in">cnt</span>(j);j = tr.<span class="hljs-built_in">fa</span>(j);&#125;tr.t[j].cnt++;ans += <span class="hljs-number">1</span> - res;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// fre(test);</span>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><p>但它 MLE 了，所以还要提前 reserve 一下（唉，卡常。</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">28</span>;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2.5e6</span> + <span class="hljs-number">2</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> fa, flag, cnt;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, flag&#123;<span class="hljs-number">-1</span>&#125;, cnt&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">Trie</span>() &#123;t.<span class="hljs-built_in">reserve</span>(N);t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);t[<span class="hljs-number">1</span>].fa = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> i)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;x = <span class="hljs-number">26</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;x = <span class="hljs-number">27</span>;&#125; <span class="hljs-keyword">else</span> &#123;x = c - <span class="hljs-string">&#x27;a&#x27;</span>;&#125;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].fa = p;&#125;p = t[p].nxt[x];t[p].flag = i;&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].flag;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].cnt;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fa;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;Trie tr;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;cin &gt;&gt; s;id[i] = tr.<span class="hljs-built_in">add</span>(s, i);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> j = id[i];<span class="hljs-keyword">while</span> (i == tr.<span class="hljs-built_in">flag</span>(j)) &#123;res += tr.<span class="hljs-built_in">cnt</span>(j);j = tr.<span class="hljs-built_in">fa</span>(j);&#125;tr.t[j].cnt++;ans += <span class="hljs-number">1</span> - res;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 1B - gym104022 B. The Great Wall】</p><p>题意：给定长为 <span class="math inline">\(n\)</span>的数组，你需要将其划分为 <span class="math inline">\(k\)</span>段，定义每段的权值为该段元素的极差，总权值为各段的权值和。对每个 <spanclass="math inline">\(k=1\sim n\)</span> 给出最大总权值。</p><p><span class="math inline">\(1 \le n \le 10^4\)</span>，<spanclass="math inline">\(1 \le a_i \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>妙妙题，第一步转化就十分 amazing。</p><p>一眼 dp，但每段的极差不好处理。不妨把极差转化为 <spanclass="math inline">\(\max(将该段一个数 \times 1，一个数 \times-1\  后二者的和)\)</span>。</p><p>令 <span class="math inline">\(dp[i][j][k=0\sim3]\)</span>表示处理了前 <span class="math inline">\(i\)</span> 个数，分成了 <spanclass="math inline">\(j\)</span> 段，且此时第 <spanclass="math inline">\(j\)</span> 段的状态为 <spanclass="math inline">\(k\)</span>。</p><ul><li><p><span class="math inline">\(k = 0\)</span>：既没有选 <spanclass="math inline">\(\times1\)</span> 的数，也没有选 <spanclass="math inline">\(\times -1\)</span> 的数。</p></li><li><p><span class="math inline">\(k = 1\)</span>：已经选了 <spanclass="math inline">\(\times -1\)</span> 的数，但没选 <spanclass="math inline">\(\times 1\)</span> 的数。</p></li><li><p><span class="math inline">\(k = 2\)</span>：已经选了 <spanclass="math inline">\(\times 1\)</span> 的数，但没选 <spanclass="math inline">\(\times -1\)</span> 的数。</p></li><li><p><span class="math inline">\(k = 3\)</span>：已经选了 <spanclass="math inline">\(\times 1\)</span> 的数，也选了 <spanclass="math inline">\(\times -1\)</span> 的数。</p></li></ul><p>这样就可以转移了，第一维可以滚动。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, vector(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, -inf)))</span></span>;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;t ^= <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;dp[t][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>],   dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);dp[t][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>],    dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + a[i],    dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] + a[i]&#125;);dp[t][j][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">2</span>],    dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - a[i],    dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] - a[i]&#125;);dp[t][j][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">3</span>],    dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>],    dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">2</span>] + a[i],    dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] - a[i]&#125;);&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; dp[t][i][<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 1J - gym102920 H. Needle】</p><p>题意：有三条平行 <span class="math inline">\(x\)</span>轴直线，直线上有缺口，三条直线上的缺口坐标分别给定为 <spanclass="math inline">\(\{a\},\{b\},\{c\}\)</span>，问有多少组三点共线。</p><p><span class="math inline">\(1 \le n_a,n_b,n_c \le 5\cdot10^4\)</span>，<span class="math inline">\(-3\cdot10^4 \le a_i,b_i,c_i\le 3\cdot 10^4\)</span>。</p>          </div><div class="note note-success">            <p>结论：等效于求满足 <span class="math inline">\(a_i+c_k=2\cdotb_j\)</span> 的三元组 <span class="math inline">\((i, j, k)\)</span>的数量。由中点性质易证。</p><p>移项，得 <span class="math inline">\(a_i - b_j = -c_k +b_j\)</span>。</p><p>将 <span class="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(-c_k\)</span> 存到 bitset 中，一个左移 <spanclass="math inline">\(b_j\)</span> 一个右移 <spanclass="math inline">\(b_j\)</span>，之后 <spanclass="math inline">\(\&amp;\)</span> 起来为 <spanclass="math inline">\(1\)</span> 的位置数目就是所求。</p><p>可以直接调用 bitset 中的 <code>count()</code> 函数，时间复杂度 <spanclass="math inline">\(O(\frac{n^2}{w})\)</span>。</p><p>注意负数，需要整体加一个数全变为正数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6e4</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> eps = <span class="hljs-number">3e4</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> A;cin &gt;&gt; A;bitset&lt;N&gt; a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= A; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[x + eps] = <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> B;cin &gt;&gt; B;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(B + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= B; i++) &#123;cin &gt;&gt; b[i];&#125;<span class="hljs-type">int</span> C;cin &gt;&gt; C;bitset&lt;N&gt; c;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= C; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;c[-x + eps] = <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= B; i++) &#123;<span class="hljs-keyword">if</span> (b[i] &gt; <span class="hljs-number">0</span>) &#123;ans += ( (a &gt;&gt; b[i]) &amp; (c &lt;&lt; b[i]) ).<span class="hljs-built_in">count</span>();&#125; <span class="hljs-keyword">else</span> &#123;ans += ( (a &lt;&lt; (-b[i]) ) &amp; (c &gt;&gt; (-b[i]) ) ).<span class="hljs-built_in">count</span>();&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>凌晨两点多了，AC 自动机的例题明天再说叭。</p><h3 id="day-4">【7.11】 Day 4</h3><p>被闹钟闹醒了，困困困，困困困。</p><p>上午听课，两个人讲课听起来都很舒服鸭，也不会很困。</p><p>一个是 lg，另一个是 QHJ 还是 pmh？昨天没来，不知道 QHJ长啥样，不知道是谁。</p><p>凸包进阶那块感觉理解还差一点，计算几何我认为结合代码来学理论才能有更深的理解。</p><p>圆这部分同样，听能听懂，但代码就不知道怎么写了，后面还要自己摸索一下。</p><p>11 点不到就结束了。</p><p>中午在朝阳吃 ￥16水煮牛肉，本来想打四星，但肉不过瘾，那就三星半。</p><p>回去没补例题，去做昨天队内赛的 C了，一个多小时调不出来，红温了，睡了半小时。</p><hr /><p>下午队内赛 2，我怎么又寄了。5/8（Rank 9）</p><p>开完两道究极签到，然后看了眼榜，有人过 D 了，就去看了D，然后我怎么就看了一个半小时。</p><p>怎么大家都会 D，自闭了。一开始想的是也许构造一个 <spanclass="math inline">\(2 \times 2\)</span>的就可以。然后脑子烧了，绕来绕去的。</p><p>过了一个小时才想到研究一下样例，感觉 <spanclass="math inline">\(2\times 3\)</span> 可行，就是从 <spanclass="math inline">\((1, 1)\)</span> 到 <spanclass="math inline">\((2,2)\)</span> 决策的时候选择错误的 <spanclass="math inline">\((2,1)\)</span> 而不是 <spanclass="math inline">\((1,2)\)</span>，但脑子又烧了。</p><p>看了下榜，怎么就到第二页了，急了。</p><p>去看了 E 和 F，E马上能注意到满足条件的是一个矩形，但后面没想清楚就交，WA了两发，不过马上就想清楚了。F 秒了。</p><p>直到这会稍微冷静了才会了 D，唉。</p><p>又急了，排名还是拉跨，看了下C，但怎么只剩半小时了，乱交几发，不出意外过不了一点（ * * * 晚上￥26炙烤蟹柳寿司，好吃，四星。</p><p>然后继续和昨天队内赛 C 搏斗，搏斗完怎么九点了？？？？？</p><p>一想到还有好多工作没做就难受。</p><hr /><div class="note note-info">            <p>【队内赛 1C - gym104022 D. Farm】</p><p>题意：给定一个 <span class="math inline">\(n\)</span>个点的图，一开始没有边。再给定 <span class="math inline">\(m\)</span>条边，边有边权，意为联通代价。你需要花最少的代价让图联通，同时必须满足<span class="math inline">\(q\)</span> 个限制条件。第 <spanclass="math inline">\(i\)</span> 个条件形如从编号为 <spanclass="math inline">\(u_i\)</span> 和 <spanclass="math inline">\(v_i\)</span>的边中至少选择一条。输出最小代价。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<spanclass="math inline">\(1 \le m \le 5 \cdot 10^5\)</span>，<spanclass="math inline">\(0 \le q\le 16\)</span>。</p>          </div><div class="note note-success">            <p>看 <span class="math inline">\(q\)</span>范围知二进制枚举，此时直接枚举边做最小生成树，是 <spanclass="math inline">\(O(2^q \cdot q\cdot m\alpha)\)</span>。</p><p>瓶颈是枚举的边太多了，可以想象 <span class="math inline">\(q\)</span>既然小，那么在最后的生成树中一定有很多边是确定的，不受限制条件的约束。</p><p>考虑将所有限制条件中的边（即每一个 <spanclass="math inline">\(u_i\)</span> 和每一个 <spanclass="math inline">\(v_i\)</span>）都建出来，然后跑最小生成树，此时新建出来的边（以下称作固定边）就是必须要选的。</p><p>那我们继续考虑一个只有固定边的新图 <spanclass="math inline">\(G\)</span>，此时需要枚举的边是 “两个端点在 <spanclass="math inline">\(G\)</span>中不连通的边”。用一个可持久化并查集执行每次加边，到新的二进制状态就回退，能过吗？还是不能，因为边还是太多了，如果每一个孤立点都和其它所有点连边，就是<span class="math inline">\(O(nq)\)</span> 的边。</p><p>但我们注意到除了孤立点以外的 <span class="math inline">\(G\)</span>是一个大的连通块，我们用一个 <code>std::map</code>存联通任意两个连通块的最小边，这样边数就是 <spanclass="math inline">\(O(q^2)\)</span> 的了。</p><p>时间复杂度 <span class="math inline">\(O(m\log m+2^q \cdotq^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; ver;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<span class="hljs-built_in">iota</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);siz.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;ver.<span class="hljs-built_in">push_back</span>(&#123;x, y, siz[x]&#125;);siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">roll</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<span class="hljs-keyword">while</span> (ver.<span class="hljs-built_in">size</span>() &gt; v) &#123;<span class="hljs-keyword">auto</span> [x, y, szx] = ver.<span class="hljs-built_in">back</span>();ver.<span class="hljs-built_in">pop_back</span>();f[y] = y;siz[x] = szx;&#125;&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; a;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y, w;cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;a.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);&#125;<span class="hljs-type">int</span> q;cin &gt;&gt; q;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; choose;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">have_choosed</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;x--; y--;choose.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);have_choosed[x] = <span class="hljs-literal">true</span>;have_choosed[y] = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-keyword">if</span> (have_choosed[i]) &#123;dsu.<span class="hljs-built_in">merge</span>(a[i][<span class="hljs-number">1</span>], a[i][<span class="hljs-number">2</span>]);&#125;&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; sorted_a = a;<span class="hljs-built_in">sort</span>(sorted_a.<span class="hljs-built_in">begin</span>(), sorted_a.<span class="hljs-built_in">end</span>());vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; must_choose;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : sorted_a) &#123;<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">merge</span>(x, y)) &#123;must_choose.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);&#125;&#125;<span class="hljs-function">DSU <span class="hljs-title">dsu2</span><span class="hljs-params">(n)</span></span>; <span class="hljs-type">int</span> ori_w = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : must_choose) &#123;dsu<span class="hljs-number">2.</span><span class="hljs-built_in">merge</span>(x, y);ori_w += w;&#125;<span class="hljs-type">int</span> ori_ver = dsu<span class="hljs-number">2.</span>ver.<span class="hljs-built_in">size</span>(); map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; minw;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; waiting_choose;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : sorted_a) &#123;<span class="hljs-type">int</span> xx = dsu<span class="hljs-number">2.f</span>ind(x);<span class="hljs-type">int</span> yy = dsu<span class="hljs-number">2.f</span>ind(y);<span class="hljs-keyword">if</span> (xx == yy) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (!minw.<span class="hljs-built_in">count</span>(&#123;xx, yy&#125;)) &#123;minw[&#123;xx, yy&#125;] = minw[&#123;yy, xx&#125;] = w;waiting_choose.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);&#125;&#125;<span class="hljs-type">int</span> ans = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; q); i++) &#123;dsu<span class="hljs-number">2.</span><span class="hljs-built_in">roll</span>(ori_ver);<span class="hljs-type">int</span> res = ori_w;unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; q; j++) &#123;<span class="hljs-type">int</span> edge = choose[j][i &gt;&gt; j &amp; <span class="hljs-number">1</span>];<span class="hljs-keyword">if</span> (mp[edge]) &#123;<span class="hljs-keyword">continue</span>;&#125;mp[edge] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">auto</span> [w, x, y] = a[edge];dsu<span class="hljs-number">2.</span><span class="hljs-built_in">merge</span>(x, y);res += w;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : waiting_choose) &#123;<span class="hljs-keyword">if</span> (dsu<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) == n) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (dsu<span class="hljs-number">2.</span><span class="hljs-built_in">merge</span>(x, y)) &#123;res += w;&#125;&#125;<span class="hljs-keyword">if</span> (dsu<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) == n) &#123;ans = <span class="hljs-built_in">min</span>(ans, res);&#125;&#125;<span class="hljs-keyword">if</span> (ans == inf) &#123;ans = <span class="hljs-number">-1</span>;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><p>今天的队内赛明天再补好了，明天又是字符串专题，上次字符串专题还没搞懂一点。</p><p>写了下 AC 自动机课件上的五个例题。</p><hr /><div class="note note-info">            <p>【P5357 【模板】AC 自动机】</p><p>题意：给定一个文本串 <span class="math inline">\(S\)</span> 和 <spanclass="math inline">\(n\)</span> 个模式串 <spanclass="math inline">\(T_{1\simn}\)</span>。求每个模式串在文本串中的出现次数。</p><p><span class="math inline">\(1 \le n,\sum|T| \le 2\cdot10^5\)</span>，<span class="math inline">\(1\le |S| \le 2\cdot10^6\)</span>。</p>          </div><div class="note note-success">            <p>AC 自动机上 fail 指针指向的是最长真后缀。fail 指针构成一棵树。</p><p>那么当一个节点被匹配时，其祖先也被匹配。相当于每次将根到某个单词末尾的一条链上的点+1。</p><p>可以在树上维护 <code>sz[x]</code>，给 <spanclass="math inline">\(S\)</span> 对应的链上的点<code>sz[x]++</code>。</p><p>那么单词末尾对应的节点的 <code>sz</code>就是它在文本串中的出现次数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">26</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> len, fail;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : len&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">ACTree</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);t[<span class="hljs-number">0</span>].len = <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].len = t[p].len + <span class="hljs-number">1</span>;&#125;p = t[p].nxt[x];&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;t[x].nxt[i] = t[t[x].fail].nxt[i];&#125; <span class="hljs-keyword">else</span> &#123;t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fail;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].len;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;ACTree G;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;cin &gt;&gt; s;id[i] = G.<span class="hljs-built_in">add</span>(s);&#125;G.<span class="hljs-built_in">work</span>();string t;cin &gt;&gt; t;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-type">int</span> x = t[i] - <span class="hljs-string">&#x27;a&#x27;</span>;p = G.<span class="hljs-built_in">next</span>(p, x);sz[p]++;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);sz[x] += sz[y];&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cout &lt;&lt; sz[id[i]] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// fre(test);</span>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P3966 [TJOI2013] 单词】</p><p>题意：给定 <span class="math inline">\(n\)</span>个单词，对每个单词询问在这 <span class="math inline">\(n\)</span>个单词组成的文章中出现了多少次。</p><p>例如给定 <code>a</code> <code>aa</code><code>aaa</code>，则第二个单词出现了 <spanclass="math inline">\(3\)</span> 遍。</p><p><span class="math inline">\(1 \le n \le 200\)</span>，$ 单词总长度^6$。</p>          </div><div class="note note-success">            <p>看了样例才读明白题。</p><p>和 AC 自动机模板的区别就是单词之间不能跨越。</p><p>那我们直接在中间插一个特殊字符就行了，其它都一样。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">27</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> len, fail;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : len&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">ACTree</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);t[<span class="hljs-number">0</span>].len = <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].len = t[p].len + <span class="hljs-number">1</span>;&#125;p = t[p].nxt[x];&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;t[x].nxt[i] = t[t[x].fail].nxt[i];&#125; <span class="hljs-keyword">else</span> &#123;t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fail;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].len;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;string t = <span class="hljs-string">&quot;&quot;</span>;ACTree G;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;string s;cin &gt;&gt; s;t += s + <span class="hljs-string">&quot;@&quot;</span>;id[i] = G.<span class="hljs-built_in">add</span>(s);&#125;G.<span class="hljs-built_in">work</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-type">int</span> x = t[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span> (t[i] == <span class="hljs-string">&#x27;@&#x27;</span>) &#123;x = <span class="hljs-number">26</span>;&#125;p = G.<span class="hljs-built_in">next</span>(p, x);sz[p]++;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);sz[x] += sz[y];&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cout &lt;&lt; sz[id[i]] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P2414 [NOI2011] 阿狸的打字机】</p><p>题意：给定一个含 <span class="math inline">\(a\sim z,B,P\)</span>的字符串 <span class="math inline">\(T\)</span>，现按规则生成字符串集合<span class="math inline">\(S\)</span>：</p><ul><li><p>有一个 Cache，初始为空，开始从左到右读取 <spanclass="math inline">\(T\)</span> 中字符。</p></li><li><p>若读取到 <span class="math inline">\(a\sim z\)</span>，在 Cache中加入相应字符。</p></li><li><p>若读取到 <span class="math inline">\(P\)</span>，将 Cache中的字符串拷贝一份到 <span class="math inline">\(S\)</span>中。</p></li><li><p>若读取到 <span class="math inline">\(B\)</span>，删除 Cache中最后一次加入的字符。</p></li></ul><p>给定 <span class="math inline">\(m\)</span> 个询问，每次给定 <spanclass="math inline">\(x, y\)</span>，询问 <spanclass="math inline">\(S\)</span> 中的第 <spanclass="math inline">\(x\)</span> 个字符串在第 <spanclass="math inline">\(y\)</span> 个字符串中出现了几次。</p><p><span class="math inline">\(1 \le x, y \le 10^5\)</span>，<spanclass="math inline">\(1 \le m \le 10^5\)</span>，<spanclass="math inline">\(1 \le |T| \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>暴力是对于每一个询问都建 AC 自动机并询问。</p><p>进阶一点可以对于相同的 <span class="math inline">\(y\)</span>记录所有的 <spanclass="math inline">\(x\)</span>，这样是一次建树多次询问。</p><p>这里的 “建树” 是指给字符串 <span class="math inline">\(y\)</span> 在fail 树上对应的链设置 <code>sz</code>。</p><p>还可以更聪明一点，我们思考 <span class="math inline">\(P\)</span>操作和 <span class="math inline">\(B\)</span> 操作的本质： * <spanclass="math inline">\(P\)</span> 操作拷贝了一份Cache，但迫于空间限制我们肯定不能显式储存，于是只储存该字符串的endpos。</p><ul><li><span class="math inline">\(B\)</span> 操作 “退格”相当于将当前指针移动到父亲节点的位置。</li></ul><p>这样我们就可以像读取一般字符串一样读取 <spanclass="math inline">\(T\)</span> 了！</p><p>将 <span class="math inline">\(T\)</span> 放到 AC 自动机上跑，对于<span class="math inline">\(a\sim z\)</span> 就直接<code>sz[p]++</code>，删除操作就 <code>sz[p]--</code>。</p><p>对于询问，我们知道endpos，相当于子树求和，而上一行的两个操作相当于单点加，就有用树状数组维护<code>sz</code> 的思路了。对着 fail 树进行 dfs，记录 dfn 即可。</p><p>时间复杂度 <span class="math inline">\(O(|T|+m)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fenwick</span> &#123;<span class="hljs-type">int</span> n;vector&lt;T&gt; tr;<span class="hljs-built_in">Fenwick</span>() &#123;&#125;<span class="hljs-built_in">Fenwick</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;n = n;tr.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, (T)&#123;&#125;);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, T x)</span> </span>&#123;<span class="hljs-keyword">while</span> (pos &lt;= n) &#123;tr[pos] += x;pos += pos &amp; -pos;&#125;&#125;<span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;T res = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (pos) &#123;res += tr[pos];pos -= pos &amp; -pos;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>);&#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">26</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> fa, fail;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;vector&lt;<span class="hljs-type">int</span>&gt; endpos;<span class="hljs-built_in">ACTree</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;P&#x27;</span>) &#123;endpos.<span class="hljs-built_in">push_back</span>(p);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;p = t[p].fa;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();t[t[p].nxt[x]].fa = p;&#125;p = t[p].nxt[x];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;t[x].nxt[i] = t[t[x].fail].nxt[i];&#125; <span class="hljs-keyword">else</span> &#123;t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fail;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fa;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;string t;cin &gt;&gt; t;ACTree G;G.<span class="hljs-built_in">add</span>(t);G.<span class="hljs-built_in">work</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span>, <span class="hljs-title">dfn</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;dfn[x] = ++tim;sz[x] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-built_in">self</span>(self, y);sz[x] += sz[y];&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);<span class="hljs-type">int</span> m;cin &gt;&gt; m;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">qry</span>(G.endpos.<span class="hljs-built_in">size</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;x--; y--;qry[y].<span class="hljs-built_in">push_back</span>(&#123;x, i&#125;);&#125;<span class="hljs-function">Fenwick&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fen</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>, tot = <span class="hljs-number">-1</span>, i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-keyword">if</span> (t[i] == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;fen.<span class="hljs-built_in">add</span>(dfn[p], <span class="hljs-number">-1</span>);p = G.<span class="hljs-built_in">fa</span>(p);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[i] != <span class="hljs-string">&#x27;P&#x27;</span>) &#123;p = G.<span class="hljs-built_in">next</span>(p, t[i] - <span class="hljs-string">&#x27;a&#x27;</span>);fen.<span class="hljs-built_in">add</span>(dfn[p], <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> &#123;tot++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [id, qid] : qry[tot]) &#123;<span class="hljs-type">int</span> x = G.endpos[id];ans[qid] = fen.<span class="hljs-built_in">query</span>(dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【P2444 [POI2000] 病毒】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(01\)</span> 串，问是否存在一个无限长的 <spanclass="math inline">\(01\)</span> 串不包含任何一个给定的 <spanclass="math inline">\(01\)</span> 串作为子串。</p><p><span class="math inline">\(1 \le n \le 2000\)</span>，<spanclass="math inline">\(1\le \sum|S| \le 3\cdot 10^4\)</span>。</p>          </div><div class="note note-success">            <p>假定存在这么一个无限长的 <span class="math inline">\(01\)</span>串，记作 <span class="math inline">\(T\)</span>。</p><p>那么把 <span class="math inline">\(T\)</span> 放到这 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(01\)</span> 串构成的 AC自动机上跑，一定是不断失配，并且跳 fail 指针跳到的点不在任何 endpos的子树中。</p><p>为此，我们把所有的 endpos 及其子树都标记为危险节点。具体的，bfs 构建fail 指针的时候，如果 fail指针指向的点（最长后缀）是危险节点，那么当前节点就标记为危险。</p><p>因为是无限，所以指针肯定是在一个不存在危险节点的环上绕圈。</p><p>在 next 指针上跑 dfs 找环即可，注意避开危险节点。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">2</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> end, fail;array&lt;<span class="hljs-type">int</span>, S&gt; nxt;<span class="hljs-built_in">Node</span>() : end&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;&#125;;vector&lt;Node&gt; t;<span class="hljs-built_in">ACTree</span>() &#123;t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;t.<span class="hljs-built_in">emplace_back</span>();<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();&#125;p = t[p].nxt[x];&#125;t[p].end = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;t[x].nxt[i] = t[t[x].fail].nxt[i];&#125; <span class="hljs-keyword">else</span> &#123;t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];<span class="hljs-keyword">if</span> (t[t[t[x].nxt[i]].fail].end) &#123;t[t[x].nxt[i]].end = <span class="hljs-literal">true</span>;&#125;q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].nxt[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].fail;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isend</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-keyword">return</span> t[p].end;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;ACTree G;<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; s[i];G.<span class="hljs-built_in">add</span>(s[i]);&#125;G.<span class="hljs-built_in">work</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(G.size())</span>, <span class="hljs-title">circle</span><span class="hljs-params">(G.size())</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">int</span> &#123;circle[x] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : &#123;G.<span class="hljs-built_in">next</span>(x, <span class="hljs-number">0</span>), G.<span class="hljs-built_in">next</span>(x, <span class="hljs-number">1</span>)&#125;) &#123;<span class="hljs-keyword">if</span> (circle[y]) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (vis[y] || G.<span class="hljs-built_in">isend</span>(y)) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[y] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>(self, y)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;circle[x] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>)) &#123;cout &lt;&lt; <span class="hljs-string">&quot;TAK\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;NIE\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>还有一题，但是太难了，我先放着。</p><h3 id="day-5">【7.12】 Day 5</h3><p>醒了，下床，趴桌上继续睡。</p><p>上午按安排徐神讲后缀数组，包大爷讲后缀自动机。因为听起来就高级，我也没接触过，所以打起了十二分精神捏。</p><p>先讲后缀数组，刚开始听觉得很有道理，但怎么逐渐听不懂了。也不算逐渐，就徐神讲怎么从长度为<span class="math inline">\(d\)</span> 扩展到长度为 <spanclass="math inline">\(2d\)</span> 的时候就懵了（</p><p>感觉再听听就懂了，就没问，结果一直懵，懵到最后我不好意思让徐神重新讲了QAQ。</p><p>我认为也许是后缀数组本身就很难不容易讲明白。</p><p>后面讲后缀自动机我状态就好多了，包大爷发音清晰思维缜密我坐第一排<del>看着它真是大帅辣</del>听它讲真是幸福捏。</p><p>中午朝阳￥15 可乐鸡饭，很牛啊，4星。这个默认给你的饭很少，下次得向阿姨要多一点。</p><p>回到宿舍水了下群直接睡了。以往中午我都不怎么睡，但可能昨晚睡比较晚？</p><hr /><p>下午第三次队内赛，我怎么又白给了。4/8（Rank16）</p><p>一个小时开了 ABI，然后怎么 C 又坐牢了鸭。</p><p>不能算坐牢，这个是刚开始就有思路，但写了一坨还调不对（</p><p>wa5，wa6，wa10，tle61…</p><p>唉，没想清楚导致的。</p><p>D 红晕了，上手就搞了个 <spanclass="math inline">\(\text{dp[2][N]}\)</span>，我在写什么？？？？</p><p>赛后发现 D 和 F 都是 ez，前者一个 dfs，后者直接把差值扔进优先队列。<ahref="https://codeforces.com/gym/535326/submission/270158995">Link-D</a><ahref="https://codeforces.com/gym/535326/submission/270160661">Link-F</a></p><p>这下遥遥落后了。</p><p>更自卑了。想似，就这样吧，说不定我的实力真的止于 div2C 了。</p><hr /><p>晚上没吃。</p><div class="note note-info">            <p>【队内赛 3E - CF406D. Hill Climbing】</p><p>题意：有 <span class="math inline">\(n\)</span> 座山，第 <spanclass="math inline">\(i\)</span> 座山山顶在 <spanclass="math inline">\((x_i,y_i)\)</span>。如果两个人站在两座山的山顶可以互相看到，则这两座山之间有绳子连接。有<span class="math inline">\(m\)</span>支队伍，每队有两个人，每个人都可以通过绳子到达直连的最右边的山顶。现给定每支队伍两个人初始所在的山的编号<span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>，问他们在哪座山的山顶相遇。</p><p><span class="math inline">\(1 \le n,m \le 10^5\)</span>，<spanclass="math inline">\(1 \le x_i \le10^7\)</span>，<spanclass="math inline">\(1 \le y_i \le 10^{11}\)</span>。</p>          </div><div class="note note-success">            <p>题图画的很清楚，因为选的是尽可能往后连的绳子，所以两个人通过绳子攀爬的路径都是凸的。</p><p>换言之，每座山选择向右到达的山的编号（*）是唯一的，连边能构成一棵树。</p><p>那么答案就是两个人所在点的 LCA。</p><p>（*）可以在求上凸包的过程中处理出来，即栈顶编号。</p><p>时间复杂度 <span class="math inline">\(O(n\log n+m\logn)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    <span class="hljs-type">int</span> x, y;    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;&#125;;<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;    <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;&#125;Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(a.x + b.x, a.y + b.y);&#125;Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(a.x - b.x, a.y - b.y);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cross</span><span class="hljs-params">(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getUpHull</span><span class="hljs-params">(vector&lt;Point&gt; p)</span> </span>&#123;    <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">size</span>();    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n)</span></span>;    vector&lt;<span class="hljs-type">int</span>&gt; h;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;    <span class="hljs-keyword">while</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">cross</span>(p[i] - p[h.<span class="hljs-built_in">back</span>()], p[i] - p[h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]]) &gt; <span class="hljs-number">0</span>) &#123;            h.<span class="hljs-built_in">pop_back</span>();        &#125;        <span class="hljs-keyword">if</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;        nxt[i] = h.<span class="hljs-built_in">back</span>();        &#125; <span class="hljs-keyword">else</span> &#123;        nxt[i] = n - <span class="hljs-number">1</span>;        &#125;        h.<span class="hljs-built_in">push_back</span>(i);    &#125;    <span class="hljs-keyword">return</span> nxt;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;Point&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;a[i] = &#123;x, y&#125;;&#125;vector&lt;<span class="hljs-type">int</span>&gt; nxt = <span class="hljs-built_in">getUpHull</span>(a);vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;adj[nxt[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(i);&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fa</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>, <span class="hljs-number">0</span>));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;fa[x][<span class="hljs-number">0</span>] = fath;dep[x] = dep[fath] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= __lg(dep[x]) + <span class="hljs-number">1</span>; i++) &#123;fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y != fath) &#123;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;<span class="hljs-keyword">while</span> (dep[x] &gt; dep[y]) &#123;x = fa[x][__lg(dep[x] - dep[y])];&#125;<span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(dep[x]); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i]) &#123;x = fa[x][i];y = fa[y][i];&#125;&#125;<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];&#125;;<span class="hljs-built_in">dfs</span>(dfs, n, <span class="hljs-number">0</span>);<span class="hljs-type">int</span> m;cin &gt;&gt; m;<span class="hljs-keyword">while</span> (m--) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;cout &lt;&lt; <span class="hljs-built_in">LCA</span>(x, y) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>剩下一个 G，本来不想写的，但题解的做法让人称奇道妙。</p><p>但一个多小时了还有几处细节想不清楚，先欠着。</p><p>昨天的队内赛还没补，那就补两题。</p><hr /><div class="note note-info">            <p>【队内赛 2C - CF337D. Book of Evil】</p><p>题意：给定一棵 <span class="math inline">\(n\)</span>个节点的树，树上有 <span class="math inline">\(m\)</span>个关键点，点集设为 <spanclass="math inline">\(S\)</span>。再给定一个整数 <spanclass="math inline">\(d\)</span>，求满足 <spanclass="math inline">\(\forall i\in S,\ \text{dis}(x,i)\le d\)</span>的节点 <span class="math inline">\(x\)</span> 的个数。</p><p><span class="math inline">\(1 \le m\le n\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>对于每个点判断离它半径为 <span class="math inline">\(d\)</span>的范围内是否有 <span class="math inline">\(m\)</span> 个关键点。</p><p>将关键点权值设为 <span class="math inline">\(1\)</span>，其余为 <spanclass="math inline">\(0\)</span>。就变成了以某个点为中心的范围权值和。</p><p>点分树即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mx = <span class="hljs-number">5e6</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;    <span class="hljs-type">int</span> sum;    Node *ch[<span class="hljs-number">2</span>];&#125; node[mx]; <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;    Node *rt;    <span class="hljs-built_in">SegmentTree</span>() &#123;    rt = <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-function">Node *<span class="hljs-title">New</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> &amp;node[cnt++];    &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node *&amp;p, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (!p) &#123;p = <span class="hljs-built_in">New</span>();&#125;<span class="hljs-keyword">if</span> (l == r) &#123;p-&gt;sum += val;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;<span class="hljs-built_in">add</span>(p-&gt;ch[<span class="hljs-number">0</span>], pos, val, l, mid);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">add</span>(p-&gt;ch[<span class="hljs-number">1</span>], pos, val, mid + <span class="hljs-number">1</span>, r);&#125;p-&gt;sum = (p-&gt;ch[<span class="hljs-number">0</span>] ? p-&gt;ch[<span class="hljs-number">0</span>]-&gt;sum : <span class="hljs-number">0</span>) +  (p-&gt;ch[<span class="hljs-number">1</span>] ? p-&gt;ch[<span class="hljs-number">1</span>]-&gt;sum : <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node *p, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (!p) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (l == ql &amp;&amp; r == qr) &#123;<span class="hljs-keyword">return</span> p-&gt;sum;&#125;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (qr &lt;= mid) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">0</span>], ql, qr, l, mid);&#125;<span class="hljs-keyword">if</span> (ql &gt; mid) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">1</span>], ql, qr, mid + <span class="hljs-number">1</span>, r);&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">0</span>], ql, mid, l, mid) +    <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">1</span>], mid + <span class="hljs-number">1</span>, qr, mid + <span class="hljs-number">1</span>, r);&#125;;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, d;cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[x] = <span class="hljs-number">1</span>;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">st</span>(<span class="hljs-number">18</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">lg2</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;dep[x] = dep[fath] + <span class="hljs-number">1</span>;st[<span class="hljs-number">0</span>][++tim] = x;id[x] = tim;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y != fath) &#123;<span class="hljs-built_in">self</span>(self, y, x);st[<span class="hljs-number">0</span>][++tim] = x;&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> Lower = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">return</span> dep[x] &lt; dep[y] ? x : y;&#125;;<span class="hljs-keyword">auto</span> getST = [&amp;] () &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= tim; i++) &#123;lg2[i] = lg2[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= tim; i++) &#123;<span class="hljs-type">int</span> w = (<span class="hljs-number">1</span> &lt;&lt; i);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j + w - <span class="hljs-number">1</span> &lt;= tim; j++) &#123;st[i][j] = <span class="hljs-built_in">Lower</span>(st[i - <span class="hljs-number">1</span>][j], st[i - <span class="hljs-number">1</span>][j + w / <span class="hljs-number">2</span>]);&#125;&#125;&#125;;<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;x = id[x];y = id[y];<span class="hljs-keyword">if</span> (x &gt; y) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;<span class="hljs-type">int</span> i = lg2[y - x + <span class="hljs-number">1</span>];<span class="hljs-keyword">return</span> <span class="hljs-built_in">Lower</span>(st[i][x], st[i][y - (<span class="hljs-number">1</span> &lt;&lt; i) + <span class="hljs-number">1</span>]);&#125;;<span class="hljs-keyword">auto</span> dist = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">return</span> dep[x] + dep[y] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">LCA</span>(x, y)];&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-built_in">getST</span>();<span class="hljs-type">int</span> all = n, rt = <span class="hljs-number">-1</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mx</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> getsz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;        sz[x] = <span class="hljs-number">1</span>;        mx[x] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;            <span class="hljs-keyword">if</span> (y == fa || vis[y]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-built_in">self</span>(self, y, x);            sz[x] += sz[y];            mx[x] = <span class="hljs-built_in">max</span>(mx[x], sz[y]);        &#125;        mx[x] = <span class="hljs-built_in">max</span>(mx[x], all - sz[x]);        <span class="hljs-keyword">if</span> (mx[x] &lt; mx[rt]) &#123;            rt = x;        &#125;    &#125;;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dsz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dfa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">auto</span> dfz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;    vis[x] = <span class="hljs-literal">true</span>;    dsz[x] = all;    dfa[x] = fa;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;    <span class="hljs-keyword">if</span> (y == fa || vis[y]) &#123;    <span class="hljs-keyword">continue</span>;    &#125;    all = sz[y];            mx[rt = <span class="hljs-number">0</span>] = inf;            <span class="hljs-built_in">getsz</span>(getsz, y, x);            <span class="hljs-built_in">getsz</span>(getsz, rt, <span class="hljs-number">0</span>);            <span class="hljs-built_in">self</span>(self, rt, x);    &#125;    &#125;;    mx[rt = <span class="hljs-number">0</span>] = inf;    <span class="hljs-built_in">getsz</span>(getsz, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">getsz</span>(getsz, rt, <span class="hljs-number">0</span>);    <span class="hljs-built_in">dfz</span>(dfz, rt, <span class="hljs-number">0</span>);    <span class="hljs-function">vector&lt;SegmentTree&gt; <span class="hljs-title">seg1</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">seg2</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">auto</span> Add = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val) -&gt; <span class="hljs-type">void</span> &#123;    <span class="hljs-type">int</span> now = x;    <span class="hljs-keyword">while</span> (now) &#123;    <span class="hljs-type">int</span> fa = dfa[now];    seg1[now].<span class="hljs-built_in">add</span>(seg1[now].rt, <span class="hljs-built_in">dist</span>(now, x), val, <span class="hljs-number">0</span>, dsz[now]);    <span class="hljs-keyword">if</span> (fa) &#123;    seg2[now].<span class="hljs-built_in">add</span>(seg2[now].rt, <span class="hljs-built_in">dist</span>(fa, x), val, <span class="hljs-number">0</span>, dsz[fa]);    &#125;    now = fa;    &#125;    &#125;;    <span class="hljs-keyword">auto</span> Query = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k) -&gt; <span class="hljs-type">int</span> &#123;    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> now = x, lst = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (now) &#123;    <span class="hljs-type">int</span> dt = <span class="hljs-built_in">dist</span>(now, x);    <span class="hljs-keyword">if</span> (dt &gt; k) &#123;    lst = now;    now = dfa[now];    <span class="hljs-keyword">continue</span>;    &#125;    res += seg1[now].<span class="hljs-built_in">query</span>(seg1[now].rt, <span class="hljs-number">0</span>, k - dt, <span class="hljs-number">0</span>, dsz[now]);    <span class="hljs-keyword">if</span> (lst) &#123;    res -= seg2[lst].<span class="hljs-built_in">query</span>(seg2[lst].rt, <span class="hljs-number">0</span>, k - dt, <span class="hljs-number">0</span>, dsz[now]);    &#125;    lst = now;    now = dfa[now];    &#125;    <span class="hljs-keyword">return</span> res;    &#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">if</span> (a[i]) <span class="hljs-built_in">Add</span>(i, a[i]);    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    ans += <span class="hljs-built_in">Query</span>(i, d) == m;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>但这题显然有更简单的结论做法。</p><p>类比树的直径的性质：距离树上任意一点最远的点一定是直径两个端点中的一个。</p><p>可以得到结论：距离树上任意一点最远的关键点一定是“树上距离最远的两个关键点” 中的一个。</p><p>证明需要分类讨论，见 <ahref="https://www.luogu.com.cn/article/bqixrrho">Link</a>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, d;cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-keyword">auto</span> getdis = [&amp;] (<span class="hljs-type">int</span> rt) &#123;vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">dis</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;dis[x] = dis[fa] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;dis[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> dis;&#125;;vector&lt;<span class="hljs-type">int</span>&gt; dis1 = <span class="hljs-built_in">getdis</span>(<span class="hljs-number">1</span>);<span class="hljs-type">int</span> ml = <span class="hljs-number">0</span>, mr = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> mxdis = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<span class="hljs-keyword">if</span> (dis1[x] &gt; mxdis) &#123;mxdis = dis1[x];ml = x;&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; dis2 = <span class="hljs-built_in">getdis</span>(ml);mxdis = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<span class="hljs-keyword">if</span> (dis2[x] &gt; mxdis) &#123;mxdis = dis2[x];mr = x;&#125;&#125;dis1 = <span class="hljs-built_in">getdis</span>(mr);<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (dis1[i] &lt;= d &amp;&amp; dis2[i] &lt;= d) &#123;ans++;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>上面两种方法一个写起来复杂，一个取巧，那么还有一个比较套路的换根 dp做法。</p><p>我们钦定 <span class="math inline">\(i\)</span> 为根，定义 <spanclass="math inline">\(dp_{i,0/1}\)</span>。</p><ul><li><p><span class="math inline">\(dp_{i,0}\)</span> 代表 <spanclass="math inline">\(i\)</span> 离与它最远的关键点 <spanclass="math inline">\(j\)</span> 之间的距离，即最后答案。</p></li><li><p><span class="math inline">\(dp_{i,1}\)</span> 代表除 <spanclass="math inline">\(j\)</span> 所在的 <spanclass="math inline">\(i\)</span> 的子树外，与 <spanclass="math inline">\(i\)</span> 距离最远的关键点和 <spanclass="math inline">\(i\)</span> 之间的距离。</p></li></ul><p>第一次以 <span class="math inline">\(1\)</span> 为根进行 dfs，同时<span class="math inline">\(fr_i\)</span> 记录 <spanclass="math inline">\(dp_{i,0}\)</span> 从哪个节点转移而来：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, -inf))</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">from</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (a[x]) &#123;dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);<span class="hljs-type">int</span> t = dp[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>] = t;from[x] = y;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = t;&#125;&#125;&#125;;</code></pre></div><p>此时的 <span class="math inline">\(dp_{i}\)</span> 从节点 <spanclass="math inline">\(1\)</span> 辐向 <spanclass="math inline">\(i\)</span> 的一侧拥有符合上述意义的答案。</p><p>考虑换根，从 <span class="math inline">\(fa\to x\)</span>，根据 <spanclass="math inline">\(fr_{fa}\)</span> 是否等于 <spanclass="math inline">\(x\)</span>，选择 <spanclass="math inline">\(dp_{fa,0}\)</span> 或 <spanclass="math inline">\(dp_{fa,1}\)</span> 进行转移。</p><p>记得此时更新 <span class="math inline">\(dp_{x,0}\)</span>时也要同步更新 <span class="math inline">\(fr_x\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">int</span> t;<span class="hljs-keyword">if</span> (from[fa] != x) &#123;t = dp[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;t = dp[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>] = t;from[x] = fa;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = t;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x); &#125;&#125;;C++</code></pre></div><p>不理解可以模拟一下题目的样例，以及将节点 <spanclass="math inline">\(4\)</span> 也变为关键点的情况。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, d;cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x;cin &gt;&gt; x;a[x] = <span class="hljs-number">1</span>;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, -inf))</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">from</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">if</span> (a[x]) &#123;dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);<span class="hljs-type">int</span> t = dp[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>] = t;from[x] = y;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = t;&#125;&#125;&#125;;<span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">int</span> t;<span class="hljs-keyword">if</span> (from[fa] != x) &#123;t = dp[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;t = dp[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>] = t;from[x] = fa;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>] = t;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x); &#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[<span class="hljs-number">1</span>]) &#123;<span class="hljs-built_in">dfs2</span>(dfs2, y, <span class="hljs-number">1</span>);&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (dp[i][<span class="hljs-number">0</span>] &lt;= d) &#123;ans++;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><hr /><p>还有一题但是点分树折磨了我两个小时，我要睡觉了。</p><p>骗自己罢了，不眠之夜。</p><h3 id="day-6">【7.13】 Day 6</h3><p>雨一直下。</p><h3 id="day-7">【7.14】 Day 7</h3><p>雨一直下。</p><p>晚上躺在床上突然想通了什么，伟大的一步。</p><p>晚上快 22 点多了才下床，笔记本充电器不知道去哪了，应该是在234。骑车过去拿，但灯都黑了，无功而返，跟 xxx 借了一个。</p><p>0 点 35，vp 了昨天的 abc，6/7，G 把板子喂到嘴里了。</p><p>就 F 有点意思，写一下。</p><hr /><div class="note note-info">            <p>题意：给定一棵 <span class="math inline">\(n\)</span> 个点的树，定义<span class="math inline">\(dis(x, y)\)</span> 为树上 <spanclass="math inline">\(x,y\)</span> 间的距离。有一个 <spanclass="math inline">\(n\)</span> 个点的完全图 <spanclass="math inline">\(G\)</span>，其中 <spanclass="math inline">\(w(x,y)=dis(x,y)\)</span>。求这个完全图的一个最大权匹配，输出匹配方案。</p><p><span class="math inline">\(2 \le n \le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>结论：令 <span class="math inline">\(c\)</span>为树的重心，则满足以下条件的匹配 <span class="math inline">\(S\)</span>为答案： * <span class="math inline">\(\forall (x_i,y_i)\inS\)</span>，<span class="math inline">\(x_i\)</span> 和 <spanclass="math inline">\(y_i\)</span> 位于重心两侧。</p>          </div><div class="note note-success">            <p>证明：拆贡献，令一条边两侧的点数为 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(n-a\)</span>，则该边的贡献为 <spanclass="math inline">\(\min(a,n-a)\)</span>。因为理想情况点少的这一侧的所有点都能跨过这条边寻找自己的匹配。那么答案的上界就是所有边的贡献和，即<span class="math inline">\(\sum\min(a,n-a)\)</span>。</p><p>对于重心 <span class="math inline">\(c\)</span>，我们令 <spanclass="math inline">\(e\)</span> 为以 <spanclass="math inline">\(c\)</span> 为根的某个子树中的某一条边，此时 <spanclass="math inline">\(e\)</span>的两侧中点比较少的一定是远离重心方向的这一侧。按照我们的理论，这一侧的点只要跨越了这条边寻找匹配就成功了，此时它们匹配了重心另一侧的点，满足条件。</p><p>不难发现对于以 <span class="math inline">\(c\)</span>为根的每一个子树中的所有边都满足上述条件，达到了贡献最大值，证毕。</p>          </div><div class="note note-success">            <p>于是我们可以进行如下构造： * 找到树的重心 <spanclass="math inline">\(c\)</span>，令 <spanclass="math inline">\(c\)</span> 的若干子树为 <spanclass="math inline">\(T_1,T_2,\cdots\)</span>。</p><ul><li><p>令数组 <span class="math inline">\(A=\{T_1 中点的编号,T_2中点的编号,\cdots\}\)</span>。</p></li><li><p>若 <span class="math inline">\(n\)</span> 为偶数，将 <spanclass="math inline">\(c\)</span> 补在 <spanclass="math inline">\(A\)</span> 的末尾。</p></li><li><p><span class="math inline">\(\foralli\in[0,\frac{n}{2})\)</span>，<spanclass="math inline">\((A_i,A_{i+\frac{n}{2}})\)</span> 为一个匹配。<spanclass="math inline">\((0-\text{index})\)</span></p></li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mx</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> rt = <span class="hljs-number">-1</span>;<span class="hljs-keyword">auto</span> getsz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;sz[x] = <span class="hljs-number">1</span>;mx[x] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);sz[x] += sz[y];mx[x] = <span class="hljs-built_in">max</span>(mx[x], sz[y]);&#125;mx[x] = <span class="hljs-built_in">max</span>(mx[x], n - sz[x]);<span class="hljs-keyword">if</span> (mx[x] &lt; mx[rt]) &#123;rt = x;&#125;&#125;;<span class="hljs-built_in">getsz</span>(getsz, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;a.<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);&#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;<span class="hljs-built_in">dfs</span>(dfs, x, rt);&#125;<span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;a.<span class="hljs-built_in">push_back</span>(rt);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[i + n / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><hr /><h3 id="day-8">【7.15】 Day 8</h3><p>10 点 30 的闹钟，10 点 28 醒了，正好提前两分钟下床等着关闹钟（</p><p>中午大伙一起去朝阳吃饭，点了个￥16叉烧鸡，很一般，两星半或者三星。</p><p>吃完到 234 打队内赛五。开始前几分钟发现<code>solved 1 of 11</code>，很乐，截个图发到了群里，然后发现大伙怎么都做过。结果比赛开始就被菜猫换掉了，虽然没换掉也是当成新题做的说。</p><hr /><p>开局直接 A上手，写着写着怎么不会了。看来以后写题还是得养成想好再动笔的习惯（后有伏笔</p><p>第一个小时开了四道签到，唉，爽！再看榜怎么大伙签得比我快这么多鸭。我主要是被那个字符串奇数位升序偶数位降序卡手了，后面灵机一动字母换成数字，然后偶数位取反。唉，差点就没签出来。</p><p>J 也是一眼，但怎么又开始 wa3，wa4 了。干脆直接跳转到F，这不是龙数吗，咔咔咔一顿码，样例忒弱，疯狂提交，最好的结果是tle6，自闭了。冷静分析了一下但感觉最多就是2log，更何况还有神秘的势能分析加持，怎么会事呢？</p><p>那干脆再跳转到 E，哎呀这不是每个点向直连的编号最小点连边吗，怎么wa9。红晕了。</p><p>中途发现 J 原来是有个 special 的情况，判掉就好了。E又一通交，终于发现自己连最小生成树都不会写了（</p><p>B 过了一堆，但我不是很懂。I 也过了一堆，怎么大伙都会构造。</p><p>6/11（Rank 23）收尾，蒸蒸日下了。</p><hr /><p>晚上回朝阳吃了个可乐鸡饭。</p><p>回宿舍本来想着洗个澡就回 234补题，但碰了床就想睡，就睡到了八点多。</p><p>洗完澡回到 234，补一题就差不多 CF 了。</p><hr /><div class="note note-info">            <p>【队内赛 5i. 唉，构造 - gym104160 F. Half Mixed】</p><p>题意：给定正整数 <spanclass="math inline">\(n,m\)</span>，你需要构造一个 <spanclass="math inline">\(n\times m\)</span> 的 <spanclass="math inline">\(01\)</span> 矩阵，使得纯子矩阵个数 <spanclass="math inline">\(=\)</span> 杂子矩阵个数。</p><p>纯子矩阵指内部只有 <span class="math inline">\(0\)</span> 或 <spanclass="math inline">\(1\)</span> 的矩阵。杂子矩阵指内部既有 <spanclass="math inline">\(0\)</span> 又有 <spanclass="math inline">\(1\)</span> 的矩阵。</p><p>输出构造方案或报告不存在。</p><p><span class="math inline">\(1\le n,m\le 10^6\)</span>，<spanclass="math inline">\(1\le \sum n\cdot m\le 5\cdot10^6\)</span>。</p>          </div><div class="note note-success">            <p>对于一个 <span class="math inline">\(1\times m\)</span>的矩形，其子矩阵个数为 <span class="math inline">\(A=\dfrac{m(m +1)}{2}\)</span>。</p><p>对于一个 <span class="math inline">\(n\times 1\)</span>的矩形，其子矩阵个数为 <span class="math inline">\(B=\dfrac{n(n +1)}{2}\)</span>。</p><p>乘法原理，对于 <span class="math inline">\(n\times m\)</span>的矩形，子矩阵个数为 <span class="math inline">\(C=\dfrac{n(n +1)}{2}\cdot\dfrac{m(m + 1)}{2}\)</span>。</p><p>那么，纯子矩阵个数 <span class="math inline">\(=\)</span>杂子矩阵个数 <span class="math inline">\(= \dfrac{C}{2}\)</span>。若<span class="math inline">\(C\)</span> 为奇数，无法构造。</p><p>否则，<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 至少有一个偶数，不妨令 <spanclass="math inline">\(A\)</span>为偶数。根据乘法原理，如果我们能够构造一个拥有 <spanclass="math inline">\(\dfrac{A}{2}\)</span> 个纯子矩阵（杂子矩阵）的<span class="math inline">\(1\times m\)</span> 的矩阵。复制 <spanclass="math inline">\(n\)</span> 份，总纯子矩阵个数就是 <spanclass="math inline">\(\dfrac{A}{2}\cdotB=\dfrac{C}{2}\)</span>，满足题意。</p><p>而这 <span class="math inline">\(1\times m\)</span> 的矩阵必然由若干<span class="math inline">\(01\)</span> 段组成，设每段的长度为 <spanclass="math inline">\(d_i\)</span>，则需要构造 <spanclass="math inline">\(d_i\)</span> 满足： * <spanclass="math inline">\(\sum d_i=m\)</span> * <spanclass="math inline">\(\sum\dfrac{d_i(d_i+1)}{2}=\dfrac{A}{2}=\dfrac{m(m+1)}{4}\)</span></p><p>按题解的说法此时贪心从大到小枚举 <spanclass="math inline">\(d_i\)</span>，就一定会有合适的取值，正确性我并没有想得很透彻。</p><p>我的做法是二分 <span class="math inline">\(d_i\)</span>，设二分出的<span class="math inline">\(d_i=mid\)</span>，此时剩下 <spanclass="math inline">\(left-mid\)</span> 段，二式剩下 <spanclass="math inline">\(T\)</span>。假设每段独立，即 <spanclass="math inline">\(01010\cdots\)</span>，产生 <spanclass="math inline">\(left-mid\)</span> 的贡献。那么只要 <spanclass="math inline">\(\dfrac{mid(mid+1)}{2} \le T-(left-mid)\)</span>就往更大的方向更新。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-type">int</span> all = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (all &amp; <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-type">bool</span> rev = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> ((n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">swap</span>(n, m);rev = <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> T = m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">4</span>, left = m;vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-keyword">while</span> (T) &#123;<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = left, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (mid * (mid + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;= T - (left - mid)) &#123;res = mid;l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;r = mid - <span class="hljs-number">1</span>;&#125;&#125;T -= res * (res + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;left -= res;a.<span class="hljs-built_in">push_back</span>(res);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> now = <span class="hljs-number">1</span>, ths = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;ths ^= <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now; i &lt;= now + x - <span class="hljs-number">1</span>; i++) &#123;ans[i] = ths;&#125;now += x;&#125;<span class="hljs-keyword">while</span> (now &lt;= m) &#123;ths ^= <span class="hljs-number">1</span>;ans[now] = ths;now++;&#125;<span class="hljs-keyword">if</span> (!rev) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;cout &lt;&lt; ans[j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m];&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; ans[j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>晚上打 CF，前三题基本都挺顺利的。</p><p>A 冷静了一分钟感觉直接用个 <code>std::multiset</code>模拟就成，只要不把分离出的 <span class="math inline">\(1\)</span>塞回去就不会很慢。（赛后发现就我最笨了） B 注意到一段 <spanclass="math inline">\(0\)</span> 可以缩成一个 <spanclass="math inline">\(0\)</span>，<span class="math inline">\(1\)</span>自然是越多越好，不用处理，最后比较 <spanclass="math inline">\(1\)</span> 的个数是否 <spanclass="math inline">\(&gt;\)</span> <spanclass="math inline">\(0\)</span> 的个数就行。</p><p>C 卡了 10 分钟，但很快把样例 <code>bitset</code>输出了一下，就发现端倪了，每次只要 <spanclass="math inline">\(0\)</span> 的位次从高位向地位移动就行。</p><p>长度就是 <code>popcount(n) + 1</code>。</p><p>你说得对，但是：</p><div class="note note-warning">            <p><code>std::__builtin_popcount(S)</code> 不彳亍！</p><p><code>std::__builtin_popcountll(S)</code> 彳亍！</p>          </div><p>浪费了十分钟，警钟长鸣。</p><p>D 上手就写了个取两次取完所有点的，看了下榜发现 lyc 和 wbc 都瞬 wa了，就发现不对劲。</p><p>思考了一下，三次取完所有点是不是就行了！很牛啊，写写写，唉，wa了。</p><p>怎么会是呢，是不是要钦定若干条边 dp，看看第三次取哪些。</p><p>然后时间很快就过了，唉，好像三次不彳亍！唉，这下不牛了。</p><p>怎么大伙都过 D 了，又垫底了。</p><hr /><p>赛后发现这题有 2log，1log，甚至线性的做法，都写写看好了。</p><div class="note note-info">            <p>【CF1988 - D. The Omnipotent Monster Killer】</p><p>题意：给定一棵树，点有点权，意为将该点留下所需的代价。你可以分若干轮将这棵树的所有节点删空，要求每一轮次中，每条边两侧的顶点不能同时被删，每轮结束剩下的点结算代价。问将树删空的最小代价。</p><p><span class="math inline">\(1 \le n \le 3\cdot 10^5\)</span>，<spanclass="math inline">\(1 \le a_i \le 10^{12}\)</span>。</p>          </div><div class="note note-success">            <p>【solution - <span class="math inline">\(O(n\log^2n)/O(n\logn)\)</span> 】</p><p>可以想象贪心必不优。同时猜测删空所需的轮数并不多，实际不超过 <spanclass="math inline">\(O(\log n)\)</span> 轮。</p><p>令 <span class="math inline">\(dp_{x, t}\)</span> 代表删空 <spanclass="math inline">\(x\)</span> 的子树，且在第 <spanclass="math inline">\(t\)</span> 轮删去 <spanclass="math inline">\(x\)</span> 的最小代价。</p><p>得到以下转移方程： <span class="math display">\[dp_{x,t}=\sum_{y\in son_x}\left(\min_{t&#39;\neq t}dp_{y,t&#39;}\right)+w_x\times(t+1)\]</span></p><p>答案为 <span class="math inline">\(\min\limits_{i=1}^{\log_n}dp_{1,i}\)</span>。</p><p>暴力枚举 <span class="math inline">\(t\)</span> 和 <spanclass="math inline">\(t&#39;\)</span> 进行转移，时间复杂度 <spanclass="math inline">\(O(n\log^2 n)\)</span>。</p><p>虽然 <span class="math inline">\(t&#39;=t\)</span> 不计入答案，但<span class="math inline">\(t&#39;&lt;t\)</span> 和 <spanclass="math inline">\(t&#39; &gt; t\)</span> 计入答案。故记录前缀 <spanclass="math inline">\(\min\)</span> 和后缀 <spanclass="math inline">\(\min\)</span>，时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        2log    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>))</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;dp[x][i] = (i + <span class="hljs-number">1</span>) * a[x];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<span class="hljs-type">int</span> mn = inf;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">20</span>; j++) &#123;<span class="hljs-keyword">if</span> (i == j) &#123;<span class="hljs-keyword">continue</span>;&#125;mn = <span class="hljs-built_in">min</span>(mn, dp[y][j]);&#125;dp[x][i] += mn;&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);cout &lt;&lt; *<span class="hljs-built_in">min_element</span>(dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        1log    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>))</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;dp[x][i] = (i + <span class="hljs-number">1</span>) * a[x];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (y == fa) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">self</span>(self, y, x);pre[<span class="hljs-number">0</span>] = dp[y][<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;pre[i] = <span class="hljs-built_in">min</span>(pre[i - <span class="hljs-number">1</span>], dp[y][i]);&#125;suf[<span class="hljs-number">19</span>] = dp[y][<span class="hljs-number">19</span>];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">18</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;suf[i] = <span class="hljs-built_in">min</span>(suf[i + <span class="hljs-number">1</span>], dp[y][i]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<span class="hljs-type">int</span> t = inf;<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;t = <span class="hljs-built_in">min</span>(t, pre[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">19</span>) &#123;t = <span class="hljs-built_in">min</span>(t, suf[i + <span class="hljs-number">1</span>]);&#125;dp[x][i] += t;&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);cout &lt;&lt; *<span class="hljs-built_in">min_element</span>(dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><p>线性我还不会，明日再补。</p><hr /><h3 id="day-9">【7.16】 Day 9</h3><p>10 点 35 被闹醒，下床继续睡到 11 点。</p><p>朝阳，￥15 烤肉饭两荤两素，感觉素菜和荤菜品种都不如沙河阳光餐厅。</p><p>烤肉饭就是烤肉饭的味道，本来是三星，但它那个鸡腿搞得挺好吃，三星半把。</p><p>预感到又是坐牢的一天呐米娜桑。</p><hr /><p>猜对了，继续蒸蒸日下。</p><p>先是 A 维护得一坨，再是两个半小时没做出 F，糖丸了。</p><p>赛后发现 <span class="math inline">\(n\)</span> 怎么是 <spanclass="math inline">\(5000\)</span> 鸭，下意识以为是 <spanclass="math inline">\(1e5\)</span> 之类的了。虽然正解也不是 <spanclass="math inline">\(O(n^2)\)</span> 的，但没准 <spanclass="math inline">\(O(n^2)\)</span> 就恰好会呢？呜呜。</p><p>被 F 红晕了，H 都没仔细看。赛后发现就是 <spanclass="math inline">\(p_i\)</span> 和 <spanclass="math inline">\(p_j\)</span> 互相问，十五分钟秒了（</p><p>菜，直接补题吧，没什么好说的。</p><hr /><div class="note note-info">            <p>【队内赛 6 - F. 迫近的客星 - CF370C. Mittens】</p><p>题意：给定一个 <span class="math inline">\(n\)</span> 个数的数组<span class="math inline">\(\{a\}\)</span>，你需要寻找 <spanclass="math inline">\(\{a\}\)</span> 的一个排列 <spanclass="math inline">\(\{b\}\)</span>（指 <spanclass="math inline">\(\{b\}\)</span> 和 <spanclass="math inline">\(\{a\}\)</span> 仅有元素排列顺序不同） 使得满足<span class="math inline">\(a_i \neq b_i\)</span>的下标数量尽可能多。</p><p><span class="math inline">\(1 \le n \le 5000\)</span>，<spanclass="math inline">\(1 \le m \le 100\)</span>。</p>          </div><div class="note note-success">            <p>结论：将 <span class="math inline">\(\{a\}\)</span> 排序后右移 <spanclass="math inline">\(\dfrac{n}{2}\)</span> 再复原排序得到 <spanclass="math inline">\(\{b\}\)</span>。（该题只要求输出映射方案，不需要复原排序）很智慧的构造，设 <span class="math inline">\(\{a\}\)</span>排序之后最长连续段长度为 <spanclass="math inline">\(d\)</span>，分两种情况讨论： * 若 <spanclass="math inline">\(d \le\left\lfloor\dfrac{n}{2}\right\rfloor\)</span>，如下图。最长段（蓝色）可以错开，剩下的连续段长度都不超过<spanclass="math inline">\(d\)</span>，因此可以用其它段（红色）补足空隙，此时上下两个数组就没有重合的地方了。</p><figure><img src="https://kisuraop.github.io/image/academic/11.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><ul><li>考虑右移 <spanclass="math inline">\(\dfrac{n}{2}\)</span>，如下图。最长段显然不会重合，其它段用不同颜色进行了标明，意在说明若在空隙的地方（即<span class="math inline">\(l_2\)</span> 右端）<spanclass="math inline">\(\{a\}\)</span>，<spanclass="math inline">\(\{b\}\)</span> 有重合，那么其他段的长度至少要从<span class="math inline">\(l_1\)</span> 右端开始直到 <spanclass="math inline">\(l_2\)</span> 右端，长度 <spanclass="math inline">\(&gt; \dfrac{n}{2}\)</span>，与假设相悖。</li></ul><p><img src="https://kisuraop.github.io/image/academic/12.png"alt="1" /> * 若 <span class="math inline">\(d &gt;\dfrac{n}{2}\)</span>，如下图。最长段（蓝色）已经不可避免地相交，剩下段（红色）不可能再重叠，因此最大匹配的下标数量为<span class="math inline">\(n-d\)</span>。</p><p><img src="https://kisuraop.github.io/image/academic/13.png"alt="1" /> * 考虑右移 <spanclass="math inline">\(\dfrac{n}{2}\)</span>，如下图。因为右移之后蓝色段<span class="math inline">\((&gt;\dfrac{n}{2})+\dfrac{n}{2}\to(&gt;n)\)</span> 必然超出右边界，因此剩下的区域仍然要么被 <spanclass="math inline">\(\{a\}\)</span> 的蓝色段覆盖，要么被 <spanclass="math inline">\(\{b\}\)</span> 的蓝色段覆盖，取到最大匹配。</p><figure><img src="https://kisuraop.github.io/image/academic/14.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;ans += a[i] != a[(i + n / <span class="hljs-number">2</span>) % n];&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[(i + n / <span class="hljs-number">2</span>) % n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 6 - E. 辞行久远之躯 - CF1242B. 0-1 MST】</p><p>题意：给定一个包含 <span class="math inline">\(n\)</span>个节点的完全图，以及图中的 <span class="math inline">\(m\)</span>条长度为 <span class="math inline">\(1\)</span> 的边，其它边长度均为<span class="math inline">\(0\)</span>。求该图最小生成树的权值。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<spanclass="math inline">\(1 \le m\le \min(\frac{n(n-1)}{2},10^5)\)</span>。</p>          </div><div class="note note-success">            <p>我们发现大部分的边都是 <span class="math inline">\(0\)</span>边，换种说法如果只保留图上的 <span class="math inline">\(0\)</span>边，之后只有少量的边需要我们连接。对于两个全 <spanclass="math inline">\(0\)</span> 连通块，若用一条 <spanclass="math inline">\(1\)</span>边连接它们，那么这一大苟的连通块相当于拥有权值为 <spanclass="math inline">\(1\)</span> 的最小生成树。</p><p>同理，若该图全 <span class="math inline">\(0\)</span> 连通块的个数为<span class="math inline">\(c\)</span>，那么需要用 <spanclass="math inline">\(c-1\)</span> 条 <spanclass="math inline">\(1\)</span>边连接它们使整个图联通，这个图的最小生成树的权值自然就是 <spanclass="math inline">\(c-1\)</span>。</p><p>现在考虑求 <span class="math inline">\(c\)</span>。以下面的 <spanclass="math inline">\(K_4\)</span> 完全图（图A）为例：</p><figure><img src="https://kisuraop.github.io/image/academic/21.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>其中红色虚边为 <span class="math inline">\(0\)</span> 边，绿色实边为<span class="math inline">\(1\)</span> 边。我们按照编号顺序依次遍历<span class="math inline">\(1\sim n\)</span>，关注连通块的变化。</p><p>一开始有节点 <span class="math inline">\(1\)</span>，全 <spanclass="math inline">\(0\)</span> 连通块默认为 <spanclass="math inline">\(1\)</span>。现在加进来节点 <spanclass="math inline">\(2\)</span>，如何判断全 <spanclass="math inline">\(0\)</span> 连通块个数是否增加？</p><p>要知道，<span class="math inline">\(0\)</span>边数量是极多的，我们不能遍历 <span class="math inline">\(0\)</span>边，我们能操作的只有 <span class="math inline">\(1\)</span>边。那么遍历与 <span class="math inline">\(2\)</span> 相连的 <spanclass="math inline">\(1\)</span> 边，发现没有（目前只考虑节点 <spanclass="math inline">\(1,2\)</span> 构成的子图，所以连向右侧的 <spanclass="math inline">\(1\)</span> 边暂不考虑）。那么自然全是 <spanclass="math inline">\(0\)</span> 边，用并查集把 <spanclass="math inline">\(1,2\)</span> 连起来，全 <spanclass="math inline">\(0\)</span> 连通块个数不变。</p><p>现在加进来节点 <span class="math inline">\(3\)</span>，发现存在 <spanclass="math inline">\(1\)</span> 边 <spanclass="math inline">\((1,3)\)</span> 和 <spanclass="math inline">\((2,3)\)</span>。我们不妨用一个标记数组<code>cnt</code> 标记一下，即对于 <span class="math inline">\(1\)</span>边 <span class="math inline">\(x\to y(y &lt; x)\)</span> 有<code>cnt[dsu.find(y)]++</code>。接着我们遍历先前的连通块，判断是否有连通块<span class="math inline">\(x\)</span> 的大小 <code>dsu.size(x)</code>比 <code>cnt[x]</code> 大。因为两个点之间不是 <spanclass="math inline">\(1\)</span> 边就是 <spanclass="math inline">\(0\)</span> 边，如果 <code>dsu.size(x)</code>更大，说明向这个连通块连的边有 <span class="math inline">\(0\)</span>边，进一步说明全 <span class="math inline">\(0\)</span>连通块的个数没有增加，如下图（图B）。</p><figure><img src="https://kisuraop.github.io/image/academic/22.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>该图满足 <code>dsu.size(1) = 2 &gt; cnt[1] = 1</code>。此时节点 <spanclass="math inline">\(3\)</span> 的加入不影响全 <spanclass="math inline">\(0\)</span> 连通块个数，直接用并查集并起来。</p><p>而图 A 则是 <code>dsu.size(1) = 2 &lt;= cnt[1] = 2</code>。此时全<span class="math inline">\(0\)</span> 连通块个数 <spanclass="math inline">\(+1\)</span>。</p><p>现在会了怎么判断全 <span class="math inline">\(0\)</span>连通块个数增加，那会不会减少呢？</p><figure><img src="https://kisuraop.github.io/image/academic/23.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>这是添加节点 <span class="math inline">\(5\)</span>之后的另一个例子，不难看出此时全 <span class="math inline">\(0\)</span>连通块数量发生了 <span class="math inline">\(2\to 1\)</span>的变化。</p><p>那我们动态维护这个数值就有点困难了。但我们只关心最后的结果：节点<span class="math inline">\(5\)</span> 添加，老样子判断<code>dsu.size(1) = 2 &gt; cnt[1] = 0</code> 且<code>dsu.size(3) = 2 &gt; cnt[3] = 0</code>，就把 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(5\)</span>，<span class="math inline">\(3\)</span>和 <span class="math inline">\(5\)</span>所在的连通块并起来了。此时对于节点 <span class="math inline">\(1\sim5\)</span>，恰有一个满足<code>dsu.find(i) = i</code>。这启示我们最后的答案就是<code>dsu.find(i) = i</code> 的节点的个数，不必动态维护连通块个数。</p><p>复杂度分析：对于每个节点，都有并或不并。合并显然最多 <spanclass="math inline">\(n\)</span>次；而不合并，那么该节点至少和先前的连通块存在一条 <spanclass="math inline">\(1\)</span> 边，<spanclass="math inline">\(1\)</span> 边一共有 <spanclass="math inline">\(m\)</span> 条。因此是 <spanclass="math inline">\(O(n\alpha+m)\)</span> 的。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125; siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; rt;map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cnt.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[i]) &#123;<span class="hljs-keyword">if</span> (x &lt; i) &#123;cnt[dsu.<span class="hljs-built_in">find</span>(x)]++;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : rt) &#123;x = dsu.<span class="hljs-built_in">find</span>(x);<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">size</span>(x) &gt; cnt[x]) &#123;dsu.<span class="hljs-built_in">merge</span>(x, i);&#125;&#125;<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">find</span>(i) == i) &#123;rt.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ans += dsu.<span class="hljs-built_in">find</span>(i) == i;&#125;cout &lt;&lt; ans - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 6 - G. 我们终将重逢 - CF1117D. Magic Gems】</p><p>题意：有无数个魔法宝石，每个魔法宝石可以分解成 <spanclass="math inline">\(m\)</span> 个普通宝石，两种宝石都占据 <spanclass="math inline">\(1\)</span>的空间，后者不能再被分解。问有多少种分解方案，可以使最后得到的宝石恰好占据<span class="math inline">\(n\)</span>个空间。两种分解方案不同当且仅当分解的魔法宝石数量不同，或者是所用宝石的编号不同。答案对<span class="math inline">\(10^9+7\)</span> 取模。</p><p><span class="math inline">\(1 \le n \le 10^{18}\)</span>，<spanclass="math inline">\(2 \le m \le 100\)</span>。</p>          </div><div class="note note-success">            <p>可以将题目概括为用若干个 <span class="math inline">\(m\)</span> 个<span class="math inline">\(0\)</span> 和若干个 <spanclass="math inline">\(1\)</span> 组成的长为 <spanclass="math inline">\(n\)</span> 的 <spanclass="math inline">\(01\)</span> 串计数。</p><p>不妨令 <span class="math inline">\(f_i\)</span> 代表长为 <spanclass="math inline">\(i\)</span> 的这样的串的数目，则转移为： <spanclass="math display">\[f_i = \begin{cases}1&amp;, i &lt; m \\f_{i - 1} + f_{i - m}&amp;,\text{otherwise}\end{cases}\]</span></p><p>意为可以在长为 <span class="math inline">\(i-1\)</span> 的串末尾加<span class="math inline">\(1\)</span> 或长为 <spanclass="math inline">\(i-m\)</span> 的串末尾加 <spanclass="math inline">\(m\)</span> 个 <spanclass="math inline">\(0\)</span> 来达到该状态。</p><p>取其中 <span class="math inline">\(f_i\)</span> 和 <spanclass="math inline">\(f_{i-m}\)</span>，列出在它们之间的转移式如下：<span class="math display">\[\begin{align}f_i = 1\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} +\cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 1\cdot f_{i -m} \\f_{i-1} = 1\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} +\cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i -m} \\f_{i-2} = 0\cdot f_{i - 1}+1\cdot f_{i - 2}+ 0\cdot f_{i - 3} +\cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i -m} \\f_{i-3} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 1\cdot f_{i - 3} +\cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i -m} \\\vdots \\f_{i-m+2} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i- 3} + \cdots&amp;+1\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdotf_{i - m} \\f_{i-m+1} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i -3} + \cdots&amp;+0\cdot f_{i - m + 2} + 1\cdot f_{i - m + 1} + 0\cdotf_{i - m} \\\end{align}\]</span></p><p>取系数矩阵，得到可以用矩阵快速幂加速的转移形式： <spanclass="math display">\[\begin{bmatrix}f_i \\f_{i-1} \\\vdots \\f_{i-m+2}\\f_{i+m-1}\end{bmatrix}=\begin{bmatrix}1&amp; &amp; &amp; &amp;&amp;1\\1&amp; &amp; &amp; &amp; &amp; \\ &amp;1&amp; &amp; &amp; &amp;\\ &amp; &amp;\ddots&amp; &amp; &amp;\\ &amp; &amp; &amp;1&amp; &amp; \\&amp; &amp; &amp; &amp;1&amp; \\\end{bmatrix}\begin{bmatrix}f_{i-1}\\f_{i-2} \\\vdots \\f_{i-m+1} \\f_{i-m}\end{bmatrix}\]</span></p><p>时间复杂度 <span class="math inline">\(O(m^3\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span> &#123;<span class="hljs-type">int</span> n, m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(n), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)) &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)) &#123;&#125;<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, k)) &#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cin &gt;&gt; a[i][j];&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(n, m); i++) &#123;a[i][i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function">matrix <span class="hljs-title">tp</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(m, n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;z.a[j][i] = a[i][j];&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;&#125;;<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> matrix &amp;x, <span class="hljs-type">const</span> matrix &amp;y) &#123;<span class="hljs-built_in">assert</span>(x.m == y.n);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(x.n, y.m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; x.m; k++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; y.m; j++) &#123;z.a[i][j] += x.a[i][k] * y.a[k][j] % modp;z.a[i][j] %= modp;&#125;&#125;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function">matrix <span class="hljs-title">qpow</span><span class="hljs-params">(matrix a, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-built_in">assert</span>(a.n == a.m);<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(a.n)</span></span>;z.<span class="hljs-built_in">build</span>();<span class="hljs-keyword">for</span> ( ; k; k &gt;&gt;= <span class="hljs-number">1</span>, a = a * a) &#123;<span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) z = z * a;&#125;<span class="hljs-keyword">return</span> z;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">if</span> (n &lt; m) &#123;cout &lt;&lt; <span class="hljs-string">&quot;1\n&quot;</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function">matrix <span class="hljs-title">G</span><span class="hljs-params">(m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;G.a[i + <span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;&#125;G.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;G.a[<span class="hljs-number">0</span>][m - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;matrix ans = <span class="hljs-built_in">qpow</span>(G, n - m + <span class="hljs-number">1</span>) * <span class="hljs-built_in">matrix</span>(m, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);cout &lt;&lt; ans.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="day-10">【7.17】 Day 10</h3><p>床起晚了，还下雨，直接赶到教室了。</p><p>上午徐神和包爷讲字符串专题。</p><p>虽然此前想象过，但事实是除了 C 这个签到之外其它题都没听懂 QAQ</p><p>甚至 C 的证明也没怎么懂，不知道会字符串的那帮人脑子是怎么转的。</p><p>慢慢来吧。</p><p>午饭外卖搞了个￥22方便面炒鸡，肉给的很多，性价比在线，吃起来也香，四星半。</p><p>中午倒头就睡，一直在梦里的感觉真好鸭。</p><hr /><p>又到了悲闻哀见的队内赛时间。</p><p>开局 wa，难崩。</p><p>半小时开完三道签到，然后转向C。一看就是分类讨论，这种题我一直捏不准，所以写的格外有条理。</p><p>大概写了二十来分钟，交！wa3！尼玛！果断拍！卧槽怎么十万组没拍出来！啊？</p><p>后面终于发现是最开始的特判错了！因为对拍很难拍无解我就略过了！唉，浪费了半小时左右。</p><p>然后看 B，啊？又是分类讨论？写！交！wa50！啊？？？？？？？？？？</p><p>不知道为什么刚刚 C拍的这么果断我这时候又犹豫了，开始手动检查逻辑，不出意外没检查出来。</p><p>磨磨唧唧了半天才拍，结果一下就拍出来了，是一个非常细的地方。</p><p>这次竟然浪费了 40 分钟，尼玛的。那只剩 25 分钟看 H那个构造了，思前想后感觉只能知道后 <spanclass="math inline">\(n-k+1\)</span> 个数和第 <spanclass="math inline">\(k\)</span> 个数的大小关系，不知道前 <spanclass="math inline">\(1\sim k-1\)</span>个数。结束了，后面看了题解大呼智慧。</p><hr /><p>晚上和沙河的大伙一起去吃了 Kingburger！拼了鸡块和汉堡，我又搞了个 9.9的 1+1，爽了。</p><p>味道不知道怎么评价，毕竟汉堡就是汉堡的味道，薯条就是薯条的味道，甜辣酱就是甜辣酱的味道。就好比在广西三品王就是三品王味，粉之都就是粉之都味一样，从小吃到大的东西，平时啥时候灵机一动就想吃，吃了上顿又不想吃下顿。</p><p>吃完和 xxx 回到基础实验大楼补题。</p><hr /><div class="note note-info">            <p>【队内赛 7 - H. 再多看一眼就会爆炸 - CF1720D. Strange Device】</p><p>题意：交互题。系统初始一个长为 <span class="math inline">\(n\)</span>的数组 <spanclass="math inline">\(\{a\}\)</span>，保证所有元素互不相同。给定正整数<span class="math inline">\(k\)</span>，你每次可以询问 <spanclass="math inline">\(k\)</span> 个不同的下标，系统会返回对应的 <spanclass="math inline">\(k\)</span> 个数中的第 <spanclass="math inline">\(m\)</span> 小的数的下标和值。最多可以询问 <spanclass="math inline">\(n\)</span> 次，需要让你猜出 <spanclass="math inline">\(m\)</span>。</p><p><span class="math inline">\(1 \le k &lt; n \le 500\)</span>，<spanclass="math inline">\(1 \le a_i \le 10^9\)</span>。保证 <spanclass="math inline">\(1 \le m \le k\)</span>。</p>          </div><div class="note note-success">            <p>据说有做法能只用下标而不用值，很牛。这里只说最简单的做法（不一定最容易想）</p><p>一种消耗 <span class="math inline">\(k+1\le n\)</span>次询问的方案如下：</p><ul><li><p>只取前 <span class="math inline">\(k+1\)</span>个数，其余部分可以扔掉。</p></li><li><p>第 <span class="math inline">\(i\)</span> 次询问序列：<spanclass="math inline">\([1,i-1]\land[i+1,k+1]\)</span>。</p></li><li><p>不难发现答案只会有两个值，分别是这 <spanclass="math inline">\(k+1\)</span> 个数的第 <spanclass="math inline">\(m\)</span> 小数和第 <spanclass="math inline">\(m+1\)</span> 小数。当去掉的数 <spanclass="math inline">\(a_i \le m\)</span>时询问到的就是后者，否则前者。</p></li><li><p>那么第 <span class="math inline">\(m + 1\)</span>小数被询问到的次数恰好是 <spanclass="math inline">\(m\)</span>。取这上述两个值中的较大者，出现次数就是答案。</p></li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, k;cin &gt;&gt; n &gt;&gt; k;<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;! 1&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">auto</span> query = [&amp;] (<span class="hljs-type">int</span> pos) -&gt; array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &#123;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">if</span> (i == pos) &#123;<span class="hljs-keyword">continue</span>;&#125;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-type">int</span> id, x;cin &gt;&gt; id &gt;&gt; x;<span class="hljs-keyword">return</span> &#123;id, x&#125;;&#125;;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(k + <span class="hljs-number">2</span>);map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) &#123;a[i] = <span class="hljs-built_in">query</span>(i);mp[a[i][<span class="hljs-number">1</span>]]++;&#125; <span class="hljs-type">int</span> ans;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, x] : mp) &#123;ans = x;&#125;cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 7 - D. 这种感觉我从未有 - CF1720D. Cut and Stick】</p><p>题意：给定长为 <span class="math inline">\(n\)</span> 的数组以及<span class="math inline">\(q\)</span> 次询问。每次询问一个区间 <spanclass="math inline">\([l,r]\)</span>，问把该区间最少分为几个子序列，使每个子序列（设长度为 <spanclass="math inline">\(len\)</span>）众数的出现次数 <spanclass="math inline">\(\le\left\lceil\frac{len}{2}\right\rceil\)</span>。</p><p><span class="math inline">\(1\le n,q,a_i \le 3\cdot10^5\)</span>。</p>          </div><div class="note note-success">            <p>设区间长度为 <spanclass="math inline">\(len\)</span>，众数的出现次数是 <spanclass="math inline">\(x\)</span>。若 <span class="math inline">\(x\le\left\lceil\frac{len}{2}\right\rceil\)</span>，答案是 <spanclass="math inline">\(1\)</span>。否则考虑分组，一种最优方案如下： *其它非众数一共有 <span class="math inline">\(len-x\)</span> 个，将其与<span class="math inline">\(len-x+1\)</span>个众数组合，因为此时长度是奇数，故组合后的序列是合法的。</p><ul><li><p>剩下的众数有 <spanclass="math inline">\(x-(len-x+1)=2x-len-1\)</span>个，每个众数单独一组。</p></li><li><p>此时有了 <span class="math inline">\(2x-len\)</span>组，可以证明这是最优的。</p></li></ul><p>证明就是此时划分成的每个子序列 “众数 <spanclass="math inline">\(-\)</span> 非众数” 都达到了最大值 <spanclass="math inline">\(1\)</span>，为最饱和的状态。</p><p>剩下的问题就变成了典题 “求区间众数个数“，常用莫队和主席树。</p><p>同时众数因为有比较强的数量特征，随机化取众数也是十分可行的。这在数据结构专题<span class="math inline">\(L\)</span> 题有充分体现。</p><p>两种方法的时间复杂度分别是 <span class="math inline">\(O((n+q)\logn)\)</span> <span class="math inline">\(\text{and}\)</span> <spanclass="math inline">\(O(n+Aq\log n)\)</span>，<spanclass="math inline">\(A\)</span> 为常数。</p><p>我这里糅合<del>(懒)</del>了一下，写了个莫队 <spanclass="math inline">\(+\)</span> 随机化，<spanclass="math inline">\(O(q\log n+Aq\sqrt{n})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rand</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">rng</span>() % (r - l + <span class="hljs-number">1</span>) + l;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">qry</span>(q);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;qry[i] = &#123;l, r, i&#125;;&#125;<span class="hljs-type">int</span> sz = n / <span class="hljs-built_in">sqrtl</span>(<span class="hljs-number">1.0</span> * q * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>);<span class="hljs-built_in">sort</span>(qry.<span class="hljs-built_in">begin</span>(), qry.<span class="hljs-built_in">end</span>(), [&amp;] (array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; i, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; j) &#123; <span class="hljs-keyword">if</span> (i[<span class="hljs-number">0</span>] / sz == j[<span class="hljs-number">0</span>] / sz) &#123; <span class="hljs-keyword">if</span> ((i[<span class="hljs-number">0</span>] / sz) % <span class="hljs-number">2</span>) &#123; <span class="hljs-keyword">return</span> i[<span class="hljs-number">1</span>] &lt; j[<span class="hljs-number">1</span>]; &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> i[<span class="hljs-number">1</span>] &gt; j[<span class="hljs-number">1</span>]; &#125; &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> i[<span class="hljs-number">0</span>] / sz &lt; j[<span class="hljs-number">0</span>] / sz; &#125;&#125;) ;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">auto</span> add = [&amp;] (<span class="hljs-type">int</span> x) &#123;cnt[a[x]]++;&#125;;<span class="hljs-keyword">auto</span> del = [&amp;] (<span class="hljs-type">int</span> x) &#123;cnt[a[x]]--;&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [ql, qr, id] : qry) &#123;<span class="hljs-keyword">while</span> (l &gt; ql) &#123;<span class="hljs-built_in">add</span>(--l);&#125;<span class="hljs-keyword">while</span> (l &lt; ql) &#123;<span class="hljs-built_in">del</span>(l++);&#125;<span class="hljs-keyword">while</span> (r &lt; qr) &#123;<span class="hljs-built_in">add</span>(++r);&#125;<span class="hljs-keyword">while</span> (r &gt; qr) &#123;<span class="hljs-built_in">del</span>(r--);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;<span class="hljs-type">int</span> pos = <span class="hljs-built_in">Rand</span>(l, r);<span class="hljs-keyword">if</span> (cnt[a[pos]] &gt; (r - l + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>) &#123;ans[id] = <span class="hljs-number">2</span> * cnt[a[pos]] - (r - l + <span class="hljs-number">1</span>);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (!ans[id]) &#123;ans[id] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="day-11">【7.18】 Day 11</h3><p>起床了吗？如起。</p><p>午饭没吃，起床直接传送到 234 了。</p><hr /><p>下午 5h 队内赛。</p><p>前面稳扎稳打，比赛不到一半开了 6 题，自我感觉还是不错的。</p><p>然后就急转直下了，后面都在杠 F，怎么大家都会做？</p><p>赛后发现原来是我刚看 F 就得出了一个错误的结论”边界四个角只能选一个“，因为数据范围比较小后面我就往二分想了。这也太蠢了。</p><p>但二分的话最密也只能压缩到 <spanclass="math inline">\(9\sim10\)</span> 次左右，红晕了。</p><p>最后半小时看了下榜随便开了个 K，看样例猜了个 BSGS，不出意料 wa2了。</p><hr /><p>赛后 Vingying 讲题，思路很清晰鸭，甚至还有回放，爱了！期待下一次 vy场OwO！</p><p>晚上跟 xxx 和 jbx 出去麦。</p><p>麦完回来又睡了，虽然很不情愿，一堆题没补，字符串也没看，但还是想打 CF的时候能精神一点。</p><hr /><p>两个小时醒来 CF 继续唐！B 样例都没读懂代码就写完了，wa2 之后又搞到第35 分钟才搞对。</p><p>C 一个简单 dp，也想了一个来小时。</p><p>剩半个小时，看了眼榜感觉 E 有希望，盲猜硬贪什么的。</p><p>结果把 xor 看成 or 了，完蛋。赛后发现是原，原题我还 AC 过，唐！</p><hr /><p>先从队内赛开始补，感觉 vy 选的题很有 edu 意义。CF 的题择日吧。</p><div class="note note-info">            <p>【队内赛 8 - C. ズッコケ問答 - gym103469E. Eulerian?】</p><p>题意：交互题。系统隐藏了一个 <span class="math inline">\(n\)</span>个点的无向连通图 <spanclass="math inline">\(G\)</span>，保证没有重边和自环。</p><p>你可以进行至多 <span class="math inline">\(60\)</span>次询问，每次询问 <span class="math inline">\(G\)</span>中一个点集，系统会返回该点集构成的导出子图的边数。</p><p>你的目标是确定 <span class="math inline">\(G\)</span>中是否存在一条欧拉回路。交互器不会自适应。</p><p><span class="math inline">\(3 \le n \le 10^4\)</span>，保证 <spanclass="math inline">\(G\)</span> 中边数不超过 <spanclass="math inline">\(10^5\)</span>。</p>          </div><div class="note note-success">            <p>交互器无法自适应（即 <span class="math inline">\(G\)</span>不会随着询问而变化）提示我们采用随机化方法。</p><p>一个无向图存在欧拉回路的充要条件是所有顶点的度均为偶数。</p><p>我们考虑将 <span class="math inline">\(G\)</span>中的顶点随机分成两个集合 <span class="math inline">\(A, B\)</span>。此时<span class="math inline">\(G\)</span> 中的边被分成了三部分：在 <spanclass="math inline">\(A\)</span> 的导出子图中，在 <spanclass="math inline">\(B\)</span> 的导出子图之中，以及横跨在 <spanclass="math inline">\(A, B\)</span> 两个点集之间。</p><p>如果 <span class="math inline">\(A\)</span>中的顶点的度均为偶数，那么 <span class="math inline">\(A\)</span>中所有顶点的度数和也为偶数，又因为在 <spanclass="math inline">\(A\)</span> 中的边每条贡献 <spanclass="math inline">\(2\)</span> 的度数，不改变奇偶性，那么横跨在 <spanclass="math inline">\(A,B\)</span> 之间的边也应该是偶数条。</p><p>故有如下询问方案： * 消耗 <span class="math inline">\(1\)</span>次询问所有的 <span class="math inline">\(n\)</span> 个点，得到 <spanclass="math inline">\(G\)</span> 的总边数。</p><ul><li><p>重复 <span class="math inline">\(29\)</span> 次将 <spanclass="math inline">\(G\)</span> 随机划分成 <spanclass="math inline">\(A,B\)</span>。消耗 <spanclass="math inline">\(29\cdot2\)</span> 次分别询问 <spanclass="math inline">\(A,B\)</span>导出子图中的边数，从而用总边数减去它们得到横跨边的数量。</p></li><li><p>若至少 <span class="math inline">\(1\)</span> 次询问到了 <spanclass="math inline">\(A,B\)</span>间有奇数条横跨边，判定不存在欧拉回路；反之存在。</p></li></ul><p>正确性证明：横跨边数目为奇数或偶数各占 <spanclass="math inline">\(\frac{1}{2}\)</span> 概率，<spanclass="math inline">\(29\)</span> 次判定仍旧失败的概率为 <spanclass="math inline">\(\frac{1}{2^{29}}\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;cin &gt;&gt; m;<span class="hljs-type">int</span> test_case = <span class="hljs-number">29</span>;<span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (test_case--) &#123;vector&lt;<span class="hljs-type">int</span>&gt; A, B;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> o = <span class="hljs-built_in">rng</span>() % <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (o &gt; <span class="hljs-number">0</span>) &#123;A.<span class="hljs-built_in">push_back</span>(i);&#125; <span class="hljs-keyword">else</span> &#123;B.<span class="hljs-built_in">push_back</span>(i);&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; A.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : A) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-type">int</span> cnt1;cin &gt;&gt; cnt1;cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; B.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : B) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-type">int</span> cnt2;cin &gt;&gt; cnt2;<span class="hljs-type">int</span> mid = m - cnt1 - cnt2;<span class="hljs-keyword">if</span> (mid &amp; <span class="hljs-number">1</span>) &#123;ok = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (ok) &#123;cout &lt;&lt; <span class="hljs-string">&quot;! YES&quot;</span> &lt;&lt; endl;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;! NO&quot;</span> &lt;&lt; endl;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// cout.flush();</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 8 - K. 世界のまん中 - gym103469F. Fancy Formulas】</p><p>题意：给定一个质数 <span class="math inline">\(p\)</span>，以及 <spanclass="math inline">\(q\)</span> 组询问。每次给定两个二元组 <spanclass="math inline">\((a,b)\)</span> 和 <spanclass="math inline">\((c,d)\)</span>，保证 <spanclass="math inline">\(p\nmid (a+b)\)</span>。</p><p>一次操作可以选择如下其一，你可以无限次操作。问是否能将 <spanclass="math inline">\((a,b)\)</span> 转化为 <spanclass="math inline">\((c,d)\)</span>。</p><ul><li><span class="math inline">\((a,b):=(2a\bmod p, (b+p-a)\bmodp)\)</span></li><li><span class="math inline">\((a, b):=((a+p-b)\bmod p, 2b\bmodp)\)</span></li></ul><p><span class="math inline">\(2 \le p \le 10^9+7\)</span>，<spanclass="math inline">\(1\le q\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>无论那种操作，操作后的 <span class="math inline">\((a, b)\)</span>均满足 <span class="math inline">\(s=(a+b)\bmod p\)</span> 不变。</p><p>那么知道 <span class="math inline">\((a,b)\)</span> 中的 <spanclass="math inline">\(a\)</span> 或 <spanclass="math inline">\(b\)</span>，另一个也同时确定，<spanclass="math inline">\((c,d)\)</span> 同理。</p><p>于是不妨将问题转化为：每次将一个整数 <spanclass="math inline">\(a\)</span> 进行 <spanclass="math inline">\(a:=2a\)</span> 或 <span class="math inline">\(a:=a-b\)</span> 的操作，能否将 <span class="math inline">\(a\toc\)</span>。</p><p>而 <span class="math inline">\(a:=a-b \Leftrightarrowa:=a-(s-a)\)</span>。即 <spanclass="math inline">\(a:=2a-s\)</span>。</p><p>但有 <span class="math inline">\(s\)</span> 在仍旧不好处理，考虑给<span class="math inline">\(a,c\)</span> 都乘上 <spanclass="math inline">\(s^{-1}\)</span>，此时满足 <spanclass="math inline">\((a+b)\bmod p = 1\)</span>。</p><p>问题再次转化为每次将一个整数 <span class="math inline">\(a\)</span>进行 <span class="math inline">\(a:=2a\)</span> 或 <spanclass="math inline">\(a:=2a-1\)</span> 的操作，能否将 <spanclass="math inline">\(a\to c\)</span>。</p><p>这样就变成了单变量问题。注意到对 <spanclass="math inline">\(a\)</span> 进行 <spanclass="math inline">\(k\)</span>次操作后得到的数一定在一个区间范围内连续分布，具体的，是 <spanclass="math inline">\([2^ka-(2^k-1), 2^ka]\)</span>。而当 <spanclass="math inline">\(k &gt; 30\)</span> 的时候，这个区间的长度会 <spanclass="math inline">\(\ge p\)</span>，意味着在 <spanclass="math inline">\(\bmod p\)</span> 意义下拥有 <spanclass="math inline">\(0\sim p-1\)</span> 中的所有取值，就一定能找到和<span class="math inline">\(c\bmod p\)</span> 同余的数。</p><p>于是直接枚举 <spanclass="math inline">\(k\)</span>，当值域区间内第一次存在和 <spanclass="math inline">\(c\)</span> 同余的数时，对应的 <spanclass="math inline">\(k\)</span> 就是答案。</p><p>时间复杂度 <span class="math inline">\(O(q\log p)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % p) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % p;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> p, q;cin &gt;&gt; p &gt;&gt; q;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> a, b, c, d;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<span class="hljs-keyword">if</span> ((a + b) % p != (c + d) % p) &#123;cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> s = (a + b) % p;a = a * <span class="hljs-built_in">qpow</span>(s, p - <span class="hljs-number">2</span>, p) % p;c = c * <span class="hljs-built_in">qpow</span>(s, p - <span class="hljs-number">2</span>, p) % p;<span class="hljs-keyword">if</span> (a == c) &#123;cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> cover = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, l = a, r = a; ; i++) &#123;l = l * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;r = r * <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span>) &#123;l = p - <span class="hljs-number">1</span>;r = p;&#125;<span class="hljs-type">int</span> len = r - l + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (len &gt;= p) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-type">int</span> lp = l % p;<span class="hljs-type">int</span> rp = r % p;<span class="hljs-keyword">if</span> (lp &lt;= rp &amp;&amp; lp &lt;= c &amp;&amp; c &lt;= rp) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (lp &gt; rp &amp;&amp; (c &gt;= lp || c &lt;= rp)) &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 8 - G. 名前をつけてやる - gym102471H. King】</p><p>题意：给定一个质数 <span class="math inline">\(p\)</span>。一个长为<span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(\{a\}\)</span> 被称作 good，当且仅当 <spanclass="math inline">\(\exists q\in[1,p),\  \forall i \in[2, n], \qa_{i-1}\equiv a_i \pmod{p}\)</span>。</p><p>给定一个序列 <span class="math inline">\(\{b\}\)</span>，设其最长的good 子序列长度为 <span class="math inline">\(len\)</span>。若 <spanclass="math inline">\(len \ge \frac{n}{2}\)</span> 输出 <spanclass="math inline">\(len\)</span>；否则输出 <spanclass="math inline">\(-1\)</span>。</p><p><span class="math inline">\(2 \le n \le 2 \cdot 10^5\)</span>，<spanclass="math inline">\(2 \le p \le 10^9+7\)</span>。</p>          </div><div class="note note-success">            <p>题目中 <span class="math inline">\(len \ge \frac{n}{2}\)</span>其实是一个随机化暗示。这意味着组成该子序列的元素在原序列中分布的十分密集。</p><p>如果 <span class="math inline">\(n\)</span>为奇数，那么至少存在一对相邻的数，它们的比值正好是公比（鸽笼原理）。</p><p>如果 <span class="math inline">\(n\)</span> 为偶数，极限情况也是<span class="math inline">\(\text{xoxoxoxo}\)</span>（<spanclass="math inline">\(\text{x}\)</span> 代表出现在最长的 good子序列中），此时正好占到总长度的 <spanclass="math inline">\(\frac{1}{2}\)</span>。</p><p>那么我们可以进行以下操作若干次以得到正确答案： * 从 <spanclass="math inline">\(\{b\}\)</span> 中随机选一对数 <spanclass="math inline">\((x, y)\)</span>，满足 <spanclass="math inline">\(y = x + 1\)</span> or <spanclass="math inline">\(y = x + 2\)</span>。</p><ul><li><p>令公比为 <spanclass="math inline">\(\dfrac{b_y}{b_x}\)</span>，向 <spanclass="math inline">\(x\)</span> 左侧和 <spanclass="math inline">\(y\)</span> 右侧拓展得到满足该公比的最长 good序列，设长度为 <span class="math inline">\(m\)</span>。</p></li><li><p>若 <span class="math inline">\(2 \cdot m \gen\)</span>，更新答案。</p></li></ul><p>正确性证明：不是很会，但显然失败概率极低。实际取 <spanclass="math inline">\(50\)</span> 次左右就能 AC 了。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rand</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">rng</span>() % (r - l + <span class="hljs-number">1</span>) + l;&#125;<span class="hljs-type">int</span> modp;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;&#125;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n &gt;&gt; modp;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">inv</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; b[i];inv[i] = <span class="hljs-built_in">qpow</span>(b[i], modp - <span class="hljs-number">2</span>);&#125;<span class="hljs-type">int</span> test_case = <span class="hljs-number">50</span>;<span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (test_case--) &#123;<span class="hljs-type">int</span> x = <span class="hljs-built_in">Rand</span>(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : &#123;x + <span class="hljs-number">1</span>, x + <span class="hljs-number">2</span>&#125;) &#123;<span class="hljs-keyword">if</span> (y &gt; n) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-type">int</span> d = b[y] * inv[x] % modp;<span class="hljs-type">int</span> res = <span class="hljs-number">2</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = y + <span class="hljs-number">1</span>, lst = y; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (b[i] * inv[lst] % modp == d) &#123;res++;lst = i;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x - <span class="hljs-number">1</span>, lst = x; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-keyword">if</span> (b[lst] * inv[i] % modp == d) &#123;res++;lst = i;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * res &gt;= n) &#123;ans = <span class="hljs-built_in">max</span>(ans, res);&#125;&#125; &#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 8 - J. ワンターフォゲール - gym102992D. Degree of SpanningTree】</p><p>题意：给你一张 <span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\(m\)</span>条边的无向图，你需要找到它的一个生成树，满足所有节点度数 <spanclass="math inline">\(\le \frac{n}{2}\)</span>。</p><p><span class="math inline">\(2 \le n \le 10^5\)</span>，<spanclass="math inline">\(n - 1\le m\le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>有正常做法，也有随机化做法，这里叙述后者。</p><p>我们先将所有边都连起来，尝试 dfs 找到一棵符合要求的生成树。</p><p>重复以下过程若干次： * 随机一个起点，开始 dfs。</p><ul><li><p>每到一个未经过的点 <span class="math inline">\(x\)</span>，将<span class="math inline">\(x\)</span> 的邻接边序列 shuffle一遍。</p></li><li><p>遍历邻接边序列，在 <span class="math inline">\(x\)</span>不超度数的情况下能连边就连边，递归到点 <spanclass="math inline">\(y\)</span>。</p></li><li><p>若遍历完所有点即找到一个连边方案。</p></li></ul><p>实测 <span class="math inline">\(50\)</span> 次就能AC。正确性最不好证明的一集。</p><p>时间复杂度 <span class="math inline">\(O(50n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<span class="hljs-type">int</span> x, y;cin &gt;&gt; x &gt;&gt; y;adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; ans;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;vis[x] = <span class="hljs-literal">true</span>;<span class="hljs-built_in">shuffle</span>(adj[x].<span class="hljs-built_in">begin</span>(), adj[x].<span class="hljs-built_in">end</span>(), rng);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;<span class="hljs-keyword">if</span> (vis[y] || deg[x] &gt;= n / <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;deg[x]++;deg[y]++;ans.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);<span class="hljs-built_in">self</span>(self, y);&#125;&#125;;<span class="hljs-type">int</span> test_case = <span class="hljs-number">100</span>;<span class="hljs-keyword">while</span> (test_case--) &#123;vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);deg.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);ans.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-built_in">rng</span>() % n + <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() == n - <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : ans) &#123;cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-keyword">return</span> ;&#125;&#125;cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="day-12">【7.19】 Day 12</h3><p>定了 9 点的闹钟，但经典下床继续睡。</p><p>中午在基础实验大楼一楼售货机买了一个面包一盒纯牛奶。鉴定为贪睡导致的。</p><p>下午是 psk 场，不知道会不会整什么花活（然而并没有）。</p><hr /><p>经典从 M倒序开题，我超，真是原。这题我怎么感觉在哪里见过啊？但没能想起来，悲。</p><p>手算了一下样例，发现样例都算不对。</p><p>跟榜过了三道签到。但 lyc 15min 过的 J我怎么签不出来鸭？第一感觉是直接横坐标 <spanclass="math inline">\(+1\)</span> 或纵坐标 <spanclass="math inline">\(+1\)</span>，狂wa，遂放着。</p><p>看榜 wbc 过了D，看了下题，感觉和第三场队内赛的某个题很像，都是中间夹了个回文串，抄了个manacher 就过了。</p><p>然后看 E，观察到一定是 <span class="math inline">\(1/3\)</span> 一组<span class="math inline">\(2\)</span>一组，就写了个二分图染色交了上去，怎么又 wa了鸭。再次确定了一下思路，又捏了几个边界情况，感觉都没问题，就直接对拍启动了。结果拍出来是我dfs 挂了，不是哥们？</p><p>继续看J，我超为什么不对呢？干脆又写了个对拍。马上拍出来了，原来不一定是端点旁边啊？那我不会了。</p><p>看榜 lyc 过了 G，看题这不是逆序对模板题吗？15min 秒了。</p><p>怎么 J 和 L 过了一堆了鸭。L 还是推不出样例，J画了几个图猜了个结论，又 wa。</p><p>红温了红温了红温了红温了红温了。直到赛后也没有过 J。</p><hr /><p>没有讲题，就去吃饭了。朝阳￥16 黑椒牛肉，还不错，三星半或者四星。</p><p>回 234 补题，但是头晕晕的，不知道什么时候就趴桌子上睡着了。醒来快 9点半了。</p><p>感觉一天什么都没做，倒是欠的题又多了一堆。</p><h3 id="day-13">【7.20】 Day 13</h3><p>没起，起了。</p><p>没吃，吃了。（精神错乱）</p><p>下午和 B 搏斗 3h，终于在最后把 B做出来了，排名鉴定为人口普查，唉。</p><hr /><div class="note note-info">            <p>【队内赛 10 - Being Meltdown - CF1516D. Cut】</p><p>题意：给定长度为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(\{a\}\)</span>，<spanclass="math inline">\(q\)</span> 次询问。每次询问一段区间 <spanclass="math inline">\([l,r]\)</span>，问至少要把这个区间分为几个子区间，才能使每个子区间的数的乘积等于这个子区间内所有数的<span class="math inline">\(\text{Lcm}\)</span>。</p><p><span class="math inline">\(1 \le n,q,a_i \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>区间乘积 <span class="math inline">\(=\)</span> 区间 <spanclass="math inline">\(\text{Lcm}\)</span> 即区间中的数两两互质。</p><p>那么对于每个询问只需要从左往右扫，如果加上这个数之后区间不满足两两互质，就新开另一个区间。</p><p>考虑优化这个过程，通过枚举质因数，可以预处理出 <spanclass="math inline">\(nxt_i\)</span> 代表 <spanclass="math inline">\(i\)</span> 后面第一个不和 <spanclass="math inline">\(a_i\)</span> 互质的数的位置。</p><p>那么一段区间两两互质等价于右端点是 <span class="math inline">\([l,r]\)</span> 中所有的 <span class="math inline">\(nxt_i-1\)</span> 取<span class="math inline">\(\min\)</span>。</p><p>具体地，令 <span class="math inline">\(dp_i\)</span> 代表以 <spanclass="math inline">\(i\)</span>为左端点时，下一个左端点的位置，即：<span class="math inline">\(dp_i =\min\limits_{j = i}^{nxt_i - 1}nxt_j\)</span>。这个式子可以用 st 表<span class="math inline">\(O(n\log n)\)</span> 预处理。</p><p>那么每次询问就可以不断跳到下一个左端点的位置，以求出区间数量。</p><p>套路化地，还可以倍增加速：令 <span class="math inline">\(dp_{i,j}\)</span> 代表 <span class="math inline">\(i\)</span> 后面第 <spanclass="math inline">\(2^j\)</span> 个左端点的位置。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>vector&lt;<span class="hljs-type">int</span>&gt; prime;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">not_prime</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span>(!not_prime[i]) &#123;prime.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j : prime) &#123;<span class="hljs-keyword">if</span> (i * j &gt; n) &#123;<span class="hljs-keyword">break</span>;&#125;not_prime[i * j] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SparseTable</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ST;<span class="hljs-built_in">SparseTable</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr) &#123;<span class="hljs-keyword">this</span>-&gt;n = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;ST.<span class="hljs-built_in">resize</span>(n <span class="hljs-number">+1</span> ,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;ST[i][<span class="hljs-number">0</span>] = arr[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= __lg(n); j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1LL</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++) &#123;ST[i][j] = <span class="hljs-built_in">min</span>(ST[i][j - <span class="hljs-number">1</span>], ST[i + (<span class="hljs-number">1LL</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-type">int</span> len = __lg(r - l + <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ST[l][len], ST[r - (<span class="hljs-number">1LL</span> &lt;&lt; len) + <span class="hljs-number">1</span>][len]);&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, q;cin &gt;&gt; n &gt;&gt; q;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-type">int</span> mx = *<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(mx + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-type">int</span> x = a[i];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : prime) &#123;<span class="hljs-keyword">if</span> (p * p &gt; x) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (x % p == <span class="hljs-number">0</span>) &#123;b[p].<span class="hljs-built_in">push_back</span>(i);<span class="hljs-keyword">while</span> (x % p == <span class="hljs-number">0</span>) &#123;x /= p;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;b[x].<span class="hljs-built_in">push_back</span>(i);&#125;&#125; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= mx; i++) &#123;<span class="hljs-keyword">if</span> (b[i].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; b[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j++) &#123;nxt[b[i][j]] = <span class="hljs-built_in">min</span>(nxt[b[i][j]], b[i][j + <span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-function">SparseTable <span class="hljs-title">st</span><span class="hljs-params">(nxt)</span></span>;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">3</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>))</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;dp[i][<span class="hljs-number">0</span>] = st.<span class="hljs-built_in">query</span>(i, <span class="hljs-built_in">min</span>(n, nxt[i] - <span class="hljs-number">1</span>));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">25</span>; j++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;dp[i][j] = dp[dp[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];&#125;&#125;<span class="hljs-keyword">while</span> (q--) &#123;<span class="hljs-type">int</span> l, r;cin &gt;&gt; l &gt;&gt; r;<span class="hljs-type">int</span> pos = l, res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-keyword">if</span> (dp[pos][i] &gt; <span class="hljs-number">0</span> &amp;&amp; dp[pos][i] &lt;= r) &#123;res += <span class="hljs-number">1</span> &lt;&lt; i;pos = dp[pos][i];&#125;&#125;cout &lt;&lt; res + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-built_in">init_phi</span>(<span class="hljs-number">1e5</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><p>晚上 atc，犯病了，E 拉了坨大的，后面发现只要把四周框起来就行了。</p><p>CF 继续犯病，D 很快就想到一行里黑色格子的数量大于 <spanclass="math inline">\(4\)</span> 就直接消行。但剩下的 <spanclass="math inline">\(n\times 4\)</span> 不会处理，脑子里一直想的状压dp，一行记作一个状态，结果转移直到比赛结束都没写出来。</p><hr /><div class="note note-info">            <p><a href="https://atcoder.jp/contests/abc363/tasks/abc363_e">E -Sinking Land (atcoder.jp)</a></p>          </div><div class="note note-success">            <p>新建一个超级源点，先用并查集把边框和源点连起来。那么从 <spanclass="math inline">\(1\sim Y\)</span>，依次遍历海拔高度为 <spanclass="math inline">\(i\)</span>的点，看其四周有没有海拔小于等于它的点，有就并起来，那么和源点并起来的点的个数就是被淹没的点的个数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;f[i] = i;siz[i] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;x = <span class="hljs-built_in">find</span>(x);y = <span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;<span class="hljs-built_in">swap</span>(x, y);&#125;siz[x] += siz[y];f[y] = x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n, m, t;cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;<span class="hljs-function">vector <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">2</span>))</span></span>;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">b</span>(t + <span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;cin &gt;&gt; a[i][j];<span class="hljs-keyword">if</span> (a[i][j] &lt;= t) &#123;b[a[i][j]].<span class="hljs-built_in">push_back</span>(&#123;i, j&#125;);&#125;&#125;&#125;<span class="hljs-type">int</span> S = (n + <span class="hljs-number">2</span>) * (m + <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(S)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m + <span class="hljs-number">2</span>; j++) &#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> || i == n + <span class="hljs-number">1</span> || j == m + <span class="hljs-number">1</span>) &#123;dsu.<span class="hljs-built_in">merge</span>(S, i * (m + <span class="hljs-number">2</span>) + j);&#125;&#125;&#125;<span class="hljs-type">int</span> init = dsu.<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>);<span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : b[i]) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<span class="hljs-type">int</span> xx = x + dx[j];<span class="hljs-type">int</span> yy = y + dy[j];<span class="hljs-keyword">if</span> (a[xx][yy] &lt;= a[x][y]) &#123;dsu.<span class="hljs-built_in">merge</span>(x * (m + <span class="hljs-number">2</span>) + y, xx * (m + <span class="hljs-number">2</span>) + yy);&#125;&#125;&#125;cout &lt;&lt; n * m - (dsu.<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) - init) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>题意：给定一个 <span class="math inline">\(n\times n\)</span>的网格，第 <span class="math inline">\(i\)</span> 行前 <spanclass="math inline">\(a_i\)</span>个格子是黑色，其余为白色。每一次操作可以选择将一行全部涂白或将一个 <spanclass="math inline">\(2\times 2\)</span>的区域全部涂白，问将所有格子涂白所需的最小操作次数。</p><p><span class="math inline">\(1 \le n \le 2\cdot 10^5\)</span>，<spanclass="math inline">\(0 \le a_i \le n\)</span>。</p>          </div><div class="note note-success">            <p>首先某一行如果有巨多黑色格子，直接运用第一种操作显然最佳。</p><p>第一个观察：若某行有大于 <span class="math inline">\(4\)</span>个黑色格子，直接整行涂白。</p><ul><li>证明：大于 <span class="math inline">\(4\)</span> 个格子，那么至少用<span class="math inline">\(3\)</span> 次 <spanclass="math inline">\(2\times 2\)</span>操作，最优情况将这一行连带下一行一起清理完，但如果用涂整行的操作的话仅用<span class="math inline">\(2\)</span> 次。</li></ul><p>现在问题变为了将 <span class="math inline">\(n\times 4\)</span>的矩阵涂白的最小操作次数。</p><p>考虑一个逐行的贪心，同时引出第二个观察：若某行剩余黑格数 <spanclass="math inline">\(&gt; 2\)</span>，直接整行涂白。</p><ul><li>证明：当剩余黑格数 <span class="math inline">\(&gt;2\)</span>时，说明该行一定没有被上一行连带消去过任何一个格子。此时用 <spanclass="math inline">\(2\times 2\)</span> 消除至少需要 <spanclass="math inline">\(2\)</span>次，最优情况将下一行连带清理完，仍然不如使用 <spanclass="math inline">\(2\)</span> 次整行涂白。</li></ul><p>综上，设 <code>flag = 0 / 1 / 2</code> 代表该行没被上一行连带消除<span class="math inline">\(/\)</span> 被连带消除了 <spanclass="math inline">\(1\sim2\)</span> 列的黑格 <spanclass="math inline">\(/\)</span> 被连带消除了 <spanclass="math inline">\(3\sim 4\)</span> 列的黑格，逐行贪心即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">4</span>) &#123;a[i] = <span class="hljs-number">0</span>;ans++;&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 1~2 cols have colored = 1</span><span class="hljs-comment">// 3~4 cols have colored = 2</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-keyword">if</span> (a[i] &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">continue</span>;&#125;ans++;<span class="hljs-keyword">if</span> (a[i] &lt;= <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span> (flag[i] == <span class="hljs-number">1</span>) &#123;flag[i + <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;a[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<span class="hljs-number">2ll</span>, a[i + <span class="hljs-number">1</span>]);&#125; <span class="hljs-keyword">else</span>  &#123;flag[i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;a[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">2</span>;&#125;&#125;&#125;cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><h3 id="day-14">【7.21】 Day 14</h3><p>难得的周末，但是在睡梦中度过了。</p><p>我越来越喜欢睡觉了，只是有时候事情积压的太多了，只能熬夜去赶进度。</p><p>梦里什么都有，只是上一次做梦些许是半个月之前了。梦到了知更鸟，以及一些散装的小剧场。</p><p>网上有一种说法是人每次睡觉都会做梦，只是回想不起来罢了。</p><p>也许是记忆被抹杀才带来的孤独。</p><p>下午才醒，不是很想动，感觉训练对我作用不大，我的智商就摆在这里了。</p><p>越来越菜了，高中我也何尝不是这样呢？暑假一轮只剩一周，也许到最后没比赛打，没人愿意和我组队，甚至队都没进。</p><p>我努力过了吗？努力的时候不敢说自己努力了，不努力的时候也不敢说自己什么都没干。这么问也就显得乏之无味。</p><p>对不起很多人，集训队的大家，青柠工作室，以及嵌入式工作室的大家，他们都很看好我，但我就像不谙世事的孩子一样，又时不时吐露出自己悲哀的那一面。</p><p>翻了个身，之后又联想到很多心酸的事实，旁人的责备，又或者是 galgame里的一段刀子，就像走马灯一样。</p><p>当一个人濒临崩溃的时候，它会想些什么呢？</p><p>啜泣，心绞痛，干脆继续睡了过去。</p><p>希望有羽毛和翅膀。</p><hr /><h3 id="day-15">【7.22】 Day 15</h3><p>昨晚直接在基础实验大楼睡了。11 点 30 有人推门我就醒了。</p><p>午饭又没吃，是不是只要 5h 场就没吃过午饭，好像真是。</p><hr /><p>下午队内赛，很奇怪的场，怎么我每题必 wa，真是病入膏肓了鸭。</p><p>开局 L，我用二进制考虑，结果卡壳了，遂看其它的。</p><p>开了三题怎么用了一个多小时啊，最慢的一集。感觉自己状态有问题，情绪被影响了，打字都很佛系。</p><p>再开C，wa，稍微用力的想了下，红温之后想到负数会出问题，加了个判断过了。</p><p>L 也会了，宏观的考虑先一直乘 <spanclass="math inline">\(2\)</span>，看需要减多少，再分配到前面乘 <spanclass="math inline">\(2\)</span> 的操作之间。</p><p>然后开始博弈，上次博弈挂完了，想雪耻。</p><p>雪耻失败了，两个小时没做出博弈，只想到 <spanclass="math inline">\(n\le 3\)</span> 怎么做，<spanclass="math inline">\(n\)</span> 大了脑子就转不动了。</p><p>完败，还好后面红温了也能看清 K，写了个最短路就过了。</p><hr /><p>晚上直接在 234 点了外卖，焖饼炒鸡！一般，三星半。</p><div class="note note-info">            <p>【队内赛 11E - gym105161K. Number Deletion Game】</p><p>题意：给定 <span class="math inline">\(n\)</span> 堆石子，第 <spanclass="math inline">\(i\)</span> 堆数量 <spanclass="math inline">\(a_i\)</span>。两名玩家博弈，每轮玩家可以选择拿走最多的一堆石子中的任意个，无法操作则判输。问先手是否有必胜策略。</p>          </div><div class="note note-success">            <p>典题。结论是：<span class="math inline">\(a_i\)</span>最大值出现奇数次，先手胜；否则后手胜。</p><p>证明使用归纳法： * <span class="math inline">\(\max =1\)</span>，显然成立。</p><ul><li>设对 <span class="math inline">\(\max =1\sim k\)</span> 成立，则对<span class="math inline">\(\max= k+1\)</span>：<ul><li><p>若 <span class="math inline">\(k+1\)</span>出现奇数次，则操作最后一个 <span class="math inline">\(k+1\)</span>的是先手。先手可以决定次大值出现偶数次，这样后手输，先手胜。</p></li><li><p>若 <span class="math inline">\(k+1\)</span>出现偶数次，则操作最后一个 <span class="math inline">\(k+1\)</span>的是后手，同理后手胜。</p></li><li><p>故结论对 <span class="math inline">\(\max=k+1\)</span>成立，于是对最大值为任意正整数都成立，证毕。</p></li></ul></li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;cin &gt;&gt; a[i];&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, j = n - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j - <span class="hljs-number">1</span>] == a[n - <span class="hljs-number">1</span>]) &#123;j--;cnt++;&#125;<span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) &#123;cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 11J - CF730J. Bottles】</p><p>题意：有 <span class="math inline">\(n\)</span> 瓶水，第 <spanclass="math inline">\(i\)</span> 瓶水的水量为 <spanclass="math inline">\(a_i\)</span>，容量为 <spanclass="math inline">\(b_i\)</span>。将 <spanclass="math inline">\(1\)</span>单位水从一个瓶子转移到另一个瓶子所消耗时间为 <spanclass="math inline">\(1\)</span>秒，且可以进行无限次转移。求储存所有水所需最小瓶子数 <spanclass="math inline">\(k\)</span> 以及该情况下所用最小时间 <spanclass="math inline">\(t\)</span>。</p><p><span class="math inline">\(1 \le n, a_i, b_i \le 100\)</span>。</p>          </div><div class="note note-success">            <p><span class="math inline">\(k\)</span>比较简单，将容量降序排序，之后按顺序取到 <spanclass="math inline">\(\min\limits_{k}\sum\limits_{i=1}^{k}b_i \ge \suma_i\)</span> 即可。</p><p>对于求最小时间 <span class="math inline">\(t\)</span>，可以转化为在这<span class="math inline">\(n\)</span> 个瓶中取 <spanclass="math inline">\(k\)</span>个瓶，使得剩余瓶子的水量之和最小，也就是使这 <spanclass="math inline">\(k\)</span> 个瓶的水量之和最大。</p><p>这是经典的 <span class="math inline">\(01\)</span> 背包问题，令 <spanclass="math inline">\(dp[i][j][s]\)</span> 代表前 <spanclass="math inline">\(i\)</span> 个瓶中选了 <spanclass="math inline">\(j\)</span> 个瓶，容量之和为 <spanclass="math inline">\(s\)</span> 时的最大水量，则： <spanclass="math display">\[dp[i][j][s] = \max(dp[i-1][j][s], dp[i-1][j-1][s-b_i]+a_i)\]</span> 其中第一维可以滚动，或者倒序枚举压缩掉。</p><p>时间复杂度 <span class="math inline">\(O(n^4)\)</span>，空间复杂度<span class="math inline">\(O(n^3)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<span class="hljs-type">int</span> water, vol;<span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;<span class="hljs-keyword">return</span> a.vol &gt; b.vol;&#125;;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n;cin &gt;&gt; n;<span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-type">int</span> sum_water = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i].water;sum_water += a[i].water;&#125;<span class="hljs-type">int</span> sum_vol = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;cin &gt;&gt; a[i].vol;sum_vol += a[i].vol;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> ans1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;sum += a[i].vol;<span class="hljs-keyword">if</span> (sum &gt;= sum_water) &#123;ans1 = i;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(ans1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(sum_vol + <span class="hljs-number">1</span>, -inf))</span></span>;dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = ans1; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = sum_vol; k &gt;= a[i].vol; k--) &#123;dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j - <span class="hljs-number">1</span>][k - a[i].vol] + a[i].water);&#125;&#125;&#125;<span class="hljs-type">int</span> ans2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sum_water; i &lt;= sum_vol; i++) &#123;ans2 = <span class="hljs-built_in">max</span>(ans2, dp[ans1][i]);&#125;cout &lt;&lt; ans1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; sum_water - ans2 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><hr /><div class="note note-info">            <p>【队内赛 11D - gym105161B. Area of the Devil】</p><p>题意：给一个半径为 <span class="math inline">\(r\)</span>的圆上的五段不相交的圆弧，从每个圆弧依次选择一个点然后按顺序连成一个五角星，求五角星的面积并。</p><p><span class="math inline">\(1\le T \le 10^4\)</span>，<spanclass="math inline">\(1 \le r \le 10^3\)</span>。</p>          </div><div class="note note-success">            <p>如下图。我们用整个圆的面积减去五个（小三角 <spanclass="math inline">\(+\)</span> 弓形）的面积即可。</p><p>令 <span class="math inline">\(A_{is}\)</span> 代表第 <spanclass="math inline">\(i\)</span> 段圆弧的极角最小点，<spanclass="math inline">\(A_{it}\)</span> 代表第 <spanclass="math inline">\(i\)</span> 段圆弧的极角最大点。</p><p>以 <span class="math inline">\(\Delta A_{1s}B_{1}A_{5t}\)</span>为例，<span class="math inline">\(B_1\)</span> 可以通过直线 <spanclass="math inline">\(A_{2s}A_{5t}\)</span> 和 <spanclass="math inline">\(A_{1s}A_{4t}\)</span>求交点得到。知道了三角形三个点的坐标，利用叉积公式即可求得面积。</p><p>弓形 <spanclass="math inline">\(\overset{\frown}{A_{1s}A_{5t}}\)</span> 也等价于<span class="math inline">\(S_{\text{扇形}OA_{1s}A_{5t}} - S_{\DeltaOA_{1s}A_{5t}}\)</span>。</p><p><img src="https://kisuraop.github.io/image/academic/31.png"alt="1" /> 时间复杂度 <span class="math inline">\(O(T)\)</span>。</p><p>值得注意的是，使用叉积公式时不需要加绝对值，因为我们求的是有向面积。</p><p>如下图（可爱的 xing4c画出来的！），当出现优弧时，阴影部分的面积应该被加上而不是减去。</p><figure><img src="https://kisuraop.github.io/image/academic/32.png"alt="xing4c" /><figcaption aria-hidden="true">xing4c</figcaption></figure>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pi acos(-1)</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    T x, y;    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;        Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;        x += p.x;        y += p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;        x -= p.x;        y -= p.y;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;        x *= v;        y *= v;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a += b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a -= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;        <span class="hljs-keyword">return</span> a *= b;    &#125;    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;        <span class="hljs-keyword">return</span> b *= a;    &#125;    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;    Point&lt;T&gt; a, b;    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">lineIntersection</span><span class="hljs-params">(Line&lt;T&gt; l1, Line&lt;T&gt; l2)</span> </span>&#123;    <span class="hljs-keyword">return</span> l<span class="hljs-number">1.</span>a + (l<span class="hljs-number">1.</span>b - l<span class="hljs-number">1.</span>a) *     (<span class="hljs-built_in">cross</span>(l<span class="hljs-number">2.</span>b - l<span class="hljs-number">2.</span>a, l<span class="hljs-number">1.</span>a - l<span class="hljs-number">2.</span>a) /      <span class="hljs-built_in">cross</span>(l<span class="hljs-number">2.</span>b - l<span class="hljs-number">2.</span>a, l<span class="hljs-number">1.</span>a - l<span class="hljs-number">1.</span>b));&#125;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(vector&lt;Point&lt;T&gt;&gt; a)</span> </span>&#123;    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();    <span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        res += <span class="hljs-built_in">cross</span>(a[i], a[(i + <span class="hljs-number">1</span>) % n]);    &#125;    res /= <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">/*ooooooooooooooooooooo</span><span class="hljs-comment">o   templates above   o</span><span class="hljs-comment">oooooooooooooooooooooo*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> r;cin &gt;&gt; r;vector&lt;Point&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">5</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">5</span>);<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ori_a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">ori_b</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;cin &gt;&gt; ori_a[i];<span class="hljs-type">double</span> x = r * <span class="hljs-built_in">cos</span>((<span class="hljs-number">1.0</span> * ori_a[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);<span class="hljs-type">double</span> y = r * <span class="hljs-built_in">sin</span>((<span class="hljs-number">1.0</span> * ori_a[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);a[i] = &#123;x, y&#125;;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;cin &gt;&gt; ori_b[i];<span class="hljs-type">double</span> x = r * <span class="hljs-built_in">cos</span>((<span class="hljs-number">1.0</span> * ori_b[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);<span class="hljs-type">double</span> y = r * <span class="hljs-built_in">sin</span>((<span class="hljs-number">1.0</span> * ori_b[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);b[i] = &#123;x, y&#125;;&#125;<span class="hljs-type">double</span> circle = <span class="hljs-number">1.0</span> * r * r * pi;<span class="hljs-type">double</span> res = circle;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l1</span><span class="hljs-params">(&#123;a[i], b[(i + <span class="hljs-number">3</span>) % <span class="hljs-number">5</span>]&#125;)</span></span>;<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l2</span><span class="hljs-params">(&#123;a[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>], b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>]&#125;)</span></span>;Point&lt;<span class="hljs-type">double</span>&gt; p = <span class="hljs-built_in">lineIntersection</span>(l1, l2);res -= <span class="hljs-built_in">area</span>(vector&#123;p, b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>], a[i]&#125;);res -= (circle * ((ori_a[i] - ori_b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>] + <span class="hljs-number">360</span>) % <span class="hljs-number">360</span>) / <span class="hljs-number">360</span>) - <span class="hljs-built_in">area</span>(vector&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>], a[i]&#125;);&#125;cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>) &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">fre</span>(test);ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-type">int</span> T;cin &gt;&gt; T;<span class="hljs-keyword">while</span> (T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><hr /><div class="note note-primary">            <h4 id="后缀自动机sam小记">后缀自动机（SAM）小记</h4><ul><li>架构<ul><li><p>不包含后缀链接时是一张有向无环图。</p></li><li><p>至多 <span class="math inline">\(2n-1\)</span> 个点，<spanclass="math inline">\(3n-4\)</span> 条边。</p></li><li><p>在线的线性算法。</p></li></ul></li><li>Endpos<ul><li><p><span class="math inline">\(\text{endpos}\)</span> 是子串在 <spanclass="math inline">\(S\)</span> 中结束位置的集合，<spanclass="math inline">\(\text{endpos}\)</span>相等的子串归为一个等价类。</p></li><li><p>图上到达该节点的所有路径构成了以该等价类为结尾的所有后缀子串。</p></li><li><p>最长的子串称作 <spanclass="math inline">\(\text{longest(x)}\)</span>，将 <spanclass="math inline">\(\text{endpos}\)</span>等价类中的子串按长度从大到小排序得到了 <spanclass="math inline">\(\text{longest(x)}\)</span>长度连续的后缀。</p></li><li><p>原串的每个前缀都是 <spanclass="math inline">\(\text{longest}\)</span>。</p></li></ul></li><li>Link<ul><li><p>一个状态的 <span class="math inline">\(x\)</span> 的 <spanclass="math inline">\(\text{link(x)}\)</span> 连接到最长的后缀 <spanclass="math inline">\(y\)</span>，满足 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 拥有属于不同等价类。</p></li><li><p>如果满足条件的后缀是空串，会直接连向起始节点。</p></li><li><p>SAM 维护的三个信息：<spanclass="math inline">\(\text{longest(x)}\)</span> 的长度 <spanclass="math inline">\(\text{len(x)}\)</span>，后缀链接 <spanclass="math inline">\(\text{link(x)}\)</span>，转移 <spanclass="math inline">\(\text{nxt(x, c)}\)</span>。</p></li><li><p>节点和 <span class="math inline">\(\text{link}\)</span>构成一棵树，称作 <span class="math inline">\(\text{parent}\)</span>树。</p></li></ul></li><li>构建<ul><li><p>每插入 <span class="math inline">\(c\)</span>一定会出现一个新的状态（设为 <spanclass="math inline">\(\text{cur}\)</span>），且一定是 <spanclass="math inline">\(\text{longest(lst)}+c =\text{longest(cur)}\)</span>。</p></li><li><p>开始时 <span class="math inline">\(\text{cur}\)</span>只有一个串。让指针从 <span class="math inline">\(\text{lst}\)</span>开始，通过 <span class="math inline">\(\text{link}\)</span>往起点的方向跳。对于路径上的状态 <spanclass="math inline">\(\text{p}\)</span>，如果没有 <spanclass="math inline">\(\text{nxt(p, c)}\)</span> 的转移，那么 <spanclass="math inline">\(\text{nxt(p, c) = cur}\)</span>。</p></li><li><p>因为 <span class="math inline">\(\text{link}\)</span> 指向的都是<span class="math inline">\(\text{longest}\)</span>的后缀，所以自然构成新的子串。</p></li><li><p>如果已经存在转移，设当前状态为 <spanclass="math inline">\(\text{p}\)</span>，<spanclass="math inline">\(\text{q=nxt(p,c)}\)</span>，存在两种情况：</p><ul><li><p>若 <spanclass="math inline">\(\text{len(q)=len(p)+1}\)</span>，说明 <spanclass="math inline">\(\text{q}\)</span> 中最长的字符串一定是 <spanclass="math inline">\(\text{longest(p)+c}\)</span>，故连 <spanclass="math inline">\(\text{link(cur)=q}\)</span>，退出。</p></li><li><p>否则把 <span class="math inline">\(\text{q}\)</span>拷贝到一个新状态 <spanclass="math inline">\(\text{clone}\)</span>，<spanclass="math inline">\(\text{clone}\)</span> 拥有 <spanclass="math inline">\(\text{link(q)}\)</span> 以及 <spanclass="math inline">\(q\)</span> 所有的出边。令 <spanclass="math inline">\(\text{link(clone)=link(p)+1}\)</span>，再把 <spanclass="math inline">\(\text{q}\)</span> 和 <spanclass="math inline">\(\text{cur}\)</span> 都 <spanclass="math inline">\(\text{link}\)</span> 到这个点。</p></li><li><p>继续从 <span class="math inline">\(\text{p}\)</span> 向起点跳<span class="math inline">\(\text{link}\)</span>，若存在指向 <spanclass="math inline">\(\text{q}\)</span> 的出边，改成指向 <spanclass="math inline">\(\text{clone}\)</span>；否则退出。</p></li><li><p>这么做是因为 <span class="math inline">\(\text{q}\)</span>原来就存在，但我们不清楚 <span class="math inline">\(\text{q}\)</span>的最长串是不是 <spanclass="math inline">\(\text{longest(p)+c}\)</span>，于是将 <spanclass="math inline">\(\text{longest(p)+c}\)</span> 和其在 <spanclass="math inline">\(\text{q}\)</span>中的后缀单独拿出来，形成一个新的节点 <spanclass="math inline">\(\text{clone}\)</span>，以满足 <spanclass="math inline">\(\text{link(cur)}\)</span> 的要求。</p></li></ul></li></ul></li></ul>          </div><h3 id="day-16">【7.23】 Day 16</h3><p>要结束了啊，希望今天队内赛能打好一点。</p><p>rating 已经排到 20名开外了，脑子再不发力就真寄了，脑子给点力哇qwq。</p><hr /><p>队内赛12，开题最慢的一次，不是怎么大家都会勾股数？输！</p><p>注意到了当 <span class="math inline">\(a\)</span> 是质数的时候 <spanclass="math inline">\(b,c\)</span> 一定连续，交！wa！</p><p>受不了了跟榜看 b，还好是一个简单二分，要不然 1h 过不了一题（</p><p>继续看勾股数，不是所有数质因数分解都能有解，比如 <spanclass="math inline">\(2\)</span> 就没有一组解，又不会了。</p><p>继续看榜，K 中位数很有意思，map 搞了一下过了。G，H 都 wa2，2h了，急急急。</p><p>F 有一个人过了，我一看，我趣！这不跑两遍就行了吗，这么简单竟然 2h才开出来，G 加了特判也过了。</p><p>然后终于会勾股数了，特判了一组 <code>8 15 17</code>，<spanclass="math inline">\(8\)</span> 之后 <spanclass="math inline">\(2\)</span> 的倍数都这么搞。</p><p>H 是个分类讨论，wa119，红温！拍！成了！但改了好久。你说得对但 M怎么一直过不了鸭。</p><p>赛后在群里说，感觉做法没什么问题。结果 wbc 一眼看出我用<code>lower_bound</code> 搜了一个无序的数组，尼玛！</p><div class="note note-warning">            <p><code>std::lower_bound</code> 需要保证数组有序。</p><p><code>std::erase(std::vector)</code>就算你指定了在迭代器的哪个位置，删除也是线性的！</p>          </div><hr /><p>晚上本来想在 234 打 CF 的，外卖都直接点到了 234，暴暴锅好吃捏。</p><p>但太累了，支持不住，还是回宿舍睡了。</p><hr /><p>快进到赛后，稳定汤碗。</p><p>B2 做了 90min，原来是模拟题，乐。</p><p>如果不看 B2 直接看 C 分都会高很多，掐点过样例，气得睡不着觉。</p><p>但还是睡了，因为感觉总是上午 11 点起有点那啥了，还是得调整一下。</p><hr /><h3 id="day-17">【7.24】 Day 17</h3><p>8 点下床，怎么又睡了？？不过好在 9 点醒了，不算荒废了很多。</p><p>这几天要开始学字符串，学几何，写专题了。毕竟专题不做个五六道真进不了队了。</p><p>时间紧，直接把补题停了。</p><p>所以之后几天你只能在这篇文章里看到流水账了（专题解题报告可能也会发到博客上，不过一轮结束前不能够公开。</p><p>中午朝阳，鸡扒饭，出品很稳定啊，四星。</p><hr /><p>下午队内赛 13，开局怎么这么顺，上一次 1h过四题不知道是什么时候了。</p><p>心里正乐着结果 J 又开始了，wa3，wa5，wa9，wa11，wa27。</p><p>爆了，去看 K，类似生命游戏。直接广搜，搜完发现读错题了，我以为是“周围有不同颜色的块就变化”。</p><p>于是看 H，裸 meet in the middle，一发过。然后 K 发现改一下就行。</p><p>J 继续红温，感觉交了得有二十多发。转向C，写了个割边构造，wa8，没救了！</p><p>继续交 J，三十多发了，寄！</p><hr /><p>赛后听芙兰朵和小武说看我代码看乐了，然后才知道我二分图判定直接退出会导致同一个连通块搜两遍。</p><p>啊，红温了红温了红温了红温了红温了红温了红温了红温了红温了红温了。</p><p>于是和可爱的 xing4c 去汉堡王降温，爽点，爽吃。</p><p>菠萝派真的好好吃鸭，还点了个可可味的派，也好吃！</p><p>晚上宿舍睡了，然后 10 点多爬起来洗了个澡，看专题。</p><h3 id="后日谈">【7.28】后日谈</h3><p>真的结束了啊？想起 7.8 的时候还在为暑假哀悼，一转眼就到尾声了。</p><p>当然，指的是一轮集训。能否进得了二轮还有待商榷，负责人把最关键的Rating 排名藏起来了，真是趣味呢。</p><p>尝试回忆我经历了什么，第一个想到的就是群主 xcy。</p><p>他很贴心，可爱，好说话。集训的时候有一天我因为个人原因没有去，他就来宿舍找我；我听讲座他下来看我，我跟他抱怨除了第一题都没听懂，他也安慰我慢慢来。</p><p>也许很多年之后别人问我暑假集训是怎么样的，我也只能说上来这些。</p><p>毕竟学到了什么知识，谁讲课讲的特别好，谁的 PPT又做得根屎一样，都经不住时间的冲刷。</p><p>也正是因为这样，记录才有记录的价值。就比如讲课讲得特别好的，徐神，包大✌，vingying，这些都能脱口而出。讲得烂的，啊这是能说的吗？前文已经有了，这里就不重复提了（真没有贬低的意思）。然后队内赛打得牛的，lyc，czz，rzy。尤其lyc 鸭，经常被 2n，照这个进步速度估计明年就和银牌✌组队了啊！</p><p>此外，能想起来的就是集训队的大家。为什么这么说，因为我虽然线下唯唯诺诺，但是事<del>水群糕手</del>。真的是这样，水群水的多，就能记得住集训队的大伙。大伙喜欢什么，爱看什么，经常说什么话，最后都会变成回忆的一部分。</p><p>说回集训，时间安排还是十分紧密的。这篇博客本身就能看出很多东西，就比如我不知不觉埋了各式各样的坑，几周前说的“明天再补吧”或许今天都没能补的上。但与其说紧吧，感觉也没那么阴沉，因为算法本身我认为就是充满乐趣的。就算我没能进队，我也会继续打CF，明年暑假集训我还能继续陪跑。</p><p>然后不得不说的就是舍友了，jbx，xjj，还有everflame。因为都是沙河的，所以也聊得来，队内赛打得不好，CF打挂了都可以相互抱怨，有什么八卦也都可以图一乐。</p><p>真的结束了吗？</p><hr /><p><span class="math display">\[\begin{align}&amp;\color{Rhodamine}無くなったのか　始まったのか分からないけど\\&amp;\color{Cerulean}究竟是失去还是开始\\\\&amp;\color{Rhodamine}行くしか方法は無いんだろう？\\&amp;\color{Cerulean}可除了前进也没有其它办法了吧？\\\\&amp;\color{Rhodamine}正解がなんだ　価値なんて無いんだ\\&amp;\color{Cerulean}正确答案是什么 \ \ 毫无价值可言\\\\&amp;\color{Rhodamine}あたしは生涯　あたし以外じゃ生きられないよ\\&amp;\color{Cerulean}我终其一生 \ \ 都无法活成别人的模样\\\\&amp;\color{Rhodamine}これ以上かき乱しても明日はない\\&amp;\color{Cerulean}哪怕将一切颠覆搅乱仍不会迎来明天\\\\&amp;\color{Rhodamine}どう足掻いても明日はない\\&amp;\color{Cerulean}如何竭力挣扎都不会迎来明天\\\\&amp;\qquad\qquad\qquad\qquad——\small \text{ GIRLS BANDCRY}\normalsize《空の箱\normalsize》\end{align}\]</span></p><hr /><p>UPD：进队了！不知道是不是被群巨捞了QAQ</p><p>队友是可爱的 <ahref="https://codeforces.com/profile/everflame">everflame</a> 和可爱的<a href="https://codeforces.com/profile/nicnaknic">nicnaknic</a>，队名是UESTC_EndlessEmbrace！</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> UESTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NNSZCP2023】南宁三中第13届科技文化节程序设计竞赛 G,H,I</title>
      <link href="/posts/996d8e6.html"/>
      <url>/posts/996d8e6.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://kisuraop.github.io/image/nnsz/1.jpg"><imgsrc="https://kisuraop.github.io/image/nnsz/1.jpg" /></a></p><p><a href="https://kisuraop.github.io/image/nnsz/2.jpg"><imgsrc="https://kisuraop.github.io/image/nnsz/2.jpg" /></a></p><h2 id="闲话">闲话</h2><p>比赛的前一天下午听<ahref="https://www.luogu.com.cn/user/137242">NNSZ捞王</a>说明天母校要办比赛，后面再打听说还是<span class="math inline">\(\text{IOI}\)</span>赛制，很快啊，马上就来捧场了。</p><p>明明才毕业不到半年，就已经要用“母校”称呼了，真是令人感慨。</p><p>比赛快开始的时候跟 <span class="math inline">\(\text{hdm}\)</span>要了账号，感觉上次打 <span class="math inline">\(\text{OI}\)</span>还是在不久前（实际已经退役一年半了），又感慨了一下。</p><p>赛题质量高得出乎意料，尤其是最后几题。我曾经也办过三场 <spanclass="math inline">\(\text{EdenRound}\)</span>，知道每一道原创题背后的付出远比表面看上去要多，所以赛后还是很欣喜的。</p><p>题是好，但时间真的太仓促了，<spanclass="math inline">\(\text{I}\)</span>题刚出了思路，比赛啪的一下就结束了，<spanclass="math inline">\(\text{3h}\)</span>的时间感觉真对不起这些题。不过后来看了终榜才发现来比赛的基本都是初学者，那也怪不得。</p><p>赛时前半段状态不是很好，前 <span class="math inline">\(6\)</span>题签了大概 <span class="math inline">\(90\min\)</span>（主要 <spanclass="math inline">\(\text{C}\)</span> 题题意想岔了浪费了 <spanclass="math inline">\(20\)</span> 来分钟，<spanclass="math inline">\(\text{D}\)</span>题又愣了一下才推出来）。后面一个半小时也只是做了两题，不过已经相当满意了。因为上次写换根<span class="math inline">\(\text{dp}\)</span>都不知道是几年前了，能调出来说明脑子还是稍微能动的。<spanclass="math inline">\(\text{J}\)</span> 题看了一眼就爆炸了，所以做完<span class="math inline">\(\text{H}\)</span> 之后都在想 <spanclass="math inline">\(\text{I}\)</span>。没注意到 <spanclass="math inline">\(2\)</span>的幂次的奇偶性，还以为是一堆线段的容斥，把每种同余情况列成了一个表，感觉是<span class="math inline">\(\text{2-SAT}\)</span>+线段树优化建图类物，赛后发现对了一半。<spanclass="math inline">\(\text{GHI}\)</span>三题我都觉得很棒，就写了题解放在下面，加深一下印象。</p><p>希望能参加下一次，如果还能有的话）</p><p>我们 <span class="math inline">\(01\)</span>社正在蒸蒸日上啊！（无贬义</p><h2 id="g.-排序算法">G. 排序算法</h2><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a_i\)</span>。</p><p>判断以下算法是否能将 <span class="math inline">\(a\)</span>排序为严格不下降序列。</p><p>若能，输出 <code>std::swap(a[i],a[j])</code> 的执行次数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)        <span class="hljs-keyword">if</span> (a[i] &lt; a[j])             std::<span class="hljs-built_in">swap</span>(a[i], a[j]);</code></pre></div><p><span class="math inline">\(1\le n\le 2 \cdot 10^5\)</span>，<spanclass="math inline">\(1\le a_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>考察直观想象，样例那个 <code>5 4 3 2 1</code>给的就很不错，手推一下就能发现性质。</p><p>首先算法一定是正确的，外层执行完 <spanclass="math inline">\(i\)</span> 时，<spanclass="math inline">\(a_i\)</span> 必定是 <spanclass="math inline">\(i\)</span>前缀的最大值，且第一轮循环已经把序列最大值放到了 <spanclass="math inline">\(a_1\)</span>，那么当 <spanclass="math inline">\(j&gt;i\)</span> 时也不会出现 <spanclass="math inline">\(a_i&lt;a_j\)</span> 的情况，即不会交换。</p><p>那么我们只需要计算 <span class="math inline">\(i\)</span>前缀的贡献，不难发现这个值是前缀中比 <spanclass="math inline">\(a_i\)</span> 大的不同元素的个数。</p><p>用一个支持插入元素和查询大于某个元素的不同元素个数的数据结构维护：树状数组、线段树和平衡树都是不错的选择。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) puts(x);return ;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fenwick</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; tr;<span class="hljs-built_in">Fenwick</span>() &#123;&#125;<span class="hljs-built_in">Fenwick</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n<span class="hljs-number">+1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-keyword">this</span>-&gt;n = n;tr.<span class="hljs-built_in">assign</span>(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">while</span>(pos&lt;=n)&#123;tr[pos]+=x;pos+=pos&amp;-pos;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(pos)&#123;res+=tr[pos];pos-=pos&amp;-pos;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r)-<span class="hljs-built_in">sum</span>(l<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">// tr[x] count the cnt of x</span><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;res+=(<span class="hljs-number">1</span>&lt;&lt;i);<span class="hljs-keyword">if</span>(res&gt;n || cnt+tr[res]&gt;=k)&#123;res-=(<span class="hljs-number">1</span>&lt;&lt;i);&#125; <span class="hljs-keyword">else</span> &#123;cnt+=tr[res];&#125;&#125;<span class="hljs-keyword">return</span> res<span class="hljs-number">+1</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();b[i]=a[i];&#125;<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());b.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>()),b.<span class="hljs-built_in">end</span>());map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pos;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;b.<span class="hljs-built_in">size</span>();++i) &#123;pos[b[i]]=i;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;a[<span class="hljs-number">1</span>]) &#123;++ans;<span class="hljs-built_in">swap</span>(a[i],a[<span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-function">Fenwick <span class="hljs-title">fen</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans+=tot-fen.<span class="hljs-built_in">sum</span>(pos[a[i]]);<span class="hljs-keyword">if</span>(!vis[pos[a[i]]]) &#123;vis[pos[a[i]]]=<span class="hljs-literal">true</span>;tot++;fen.<span class="hljs-built_in">add</span>(pos[a[i]],<span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="h.-购买车券">H. 购买车券</h2><div class="note note-info">            <p>题意：给定一棵 <span class="math inline">\(n\)</span>个点的无根树，每次删去一个叶子节点（指上一次操作后度数不大于 <spanclass="math inline">\(1\)</span>的节点），直至删空。问合法的操作序列数。操作序列不同，当且仅当某一次删去的叶子节点不同。</p><p><span class="math inline">\(1\le n\le 2\cdot 10^5\)</span>。</p>          </div><div class="note note-success">            <p>换根 <span class="math inline">\(\text{dp}\)</span>。先计算一个根<span class="math inline">\(x\)</span> 的结果（即 <spanclass="math inline">\(x\)</span> 最后才删的方案数）<spanclass="math inline">\(dp_x\)</span>，再转移，答案就是 <spanclass="math inline">\(\sum dp_x\)</span>。</p><p>第一遍 <spanclass="math inline">\(\text{dfs}\)</span>，对于当前子树和其它子树的状态合并（即一段操作序列插到另一端操作序列中），其实就是一个多重集的排列：具体的，两段长分别为<span class="math inline">\(n,m\)</span>的序列相互插（元素互不相同），相当于 <spanclass="math inline">\(n\)</span> 个无区别球放入 <spanclass="math inline">\(m\)</span> 个有区别盒子且允许空盒，即能形成 <spanclass="math inline">\(C_{m+n-1}^{n}\)</span> 种序列（<ahref="https://kisuraop.github.io/posts/f9da5f78.html#j.-ihis-homework">参考this</a>）。</p><p>用 <span class="math inline">\(sz_x\)</span> 表示 <spanclass="math inline">\(x\)</span> 的子树大小，那么对于 <spanclass="math inline">\(x\)</span> 的一个儿子 <spanclass="math inline">\(y\)</span>，这里 <spanclass="math inline">\(n,m\)</span> 就分别是 <spanclass="math inline">\(sz_{y}\)</span> 和 <spanclass="math inline">\(sz_{x}-sz_y\)</span>，状态转移可以写成： <spanclass="math display">\[dp_x=\prod\limits_{y\in son_x} \bigg[\binom{sz_x-1}{sz_y}dp_y\bigg]\]</span></p><p>第二遍 <span class="math inline">\(\text{dfs}\)</span>，考虑将根从<span class="math inline">\(x\)</span> 转移到 <spanclass="math inline">\(y\)</span>，此时序列 <spanclass="math inline">\(n\)</span> 中的一个节点跑到了 <spanclass="math inline">\(m\)</span> 中，即： <span class="math display">\[sz_y\rightarrow sz_y-1\]</span></p><p><span class="math display">\[sz_x-sz_y\rightarrow sz_x-sz_y+1\]</span></p><p>也可以根据 <span class="math inline">\(C_{m+n-1}^{n}\)</span>的结构得知：底数 <span class="math inline">\(m,n\)</span>一加一减抵消，贡献就从 <spanclass="math inline">\(\binom{n-1}{sz_y}\rightarrow\binom{n-1}{sz_y-1}\)</span>。</p><p>那么转移可以写成： <span class="math display">\[dp_y=dp_x\cdot\frac{\binom{n-1}{sz_y-1}}{\binom{n-1}{sz_y}}=dp_x\cdot\frac{sz_y}{n-sz_y}\]</span></p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) puts(x);return ;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;    <span class="hljs-type">int</span> x;    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == a.x; &#125;;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x != a.x; &#125;;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * y * a.x % mod);&#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(y) / a;&#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="hljs-keyword">return</span> is &gt;&gt; t.x;&#125;    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;            mul *= mul;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (b) &#123;            <span class="hljs-type">int</span> t = a / b;            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);        &#125;        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;        <span class="hljs-keyword">return</span> u;    &#125;    &#125;;<span class="hljs-keyword">using</span> mint = ModInt&lt;modp&gt;;<span class="hljs-function"><span class="hljs-keyword">inline</span> mint <span class="hljs-title">qpow</span><span class="hljs-params">(mint k,<span class="hljs-type">int</span> n)</span> </span>&#123;mint s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s=s*k;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">math</span> &#123;<span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;vector&lt;mint&gt; frac;vector&lt;mint&gt; inv;<span class="hljs-built_in">math</span>() &#123;&#125;<span class="hljs-built_in">math</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;frac.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+2</span>);inv.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+2</span>);frac[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size<span class="hljs-number">+1</span>;i&lt;=n;++i) &#123;frac[i]=frac[i<span class="hljs-number">-1</span>]*i;&#125;inv[n]=<span class="hljs-built_in">qpow</span>(frac[n],modp<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=size<span class="hljs-number">+1</span>;--i) &#123;inv[i<span class="hljs-number">-1</span>]=inv[i]*i;&#125;size=n;&#125;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m || m&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(n&gt;size) <span class="hljs-built_in">init</span>(n);<span class="hljs-keyword">return</span> frac[n]*inv[m]*inv[n-m];&#125;&#125;binom;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">return</span> binom.<span class="hljs-built_in">C</span>(n,m); &#125;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(mint n,mint m)</span> </span>&#123;<span class="hljs-keyword">return</span> binom.<span class="hljs-built_in">C</span>(n.<span class="hljs-built_in">val</span>(),m.<span class="hljs-built_in">val</span>()); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n<span class="hljs-number">+1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;mint&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs1 = [&amp;](<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;sz[x]=<span class="hljs-number">1</span>;dp[x]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fath) &#123;<span class="hljs-built_in">self</span>(self,y,x);dp[x]*=dp[y]*<span class="hljs-built_in">C</span>(sz[x]+sz[y]<span class="hljs-number">-1</span>,sz[y]);sz[x]+=sz[y];&#125;&#125;&#125;;<span class="hljs-built_in">dfs1</span>(dfs1,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> dfs2 = [&amp;](<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fath) &#123;dp[y]=dp[x]*<span class="hljs-built_in">C</span>(n<span class="hljs-number">-1</span>,sz[y]<span class="hljs-number">-1</span>)/<span class="hljs-built_in">C</span>(n<span class="hljs-number">-1</span>,sz[y]);<span class="hljs-built_in">self</span>(self,y,x);&#125;&#125;&#125;;<span class="hljs-built_in">dfs2</span>(dfs2,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(),dp.<span class="hljs-built_in">end</span>(),(mint)<span class="hljs-number">0</span>));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="i.-花卉培育">I. 花卉培育</h2><div class="note note-info">            <p>题意：构造序列 <span class="math inline">\(\{a_i\}\)</span>使其同时满足 <span class="math inline">\(q\)</span> 个限制。</p><p>其中第 <span class="math inline">\(j\in[1,q]\)</span> 个限制形如<spanclass="math inline">\(\bigg(\prod\limits_{i=l_j}^{r_j}a_i\bigg)\equivv_j\pmod{3}\)</span> .</p><p><span class="math inline">\(1\le n,q \le 3\cdot 10^5\)</span>，<spanclass="math inline">\(0\le a_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>首先，在模 <span class="math inline">\(3\)</span> 意义下，<spanclass="math inline">\(0\le a_i\le 10^9\)</span> 等价于 <spanclass="math inline">\(0\le a_i \le 2\)</span>。</p><p>那么我们只需考量 <span class="math inline">\(a_i=0/1/2\)</span>时在序列中的性质：</p><p>若 <span class="math inline">\(a_i=0\)</span>，那么所有含 <spanclass="math inline">\(a_i\)</span> 的区间乘积都是 <spanclass="math inline">\(0\)</span>。因此在每个 <spanclass="math inline">\(v_j\neq 0\)</span> 的区间中不能含有 <spanclass="math inline">\(0\)</span>。</p><p>再考虑 <span class="math inline">\(v_j=0\)</span> 的限制，<spanclass="math inline">\(a_i=1\)</span> 对乘积没有任何影响，对于 <spanclass="math inline">\(a_i=2\)</span> 则有一个经典结论： <spanclass="math display">\[\begin{cases}3|(2^n+1)\ ,n\textbf{ 为奇数}\\3|(2^n-1)\ ,n\textbf{为偶数}\end{cases}\quad\Longrightarrow\quad 2^k \bmod{3} =\begin{cases}2\ ,k\textbf{ 为奇数}\\1\ ,k\textbf{ 为偶数}\end{cases}\]</span></p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        证明?    </div>    <div class='spoiler-content'>        <p>当 <span class="math inline">\(n\)</span> 为偶数时，令 <spanclass="math inline">\(n=2k\)</span>，则： <span class="math display">\[\begin{align}\quad2^{2k}-1&amp;=4^k-1\\&amp;=(3+1)^k-1\\&amp;=3^k+\tbinom{k}{1}3^{k-1}+\tbinom{k}{2}3^{k-2}+\dots+1-1\\&amp;\equiv1-1\pmod{3}\\&amp;\equiv0 \pmod{3}\end{align}\]</span></p><p>当 <span class="math inline">\(n\)</span> 为奇数时，令 <spanclass="math inline">\(n=2k+1\)</span>，则： <spanclass="math display">\[\begin{align}2^{2k+1}+1&amp;=2\cdot{2^{2k}+1}\\&amp;=2\cdot(3+1)^{k}+1\\&amp;=2(3^k+\tbinom{k}{1}3^{k-1}+\tbinom{k}{2}3^{k-2}+\dots+1)+1\\&amp;\equiv2\cdot1+1\pmod{3}\\&amp;\equiv 0 \pmod{3}\end{align}\]</span></p><p>证毕。</p>    </div></div><div class="note note-success">            <p>这能带来两个巧思： 1. 若干个 <span class="math inline">\(1,2\)</span>相乘不会出现 <span class="math inline">\(3\)</span>的倍数，意味着满足限制 <span class="math inline">\(v_j=0\)</span>的充要条件是 <span class="math inline">\([l_j,r_j]\)</span> 间有 <spanclass="math inline">\(0\)</span>。即若有 <spanclass="math inline">\(v_j=0\)</span> 的区间完全包含在 <spanclass="math inline">\(v_j\neq0\)</span> 的区间的并中，无解。</p><ol start="2" type="1"><li>有解情形下，只要每个限制区间 <span class="math inline">\(2\)</span>的个数的奇偶性满足条件，通过用 <span class="math inline">\(1\)</span>补齐的方式一定能构造出可行解。</li></ol><p>那么问题转化为是否能有一种构造方案使得每个限制区间中 <spanclass="math inline">\(2\)</span> 的个数的奇偶性满足要求。</p><p>妙手：记 <span class="math inline">\(a_i=2\)</span> 的位置 <spanclass="math inline">\(i\)</span> 有 <spanclass="math inline">\(x_i=1\)</span>，那么对于 <spanclass="math inline">\([l,r]\)</span>，有如下等价形式： <spanclass="math display">\[x_l\oplus x_{l+1}\oplus \dots\oplus x_{r-1}\oplus x_{r}=\begin{cases}0\,[l,r]\textbf{ 中有偶数个 }2\\1\ ,[l,r]\textbf{ 中有奇数个 }2\end{cases}\ =s_{l-1}\oplus s_r\]</span></p><p>其中 <span class="math inline">\(s_i\)</span> 是 <spanclass="math inline">\(x_i\)</span> 的前缀异或和。</p><p>换言之，对于一个限制条件，可以转化为两个单点的异或，进而转化为如下二元按位关系：<span class="math display">\[\begin{align}s_{l-1} \oplus s_r=1 \rightarrow (s_{l-1}\lors_r)\land(\neg s_{l-1} \lor \neg s_r)\\s_{l-1} \oplus s_r=0 \rightarrow(s_{l-1}\lor \neg s_r)\land(\neg s_{l-1} \lor s_r)\end{align}\]</span></p><p>用 <span class="math inline">\(\small\text{2-SAT}\)</span>求解，时间复杂度 <span class="math inline">\(O(n+q)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) puts(x);return ;</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoSet</span> &#123;<span class="hljs-type">int</span> n;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-built_in">TwoSet</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n;adj.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>*n<span class="hljs-number">+1</span>);ans.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addbind</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">bool</span> ok1,<span class="hljs-type">int</span> y,<span class="hljs-type">bool</span> ok2)</span> </span>&#123;adj[x+n*(!ok1)].<span class="hljs-built_in">push_back</span>(y+n*ok2);adj[y+n*(!ok2)].<span class="hljs-built_in">push_back</span>(x+n*ok1);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span>*n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span>*n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span>*n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span>*n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span>*n<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>)</span></span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(<span class="hljs-number">2</span>*n<span class="hljs-number">+1</span>);<span class="hljs-type">int</span> tim=<span class="hljs-number">0</span>,top=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;dfn[x]=low[x]=++tim;vis[x]=<span class="hljs-literal">true</span>;stack_[++top]=x;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(!dfn[y]) &#123;<span class="hljs-built_in">tarjan</span>(y);low[x]=<span class="hljs-built_in">min</span>(low[x],low[y]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[y]) &#123;low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[y]);&#125;&#125;<span class="hljs-keyword">if</span>(dfn[x]==low[x]) &#123;<span class="hljs-type">int</span> now;++cnt;<span class="hljs-keyword">do</span>&#123;now=stack_[top--];vis[now]=<span class="hljs-literal">false</span>;c[now]=cnt;scc[cnt].<span class="hljs-built_in">push_back</span>(now);&#125;<span class="hljs-keyword">while</span>(x!=now);&#125;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;++i) &#123;<span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(c[i]==c[i+n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;ans[i]=c[i]&gt;c[i+n]?<span class="hljs-number">1ll</span>:<span class="hljs-number">0ll</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getans</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ans;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();<span class="hljs-meta">#<span class="hljs-keyword">define</span> FAIL while(n--) printf(<span class="hljs-string">&quot;-1 &quot;</span>);return ;</span><span class="hljs-function">TwoSet <span class="hljs-title">ts</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n<span class="hljs-number">+2</span>)</span></span>;vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; arr0;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) &#123;arr<span class="hljs-number">0.</span><span class="hljs-built_in">push_back</span>(&#123;l,r<span class="hljs-number">+1</span>,x&#125;);&#125; <span class="hljs-keyword">else</span> &#123;sum[l]++;sum[r<span class="hljs-number">+1</span>]--;<span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) &#123;ts.<span class="hljs-built_in">addbind</span>(l,<span class="hljs-number">0</span>,r<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>); ts.<span class="hljs-built_in">addbind</span>(l,<span class="hljs-number">1</span>,r<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>); &#125; <span class="hljs-keyword">else</span> &#123;ts.<span class="hljs-built_in">addbind</span>(l,<span class="hljs-number">0</span>,r<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>);ts.<span class="hljs-built_in">addbind</span>(l,<span class="hljs-number">1</span>,r<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">+1</span>;++i) &#123;sum[i]+=sum[i<span class="hljs-number">-1</span>];&#125;sum.<span class="hljs-built_in">insert</span>(sum.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>);sum.<span class="hljs-built_in">pop_back</span>();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i:sum) &#123;i=(<span class="hljs-type">bool</span>)i;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">+1</span>;++i) &#123;sum[i]+=sum[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [l,r,x]:arr0) &#123;<span class="hljs-keyword">if</span>(sum[r]-sum[l]==r-l) &#123;FAIL;&#125;&#125;<span class="hljs-keyword">if</span>(!ts.<span class="hljs-built_in">work</span>()) &#123;FAIL;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(sum[i]!=sum[i<span class="hljs-number">+1</span>]) &#123;ts.ans[i]==ts.ans[i<span class="hljs-number">+1</span>] ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 &quot;</span>) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2 &quot;</span>); &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 &quot;</span>);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> NNSZ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】Codeforces Round 910 (Div.2) B,D,E,F</title>
      <link href="/posts/79faf3ae.html"/>
      <url>/posts/79faf3ae.html</url>
      
        <content type="html"><![CDATA[<h2 id="b.-milena-and-admirer">B. Milena and Admirer</h2><p><ahref="https://codeforces.com/contest/1898/problem/B">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a\)</span>，每次可以选定一个 <spanclass="math inline">\(a_i\)</span> 和正整数 <spanclass="math inline">\(x\in[1,x)\)</span>，并将 <spanclass="math inline">\(a_i\)</span> 替换成 <spanclass="math inline">\(x\)</span> 和 <span class="math inline">\(a_i-x\)</span>。问使序列单调不降的最小操作次数。</p><p><span class="math inline">\(1\le n \le 2\times 10^5\)</span>，<spanclass="math inline">\(1\le a_i\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>倒序考虑。</p><p>对于每一个 <span class="math inline">\(a_i,a_{i+1}\)</span>： * 若<span class="math inline">\(a_i\lea_{i+1}\)</span>，不进行任何操作。</p><ul><li>若 <span class="math inline">\(a_i &gt;a_{i+1}\)</span>，记操作次数为 <spanclass="math inline">\(cnt\)</span>。可以证明，最优策略肯定是使分裂序列最左端的数（即最小数）最大：例如<span class="math inline">\([21,6]\)</span> 中的 <spanclass="math inline">\(21\)</span> 拆分成 <spanclass="math inline">\([{\color{Red}5},5,5,6]\)</span> 肯定要比 <spanclass="math inline">\([{\color{Red}3},6,6,6]\)</span>更优，这样继续倒序操作会有更大的操作空间。具体地：<ul><li><p>若 <span class="math inline">\(a_{i+1} \mid a_i\)</span>，则将<span class="math inline">\(a_i\)</span> 拆分成 <spanclass="math inline">\(\dfrac{a_i}{a_{i+1}}\)</span> 个 <spanclass="math inline">\(a_{i+1}\)</span>，<spanclass="math inline">\(cnt=\dfrac{a_i}{a_{i+1}}-1\)</span>。</p></li><li><p>否则，会多出一个余数，则 <spanclass="math inline">\(cnt=\left\lfloor\dfrac{a_{i}}{a_{i+1}}\right\rfloor\)</span>。此时最左端的数最大为<spanclass="math inline">\(\left\lfloor\dfrac{a_i}{cnt}\right\rfloor\)</span>。</p></li><li><p>每次的 <span class="math inline">\(a_{i+1}\)</span>其实就是上一次操作后最左端的数。</p></li></ul></li></ul><p>可以用 <code>std::queue</code> 模拟这一加数过程。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;deque&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;--i) &#123;q.<span class="hljs-built_in">push_back</span>(a[i]);&#125;vector&lt;<span class="hljs-type">int</span>&gt; b;b.<span class="hljs-built_in">push_back</span>(a[n]);<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();<span class="hljs-keyword">if</span>(x&lt;=b.<span class="hljs-built_in">back</span>()) &#123;b.<span class="hljs-built_in">push_back</span>(x);q.<span class="hljs-built_in">pop_front</span>();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> y=b.<span class="hljs-built_in">back</span>();<span class="hljs-type">int</span> cnt=x/y;res+=cnt<span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span>(x%y) &#123;res++;<span class="hljs-type">int</span> z=x/(cnt<span class="hljs-number">+1</span>);b.<span class="hljs-built_in">push_back</span>(z);&#125;q.<span class="hljs-built_in">pop_front</span>();&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-absolute-beauty">D. Absolute Beauty</h2><p><ahref="https://codeforces.com/contest/1898/problem/D">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a,b\)</span>。你可以交换 <spanclass="math inline">\(b\)</span> 中的任意两个数一次或不进行任何操作，求<spanclass="math inline">\(\max(\sum\limits_{i=1}^n|a_i-b_i|)\)</span>。</p><p><span class="math inline">\(2\le n \le 2\cdot 10^5\)</span>，<spanclass="math inline">\(1\le a_i,b_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>将每一组 <span class="math inline">\((a_i,b_i)\)</span> 看作线段（若<span class="math inline">\(a_i&gt;b_i\)</span> 则交换），一共 <spanclass="math inline">\(n\)</span> 条线段。</p><p>此时 <span class="math inline">\(|a_i-b_i|\)</span>即线段的长度，我们要求 <span class="math inline">\(n\)</span>条线段长度和的最大值。</p><p>考虑交换一组 <span class="math inline">\(b_i,b_j\)</span>对答案的影响：即交换两条线段的某两个端点。</p><p>可能的情况如下（不完全）：</p><p><imgsrc="https://kisuraop.github.io/image/academic/CF910_1.png" /></p><p><imgsrc="https://kisuraop.github.io/image/academic/CF910_2.png" /></p><p><imgsrc="https://kisuraop.github.io/image/academic/CF910_3.png" /></p><p>会发现只有第一组线段的长度得以扩张，且扩张值为原先线段间空白长度的两倍。</p><p>那么我们找到所有 <span class="math inline">\((a_i,b_i)\)</span>中最小的右端点 <span class="math inline">\(s\)</span> 和最大的左端点<span class="math inline">\(t\)</span>。</p><p>有 <spanclass="math inline">\(\text{ans}=\max(0,2(t-s))+\sum\limits_{i=1}^n|a_i-b_i|\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-type">int</span> minn=inf,maxn=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;res+=<span class="hljs-built_in">abs</span>(a[i]-b[i]);minn=<span class="hljs-built_in">min</span>(minn,<span class="hljs-built_in">max</span>(a[i],b[i]));maxn=<span class="hljs-built_in">max</span>(maxn,<span class="hljs-built_in">min</span>(a[i],b[i]));&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res+<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,<span class="hljs-number">2</span>*(maxn-minn)));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="e.-sofia-and-strings">E. Sofia and Strings</h2><p><ahref="https://codeforces.com/contest/1898/problem/E">Problem</a></p><div class="note note-info">            <p>题意：给定两个由小写字母构成的字符串 <spanclass="math inline">\(S,T\)</span>，长度分别为 <spanclass="math inline">\(n,m\)</span>。你可以进行以下两种操作任意次，问是否能将<span class="math inline">\(S\)</span> 转化成 <spanclass="math inline">\(T\)</span>。</p><ol type="1"><li><p>删除 <span class="math inline">\(S\)</span>中的一个元素。</p></li><li><p>使 <span class="math inline">\(S\)</span>中的某个子段按字典序排序。</p></li></ol><p><span class="math inline">\(1\le m\le n\le 2 \cdot10^5\)</span>。</p>          </div><div class="note note-success">            <p>首先，因为不计操作次数，所以操作 <spanclass="math inline">\(2\)</span>其实可以转化为每次排序两个相邻字母。</p><p>例如，<span class="math inline">\(\text{cba}\to\)</span> <spanclass="math inline">\(\text{abc}\)</span> 其实相当于 <spanclass="math inline">\(\text{cba} \to \text{cab} \to \text{acb} \to\text{abc}\)</span>。</p><p>其次，逐个匹配 <span class="math inline">\(T\)</span>中字符，观察匹配过程：假若当前匹配字母 <spanclass="math inline">\(\text{d}\)</span>，那么在 <spanclass="math inline">\(S\)</span> 中找到第一个仍未被匹配的 <spanclass="math inline">\(\text{d}\)</span>，由于当且仅当字典序小的字母紧跟在字典序大的字母后面时才会发生交换，那么在确定<span class="math inline">\(\text{d}\)</span> 的位置的同时，位于 <spanclass="math inline">\(\text{d}\)</span> 之前且字典序比 <spanclass="math inline">\(\text{d}\)</span> 小的字母（<spanclass="math inline">\(\text{a,b,c}\)</span>）就失去了贡献，无法参与后续匹配。因为后续匹配继续向<span class="math inline">\(\text{d}\)</span> 的右侧寻找，而 <spanclass="math inline">\(\text{a,b,c}\)</span> 无论如何也跨越不了这个 <spanclass="math inline">\(\text{d}\)</span>。</p><p>用 <code>std::vector</code> 记录每个字母出现的下标，逐个扫描 <spanclass="math inline">\(T\)</span>，并将符合上述要求不再有贡献的下标从容器中移除。若能一直匹配到<span class="math inline">\(T\)</span>末尾，则必然存在一个解。否则无解。</p><p>时间复杂度 <span class="math inline">\(O(n+m\cdot 26)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();string s,t;cin&gt;&gt;s&gt;&gt;t;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pos</span>(<span class="hljs-number">26</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;pos[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i) &#123;<span class="hljs-type">int</span> x=t[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-keyword">if</span>(pos[x].<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> fir=pos[x].<span class="hljs-built_in">back</span>();pos[x].<span class="hljs-built_in">pop_back</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x;++j) &#123;<span class="hljs-keyword">while</span>(!pos[j].<span class="hljs-built_in">empty</span>() &amp;&amp; pos[j].<span class="hljs-built_in">back</span>()&lt;fir) &#123;pos[j].<span class="hljs-built_in">pop_back</span>();&#125;&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="f.-vova-escapes-the-matrix">F. Vova Escapes the Matrix</h2><p><ahref="https://codeforces.com/contest/1898/problem/F">Problem</a></p><div class="note note-info">            <p>题意：给定一个 <span class="math inline">\(n\times m\)</span>的矩形迷宫和初始坐标，迷宫的出口定义为位于迷宫边缘且没有障碍且能从初始位置走到的格子。一个迷宫有三种状态：没有出口，有一个出口，有两个及以上出口。问在不破坏迷宫状态的前提下，能再往这个迷宫中添加多少障碍物。</p><p><span class="math inline">\(3\le n,m\le 1000\)</span>。</p>          </div><div class="note note-success">            <p>先从起点跑一遍 <spanclass="math inline">\(\text{bfs}\)</span>，预处理出 <spanclass="math inline">\(dis_{i,j}\)</span> 代表起点到点 <spanclass="math inline">\((i,j)\)</span> 的最短距离。</p><p>设迷宫出口数量为 <span class="math inline">\(k\)</span>，初始有 <spanclass="math inline">\(p\)</span> 个可放障碍的点，出口点集为 <spanclass="math inline">\(T\)</span>： * <spanclass="math inline">\(k=0\)</span>，把迷宫塞满，<spanclass="math inline">\(\text{ans}=p\)</span>。</p><ul><li><p><spanclass="math inline">\(k=1\)</span>，无脑塞，只留一条通向出口的最短路，<spanclass="math inline">\(\text{ans}=p-\min(dis_T)\)</span>。</p></li><li><p><spanclass="math inline">\(k\ge2\)</span>，显然最后只保留两个出口。以 <spanclass="math inline">\(i\in T\)</span> 为起点再跑 <spanclass="math inline">\(\text{bfs}\)</span>，记录出 <spanclass="math inline">\(diss_{i,j,0/1}\)</span> 表示点 <spanclass="math inline">\((i,j)\)</span>到最近出口的距离和到次近出口的距离，则 <spanclass="math inline">\(\text{ans}=p-\min(dis_{i,j}+diss_{i,j,0}+diss_{i,j,1})\)</span>。</p></li></ul><p>时间复杂度 <span class="math inline">\(O(mn)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-type">int</span> sx,sy;<span class="hljs-type">int</span> blank=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;cin&gt;&gt;s[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;V&#x27;</span>) &#123;sx=i;sy=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>) &#123;blank++;&#125;&#125;&#125;<span class="hljs-type">int</span> dx[]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-type">int</span> dy[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-keyword">auto</span> overline = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">return</span> x&lt;<span class="hljs-number">0</span> || x&gt;=n || y&lt;<span class="hljs-number">0</span> || y&gt;=m;&#125;;<span class="hljs-keyword">auto</span> isexit = [&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<span class="hljs-built_in">return</span> (x==<span class="hljs-number">0</span> || x==n<span class="hljs-number">-1</span> || y==<span class="hljs-number">0</span> || y==m<span class="hljs-number">-1</span>) &amp;&amp; s[x][y]!=<span class="hljs-string">&#x27;#&#x27;</span>;&#125;;queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dis</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m,<span class="hljs-number">-1</span>));q.<span class="hljs-built_in">push</span>(&#123;sx,sy&#125;);dis[sx][sy]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> exit=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> [x,y]=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();exit+=<span class="hljs-built_in">isexit</span>(x,y);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i) &#123;<span class="hljs-type">int</span> xx=x+dx[i],yy=y+dy[i];<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">overline</span>(xx,yy) &amp;&amp; dis[xx][yy]==<span class="hljs-number">-1</span> &amp;&amp; s[xx][yy]!=<span class="hljs-string">&#x27;#&#x27;</span>) &#123;dis[xx][yy]=dis[x][y]<span class="hljs-number">+1</span>;q.<span class="hljs-built_in">push</span>(&#123;xx,yy&#125;);&#125;&#125;&#125;<span class="hljs-keyword">if</span>(!exit) &#123;<span class="hljs-type">int</span> ans=blank;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exit==<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isexit</span>(i,j) &amp;&amp; dis[i][j]!=<span class="hljs-number">-1</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,dis[i][j]);&#125;&#125;&#125;ans=blank-ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125; <span class="hljs-keyword">else</span> &#123;queue&lt;array&lt;<span class="hljs-type">int</span>,<span class="hljs-number">4</span>&gt;&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isexit</span>(i,j)) &#123;q.<span class="hljs-built_in">push</span>(&#123;i,j,<span class="hljs-number">0</span>,i*m+j&#125;);&#125;&#125;&#125;<span class="hljs-function">vector <span class="hljs-title">diss</span><span class="hljs-params">(n,vector(m,array&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;))</span></span>;<span class="hljs-function">vector <span class="hljs-title">id</span><span class="hljs-params">(n,vector&lt;<span class="hljs-type">int</span>&gt;(m,<span class="hljs-number">-1</span>))</span></span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> [x,y,d,pid]=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(diss[x][y][<span class="hljs-number">0</span>]==<span class="hljs-number">-1</span>) &#123;diss[x][y][<span class="hljs-number">0</span>]=d;id[x][y]=pid;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diss[x][y][<span class="hljs-number">1</span>]==<span class="hljs-number">-1</span> &amp;&amp; pid!=id[x][y]) &#123;diss[x][y][<span class="hljs-number">1</span>]=d;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i) &#123;<span class="hljs-type">int</span> xx=x+dx[i],yy=y+dy[i];<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">overline</span>(xx,yy) &amp;&amp; s[xx][yy]!=<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; diss[xx][yy][<span class="hljs-number">1</span>]==<span class="hljs-number">-1</span>) &#123;q.<span class="hljs-built_in">push</span>(&#123;xx,yy,d<span class="hljs-number">+1</span>,pid&#125;);&#125;&#125;&#125;<span class="hljs-type">int</span> ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) &#123;<span class="hljs-keyword">if</span>(s[i][j]!=<span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; dis[i][j]!=<span class="hljs-number">-1</span> &amp;&amp; diss[i][j][<span class="hljs-number">1</span>]!=<span class="hljs-number">-1</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,dis[i][j]+diss[i][j][<span class="hljs-number">0</span>]+diss[i][j][<span class="hljs-number">1</span>]);&#125;&#125;&#125;ans=blank-ans;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】GenshinOI Round 3 A~C</title>
      <link href="/posts/81a98245.html"/>
      <url>/posts/81a98245.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://sy.hhwdd.com/RequireFile.do?fid=aZQ9MeAe" /></p><h2 id="a.-wbybld">A. wbyblD</h2><p><ahref="https://www.luogu.com.cn/problem/P9815?contestId=141486">Problem</a></p><div class="note note-info">            <p>题意：有 <span class="math inline">\(n+2\)</span> 个点排成一排，编号<span class="math inline">\(0\sim n+1\)</span>。对每个 <spanclass="math inline">\(0\le i\le n+1\)</span> 号点有两个整数 <spanclass="math inline">\(a_i,b_i\)</span>。初始时 <spanclass="math inline">\(a_0=b_0=a_{n+1}=b_{n+1}=0\)</span>。</p><p>设你当前在第 <span class="math inline">\(x\)</span> 号点，移动方向为<span class="math inline">\(y\)</span>，初始时 <spanclass="math inline">\(x=0,y=1\)</span>。</p><p>接下来你按如下方式移动直到 <span class="math inline">\(x,y\)</span>某一次变化后满足 <span class="math inline">\(x=0,y=-1\)</span> 或 <spanclass="math inline">\(x=n+1,y=1\)</span>。</p><ul><li><p>若 <span class="math inline">\(y=1\)</span>，先将 <spanclass="math inline">\(x\)</span> 加 <spanclass="math inline">\(1\)</span>，此时若 <spanclass="math inline">\(a_x&gt;0\)</span> 则将 <spanclass="math inline">\(y\)</span> 变成 <spanclass="math inline">\(-1\)</span>，否则 <spanclass="math inline">\(y\)</span> 不变，最后再将 <spanclass="math inline">\(a_x\)</span> 减 <spanclass="math inline">\(1\)</span>。</p></li><li><p>若 <span class="math inline">\(y=-1\)</span>，先将 <spanclass="math inline">\(x\)</span> 减 <spanclass="math inline">\(1\)</span>，此时若 <spanclass="math inline">\(b_x&gt;0\)</span> 则将 <spanclass="math inline">\(y\)</span> 变成 <spanclass="math inline">\(1\)</span>，否则 <spanclass="math inline">\(y\)</span> 不变，最后再将 <spanclass="math inline">\(b_x\)</span> 减 <spanclass="math inline">\(1\)</span>。</p></li></ul><p>问最后结束时 <span class="math inline">\(x\)</span> 会在 <spanclass="math inline">\(0\)</span> 号点还是 <spanclass="math inline">\(n+1\)</span> 号点。</p><p><span class="math inline">\(1\le \sum n\le 10^6\)</span>，<spanclass="math inline">\(0\le a_i,b_i\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>看到题很快写了个线段树二分。咦，怎么样例不对？哦，看错题了，乐。</p><p>脑海里模拟一下，发现对于一组 <spanclass="math inline">\(a_i,b_{i-1}\)</span> 相当于较量谁大直到一方变为<span class="math inline">\(0\)</span>，而在这之前你只能左右横跳。</p><p>如果 <span class="math inline">\(a_i\)</span>较大，那你往回走，如果凑不够足够的 <span class="math inline">\(\sumb_{j} \text{ }, j\in[1,i-1]\)</span>（指比较后剩下的 <spanclass="math inline">\(b_j\)</span>），那你就回家了。</p><p>重复这个过程，思路转个弯，实际上就是对每个 <spanclass="math inline">\(i\)</span> 比较 <span class="math inline">\(\suma_{1\sim i}\)</span> 和 <span class="math inline">\(\sumb_{1\sim{i-1}}\)</span>。</p><p>前缀和记录，时间复杂度 <spanclass="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+2</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+2</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(a[i]&gt;<span class="hljs-number">0</span>) &#123;sum-=a[i];&#125;<span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span>(b[i]&gt;<span class="hljs-number">0</span>) &#123;sum+=b[i];&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n<span class="hljs-number">+1</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-少项式复合幂">B. 少项式复合幂</h2><p><ahref="https://www.luogu.com.cn/problem/P9816?contestId=141486">Problem</a></p><div class="note note-info">            <p>题意：给定多项式 <spanclass="math inline">\(f(x)=\sum_{i=1}^ma_ix^{b_i}\)</span>。定义 <spanclass="math inline">\(f_1(x)=f(x)\)</span>，<spanclass="math inline">\(f_n(x)=f(f_{n-1}(x))\)</span>。</p><p>给定模数 <span class="math inline">\(p\)</span>。有 <spanclass="math inline">\(q\)</span> 次询问，每次给出 <spanclass="math inline">\(x,y\)</span>，查询 <spanclass="math inline">\(f_y(x)\bmod p\)</span> 的值。</p><p><span class="math inline">\(1\le m\le 20\)</span>，<spanclass="math inline">\(0\le a_i,b_i\le 10^5\)</span>，<spanclass="math inline">\(2\le p\le 10^5\)</span>，<spanclass="math inline">\(1\le q\le 3\times 10^5\)</span>，<spanclass="math inline">\(1\le x,y\le 10^7\)</span>。</p>          </div><div class="note note-success">            <p>诈骗题。</p><p>注意到模数 <span class="math inline">\(p\)</span> 十分小，而每次经过<span class="math inline">\(f(x)\)</span> 运算后得出的结果只能是 <spanclass="math inline">\([0,p)\)</span>。</p><p>那么只需要对每个 <span class="math inline">\(i\in[0,p)\)</span>代进函数预处理出 <spanclass="math inline">\(f(i)\)</span>，那么进行一次询问的复杂度降到 <spanclass="math inline">\(O(y)\)</span>。</p><p>总复杂度 <span class="math inline">\(O(qy)\)</span>，继续优化。</p><p>倍增，令 <span class="math inline">\(f_{i,j}\)</span> 为数 <spanclass="math inline">\(i\)</span> 经过 <spanclass="math inline">\(2^j\)</span> 次迭代后得到的结果。</p><p>询问时对 <span class="math inline">\(y\)</span>的二进制下的每一位考虑即可。</p><p>时间复杂度 <span class="math inline">\(O(mp+q\log y)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k%p) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s=s*k%p;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> m=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>(),modp=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(m<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-type">int</span> x) &#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;res+=a[i]*<span class="hljs-built_in">qpow</span>(x,b[i],modp)%modp;res%=modp;&#125;<span class="hljs-keyword">return</span> res;&#125;;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(modp,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;modp;++i) &#123;f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">calc</span>(i);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">25</span>;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;modp;++i) &#123;f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>()%modp,y=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">25</span>;++j) &#123;<span class="hljs-keyword">if</span>(y&gt;&gt;j&amp;<span class="hljs-number">1</span>) &#123;x=f[x][j];&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,x);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p>倍增的写法：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">25</span>;++j) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;f[i][j]=f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];&#125;&#125;</code></pre></div><p>选从 <span class="math inline">\(i\)</span> 开始的第 <spanclass="math inline">\(2^j\)</span> 个相当于选从 <spanclass="math inline">\(i\)</span> 往后 <spanclass="math inline">\(2^{j-1}\)</span> 处开始的第 <spanclass="math inline">\(2^{j-1}\)</span> 个。</p>          </div><h2 id="c.-imxcsld">C. ImxcslD</h2><p><ahref="https://www.luogu.com.cn/problem/P9817?contestId=141486">Problem</a></p><div class="note note-info">            <p>题意：定义长度为 <span class="math inline">\(m\)</span> 的非空序列<span class="math inline">\(p_1,p_2,...,p_m\)</span>是<strong>乱</strong>的当且仅当满足以下条件。</p><ul><li><p><span class="math inline">\(\sum_{i=1}^m p_i\len\)</span>。</p></li><li><p><span class="math inline">\(\forall\text{ }i\in[1,m]\)</span>，<span class="math inline">\(p_i=1\)</span> 或 <spanclass="math inline">\(p_i\)</span> 为质数。</p></li></ul><p>定义一个<strong>乱</strong>的序列 <spanclass="math inline">\(p_1,p_2,...,p_m\)</span>的<strong>乱斗值</strong>为 <span class="math inline">\(\sum_{i=1}^m(p_i-k)^2\)</span>。</p><p>特别的，定义一个<strong>不乱</strong>的序列的乱斗值为 <spanclass="math inline">\(0\)</span>。</p><p>现在给定正整数 <spanclass="math inline">\(n,k\)</span>，问所有序列中<strong>乱斗值</strong>最大的序列的<strong>乱斗值</strong>是多少。</p><p><span class="math inline">\(1\le T\le 10^3\)</span>，<spanclass="math inline">\(1\le n\le 10^9\)</span>，<spanclass="math inline">\(1\le k\le 5\times 10^4\)</span>。</p>          </div><div class="note note-success">            <p>有难度的贪心。</p><p>考虑什么时候结果是最优的：我们要让 <spanclass="math inline">\((p_i-k)^2\)</span> 尽可能的大，也就是 <spanclass="math inline">\(p_i\)</span> 和 <spanclass="math inline">\(k\)</span> 的差值大，分为两种情况： * 当 <spanclass="math inline">\(p_i&lt;k\)</span> 时，要离 <spanclass="math inline">\(k\)</span> 越远，肯定是全为 <spanclass="math inline">\(1\)</span> 最优。</p><ul><li>当 <span class="math inline">\(p_i&gt;k\)</span> 时，考虑写上一个<span class="math inline">\(p_i\)</span> 对答案的影响。<ul><li><p>一开始构造序列全为 <span class="math inline">\(1\)</span>，答案是<span class="math inline">\(m(1-k)^2\)</span>。</p></li><li><p>写出一个 <span class="math inline">\(p_i\)</span>时，相当于划掉了 <span class="math inline">\(p_i\)</span> 个 <spanclass="math inline">\(1\)</span>，答案增加了 <spanclass="math inline">\((p_i-k)^2-p_i(1-k)^2\)</span>。</p></li><li><p>发现每次变更总是可以选择大的 <spanclass="math inline">\(p_i\)</span>，而答案也只和当时 <spanclass="math inline">\(1\)</span> 的个数相关。</p></li><li><p>所以可以递归，每次选择小于等于 <spanclass="math inline">\(n\)</span> 的最大的质数 <spanclass="math inline">\(P\)</span>，看看最大值能不能更新，然后将问题递归到<span class="math inline">\((n-P,k)\)</span>。</p></li></ul></li></ul><p>这并不严谨，需要感性理解。</p><p>复杂度不会分析，只能说感觉能接受？</p><p>预处理出质数表能 <span class="math inline">\(O(\frac{\sqrt{n}}{\lnn})\)</span> 查找质数，但事实 <spanclass="math inline">\(O(\sqrt{n})\)</span> 也完全卡不满。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span><span class="hljs-number">+5</span>;<span class="hljs-type">int</span> prime[N],mark[N],phi[N],tot_prime;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getphi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;        <span class="hljs-keyword">if</span>(!mark[i]) &#123;            prime[++tot_prime]=i;            phi[i]=i<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot_prime;j++) &#123;            <span class="hljs-keyword">if</span>(i*prime[j]&gt;n) &#123;            <span class="hljs-keyword">break</span>;            &#125;            mark[i*prime[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) &#123;                phi[i*prime[j]]=phi[i]*prime[j];                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> &#123;            phi[i*prime[j]]=phi[i]*phi[prime[j]];            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(tot_prime) &#123;<span class="hljs-keyword">return</span> x<span class="hljs-number">-1</span>==phi[x];&#125;<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(x);++i) &#123;<span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> res=n*(k<span class="hljs-number">-1</span>)*(k<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n,sum=res;i&gt;=<span class="hljs-number">1</span>;--i) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">isprime</span>(i)) &#123;sum-=i*(k<span class="hljs-number">-1</span>)*(k<span class="hljs-number">-1</span>);sum+=(k-i)*(k-i);res=<span class="hljs-built_in">max</span>(res,sum);n-=i;i=<span class="hljs-built_in">min</span>(n,i)<span class="hljs-number">+1</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】UESTC-XCPC集训队2023年9月招新赛 第二场</title>
      <link href="/posts/f9da5f78.html"/>
      <url>/posts/f9da5f78.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接：<ahref="https://vjudge.net/contest/583377#overview">Link</a></p><p>为避免 MyGO!!!!! 污染，以下均采用原题头。</p><p>按个人感官难度排序，及其主观。</p><p>题选的相当棒，值得反复品味。</p><h2 id="b.-hello-acmer">B. Hello, ACMer!</h2><div class="note note-info">            <p>题意：统计给定字符串中 <code>hznu</code> 的出现次数。</p>          </div><div class="note note-success">            <p>模拟即可。</p><p>记得特判字符串长度小于 <span class="math inline">\(4\)</span>的情况。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;string s;cin&gt;&gt;s;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">4</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>),<span class="hljs-built_in">void</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-4</span>;++i) &#123;string t=s.<span class="hljs-built_in">substr</span>(i,<span class="hljs-number">4</span>);<span class="hljs-keyword">if</span>(t==<span class="hljs-string">&quot;hznu&quot;</span>) &#123;res++;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-new-string">C. New String</h2><div class="note note-info">            <p>题意：给定一个自定义字典序排序规则以及若干字符串，求字典序第 <spanclass="math inline">\(k\)</span> 小的串。</p><p><span class="math inline">\(1\le|S|\le 1000\)</span>。</p>          </div><div class="note note-success">            <p>用 <code>std::map</code> 还原字典序或自定义 <code>std::sort</code>排序规则均可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;string all;cin&gt;&gt;all;map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; mp,yl;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;all.<span class="hljs-built_in">size</span>();++i) &#123;mp[all[i]]=(<span class="hljs-string">&#x27;a&#x27;</span>+i);yl[<span class="hljs-string">&#x27;a&#x27;</span>+i]=all[i];&#125;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;cin&gt;&gt;s[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;s[i].<span class="hljs-built_in">size</span>();++j) &#123;s[i][j]=mp[s[i][j]];&#125;&#125;<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> K=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s[K<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>();++i) &#123;cout&lt;&lt;yl[s[K<span class="hljs-number">-1</span>][i]];&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;&#125;</code></pre></div>    </div></div><h2 id="l.-klees-wonderful-adventure">L. Klee’s Wonderful Adventure</h2><div class="note note-info">            <p>题意：平面直角坐标系上有 <span class="math inline">\(n\)</span>个点，相同第 <span class="math inline">\(i\)</span> 象限间点的移动速度为<span class="math inline">\(v_i\)</span>，不同象限间点间的移动速度为<span class="math inline">\(v_0\)</span>，求从起点 <spanclass="math inline">\(s\)</span> 到终点 <spanclass="math inline">\(t\)</span> 的最短时间。</p><p><span class="math inline">\(1\le n\le 3\times 10^3\)</span>。</p>          </div><div class="note note-success">            <p>注意到 <span class="math inline">\(n\)</span>很小，直接预处理出通过任意两点所需的时间，再跑 <code>dijkstra</code>就行了。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3002</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-type">int</span> x,y;&#125;a[N];<span class="hljs-type">double</span> dis[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">whd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span> &amp;&amp; y&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">-1</span> &amp;&amp; y&gt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">-1</span> &amp;&amp; y&lt;=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">1</span> &amp;&amp; y&lt;=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> v[<span class="hljs-number">6</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();v[<span class="hljs-number">1</span>]=<span class="hljs-built_in">read</span>(),v[<span class="hljs-number">2</span>]=<span class="hljs-built_in">read</span>(),v[<span class="hljs-number">3</span>]=<span class="hljs-built_in">read</span>(),v[<span class="hljs-number">4</span>]=<span class="hljs-built_in">read</span>(),v[<span class="hljs-number">0</span>]=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> st=<span class="hljs-built_in">read</span>(),ed=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i].x=<span class="hljs-built_in">read</span>(),a[i].y=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;dis[i][j]=<span class="hljs-built_in">sqrt</span>( (a[i].x-a[j].x)*(a[i].x-a[j].x) + (a[i].y-a[j].y)*(a[i].y-a[j].y));<span class="hljs-type">int</span> fir=<span class="hljs-built_in">whd</span>(a[i].x,a[i].y);<span class="hljs-type">int</span> sec=<span class="hljs-built_in">whd</span>(a[j].x,a[j].y);<span class="hljs-keyword">if</span>(fir==sec) &#123;dis[i][j]/=v[fir];&#125; <span class="hljs-keyword">else</span> &#123;dis[i][j]/=v[<span class="hljs-number">0</span>];&#125;&#125;&#125;vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n<span class="hljs-number">+1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;adj[i].<span class="hljs-built_in">push_back</span>(&#123;j,dis[i][j]&#125;);adj[j].<span class="hljs-built_in">push_back</span>(&#123;i,dis[i][j]&#125;);&#125;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">real_dis</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">auto</span> dijkstra = [&amp;] (<span class="hljs-type">int</span> s) &#123;real_dis.<span class="hljs-built_in">assign</span>(n<span class="hljs-number">+1</span>,<span class="hljs-number">1.0</span>*inf);vis.<span class="hljs-built_in">assign</span>(n<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>);priority_queue&lt;pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt;&gt; q;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0.0</span>,s&#125;);real_dis[s]=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">top</span>().second;q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">if</span>(vis[x]) &#123;<span class="hljs-keyword">continue</span>;&#125;vis[x]=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,z]:adj[x]) &#123;<span class="hljs-keyword">if</span>(real_dis[y]&gt;real_dis[x]+z) &#123;real_dis[y]=real_dis[x]+z;q.<span class="hljs-built_in">push</span>(&#123;-real_dis[y],y&#125;);&#125;&#125;&#125;&#125;;<span class="hljs-built_in">dijkstra</span>(st);<span class="hljs-type">double</span> ans=real_dis[ed];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8lf\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-check-problems">D. Check Problems</h2><div class="note note-info">            <p>题意：有 <span class="math inline">\(n\)</span> 个人查验题目，第<span class="math inline">\(i\)</span> 个人在第 <spanclass="math inline">\(j\)</span> 秒会查验编号为 <spanclass="math inline">\(a_i+j-1\)</span> 的题。<spanclass="math inline">\(q\)</span> 次询问，每次问第 <spanclass="math inline">\(t\)</span> 秒时有多少道题目已经被查验。</p><p><span class="math inline">\(1\le n,q\le 5\times 10^5\)</span>，<spanclass="math inline">\(1\le a_1 \le a_2 \le \dots \le a_n \le10^{18}\)</span>，<span class="math inline">\(0\le t \le10^{18}\)</span>。</p>          </div><div class="note note-success">            <p>相当于数轴上 <span class="math inline">\(n\)</span>个点，每个点每次向右扩张一个单位。</p><p>那么当一个点触到离它右边的一个点时，往后它就没有贡献了。</p><p>并且当一个点没有贡献时，间隔比它小对应的点也都没有了贡献，符合单调性。</p><p>因此我们把每个点间的间隔距离 <spanclass="math inline">\(a_i-a_{i-1}\)</span>记录下来，排序，记录前缀和，再在上面二分。</p><p>每次查询总是前缀和 <span class="math inline">\(+\)</span>没有扩张完的剩下段。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125; <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) &#123;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(q--) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,x);&#125;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>,a.<span class="hljs-built_in">end</span>());vector&lt;<span class="hljs-type">int</span>&gt; d;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) &#123;d.<span class="hljs-built_in">push_back</span>(a[i]-a[i<span class="hljs-number">-1</span>]);&#125;<span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(),d.<span class="hljs-built_in">end</span>());<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;sum[<span class="hljs-number">0</span>]=d[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;d.<span class="hljs-built_in">size</span>();++i) &#123;sum[i]=sum[i<span class="hljs-number">-1</span>]+d[i];&#125;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),pos;<span class="hljs-keyword">auto</span> p=<span class="hljs-built_in">upper_bound</span>(d.<span class="hljs-built_in">begin</span>(),d.<span class="hljs-built_in">end</span>(),x);<span class="hljs-keyword">if</span>(p==d.<span class="hljs-built_in">end</span>()) &#123;pos=n<span class="hljs-number">-1</span>; &#125; <span class="hljs-keyword">else</span> &#123; pos=p-d.<span class="hljs-built_in">begin</span>(); &#125; <span class="hljs-type">int</span> res = pos==<span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : sum[pos<span class="hljs-number">-1</span>]; res+=(n-pos)*x; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;&#125;</code></pre></div>    </div></div><h2 id="e.-tree-problem">E. Tree Problem</h2><div class="note note-info">            <p>题意：给定 <span class="math inline">\(n\)</span> 个点的树，<spanclass="math inline">\(q\)</span> 次询问每次询问一个点 <spanclass="math inline">\(x\)</span>，问树上有多少条简单路径途径点 <spanclass="math inline">\(x\)</span>。</p><p><span class="math inline">\(2\le n \le 10^5\)</span>，<spanclass="math inline">\(1\le q\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>简单画个图，经过 <span class="math inline">\(x\)</span>的简单路径的数量就是 <span class="math inline">\(x\)</span>所有子树大小的两两乘积。</p><p>由于每个子树算了两遍，贡献要除以 <spanclass="math inline">\(2\)</span>。</p><p>别忘记 <span class="math inline">\(x\)</span> 作为简单路径端点的<span class="math inline">\(n-1\)</span> 种情况。</p><p>时间复杂度 <span class="math inline">\(O(n+q)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n<span class="hljs-number">+1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(y);adj[y].<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">fa</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs = [&amp;] (<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath) &#123;sz[x]=<span class="hljs-number">1</span>;fa[x]=fath;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y==fath) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">dfs</span>(y,x);sz[x]+=sz[y];&#125;&#125;;<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> calc = [&amp;](<span class="hljs-type">int</span> x)&#123;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y==fa[x]) &#123;sum+=(n-sz[x]);&#125; <span class="hljs-keyword">else</span> &#123;sum+=sz[y];&#125;&#125;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:adj[x]) &#123;<span class="hljs-keyword">if</span>(y==fa[x]) &#123;res+=(n-sz[x])*(sum-(n-sz[x]));&#125; <span class="hljs-keyword">else</span> &#123;res+=sz[y]*(sum-sz[y]);&#125;&#125;<span class="hljs-keyword">return</span> res/<span class="hljs-number">2</span>+n<span class="hljs-number">-1</span>;&#125;; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(!ans[x]) &#123;ans[x]=<span class="hljs-built_in">calc</span>(x);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[x]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();&#125;&#125;</code></pre></div>    </div></div><h2 id="g.-subarrays">G. Subarrays</h2><div class="note note-info">            <p>题意：给定长度为 <span class="math inline">\(n\)</span> 的正整数序列<span class="math inline">\(a\)</span>，求满足子段和为 <spanclass="math inline">\(k\)</span> 的倍数的子段数量。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<spanclass="math inline">\(1\le k,a_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>令 <span class="math inline">\(sum\)</span> 为前缀和，即求满足 <spanclass="math inline">\(sum[l,r]\equiv 0 \pmod k\)</span> 的区间个数。</p><p>即： <span class="math display">\[sum[l,r] \bmod k =(sum[r]-sum[l-1])\bmod k = 0\]</span></p><p>也就是： <span class="math display">\[sum[l-1]\equiv sum[r] \pmod k\]</span></p><p>于是题目变成了对每个位置 <span class="math inline">\(i\)</span>求小于 <span class="math inline">\(i\)</span> 的所有前缀和中有多少模<span class="math inline">\(k\)</span> 值相同，用 <code>std::map</code>维护即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">sum</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];&#125;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cnt;cnt[<span class="hljs-number">0</span>]++;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;res+=cnt[sum[i]%k];cnt[sum[i]%k]++;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="f.-easy-problem">F. Easy Problem</h2><div class="note note-info">            <p>题意：<span class="math inline">\(A,B\)</span> 在 <spanclass="math inline">\(n\times n\)</span>的网格图上游走，每次移动它们能选择上下左右四个方向中的一个，然后两个人按该方向行走一格（如前方是边界或障碍物则不移动），问两人相遇所需的最小移动步数。</p><p><span class="math inline">\(2\le n \le 50\)</span>。</p>          </div><div class="note note-success">            <p>只要想到把两个玩家的位置同时压缩成一个状态就迎刃而解了。</p><p>令 <span class="math inline">\(dep[ax][ay][bx][by]\)</span> 为 <spanclass="math inline">\(A\)</span> 在点 <spanclass="math inline">\((ax,ay)\)</span>，<spanclass="math inline">\(B\)</span> 在点 <spanclass="math inline">\((bx,by)\)</span> 时两人相遇所需的最短步数。</p><p>广度优先搜索，每次移动若新位置对应的状态非 <spanclass="math inline">\(0\)</span>，则代表有更短的路径到达那个位置。</p><p>那么我们不移动，否则步数 <span class="math inline">\(+1\)</span>进行转移。</p><p>当 <span class="math inline">\((ax,ay)=(bx,by)\)</span>时代表两人到达同一点。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<span class="hljs-type">int</span> sx,sy,fx,fy;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;cin&gt;&gt;s[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) &#123;<span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;a&#x27;</span>) &#123;sx=i;sy=j;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;b&#x27;</span>) &#123;fx=i;fy=j;&#125;&#125;&#125;<span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; node;<span class="hljs-type">int</span> dx[]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;queue&lt;node&gt; q;map&lt;node,<span class="hljs-type">int</span>&gt; dep;dep[&#123;sx,sy,fx,fy&#125;]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;sx,sy,fx,fy&#125;);<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-keyword">auto</span> point=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">auto</span> [ax,ay,bx,by]=point;<span class="hljs-keyword">if</span>(ax==bx &amp;&amp; ay==by) &#123;<span class="hljs-type">int</span> res=dep[point];<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i) &#123;<span class="hljs-type">int</span> nax=ax+dx[i],nay=ay+dy[i];<span class="hljs-type">int</span> nbx=bx+dx[i],nby=by+dy[i];<span class="hljs-keyword">if</span>(nax&lt;<span class="hljs-number">0</span> || nax&gt;=n || nay&lt;<span class="hljs-number">0</span> || nay&gt;=n || s[nax][nay]==<span class="hljs-string">&#x27;*&#x27;</span>) &#123;nax=ax;nay=ay;&#125;<span class="hljs-keyword">if</span>(nbx&lt;<span class="hljs-number">0</span> || nbx&gt;=n || nby&lt;<span class="hljs-number">0</span> || nby&gt;=n || s[nbx][nby]==<span class="hljs-string">&#x27;*&#x27;</span>) &#123;nbx=bx;nby=by;&#125;node npoint=&#123;nax,nay,nbx,nby&#125;;<span class="hljs-keyword">if</span>(dep.<span class="hljs-built_in">find</span>(npoint)==dep.<span class="hljs-built_in">end</span>()) &#123;q.<span class="hljs-built_in">push</span>(npoint);dep[npoint]=dep[point]<span class="hljs-number">+1</span>;&#125;&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;no solution&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="j.-ihis-homework">J. IHI’s Homework</h2><div class="note note-info">            <p>题意：给定整数 <span class="math inline">\(s\)</span> 和序列 <spanclass="math inline">\(a\)</span>，令答案为满足 <spanclass="math inline">\(x_1+x_2+\dots+x_n\le s\)</span> 且 <spanclass="math inline">\(\forall x_i \ge a_i\)</span> 的序列 <spanclass="math inline">\(x\)</span> 的方案数。<spanclass="math inline">\(q\)</span> 次询问每次更改 <spanclass="math inline">\(a\)</span> 中的一个数，问每次变动后的答案。</p><p><span class="math inline">\(1\le n,q,a_i \le 2\times10^5\)</span>，<span class="math inline">\(0\le s\le 2\times10^5\)</span>。</p>          </div><div class="note note-success">            <p>简单排列组合，但我不会数学，这题就显得很难。</p><p>将题目转化成球盒问题，有 <span class="math inline">\(n\)</span>个盒子和 <span class="math inline">\(s\)</span>个球，将无区分的球放进有区分的盒子，可以有空盒，且第 <spanclass="math inline">\(i\)</span> 个盒子至少得有 <spanclass="math inline">\(x_i\)</span> 个球，每次修改一个 <spanclass="math inline">\(x_i\)</span>，问方案数。</p><p>首先把每个盒子放入 <span class="math inline">\(x_i\)</span>个球，剩下 <span class="math inline">\(t=s-\sum x_i\)</span>个球可以任意放入 <span class="math inline">\(n\)</span> 个盒子。</p><p>结论：<span class="math inline">\(n\)</span> 个无区别球放入 <spanclass="math inline">\(m\)</span> 个有区别盒子，允许空盒的方案数是 <spanclass="math inline">\(C_{m+n-1}^{n}\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Why?    </div>    <div class='spoiler-content'>        <p>高中数学学过插板法。</p><p>如果每个盒子至少有一个球，那么我们可以用 <spanclass="math inline">\(m-1\)</span> 个板去插 <spanclass="math inline">\(n-1\)</span> 个空，方案数是 <spanclass="math inline">\(C_{n-1}^{m-1}\)</span>。</p><p>如果允许空盒，那么要做一个转化：</p><p>转化为 <span class="math inline">\(n\)</span> 个无区别球和 <spanclass="math inline">\(m-1\)</span> 个无区别板的一个自由排列，再把这<span class="math inline">\(m-1\)</span> 个板选出来，也就是 <spanclass="math inline">\(C_{n+m-1}^{m-1}=C_{n+m-1}^{n}\)</span>。</p>    </div></div><div class="note note-success">            <p>那么答案就是： <span class="math display">\[\sum_{i=1}^t C_{n+i-1}^{i}\]</span></p><p>发现对于相同的 <span class="math inline">\(t\)</span>答案相同，那么只要预处理出上式的前缀和就可以 <spanclass="math inline">\(O(1)\)</span> 回答询问。</p><p>时间复杂度 <span class="math inline">\(O(n+s+q)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout);</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span><span class="hljs-number">+7</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;    <span class="hljs-type">int</span> x;    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == a.x; &#125;;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x != a.x; &#125;;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * y * a.x % mod);&#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(y) / a;&#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="hljs-keyword">return</span> is &gt;&gt; t.x;&#125;    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;            mul *= mul;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (b) &#123;            <span class="hljs-type">int</span> t = a / b;            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);        &#125;        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;        <span class="hljs-keyword">return</span> u;    &#125;    &#125;;<span class="hljs-keyword">using</span> mint = ModInt&lt;modp&gt;;<span class="hljs-function"><span class="hljs-keyword">inline</span> mint <span class="hljs-title">qpow</span><span class="hljs-params">(mint k,<span class="hljs-type">int</span> n)</span> </span>&#123;mint s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s=s*k;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">math</span> &#123;<span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;vector&lt;mint&gt; frac;vector&lt;mint&gt; inv;<span class="hljs-built_in">math</span>() &#123;&#125;<span class="hljs-built_in">math</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;frac.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+2</span>);inv.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+2</span>);frac[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size<span class="hljs-number">+1</span>;i&lt;=n;++i) &#123;frac[i]=frac[i<span class="hljs-number">-1</span>]*i;&#125;inv[n]=<span class="hljs-built_in">qpow</span>(frac[n],modp<span class="hljs-number">-2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=size<span class="hljs-number">+1</span>;--i) &#123;inv[i<span class="hljs-number">-1</span>]=inv[i]*i;&#125;size=n;&#125;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">if</span>(n&lt;m || m&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(n&gt;size) <span class="hljs-built_in">init</span>(n);<span class="hljs-keyword">return</span> frac[n]*inv[m]*inv[n-m];&#125;&#125;binom;<span class="hljs-function">mint <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>&#123;<span class="hljs-keyword">return</span> binom.<span class="hljs-built_in">C</span>(n,m); &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),s=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();sum+=a[i];&#125;<span class="hljs-function">vector&lt;mint&gt; <span class="hljs-title">p</span><span class="hljs-params">(s<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s;++i) &#123;p[i]=<span class="hljs-built_in">C</span>(n+i<span class="hljs-number">-1</span>,i);<span class="hljs-keyword">if</span>(i) p[i]+=p[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> pos=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>();sum+=x-a[pos];a[pos]=x;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s-sum&gt;=<span class="hljs-number">0</span> ? p[s-sum] : <span class="hljs-number">0ll</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="k.-ihis-magic-string">K. IHI’s Magic String</h2><div class="note note-info">            <p>题意：现在有一个空字符串和三种操作，输出 <spanclass="math inline">\(q\)</span> 次操作后的字符串。</p><ol type="1"><li><p>把一个指定小写字母插到末尾。</p></li><li><p>删除字符串末尾的字符（若为空字符串则不操作）</p></li><li><p>把目前所有的字符 <span class="math inline">\(x\)</span>替换成字符 <span class="math inline">\(y\)</span>。</p></li></ol><p><span class="math inline">\(1\le q \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>一般这种正着做简单但时间复杂度高的题总是考虑倒着做。</p><p>倒着做的好处在于：假设有操作 <span class="math inline">\(a\tob\)</span>，那么之后添加的 <span class="math inline">\(a\)</span>都可以直接用 <span class="math inline">\(b\)</span> 替代，那如果再有<span class="math inline">\(b\to c\)</span> 呢？</p><p>用 <span class="math inline">\(mp[i]\)</span> 表示在添加 <spanclass="math inline">\(i\)</span> 时应该添加 <spanclass="math inline">\(mp[i]\)</span>，初始 <spanclass="math inline">\(mp[i]=i\)</span>。</p><p>那么对于上面那种情况实际等效于 <span class="math inline">\(a\toc\)</span>，我们直接 <spanclass="math inline">\(mp[a]=mp[b]\)</span>。</p><p>这其实类似并查集的路径压缩方法。</p><p>对于删除操作，可以直接用一个延迟标记（这里是 <spanclass="math inline">\(\text{del}\)</span>），来 <spanclass="math inline">\(O(1)\)</span> 判断当前字符是否计入答案，很妙。</p><p>时间复杂度 <span class="math inline">\(O(q\log 26)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; ver;<span class="hljs-type">int</span> q=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> opt=<span class="hljs-built_in">read</span>(),a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;<span class="hljs-type">char</span> t[<span class="hljs-number">3</span>];<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;t);a=t[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;t);a=t[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;t);b=t[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>;&#125;ver.<span class="hljs-built_in">push_back</span>(&#123;opt,a,b&#125;);&#125;map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i) &#123;mp[i]=i;&#125;<span class="hljs-type">int</span> del=<span class="hljs-number">0</span>;string res=<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ver.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-keyword">auto</span> [opt,a,b] = ver[i];<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(del) &#123;del--;&#125; <span class="hljs-keyword">else</span> &#123;res+=mp[a]+<span class="hljs-string">&#x27;a&#x27;</span>;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>) &#123;del++;&#125; <span class="hljs-keyword">else</span> &#123;mp[a]=mp[b];&#125;&#125;<span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The final string is empty&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;cout&lt;&lt;res&lt;&lt;endl;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="i.-optimal-biking-strategy">I. Optimal Biking Strategy</h2><div class="note note-info">            <p>题意：<span class="math inline">\(\text{Alice}\)</span> 要去到 <spanclass="math inline">\(p\)</span> 米外的超市，他可以走路或骑车。路上有<span class="math inline">\(n\)</span>个停车点，能且仅能在停车点上下车，一块钱最多能骑 <spanclass="math inline">\(s\)</span> 米（骑 <spanclass="math inline">\(x\)</span> 米需花费 <spanclass="math inline">\(\left\lceil \frac{x}{s} \right\rceil\)</span>元）。他现在只有 <span class="math inline">\(k\)</span>元，问最少需要走路多远。</p><p><span class="math inline">\(1\le n \le 10^6\)</span>，<spanclass="math inline">\(1\le p,s \le 10^9\)</span>，<spanclass="math inline">\(1\le k\le 5\)</span>。</p>          </div><div class="note note-success">            <p>场上写了一个 <span class="math inline">\(O(nk\log n)\)</span>很奇怪的背包一直调不出来，后面发现完全是假的。</p><p>感觉我到现在对于 <span class="math inline">\(\text{dp}\)</span>一直是模棱两可的状态，很烦。</p><p>用 <span class="math inline">\(dp_{i,j}\)</span> 代表前 <spanclass="math inline">\(i\)</span> 个停车点花费 <spanclass="math inline">\(j\)</span> 能骑的最远距离，那么答案就是 <spanclass="math inline">\(p-dp_{n,k}\)</span>。</p><p>至于转移，根据题意算钱要上取整，所以多个相邻的骑车区间肯定是直接合并。</p><p>因为连续，所以可以二分，对于每一个 <spanclass="math inline">\(k\in[1,j]\)</span> 二分出花费 <spanclass="math inline">\(k\)</span> 能骑到的最远距离再转移。</p><p>具体地，当前在 <span class="math inline">\(i\)</span>，就从满足 <spanclass="math inline">\(a_i-a_l\le sk\)</span> 的最远的 <spanclass="math inline">\(l\)</span> 处转移而来，即： <spanclass="math display">\[dp_{i,j}=\max(dp_{i,j},dp_{l,j-k}+a_i-a_l)\]</span></p><p>时间复杂度 <span class="math inline">\(O(nk^2\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;    <span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),dis=<span class="hljs-built_in">read</span>(),per_cost=<span class="hljs-built_in">read</span>();    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        a[i]=<span class="hljs-built_in">read</span>();    &#125;    <span class="hljs-type">int</span> V=<span class="hljs-built_in">read</span>();    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(V<span class="hljs-number">+1</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=V;++j) &#123;            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j];            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=j;++k) &#123;                <span class="hljs-type">int</span> mx=per_cost*k;                <span class="hljs-comment">// a[i]-a[lst]&lt;=mx</span>                <span class="hljs-comment">// a[lst]&gt;=a[i]-mx</span>                <span class="hljs-type">int</span> id=<span class="hljs-built_in">lower_bound</span>(a.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>,a.<span class="hljs-built_in">end</span>(),a[i]-mx)-a.<span class="hljs-built_in">begin</span>();                <span class="hljs-keyword">if</span>(id&lt;=n) &#123;                    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[id][j-k]+a[i]-a[id]);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> res=dis-dp[n][V];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//fre(test);</span>    <span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(T--) &#123;        <span class="hljs-built_in">solve</span>();        <span class="hljs-comment">//fflush(stdout);</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="h.-ganyu-segment-tree">H. Ganyu Segment Tree</h2><div class="note note-info">            <p>题意：给定一个长度 <span class="math inline">\(n\)</span> 初值全为<span class="math inline">\(1\)</span> 的序列 <spanclass="math inline">\(a\)</span>，每个位置有上锁和不上锁两种状态。</p><p>三种操作，共操作 <span class="math inline">\(m\)</span> 次： *<code>flip p</code> ：改变 <span class="math inline">\(a_p\)</span>的状态。</p><ul><li><p><code>mul l r x</code> ：把子段 <spanclass="math inline">\([l,r]\)</span> 中所有未上锁元素乘以 <spanclass="math inline">\(x\)</span>。</p></li><li><p><code>div l r x</code> ：查询子段 <spanclass="math inline">\([l,r]\)</span> 中所有元素（包括上锁）是否是 <spanclass="math inline">\(x\)</span> 的倍数，输出 <code>Yes</code> 或<code>No</code> 。若为 <code>Yes</code> ，将 <spanclass="math inline">\([l,r]\)</span> 中的所有未上锁元素除以 <spanclass="math inline">\(x\)</span>。</p></li></ul><p><span class="math inline">\(1\le n,m \le 10^5\)</span>，<spanclass="math inline">\(1\le x \le 30\)</span>。</p>          </div><div class="note note-success">            <p>修改的数 <span class="math inline">\(x\)</span> 很小，所以可以把<span class="math inline">\(x\)</span> 质因数分解，而 <spanclass="math inline">\([1,30]\)</span> 内就 <spanclass="math inline">\(10\)</span> 个质数。</p><p>我们对每个质数都建一颗线段树，而处理是否能整除只需判断是否该区间都含有某个质因子。</p><p>具体的，对于操作 <code>mul l r x</code>，若 <spanclass="math inline">\(x\)</span> 能分解成 <spanclass="math inline">\(cnt\)</span> 个质因子 <spanclass="math inline">\(y\)</span>，则在 <spanclass="math inline">\(y\)</span> 所属的线段树上区间 <spanclass="math inline">\(+ cnt\)</span>。</p><p>那么对于操作 <code>div l r x</code>，检查 <spanclass="math inline">\(x\)</span> 的每个质因子 <spanclass="math inline">\(y\)</span>，若 <spanclass="math inline">\(y\)</span> 所属的线段树在 <spanclass="math inline">\([l,r]\)</span> 内的区间最小值比 <spanclass="math inline">\(cnt\)</span> 小，那么该区间不能被整除。否则区间<span class="math inline">\(-cnt\)</span>。</p><p>现在考虑如何维护解锁与未解锁。是一个很清奇的技巧：</p><p>对于每颗线段树开两个值 <spanclass="math inline">\(tr1,tr2\)</span>，分别代表当前区间未锁定元素的最小值和区间锁定元素的最小值，初始化<span class="math inline">\(tr1=0,\ tr2=inf\)</span>。</p><p>对于 <code>mul</code> 和 <code>div</code> 操作，只对 <spanclass="math inline">\(tr1\)</span> 进行操作。</p><p>对于 <code>flip</code> 操作，只需单点 <spanclass="math inline">\(swap(tr1,tr2)\)</span>。</p><p>对于查询操作，我们返回 <spanclass="math inline">\(\min(tr1,tr2)\)</span>。</p><p>我们发现 <span class="math inline">\(inf\)</span>和加减的值不在一个数量级，相当于没有影响，所以这么做是正确的。</p><p>时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout)</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; tree1,tree2;vector&lt;<span class="hljs-type">int</span>&gt; lazy_add;<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size) &#123;n = size<span class="hljs-number">+1</span>;tree<span class="hljs-number">1.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>);tree<span class="hljs-number">2.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n<span class="hljs-number">+1</span>,inf);lazy_add.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;tree1[p] = <span class="hljs-built_in">min</span>(tree1[p&lt;&lt;<span class="hljs-number">1</span>], tree1[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);tree2[p] = <span class="hljs-built_in">min</span>(tree2[p&lt;&lt;<span class="hljs-number">1</span>], tree2[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> </span>&#123;<span class="hljs-keyword">if</span>(lazy_add[p]) &#123;<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   += lazy_add[p];lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] += lazy_add[p];tree1[p&lt;&lt;<span class="hljs-number">1</span>]       += lazy_add[p];tree1[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]     += lazy_add[p];lazy_add[p] = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_build</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<span class="hljs-keyword">if</span>(left == right) &#123;tree1[p] = nums[left];tree2[p] = inf;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">in_build</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,nums);<span class="hljs-built_in">in_build</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,nums);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_add</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;tree1[p]    += val;lazy_add[p] += val;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql &lt;= mid) <span class="hljs-built_in">update_add</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);<span class="hljs-keyword">if</span>(qr &gt; mid)  <span class="hljs-built_in">update_add</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,ql,qr,val);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_change</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ql &lt;= left &amp;&amp; qr &gt;= right) &#123;            <span class="hljs-built_in">swap</span>(tree1[p], tree2[p]);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">pushdown</span>(p,left,right);            <span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (ql &lt;= mid) <span class="hljs-built_in">update_change</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);            <span class="hljs-keyword">if</span> (qr &gt; mid)  <span class="hljs-built_in">update_change</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,ql,qr,val);            <span class="hljs-built_in">pushup</span>(p);        &#125;    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(tree1[p], tree2[p]);&#125;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-type">int</span> res = inf;<span class="hljs-keyword">if</span>(ql &lt;= mid) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">range_query</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr));<span class="hljs-keyword">if</span>(qr &gt; mid)  res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">range_query</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,ql,qr));<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<span class="hljs-built_in">in_build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,nums);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-built_in">update_add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-built_in">update_change</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr);&#125;&#125;;<span class="hljs-type">int</span> prime[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;SegmentTree&gt; <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">10</span>,SegmentTree(n))</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;seg[i].<span class="hljs-built_in">build</span>(a);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">char</span> opt[<span class="hljs-number">5</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;opt);<span class="hljs-keyword">if</span>(opt[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;f&#x27;</span>) &#123;<span class="hljs-type">int</span> pos=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;seg[i].<span class="hljs-built_in">change</span>(pos,pos,<span class="hljs-number">0</span>);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;m&#x27;</span>) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(x%prime[i]==<span class="hljs-number">0</span>) &#123;cnt++;x/=prime[i];&#125;seg[i].<span class="hljs-built_in">add</span>(l,r,cnt);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>();<span class="hljs-type">bool</span> ok=<span class="hljs-literal">true</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;<span class="hljs-keyword">while</span>(x%prime[i]==<span class="hljs-number">0</span>) &#123;cnt[i]++;x/=prime[i];&#125;<span class="hljs-keyword">if</span>(seg[i].<span class="hljs-built_in">query</span>(l,r)&lt;cnt[i]) &#123;ok=<span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">if</span>(!ok) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) &#123;seg[i].<span class="hljs-built_in">add</span>(l,r,-cnt[i]);&#125;&#125;&#125;&#125; &#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//fre(test);</span><span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="a.-skills">A. Skills</h2><div class="note note-info">            <p>题意：现有 <span class="math inline">\(3\)</span> 项技能，编号 <spanclass="math inline">\(1,2,3\)</span>。初始每项技能的熟练度为 <spanclass="math inline">\(0\)</span>。接下来有 <spanclass="math inline">\(n\)</span> 天，第 <spanclass="math inline">\(i\)</span> 天可以选择一项技能（假设是第 <spanclass="math inline">\(j\)</span>项）进行练习，然后在这天结束时让这项技能的熟练度增加 <spanclass="math inline">\(a_{i,j}\)</span>。同时，如果某一项技能（假设是第<span class="math inline">\(k\)</span> 项）已经有 <spanclass="math inline">\(x\)</span>天没有练习，那么在这天结束时，这项技能的熟练度会减少 <spanclass="math inline">\(x\)</span>（不会减少到 <spanclass="math inline">\(0\)</span> 以下）。</p><p>问在第 <span class="math inline">\(n\)</span> 天结束后，这 <spanclass="math inline">\(3\)</span> 项技能的熟练度之和最大为多少。</p><p><span class="math inline">\(1\le n \le 1000\)</span>，<spanclass="math inline">\(\forall\text{ } 1\le i\le n\)</span>，<spanclass="math inline">\(1\le j \le 3\)</span>，<spanclass="math inline">\(0\le a_{i,j} \le 10^4\)</span>。</p>          </div><div class="note note-success">            <p><span class="math inline">\(\text{dp}\)</span> 题。</p><p>首先要注意到最优解里面，一个技能如果开始学习了，那么中间过程熟练度不会降到<span class="math inline">\(0\)</span> 以下。否则不如不学。</p><p>其次假如一个技能有 <span class="math inline">\(t\)</span>天没有学习，那么将会损失 <spanclass="math inline">\(1+2+\dots+t=\dfrac{t(t+1)}{2}\)</span>点熟练度。</p><p>也就是说一个技能如果开始学习了，不会停止学习超过 <spanclass="math inline">\(2\sqrt W +O(1)\)</span> 天，其中 <spanclass="math inline">\(W=\max (a_{i,j})\)</span>。</p><p>令 <span class="math inline">\(dp_{i,j,x,y}\)</span> 代表到第 <spanclass="math inline">\(i\)</span> 天，在这天选择练习技能 <spanclass="math inline">\(j\)</span>，其它两项技能分别有 <spanclass="math inline">\(x\)</span> 天和 <spanclass="math inline">\(y\)</span>天没有练习了能带来的最大收益。每次转移从上一天练习的三种情况转移而来。</p><p>那么 <span class="math inline">\(\text{ans}=\max(dp_{n,1\sim 3,0\simW,0\sim W})\)</span>。</p><p>其中第一维可以滚动，总状态数不超过 <spanclass="math inline">\(O(W^2)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(nW^2)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x) printf(<span class="hljs-string">&quot;check %lld\n&quot;</span>,x);fflush(stdout)</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">205</span>;<span class="hljs-type">int</span> arr[N][<span class="hljs-number">3</span>];<span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][W][W];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j) &#123;arr[i][j]=<span class="hljs-built_in">read</span>();&#125;&#125;<span class="hljs-built_in">memset</span>(dp[<span class="hljs-number">0</span>],<span class="hljs-number">-0x3f</span>,<span class="hljs-keyword">sizeof</span> dp[<span class="hljs-number">0</span>]);dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<span class="hljs-type">int</span> lst=<span class="hljs-number">1</span>,now=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;a&lt;n;++a) &#123;lst^=<span class="hljs-number">1</span>;now^=<span class="hljs-number">1</span>;<span class="hljs-built_in">memset</span>(dp[now],<span class="hljs-number">-0x3f</span>,<span class="hljs-keyword">sizeof</span> dp[now]);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;b&lt;<span class="hljs-number">3</span>;++b) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;c&lt;W;++c) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;d&lt;W;++d) &#123;<span class="hljs-type">int</span> x=(!c) ? <span class="hljs-number">0ll</span> : c<span class="hljs-number">+1</span>;<span class="hljs-type">int</span> y=(!d) ? <span class="hljs-number">0ll</span> : d<span class="hljs-number">+1</span>;dp[now][b][x][y]=<span class="hljs-built_in">max</span>(dp[now][b][x][y],dp[lst][b][c][d]+arr[a][b]-x-y);                    dp[now][(b<span class="hljs-number">+1</span>)%<span class="hljs-number">3</span>][y][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[now][(b<span class="hljs-number">+1</span>)%<span class="hljs-number">3</span>][y][<span class="hljs-number">1</span>],dp[lst][b][c][d]+arr[a][(b<span class="hljs-number">+1</span>)%<span class="hljs-number">3</span>]<span class="hljs-number">-1</span>-y);                    dp[now][(b<span class="hljs-number">+2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>][x]=<span class="hljs-built_in">max</span>(dp[now][(b<span class="hljs-number">+2</span>)%<span class="hljs-number">3</span>][<span class="hljs-number">1</span>][x],dp[lst][b][c][d]+arr[a][(b<span class="hljs-number">+2</span>)%<span class="hljs-number">3</span>]<span class="hljs-number">-1</span>-x);&#125;&#125;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;<span class="hljs-number">3</span>;++a) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;b&lt;W;++b) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;c&lt;W;++c) &#123;ans=<span class="hljs-built_in">max</span>(ans,dp[now][a][b][c]);&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> UESTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】蓝桥算法双周赛 第一场</title>
      <link href="/posts/55f142fc.html"/>
      <url>/posts/55f142fc.html</url>
      
        <content type="html"><![CDATA[<h2 id="d.-健身">D. 健身</h2><div class="note note-info">            <p>题意：在未来 <span class="math inline">\(1\sim n\)</span>天中可以安排健身计划。有 <span class="math inline">\(m\)</span>个健身计划，第 <span class="math inline">\(i\)</span> 个计划需要连续的<span class="math inline">\(2^{k_i}\)</span> 天，增益为 <spanclass="math inline">\(s_i\)</span>。一个计划可以多次完成并获得多次增益，但一天不能同时进行多个计划。在<span class="math inline">\(1\sim n\)</span> 天中有 <spanclass="math inline">\(q\)</span>天有其它安排，不能健身。问能获得的最大增益。</p><p><span class="math inline">\(1\le q\le n \le 2\times10^5\)</span>，<span class="math inline">\(1\le m \le 50\)</span>，<spanclass="math inline">\(1\le s_i \le 10^9\)</span>，<spanclass="math inline">\(0\le k \le 20\)</span>。</p>          </div><div class="note note-success">            <p>对于相同的 <spanclass="math inline">\(k\)</span>，显然只需要保留增益最大的 <spanclass="math inline">\(s_i\)</span>。</p><p>令 <span class="math inline">\(w_k\)</span> 表示锻炼 <spanclass="math inline">\(2^k\)</span> 天能得到的最大增益值。</p><p>令 <span class="math inline">\(dp_i\)</span> 表示锻炼到 <spanclass="math inline">\(i\)</span> 天可以得到的最大增益，那么： <spanclass="math display">\[dp_i=\max(dp_{i-1},dp_{i-2^k}+w_k)\]</span></p><p>转移的前提是第 <span class="math inline">\(i-2^k+1\)</span> 天到第<span class="math inline">\(i\)</span> 天必须空闲。</p><p>判断一段时间是否空闲可以用前缀和 <spanclass="math inline">\(O(1)\)</span> 判断。</p><p>时间复杂度 <span class="math inline">\(O(nk)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();sum[x]++;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;sum[i]+=sum[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>(),s=<span class="hljs-built_in">read</span>();val[k]=<span class="hljs-built_in">max</span>(val[k],s);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;dp[i]=dp[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">22</span>;++k) &#123;<span class="hljs-type">int</span> step=<span class="hljs-number">1</span>&lt;&lt;k;<span class="hljs-keyword">if</span>(i-step&gt;=<span class="hljs-number">1</span> &amp;&amp; sum[i]-sum[i-step]==<span class="hljs-number">0</span>) &#123;dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[i-step]+val[k]);&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[n]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="e.-契合匹配">E. 契合匹配</h2><div class="note note-info">            <p>题意：用一个首尾相接的由英文字母组成的字符串表示一个齿轮。两个齿轮是契合的当且仅当每个对应位是同一个字母的大小写，如<code>AbCDeFgh</code> 和 <code>aBcdEfGH</code>。齿轮是环形的，问第一个齿轮 <span class="math inline">\(S\)</span>至少旋转多少位能与第二个齿轮 <span class="math inline">\(T\)</span>完全契合，或无论如何都不能契合。</p><p><span class="math inline">\(1\le |S|,|T|\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>套路：破环成链。</p><p>以题例为例，<spanclass="math inline">\(S=\text{AbCDeFgh}\)</span>，延长一倍后变成 <spanclass="math inline">\(S=\text{AbCDeFghAbCDeFgh}\)</span>。</p><p>另外，可以将 <span class="math inline">\(S\)</span>大小写反转，变成纯粹的字符串匹配问题，如反转后：</p><p><span class="math inline">\(S=\text{aBcdEfGHaBcdEfGH}\)</span>，<spanclass="math inline">\(T=\text{aBcdEfGH}\)</span></p><p>那么假设 <span class="math inline">\(T\)</span> 在 <spanclass="math inline">\(S\)</span> 中出现的首位为 <spanclass="math inline">\(p\)</span>，则 <spanclass="math inline">\(\text{ans}=\min(p-1,n-p+1)\)</span>。</p><p>利用 KMP 算法匹配字符串，时间复杂度 <spanclass="math inline">\(O(n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();string a,b;cin&gt;&gt;a&gt;&gt;b;a+=a;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">islower</span>(a[i])) &#123;a[i]=<span class="hljs-built_in">toupper</span>(a[i]);&#125; <span class="hljs-keyword">else</span> &#123;a[i]=<span class="hljs-built_in">tolower</span>(a[i]);&#125;&#125;<span class="hljs-comment">// find b in a</span>vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">auto</span> KMP = [&amp;] (string a,string b) &#123;<span class="hljs-type">int</span> ha=a.<span class="hljs-built_in">size</span>();<span class="hljs-type">int</span> hb=b.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>) &#123;ha--;&#125; <span class="hljs-keyword">else</span> &#123;a=<span class="hljs-string">&#x27; &#x27;</span>+a;&#125;<span class="hljs-keyword">if</span>(b[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>) &#123;hb--;&#125; <span class="hljs-keyword">else</span> &#123;b=<span class="hljs-string">&#x27; &#x27;</span>+b;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(hb<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,p=<span class="hljs-number">0</span>;i&lt;=hb;++i) &#123;<span class="hljs-keyword">while</span>(p &amp;&amp; b[i]!=b[p<span class="hljs-number">+1</span>]) &#123;p=nxt[p];&#125;<span class="hljs-keyword">if</span>(b[i]==b[p<span class="hljs-number">+1</span>]) &#123;p++;&#125;nxt[i]=p;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,p=<span class="hljs-number">0</span>;i&lt;=ha;++i) &#123;<span class="hljs-keyword">while</span>(p &amp;&amp; a[i]!=b[p<span class="hljs-number">+1</span>]) &#123;p=nxt[p];&#125;<span class="hljs-keyword">if</span>(a[i]==b[p<span class="hljs-number">+1</span>]) &#123;p++;&#125;<span class="hljs-keyword">if</span>(p==hb) &#123;ans.<span class="hljs-built_in">push_back</span>(i-hb<span class="hljs-number">+1</span>);p=nxt[p];&#125;&#125;<span class="hljs-keyword">return</span> nxt;&#125;;<span class="hljs-built_in">KMP</span>(a,b);<span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-type">int</span> res=inf;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:ans) &#123;res=<span class="hljs-built_in">min</span>(res,k<span class="hljs-number">-1</span>);res=<span class="hljs-built_in">min</span>(res,n-(k<span class="hljs-number">-1</span>));&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="f.-奇怪的线段">F. 奇怪的线段</h2><div class="note note-info">            <p>题意：数轴上给定 <span class="math inline">\(n\)</span> 个线段 <spanclass="math inline">\([l_i,r_i]\)</span>。<spanclass="math inline">\(q\)</span> 次询问两个点 <spanclass="math inline">\(a,b\)</span> 问有多少个线段包含 <spanclass="math inline">\(a\)</span> 而不含 <spanclass="math inline">\(b\)</span>。</p><p><span class="math inline">\(1\le n,q,a_i,b_i \le 2 \times10^5\)</span>，<span class="math inline">\(1\le l_i &lt; r_i \le 2\times10^5\)</span>。</p>          </div><div class="note note-success">            <p>先考虑只有条件 “ 有多少个线段包含 <spanclass="math inline">\(a\)</span> ” 怎么做。</p><p>用一个 <code>vector</code> 存以 <spanclass="math inline">\(i\)</span> 为左端点的线段的右端点是哪些。</p><p>从左到右扫，每遇到一个左端点就把右端点插进线段树（单点加一），每遇到一个右端点就把该点从线段树中删掉（单点减一），遇到<span class="math inline">\(a\)</span>时查询线段树中的节点数量（区间求和）就是答案。</p><p>ps. 数轴上的一个点可能是多个线段的左/右端点，所以实际上我们是减去对应<code>vector</code> 的大小。</p><p>但现在是 ” 包含 <span class="math inline">\(a\)</span> 而不包含 <spanclass="math inline">\(b\)</span> ” 。</p><p>改进方法是：查询局部区间和而不是全局区间和。</p><p>具体的： 1. 如果 <span class="math inline">\(a=b\)</span>，答案为<span class="math inline">\(0\)</span>。</p><ol start="2" type="1"><li><p>如果 <spanclass="math inline">\(a&lt;b\)</span>，从左到右扫描，遇到左端点把右端点插进线段树；遇到右端点则将右端点从线段树中移除，扫描到<span class="math inline">\(a\)</span> 时，查询 <spanclass="math inline">\([a,b)\)</span> 区间和即为答案。</p></li><li><p>如果 <spanclass="math inline">\(a&gt;b\)</span>，从右到左扫描，遇到右端点把左端点插进线段树；遇到左端点则将左端点从线段树中移除，扫描到<span class="math inline">\(a\)</span> 时，查询 <spanclass="math inline">\((b,a]\)</span> 区间和即为答案。</p></li></ol><p>预处理出 <span class="math inline">\(2,3\)</span>两种情况对应的询问，扫两次即可。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code 线段树版本    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;<span class="hljs-type">int</span> n,modp;vector&lt;<span class="hljs-type">int</span>&gt; tree;vector&lt;<span class="hljs-type">int</span>&gt; lazy_add;vector&lt;<span class="hljs-type">int</span>&gt; lazy_mul;<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> MOD = LLONG_MAX) &#123;n = size;modp = MOD;tree.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>);lazy_add.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>);lazy_mul.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>*n<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;tree[p] = (tree[p&lt;&lt;<span class="hljs-number">1</span>] + tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]) % modp;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> </span>&#123;<span class="hljs-keyword">if</span>(lazy_mul[p]!=<span class="hljs-number">1</span>) &#123;lazy_mul[p&lt;&lt;<span class="hljs-number">1</span>]   = lazy_mul[p&lt;&lt;<span class="hljs-number">1</span>]   * lazy_mul[p] % modp;lazy_mul[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] = lazy_mul[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] * lazy_mul[p] % modp;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   = lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   * lazy_mul[p] % modp;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] = lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] * lazy_mul[p] % modp;tree[p&lt;&lt;<span class="hljs-number">1</span>]       = tree[p&lt;&lt;<span class="hljs-number">1</span>]       * lazy_mul[p] % modp;tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]     = tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]     * lazy_mul[p] % modp;lazy_mul[p] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(lazy_add[p]) &#123;<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   = (lazy_add[p&lt;&lt;<span class="hljs-number">1</span>]   + lazy_add[p]) % modp;lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] = (lazy_add[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] + lazy_add[p]) % modp;tree[p&lt;&lt;<span class="hljs-number">1</span>]       = (tree[p&lt;&lt;<span class="hljs-number">1</span>]   + (mid-left<span class="hljs-number">+1</span>)  * lazy_add[p] % modp) % modp;tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]     = (tree[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>] + (right-mid)   * lazy_add[p] % modp) % modp;lazy_add[p] = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_build</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<span class="hljs-keyword">if</span>(left == right) &#123;tree[p] = nums[left];&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-built_in">in_build</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,nums);<span class="hljs-built_in">in_build</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,nums);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit_change</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left == right) &#123;        nums[left] += tree[p];    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">pushdown</span>(p,left,right);        <span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">submit_change</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,nums);        <span class="hljs-built_in">submit_change</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,nums);        <span class="hljs-built_in">pushup</span>(p);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_add</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;tree[p]     = (tree[p]     + (right-left<span class="hljs-number">+1</span>) * val % modp) % modp;lazy_add[p] = (lazy_add[p] + val) % modp;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql &lt;= mid) <span class="hljs-built_in">update_add</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);<span class="hljs-keyword">if</span>(qr &gt; mid) <span class="hljs-built_in">update_add</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,ql,qr,val);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_mul</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;tree[p]     = tree[p]     * val % modp;lazy_add[p] = lazy_add[p] * val % modp;lazy_mul[p] = lazy_mul[p] * val % modp;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(ql &lt;= mid) <span class="hljs-built_in">update_mul</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);<span class="hljs-keyword">if</span>(qr &gt; mid) <span class="hljs-built_in">update_mul</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,ql,qr,val);<span class="hljs-built_in">pushup</span>(p);&#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_change</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ql &lt;= left &amp;&amp; qr &gt;= right) &#123;            tree[p] = (val * (right - left + <span class="hljs-number">1</span>)) % modp;            lazy_add[p] = val;            lazy_mul[p] = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">pushdown</span>(p,left,right);            <span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (ql &lt;= mid) <span class="hljs-built_in">update_change</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr,val);            <span class="hljs-keyword">if</span> (qr &gt; mid) <span class="hljs-built_in">update_change</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,ql,qr,val);            <span class="hljs-built_in">pushup</span>(p);        &#125;    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">if</span>(ql &lt;= left &amp;&amp; qr &gt;= right) &#123;<span class="hljs-keyword">return</span> tree[p] % modp;&#125;<span class="hljs-built_in">pushdown</span>(p,left,right);<span class="hljs-type">int</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ql &lt;= mid) res = (res + <span class="hljs-built_in">range_query</span>(p&lt;&lt;<span class="hljs-number">1</span>,left,mid,ql,qr) ) % modp;<span class="hljs-keyword">if</span>(qr &gt; mid) res = (res + <span class="hljs-built_in">range_query</span>(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,right,ql,qr) ) % modp;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<span class="hljs-built_in">in_build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,nums);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;    <span class="hljs-built_in">submit_change</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,nums);    &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-built_in">update_add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr,<span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-built_in">update_mul</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-built_in">update_change</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr,val);    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql,<span class="hljs-type">int</span> qr)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,ql,qr);&#125;&#125;;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pl</span>(N),<span class="hljs-built_in">pr</span>(N);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>();pl[r].<span class="hljs-built_in">push_back</span>(l);pr[l].<span class="hljs-built_in">push_back</span>(r);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; ql,qr;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a&lt;b) &#123;ql.<span class="hljs-built_in">push_back</span>(&#123;a,b,i&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&gt;b) &#123;qr.<span class="hljs-built_in">push_back</span>(&#123;a,b,i&#125;);&#125;&#125;<span class="hljs-function">SegmentTree <span class="hljs-title">segl</span><span class="hljs-params">(N)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(N)</span></span>;segl.<span class="hljs-built_in">build</span>(tmp);<span class="hljs-built_in">sort</span>(ql.<span class="hljs-built_in">begin</span>(),ql.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b,id]:ql) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&lt;=a;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:pr[i]) &#123;segl.<span class="hljs-built_in">add</span>(k,k,<span class="hljs-number">1</span>);&#125;segl.<span class="hljs-built_in">add</span>(i,i,-pl[i].<span class="hljs-built_in">size</span>());&#125;pos=a<span class="hljs-number">+1</span>;segl.<span class="hljs-built_in">add</span>(a,a,pl[a].<span class="hljs-built_in">size</span>());ans[id]=segl.<span class="hljs-built_in">query</span>(a,b<span class="hljs-number">-1</span>);segl.<span class="hljs-built_in">add</span>(a,a,-pl[a].<span class="hljs-built_in">size</span>());&#125;<span class="hljs-function">SegmentTree <span class="hljs-title">segr</span><span class="hljs-params">(N)</span></span>;segr.<span class="hljs-built_in">build</span>(tmp);<span class="hljs-built_in">sort</span>(qr.<span class="hljs-built_in">begin</span>(),qr.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(qr.<span class="hljs-built_in">begin</span>(),qr.<span class="hljs-built_in">end</span>());pos=<span class="hljs-number">2e5</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b,id]:qr) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&gt;=a;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:pl[i]) &#123;segr.<span class="hljs-built_in">add</span>(k,k,<span class="hljs-number">1</span>);&#125;segr.<span class="hljs-built_in">add</span>(i,i,-pr[i].<span class="hljs-built_in">size</span>());&#125;pos=a<span class="hljs-number">-1</span>;segr.<span class="hljs-built_in">add</span>(a,a,pr[a].<span class="hljs-built_in">size</span>());ans[id]=segr.<span class="hljs-built_in">query</span>(b<span class="hljs-number">+1</span>,a);segr.<span class="hljs-built_in">add</span>(a,a,-pr[a].<span class="hljs-built_in">size</span>());&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code 树状数组版本    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fenwick</span> &#123;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; tr;<span class="hljs-built_in">Fenwick</span>() &#123;&#125;<span class="hljs-built_in">Fenwick</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n<span class="hljs-number">+1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-keyword">this</span>-&gt;n = n;tr.<span class="hljs-built_in">assign</span>(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">while</span>(pos&lt;=n)&#123;tr[pos]+=x;pos+=pos&amp;-pos;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(pos)&#123;res+=tr[pos];pos-=pos&amp;-pos;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r)-<span class="hljs-built_in">sum</span>(l<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">// tr[x] count the cnt of x</span><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;res+=(<span class="hljs-number">1</span>&lt;&lt;i);<span class="hljs-keyword">if</span>(res&gt;n || cnt+tr[res]&gt;=k)&#123;res-=(<span class="hljs-number">1</span>&lt;&lt;i);&#125; <span class="hljs-keyword">else</span> &#123;cnt+=tr[res];&#125;&#125;<span class="hljs-keyword">return</span> res<span class="hljs-number">+1</span>;&#125;&#125;;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pl</span>(N),<span class="hljs-built_in">pr</span>(N);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>();pl[r].<span class="hljs-built_in">push_back</span>(l);pr[l].<span class="hljs-built_in">push_back</span>(r);&#125;vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; ql,qr;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a&lt;b) &#123;ql.<span class="hljs-built_in">push_back</span>(&#123;a,b,i&#125;);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&gt;b) &#123;qr.<span class="hljs-built_in">push_back</span>(&#123;a,b,i&#125;);&#125;&#125;<span class="hljs-function">Fenwick <span class="hljs-title">fenl</span><span class="hljs-params">(N)</span></span>;<span class="hljs-built_in">sort</span>(ql.<span class="hljs-built_in">begin</span>(),ql.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b,id]:ql) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&lt;=a;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:pr[i]) &#123;fenl.<span class="hljs-built_in">add</span>(k,<span class="hljs-number">1</span>);&#125;fenl.<span class="hljs-built_in">add</span>(i,-pl[i].<span class="hljs-built_in">size</span>());&#125;pos=a<span class="hljs-number">+1</span>;fenl.<span class="hljs-built_in">add</span>(a,pl[a].<span class="hljs-built_in">size</span>());ans[id]=fenl.<span class="hljs-built_in">rangeSum</span>(a,b<span class="hljs-number">-1</span>);fenl.<span class="hljs-built_in">add</span>(a,-pl[a].<span class="hljs-built_in">size</span>());&#125;<span class="hljs-function">Fenwick <span class="hljs-title">fenr</span><span class="hljs-params">(N)</span></span>;<span class="hljs-built_in">sort</span>(qr.<span class="hljs-built_in">begin</span>(),qr.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">reverse</span>(qr.<span class="hljs-built_in">begin</span>(),qr.<span class="hljs-built_in">end</span>());pos=<span class="hljs-number">2e5</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b,id]:qr) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&gt;=a;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:pl[i]) &#123;fenr.<span class="hljs-built_in">add</span>(k,<span class="hljs-number">1</span>);&#125;fenr.<span class="hljs-built_in">add</span>(i,-pr[i].<span class="hljs-built_in">size</span>());&#125;pos=a<span class="hljs-number">-1</span>;fenr.<span class="hljs-built_in">add</span>(a,pr[a].<span class="hljs-built_in">size</span>());ans[id]=fenr.<span class="hljs-built_in">rangeSum</span>(b<span class="hljs-number">+1</span>,a);fenr.<span class="hljs-built_in">add</span>(a,-pr[a].<span class="hljs-built_in">size</span>());&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】AtCoder Beginner Contest 222 D~G</title>
      <link href="/posts/81df370c.html"/>
      <url>/posts/81df370c.html</url>
      
        <content type="html"><![CDATA[<h2 id="d.-between-two-arrays">D. Between Two Arrays</h2><p><ahref="https://atcoder.jp/contests/abc222/tasks/abc222_d">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span>的单调不下降的整数序列 <span class="math inline">\(a,b\)</span>，且满足<span class="math inline">\(a_i\le b_i\)</span>。求满足 <spanclass="math inline">\(a_i\le c_i\le b_i\)</span> 的单调不下降的整数序列<span class="math inline">\(c\)</span> 的数量。</p><p><span class="math inline">\(1\le n\le 3000\)</span>，<spanclass="math inline">\(0\le a_i\le b_i\le 3000\)</span>。</p>          </div><div class="note note-success">            <p>前缀和优化 dp 经典题。</p><p>令 <span class="math inline">\(dp_{i,j}\)</span> 表示长度为 <spanclass="math inline">\(i\)</span> 且以 <spanclass="math inline">\(j\)</span> 结尾的单调不下降序列数量。则： <spanclass="math display">\[dp_{i,j}=\sum\limits_{k\in [0,j] \text{ }\cap \text{ }[a_{i-1},b_{i-1}]}dp_{i-1,k}\]</span></p><p>那么我们需要枚举 <spanclass="math inline">\(i,j,k\)</span>，时间复杂度 <spanclass="math inline">\(O(n\alpha^2)\)</span>，<spanclass="math inline">\(\alpha\)</span> 为值域。</p><p>利用前缀和优化，令 <spanclass="math inline">\(s_{i,j}=\sum\limits_{j\in[0,j]}dp_{i,j}\)</span>，<spanclass="math inline">\(O(\alpha)\)</span> 便能完成转移。</p><p>总时间复杂度 <span class="math inline">\(O(n\alpha)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;    <span class="hljs-type">int</span> x;    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == a.x; &#125;;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x != a.x; &#125;;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * y * a.x % mod);&#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(y) / a;&#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="hljs-keyword">return</span> is &gt;&gt; t.x;&#125;    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;            mul *= mul;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (b) &#123;            <span class="hljs-type">int</span> t = a / b;            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);        &#125;        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;        <span class="hljs-keyword">return</span> u;    &#125;    &#125;;<span class="hljs-keyword">using</span> mint = ModInt&lt;modp&gt;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;vector&lt;vector&lt;mint&gt;&gt; <span class="hljs-built_in">dp</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;mint&gt;(<span class="hljs-number">3002</span>,<span class="hljs-number">0</span>));vector&lt;vector&lt;mint&gt;&gt; <span class="hljs-built_in">sum</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;mint&gt;(<span class="hljs-number">3002</span>,<span class="hljs-number">0</span>));dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3000</span>;++i) &#123;sum[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=a[i];j&lt;=b[i];++j) &#123;<span class="hljs-type">int</span> l=a[i<span class="hljs-number">-1</span>],r=<span class="hljs-built_in">min</span>(j,b[i<span class="hljs-number">-1</span>]);dp[i][j]+=sum[i<span class="hljs-number">-1</span>][r<span class="hljs-number">+1</span>]-sum[i<span class="hljs-number">-1</span>][l];&#125;sum[i][<span class="hljs-number">1</span>]=dp[i][<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">3000</span>;++j) &#123;sum[i][j<span class="hljs-number">+1</span>]=sum[i][j]+dp[i][j];&#125;&#125;mint res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">3000</span>;++i) &#123;res+=dp[n][i];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="e.-red-and-blue-tree">E. Red and Blue Tree</h2><p><ahref="https://atcoder.jp/contests/abc222/tasks/abc222_e">Problem</a></p><div class="note note-info">            <p>题意：给定一棵 <span class="math inline">\(n\)</span>个点的树和一个长为 <span class="math inline">\(m\)</span> 的序列 <spanclass="math inline">\(a\)</span> 和一个整数 <spanclass="math inline">\(K\)</span>，你需要给这颗树上的边染蓝色或染红色。合法的染色方案满足从<span class="math inline">\(a_1\)</span> 开始依次途径 <spanclass="math inline">\(a_2,a_3,\dots ,a_{n-1}\)</span> 最后到达 <spanclass="math inline">\(a_n\)</span> 的路径中经过的蓝边数总和 <spanclass="math inline">\(B\)</span> 和红边数总和 <spanclass="math inline">\(R\)</span>，有 <spanclass="math inline">\(R-B=K\)</span>。求方案数。</p><p><span class="math inline">\(2\le n\le 1000\)</span>，<spanclass="math inline">\(2\le m\le 100\)</span>。</p>          </div><div class="note note-success">            <p>对每两个相邻的数都跑 <span class="math inline">\(\text{dfs}\)</span>记录每条边 <span class="math inline">\(i\)</span> 的经过次数 <spanclass="math inline">\(C_i\)</span>。</p><p>问题转化为：将 <spanclass="math inline">\(C_1,C_2,...,C_{n-1}\)</span>分成两个集合使得两个集合里元素的和 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(B\)</span> 满足 <spanclass="math inline">\(R-B=K\)</span>。</p><p>令 <span class="math inline">\(C_1+C_2+...+C_{n-1}=S\)</span> ,则</p><p><span class="math display">\[\begin{cases}S=R+B\\R-B=K \end{cases}\rightarrow 2R=S+K\rightarrowR=\frac{S+K}{2}\]</span></p><p>问题转化为从 <span class="math inline">\(C_1,C_2,...,C_{n-1}\)</span>中选择若干个数使得和为 <spanclass="math inline">\(\frac{S+K}{2}\)</span>，dp 即可 。</p><p>具体的，令 <span class="math inline">\(dp_x\)</span> 表示使得和为<span class="math inline">\(x\)</span> 的方案数，<spanclass="math inline">\(dp_x=\sum dp_{x-C_i}\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),K=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n<span class="hljs-number">+1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(&#123;y,i&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x,i&#125;);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath,<span class="hljs-type">int</span> goal) &#123;<span class="hljs-keyword">if</span>(x==goal) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,i]:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fath) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">self</span>(self,y,x,goal)) &#123;cnt[i]++;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i) &#123;<span class="hljs-built_in">dfs</span>(dfs,a[i],<span class="hljs-number">0</span>,a[i<span class="hljs-number">+1</span>]);&#125;<span class="hljs-type">int</span> S=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;S+=cnt[i];&#125;<span class="hljs-keyword">if</span>((S+K)%<span class="hljs-number">2</span> || S+K&lt;<span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>)</span></span>;dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1e5</span>;x&gt;=cnt[i];--x) &#123;dp[x]+=dp[x-cnt[i]];dp[x]%=modp;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[(S+K)/<span class="hljs-number">2</span>]);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="f.-expensive-expense">F. Expensive Expense</h2><p><ahref="https://atcoder.jp/contests/abc222/tasks/abc222_f">problem</a></p><div class="note note-info">            <p>题意：树上每个点有权值 <spanclass="math inline">\(a_i\)</span>，边也有边权 <spanclass="math inline">\(w_i\)</span>。令 <spanclass="math inline">\(dis_{i,j}\)</span> 表示 <spanclass="math inline">\(i\)</span> 到 <spanclass="math inline">\(j\)</span> 的简单路径长度 , 对于每一个 <spanclass="math inline">\(i\)</span> 求 <spanclass="math inline">\(\sum\limits_{j=1,j\neq i}^n\max(dis_{i,j}+a_j)\)</span>。</p><p><span class="math inline">\(2\le n\le 2\times 10^5\)</span>，<spanclass="math inline">\(1\le c_i,w_i \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>方法一：（树的直径的性质）</p><p>一个结论：距离树上任意一点最远的点一定是直径两个端点中的一个。（这也是两次<span class="math inline">\(\text{dfs}\)</span>能够求树的直径的依据）</p><p>但这里有点权，那我们可以变通。</p><p>两次 <span class="math inline">\(\text{dfs}\)</span>求树的直径时，将比较 <span class="math inline">\(dis_i\)</span> 换成比较<span class="math inline">\(dis_i+a_i\)</span>。这样求出来的 “直径”就是整颗树 <span class="math inline">\(dis_i+ a_i\)</span>最大的路径。</p><p>确定了直径的两个端点 <span class="math inline">\(ml,mr\)</span>后，再次应用 <span class="math inline">\(\text{dfs}\)</span>求出两个端点到所有点的简单路径距离 <spanclass="math inline">\(disl\)</span> 和 <spanclass="math inline">\(disr\)</span>。</p><p>那么对于每个 <span class="math inline">\(i\)</span>，<spanclass="math inline">\(ans=\max(disl_{i}+a_{ml},disr_{i}+a_{mr})\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n<span class="hljs-number">+1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(&#123;y,w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x,w&#125;);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fath,vector&lt;<span class="hljs-type">int</span>&gt; &amp;dis) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,z]:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fath) &#123;dis[y]=dis[x]+z;<span class="hljs-built_in">self</span>(self,y,x,dis);&#125;&#125;&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">dis1</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">dis2</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-built_in">dfs</span>(dfs,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,dis);<span class="hljs-type">int</span> ml=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,maxn=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(dis[i]+a[i]&gt;maxn) &#123;maxn=dis[i]+a[i];ml=i;&#125;&#125;<span class="hljs-built_in">dfs</span>(dfs,ml,<span class="hljs-number">0</span>,dis1);<span class="hljs-type">int</span> mr=<span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,maxn=<span class="hljs-number">0</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(i!=ml &amp;&amp; dis1[i]+a[i]&gt;maxn) &#123;maxn=dis1[i]+a[i];mr=i;&#125;&#125;<span class="hljs-built_in">dfs</span>(dfs,mr,<span class="hljs-number">0</span>,dis2);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(i!=ml) &#123;res=<span class="hljs-built_in">max</span>(res,dis1[i]+a[ml]);&#125;<span class="hljs-keyword">if</span>(i!=mr) &#123;res=<span class="hljs-built_in">max</span>(res,dis2[i]+a[mr]);&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>方法二：（换根dp）</p><p>第一次 <span class="math inline">\(\text{dfs}\)</span>，<spanclass="math inline">\(dp_{i,0/1}\)</span> 代表 <spanclass="math inline">\(i\)</span> 的子树内答案的最大值/次大值。那么有：<span class="math display">\[dp_{x}=\max_{y\in son[x]}(dp_{x},dp_{y}+w,a_y+w)\]</span></p><p>第二次 <spanclass="math inline">\(\text{dfs}\)</span>，可以画图分析： <imgsrc="https://kisuraop.github.io/image/academic/3.png" /></p><p>向下 <span class="math inline">\(\text{dfs}\)</span>时子树内的贡献没有改变，我们只需要分析另一边（绿色部分）多出了哪些贡献。</p><p>假设我们刚刚走过了边 <span class="math inline">\(fa\toy\)</span>，分为两种情况： 1. （橙字）<spanclass="math inline">\(dp_{fa,0}\)</span> 从非 <spanclass="math inline">\(y\)</span> 子树内转移而来，那么： <spanclass="math display">\[dp_y=\max(dp_y,dp_{fa,0}+w)\]</span></p><ol start="2" type="1"><li>（蓝字）<span class="math inline">\(dp_{fa,0}\)</span> 从 <spanclass="math inline">\(y\)</span>的子树内转移而来，非子树部分的最大值实际就是 <spanclass="math inline">\(fa\)</span> 节点对应的次大值，那么： <spanclass="math display">\[dp_y=\max(dp_y,dp_{fa,1}+w)\]</span></li></ol><p>最后更新答案。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>,2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n<span class="hljs-number">+1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();adj[x].<span class="hljs-built_in">push_back</span>(&#123;y,w&#125;);adj[y].<span class="hljs-built_in">push_back</span>(&#123;x,w&#125;);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">from</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,w]:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">self</span>(self,y,x);<span class="hljs-type">int</span> t=<span class="hljs-built_in">max</span>(a[y],dp[y][<span class="hljs-number">0</span>])+w;<span class="hljs-keyword">if</span>(t&gt;dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>]=dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>]=t;from[x]=y;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>]=t;&#125;&#125;&#125;&#125;;<span class="hljs-built_in">dfs</span>(dfs,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> w) -&gt; <span class="hljs-type">void</span> &#123;<span class="hljs-type">int</span> t=a[fa]+w;<span class="hljs-keyword">if</span>(from[fa]!=x) &#123;t=<span class="hljs-built_in">max</span>(t,dp[fa][<span class="hljs-number">0</span>]+w);&#125; <span class="hljs-keyword">else</span> &#123;t=<span class="hljs-built_in">max</span>(t,dp[fa][<span class="hljs-number">1</span>]+w);&#125;<span class="hljs-keyword">if</span>(t&gt;dp[x][<span class="hljs-number">0</span>]) &#123;dp[x][<span class="hljs-number">1</span>]=dp[x][<span class="hljs-number">0</span>];dp[x][<span class="hljs-number">0</span>]=t;from[x]=fa;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;dp[x][<span class="hljs-number">1</span>]) &#123;dp[x][<span class="hljs-number">1</span>]=t;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,w]:adj[x]) &#123;<span class="hljs-keyword">if</span>(y!=fa) &#123;<span class="hljs-built_in">self</span>(self,y,x,w);&#125;&#125;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y,w]:adj[<span class="hljs-number">1</span>]) &#123;<span class="hljs-built_in">dfs2</span>(dfs2,y,<span class="hljs-number">1</span>,w);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[i][<span class="hljs-number">0</span>]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="g.-222">G. 222</h2><p><ahref="https://atcoder.jp/contests/abc222/tasks/abc222_g">Problem</a></p><div class="note note-info">            <p>题意：幸运数字是由若干个 <span class="math inline">\(2\)</span>构成的数字（如 <spanclass="math inline">\(2,22,222,\dots\)</span>）。给定正整数 <spanclass="math inline">\(k\)</span>，当 <spanclass="math inline">\(k\)</span>的倍数第一次属于某个幸运数字时。输出该倍数由多少个 <spanclass="math inline">\(2\)</span> 组成。若不存在 <spanclass="math inline">\(k\)</span> 的倍数是幸运数字，输出 <spanclass="math inline">\(-1\)</span>。</p>          </div><div class="note note-success">            <p>幸运数字可以表示为 <span class="math inline">\(2\times\dfrac{10^x-1}{9}\)</span>。</p><p>问题转化为寻求最小的 <span class="math inline">\(x\)</span> 使得：<span class="math display">\[\begin{align}2\times \dfrac{10^x-1}{9}&amp;\equiv 0 \pmod{k}\\2\times(10^x-1) &amp;\equiv 0 \pmod{9k} \\10^x-1 &amp;\equiv 0\pmod{\dfrac{9k}{\gcd(k,2)}} \\10^x &amp;\equiv 1\pmod{\dfrac{9k}{\gcd(k,2)}}\end{align}\]</span></p><p>转化为了 <span class="math inline">\(a^x\equiv b \pmod{P}\)</span>的形式，运用 BSGS 算法即可求解。</p><p>还可以运用欧拉函数。</p><p>回忆欧拉定理：对于互质的正整数 <spanclass="math inline">\(a,n\)</span> 有 <spanclass="math inline">\(a^{\varphi(n)}\equiv1\pmod{n}\)</span> .</p><p>我们令 <span class="math inline">\(p=\dfrac{9k}{\gcd(k,2)},x=\varphi(p)\)</span>，则 <spanclass="math inline">\(10^{\varphi(p)}\equiv1\pmod{p}\)</span>，可以直接得到一个可行解。</p><p>虽然 <span class="math inline">\(\varphi(p)\)</span>不一定是满足条件的正整数，但答案一定是其因子，枚举即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-comment">//欧拉函数</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eular</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> ret=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/i;++i) &#123;    <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;        n/=i;        ret*=i<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) &#123;        n/=i;        ret*=i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) &#123;    ret*=n<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k%p) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s=s*k%p;<span class="hljs-keyword">return</span> s;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> K=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> p=<span class="hljs-number">9</span>*K/__gcd(K,<span class="hljs-number">2ll</span>);<span class="hljs-type">int</span> n=<span class="hljs-built_in">eular</span>(p);<span class="hljs-keyword">if</span>(__gcd(<span class="hljs-number">10ll</span>,p)&gt;<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> ans=n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">sqrtl</span>(n);++i) &#123;<span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">qpow</span>(<span class="hljs-number">10</span>,i,p) == <span class="hljs-number">1</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,i);&#125;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">qpow</span>(<span class="hljs-number">10</span>,n/i,p) == <span class="hljs-number">1</span>) &#123;ans=<span class="hljs-built_in">min</span>(ans,n/i);&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Atcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】Codeforces Round 902 (Div. 2, based on COMPFEST 15 - Final Round) 5 of 7</title>
      <link href="/posts/1537ce5a.html"/>
      <url>/posts/1537ce5a.html</url>
      
        <content type="html"><![CDATA[<h2 id="a.-goals-of-victory">A. Goals of Victory</h2><p><ahref="https://codeforces.com/contest/1877/problem/A">Problem</a></p><div class="note note-success">            <p>赢的场次一定和输的场次相等。</p><p>即 <span class="math inline">\(\sum\limits_{i=1}^{n} a_i =0\)</span>。故 <spanclass="math inline">\(ans=-\sum\limits_{i=1}^{n-1}a_i\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();sum+=a[i];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-number">-1</span>*sum);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-helmets-in-night-light">B. Helmets in Night Light</h2><p><ahref="https://codeforces.com/contest/1877/problem/B">Problem</a></p><div class="note note-info">            <p>题意：须弥除了草神外有 <span class="math inline">\(n\)</span>个居民。草神要通过虚空终端向所有 <span class="math inline">\(n\)</span>个人传递公告，其直接向一个居民传递的代价为 <spanclass="math inline">\(p\)</span>。居民 <spanclass="math inline">\(i\)</span>一旦得知，也可以向其它人传递，但最多直接传递给 <spanclass="math inline">\(a_i\)</span> 个人且每个人的传递代价为 <spanclass="math inline">\(b_i\)</span>。求最小代价。</p><p><span class="math inline">\(1\le n,a_i,b_i \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>考虑贪心。因为对于向单个人的传递代价，肯定是越小越好。</p><p>一开始，草神必然至少通知一个人，代价为 <spanclass="math inline">\(p\)</span>。</p><p>之后将代价 <span class="math inline">\(b_i\)</span>排序后从小到大选择，若 <spanclass="math inline">\(b_i&gt;p\)</span>，肯定不优，考虑把剩余的通知任务全堆给草神。</p><p>否则累加 <span class="math inline">\(a_i\)</span>，当选择的 <spanclass="math inline">\(a_i\)</span> 之和超过 <spanclass="math inline">\(n-1\)</span> 时就代表通知了所有人。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),p=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">order</span><span class="hljs-params">(n)</span></span>;<span class="hljs-built_in">iota</span>(order.<span class="hljs-built_in">begin</span>(),order.<span class="hljs-built_in">end</span>(),<span class="hljs-number">1</span>);<span class="hljs-built_in">sort</span>(order.<span class="hljs-built_in">begin</span>(),order.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<span class="hljs-keyword">return</span> b[i]&lt;b[j];&#125;);<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<span class="hljs-type">bool</span> fir=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:order) &#123;<span class="hljs-keyword">if</span>(b[i]&lt;=p) &#123;<span class="hljs-keyword">if</span>(fir) &#123;fir=<span class="hljs-literal">false</span>;res+=p;sum++;&#125;<span class="hljs-type">int</span> add=<span class="hljs-built_in">min</span>(n-sum,a[i]);sum+=add;res+=b[i]*add;<span class="hljs-keyword">if</span>(sum==n) &#123;<span class="hljs-keyword">break</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;res+=(n-sum)*p;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-joyboard">C. Joyboard</h2><p><ahref="https://codeforces.com/contest/1877/problem/C">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n+1\)</span> 的序列 <spanclass="math inline">\(a\)</span>，一开始全为空。你可以给 <spanclass="math inline">\(a_{n+1}\)</span> 填上 <spanclass="math inline">\(0\sim m\)</span> 中的一个，之后从右向左构造 <spanclass="math inline">\(a_i=a_{i+1} \pmod {i}\)</span>。求最终序列有 <spanclass="math inline">\(k\)</span> 个不同的数的方案数。</p><p><span class="math inline">\(1\le n\le 10^9\)</span>，<spanclass="math inline">\(0\le m \le 10^9\)</span>，<spanclass="math inline">\(1\le k \le n+1\)</span>。</p>          </div><div class="note note-success">            <p>随便列举一下就图穷匕见了。</p><p>当 <span class="math inline">\(n=6\)</span> 时有： <spanclass="math display">\[\begin{alignat}{7}a_1 &amp;\quad&amp; a_2 &amp;\quad&amp; a_3&amp;\quad&amp; a_4 &amp;\quad&amp; a_5 &amp;\quad&amp; a_6&amp;\quad&amp; a_7\\0 &amp;\quad&amp; 0 &amp;\quad&amp; 0&amp;\quad&amp; 0 &amp;\quad&amp; 0 &amp;\quad&amp; 0 &amp;\quad&amp; 0\\0 &amp;\quad&amp; 1 &amp;\quad&amp; 1 &amp;\quad&amp; 1&amp;\quad&amp; 1 &amp;\quad&amp; 1 &amp;\quad&amp; 1 \\0&amp;\quad&amp; 0 &amp;\quad&amp; 2 &amp;\quad&amp; 2 &amp;\quad&amp; 2&amp;\quad&amp; 2 &amp;\quad&amp; 2 \\0 &amp;\quad&amp; 0&amp;\quad&amp; 0 &amp;\quad&amp; 3 &amp;\quad&amp; 3 &amp;\quad&amp; 3&amp;\quad&amp; 3 \\ &amp;\quad&amp; &amp;\quad&amp; &amp;\quad&amp;\vdots &amp;\quad&amp; &amp;\quad&amp; &amp;\quad&amp; \\0&amp;\quad&amp; 0 &amp;\quad&amp; 0 &amp;\quad&amp; 0 &amp;\quad&amp; 0&amp;\quad&amp; 0 &amp;\quad&amp; 6 \\0 &amp;\quad&amp; 1&amp;\quad&amp; 1 &amp;\quad&amp; 1 &amp;\quad&amp; 1 &amp;\quad&amp; 1&amp;\quad&amp; 7 \\0 &amp;\quad&amp; 0 &amp;\quad&amp; 2&amp;\quad&amp; 2 &amp;\quad&amp; 2 &amp;\quad&amp; 2 &amp;\quad&amp; 8\\0 &amp;\quad&amp; 0 &amp;\quad&amp; 0 &amp;\quad&amp; 3&amp;\quad&amp; 3 &amp;\quad&amp; 3 &amp;\quad&amp; 9 \\ &amp;\quad&amp;&amp;\quad&amp; &amp;\quad&amp; \vdots &amp;\quad&amp; &amp;\quad&amp;&amp;\quad&amp; \\0 &amp;\quad&amp; 0 &amp;\quad&amp; 0 &amp;\quad&amp;0 &amp;\quad&amp; 0 &amp;\quad&amp; 0 &amp;\quad&amp; 12 \\0&amp;\quad&amp; 1 &amp;\quad&amp; 1 &amp;\quad&amp; 1 &amp;\quad&amp; 1&amp;\quad&amp; 1 &amp;\quad&amp; 13 \\0 &amp;\quad&amp; 0&amp;\quad&amp; 2 &amp;\quad&amp; 2 &amp;\quad&amp; 2 &amp;\quad&amp; 2&amp;\quad&amp; 14 \\ &amp;\quad&amp; &amp;\quad&amp; &amp;\quad&amp;\vdots &amp;\quad&amp; &amp;\quad&amp; &amp;\quad&amp; \\\end{alignat}\]</span></p><p>生成的序列一定最多经过两次衰减变为 <spanclass="math inline">\(0\)</span>。</p><p>那么当 <span class="math inline">\(k&gt;3\)</span> 时一定无解。</p><p>令 <span class="math inline">\(a_{n+1}=x\)</span>：</p><p>当 <span class="math inline">\(k=1\)</span> 时，显然只有 <spanclass="math inline">\(x=0\)</span> 符合题意。</p><p>当 <span class="math inline">\(k=2\)</span> 时，首先对于 <spanclass="math inline">\(n\mid x\)</span> 一定符合题意，其次 <spanclass="math inline">\(x\in[1,n-1]\)</span>只衰减一次，同样符合题意。</p><p>当 <span class="math inline">\(k=3\)</span> 时，容斥一下就好了。<span class="math display">\[ans=\begin{cases}1 &amp;,k=1 \\m &amp;,k=2,m\le n \\n+\lfloor\frac{m-n}{n}\rfloor &amp;,k=2,m &gt; n \\m-n-\lfloor\frac{m-n}{n}\rfloor &amp;,k=3,m &gt; n \\0 &amp;,others\end{cases}\]</span></p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125; <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">3</span>) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> div=k/n,cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(m&lt;=n) &#123;cnt=m;&#125; <span class="hljs-keyword">else</span> &#123;cnt=m/n;cnt+=(n<span class="hljs-number">-1</span>);&#125;<span class="hljs-keyword">if</span>(k==<span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,cnt);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,m-cnt);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-effects-of-anti-pimples">D. Effects of Anti Pimples</h2><p><ahref="https://codeforces.com/contest/1877/problem/D">Problem</a></p><div class="note note-info">            <p>题意：给定长度为 <span class="math inline">\(n\)</span>的数列，一开始全为白色。你可以任意选一些索引，将对应位置涂黑。然后对于每一个涂黑的位置，将它索引的所有倍数的位置涂绿（不可覆盖黑）。定义该状态的价值为黑色和绿色所有位置上数的最大值。涂黑方案有<span class="math inline">\(2^n-1\)</span> 种，求所有方案价值总和。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<spanclass="math inline">\(0\le a_i \le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>令 <span class="math inline">\(f_i\)</span> 表示位置 <spanclass="math inline">\(i\)</span> 的价值。</p><p>因为将 <span class="math inline">\(a_i\)</span> 涂成黑色的同时所有<span class="math inline">\(i\mid j\)</span> 的 <spanclass="math inline">\(a_j\)</span> 被涂成了绿色。</p><p>而这段子序列的价值只和最大值有关，故 <spanclass="math inline">\(f_i=\max\limits_{i\mid j} a_j\)</span>。</p><p>考虑 <span class="math inline">\(f_i\)</span> 对答案的贡献。</p><p>一个结论，<span class="math inline">\(n\)</span>个数的所有子集中包含某个下标的子集有 <spanclass="math inline">\(2^{n-1}\)</span> 个。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        为什么?    </div>    <div class='spoiler-content'>        <p><span class="math inline">\(n\)</span> 个数共有 <spanclass="math inline">\(2^n-1\)</span> 个子集，去掉某个下标后剩下 <spanclass="math inline">\(n-1\)</span> 个数共有 <spanclass="math inline">\(2^{n-1}-1\)</span> 个子集。</p><p>这 <span class="math inline">\(2^{n-1}-1\)</span>个子集都不包含那个下标。故包含那个下标的子集有 <spanclass="math inline">\(2^n-1-(2^{n-1}-1)=2^{n-1}\)</span> 个。</p>    </div></div><div class="note note-success">            <p>故最大的 <span class="math inline">\(f_i\)</span> 对答案的贡献是<span class="math inline">\(f_i\times 2^{n-1}\)</span>。</p><p>而次大 <span class="math inline">\(f_i\)</span> 对答案的贡献是 <spanclass="math inline">\(f_i\times2^{n-2}\)</span>。因为次大值若有贡献必不能包含最大值，相当于除去最大<span class="math inline">\(f_i\)</span> 剩下 <spanclass="math inline">\(n-1\)</span> 个数，被 <spanclass="math inline">\(2^{n-2}\)</span> 个集合包含。</p><p>以此类推。</p><p>故答案为 <span class="math inline">\(\sum\limits_{i=1}^{n} 2^{i-1}f_i\)</span>。其中 <span class="math inline">\(f_i\)</span>从小到大排序。</p><p>时间复杂度 <span class="math inline">\(O(n\ln n)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;    <span class="hljs-type">int</span> x;    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == a.x; &#125;;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x != a.x; &#125;;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-type">int</span> x0 = y - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * y * a.x % mod);&#125;    <span class="hljs-keyword">friend</span> ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">int</span> y, <span class="hljs-type">const</span> ModInt &amp;a)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(y) / a;&#125;    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="hljs-keyword">return</span> is &gt;&gt; t.x;&#125;    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;            mul *= mul;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (b) &#123;            <span class="hljs-type">int</span> t = a / b;            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);        &#125;        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;        <span class="hljs-keyword">return</span> u;    &#125;    &#125;;<span class="hljs-keyword">using</span> mint = ModInt&lt;modp&gt;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j+=i) &#123;a[i]=<span class="hljs-built_in">max</span>(a[i],a[j]);&#125;&#125;<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>,a.<span class="hljs-built_in">end</span>());mint res=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;sum == <span class="hljs-number">0</span> ? sum=<span class="hljs-number">1</span> : sum=sum*<span class="hljs-number">2</span>;res+=sum*a[i];&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><div class="note note-warning">            <p>对于以下代码段，时间复杂度为 <span class="math inline">\(O(n\lnn)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j+=i) &#123;        <span class="hljs-comment">//do something</span>    &#125;&#125;</code></pre></div><p>因为执行次数 <spanclass="math inline">\(\frac{n}{1}+\frac{n}{2}+\frac{n}{3}+\dots+\frac{n}{n} =n(1+\frac{1}{2}+\frac{1}{3}+\dots+\frac{1}{n})\)</span>。调和级数的和约为<span class="math inline">\(\ln n\)</span>。</p>          </div><h2 id="e.-autosynthesis">E. Autosynthesis</h2><p><ahref="https://codeforces.com/contest/1877/problem/E">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的正整数序列<spanclass="math inline">\(a\)</span>。你要将这个序列划分成两个不交的子序列，满足其中一个子序列的下标构成的集合等于另一个子序列的值构成的集合。输出作为值的那一个子序列。</p><p><span class="math inline">\(1\le a_i\le n \le 2\times10^5\)</span>。</p>          </div><div class="note note-success">            <p>转换为图论模型，对每个 <span class="math inline">\(i\in[1,n]\)</span>连边 <span class="math inline">\(i\toa_i\)</span>，会形成一颗基环内向树。</p><p>考虑一个经典模型——置换环。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        那是什么    </div>    <div class='spoiler-content'>        <p>对于一个任意 <span class="math inline">\(1\sim n\)</span> 的排列<span class="math inline">\(a\)</span>，连边 <spanclass="math inline">\(i\toa_i\)</span>，得到的图一定是由一个或多个环组成（一个点看作长度为 <spanclass="math inline">\(1\)</span> 的环），称作置换环。</p><p>其意义在于，位于一个长度为 <span class="math inline">\(L\)</span>的置换环内的元素，经历最少 <span class="math inline">\(L-1\)</span>次元素交换便能使元素在原序列中有序。</p><p>于是对于任意一个排列，两两交换其中元素使其变得单调增的最小交换次数就是<span class="math inline">\(n-\text{置换环个数}\)</span>。</p>    </div></div><div class="note note-success">            <p>如果序列 <span class="math inline">\(a\)</span> 是排列，只需要满足<span class="math inline">\(a\)</span> 的所有置换环长度均为偶数。</p><p>因为可以间隔黑白染色，染成黑色和白色的点的集合正好对应题中的两个序列。</p><p>例如，有排列 <code>4 3 6 5 7 8 1 2</code> ，连边后如下图。</p><p><img src="https://kisuraop.github.io/image/academic/2.png" alt="2" />下标集合 <code>1,2,5,6</code> 或 <code>1,3,5,8</code> 或<code>3,4,7,8</code> 等均符合题意。</p><p>为什么间隔染色正确？因为对于一条有向边，总是一个索引指向对应的值。</p><p>而挑选出的 <span class="math inline">\(\frac{n}{2}\)</span>个点的出边指向的 “值的点集” 正好与 “索引点集” 互补！</p><p>那么剩下的 <span class="math inline">\(\frac{n}{2}\)</span> 的“值的点集” 就必然与 “索引点集” 相同。</p><p>好，但现在 <span class="math inline">\(a\)</span>并不是排列，但这也说明有一些数不会在 <spanclass="math inline">\(a\)</span> 中出现： * 若点 <spanclass="math inline">\(i\)</span> 被选入索引点集，则存在一个没被选的点<span class="math inline">\(j\)</span> 满足 <spanclass="math inline">\(a_j=i\)</span>。</p><ul><li>若对点 <span class="math inline">\(i\)</span> 有 <spanclass="math inline">\(\exists\mkern-10mu/ \text{ }j\)</span> 使得 <spanclass="math inline">\(a_j=i\)</span>，那这个点一定属于值的点集。</li></ul><p>这意味这 <span class="math inline">\(n\)</span>个数中有一些数的状态是确定的。</p><p>手玩一下样例，模拟一下将索引点集对应的值逐步删掉，只留下值的集合的过程：</p><div class="code-wrapper"><pre><code class="hljs c++">Input：<span class="hljs-number">5</span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>Output：<span class="hljs-number">3</span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre></div><p>首先 <span class="math inline">\(1\)</span> 没在 <spanclass="math inline">\(a\)</span> 中出现，<spanclass="math inline">\(1\)</span> 不可能属于索引点集，那么 <spanclass="math inline">\(a[1]\)</span> 永远不能被删掉。</p><p>同理 <span class="math inline">\(a[5]\)</span> 也永远不能被删掉。</p><p>为保证 <span class="math inline">\(a[1]=3\)</span> 不被删，那么 <spanclass="math inline">\(a[3]\)</span> 必然被删掉。</p><p>为保证 <span class="math inline">\(a[3]=2\)</span> 必然被删，所以<span class="math inline">\(a[2]\)</span>永远不能被删掉？不，不一定。</p><p>因为场上不只有一个 <span class="math inline">\(2\)</span>，<spanclass="math inline">\(a[4]\)</span> 也是 <spanclass="math inline">\(2\)</span>，故 <spanclass="math inline">\(a[2]\)</span> 的状态不确定。</p><p>这个过程可以利用 <code>bfs</code> ，从入度为 <spanclass="math inline">\(0\)</span>的点开始搜，直到能确定状态的都被确定。</p><p>那么此时剩下的都是状态不确定的了。</p><p>此时就可以把剩下的数看作一个排列，按照上述方法判断置换环长度的奇偶性，确定答案。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">rd</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();rd[a[i]]++;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">del</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-comment">//储存有哪些数的状态被确定</span>queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!rd[i]) &#123;q.<span class="hljs-built_in">push</span>(i);&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();del[x]=<span class="hljs-literal">true</span>;ans.<span class="hljs-built_in">push_back</span>(x);<span class="hljs-keyword">if</span>(!del[a[x]] &amp;&amp; --rd[a[a[x]]]==<span class="hljs-number">0</span>) &#123;q.<span class="hljs-built_in">push</span>(a[a[x]]);&#125;del[a[x]]=<span class="hljs-literal">true</span>;&#125;<span class="hljs-type">bool</span> ok=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(del[i]) &#123;<span class="hljs-keyword">continue</span>;&#125;vector&lt;<span class="hljs-type">int</span>&gt; cycle;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;!del[j];j=a[j]) &#123;cycle.<span class="hljs-built_in">push_back</span>(j);del[j]=<span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span>(cycle.<span class="hljs-built_in">size</span>()%<span class="hljs-number">2</span>) &#123;ok=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cycle.<span class="hljs-built_in">size</span>();j+=<span class="hljs-number">2</span>) &#123;ans.<span class="hljs-built_in">push_back</span>(cycle[j]);&#125;&#125;<span class="hljs-keyword">if</span>(!ok) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans.<span class="hljs-built_in">size</span>());<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,a[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】《动手学深度学习》随笔 part1 —— pytorch 基本操作</title>
      <link href="/posts/a3c53bfd.html"/>
      <url>/posts/a3c53bfd.html</url>
      
        <content type="html"><![CDATA[<h2 id="数值操作">数值操作</h2><p>模块导入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch</code></pre></div><p>用 <code>torch.arange()</code> 创建向量：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.arange(<span class="hljs-number">12</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])</code></pre></div><div class="note note-info">            <p>参数列表：<code>torch.arange(start=0, end, step=1, \*, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor</code></p><p><code>start</code> <code>end</code> <code>step</code>：起始值，结束值和步长。</p><p><code>dtype</code> ：指定数据类型。</p><p><code>out</code> ：输出张量。</p><p><code>layout</code> ：布局方式，一般有以下两种： *<code>torch.strided</code>：密集布局，张量元素按一定步幅排列在内存中，相邻元素间地址差距连续，但元素不一定连续存储。</p><ul><li><code>torch.sparse_coo</code>：稀疏布局。只存储非零元素的索引和值，节省内存。访问 <ahref="https://runebook.dev/zh/docs/pytorch/sparse#sparse-docs">Link</a>获取更多信息。</li></ul><p><code>device</code> ：设备。例如可选 <code>cpu</code> 或<code>cuda</code> 。</p><p><code>requires_grad</code> ：是否为张量启用梯度计算。</p>          </div><p>用 <code>torch.reshape()</code> 改变张量形状：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>],         [ <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],         [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>]],        [[ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],         [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],         [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>]]])</code></pre></div><div class="note note-info">            <p>注：可以用 <span class="math inline">\(-1\)</span>表示自动填充某一个轴的大小。</p><p>如 <code>x = torch.arange(12).reshape((-1, 3, 2))</code>就和以上语句等价。</p>          </div><p>用 <code>shape</code> 获取沿所有轴的元素个数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.shape</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])</code></pre></div><div class="note note-info">            <p>如果只对张量的第一个维度感兴趣，可以用 <code>len(x)</code> 。</p>          </div><p>用 <code>torch.zeros(),torch.ones()</code> 获得全0 / 全1 张量：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.zeros(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])</code></pre></div><p>用 <code>torch.randn()</code> 随机采样（会生成均值为 0，标准差为 1的正态分布）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[[ <span class="hljs-number">0.2692</span>,  <span class="hljs-number">0.0791</span>,  <span class="hljs-number">0.0039</span>, -<span class="hljs-number">0.1389</span>],         [-<span class="hljs-number">0.1045</span>, -<span class="hljs-number">0.3420</span>,  <span class="hljs-number">0.2542</span>,  <span class="hljs-number">1.4940</span>],         [ <span class="hljs-number">1.5095</span>,  <span class="hljs-number">1.1909</span>, -<span class="hljs-number">0.5695</span>,  <span class="hljs-number">1.4376</span>]],        [[ <span class="hljs-number">0.5032</span>, -<span class="hljs-number">0.1839</span>, -<span class="hljs-number">0.0568</span>,  <span class="hljs-number">0.1740</span>],         [-<span class="hljs-number">0.2951</span>,  <span class="hljs-number">2.4619</span>,  <span class="hljs-number">1.2984</span>,  <span class="hljs-number">0.0647</span>],         [-<span class="hljs-number">0.5046</span>,  <span class="hljs-number">0.9516</span>, -<span class="hljs-number">0.0810</span>, -<span class="hljs-number">0.3269</span>]]])</code></pre></div><div class="note note-success">            <p>更一般地，有库函数<code>torch.normal(mean, std, size, out=None)</code> 。</p><p><code>mean</code> ：正态分布的均值。</p><p><code>std</code> ：正态分布的标准差。</p><p><code>size</code>：生成的张量形状。可以是整数（一维向量），也可以是元组或列表（多维张量）。</p><p><code>out</code>：如果提供了一个输出张量，随机生成的值将存储在这个张量中，而不是创建一个新的张量。</p><p>故 <code>torch.randn(2, 3, 4)</code> 等效于：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.normal(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))</code></pre></div>          </div><p>指定值：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],        [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>],        [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])</code></pre></div><p>用 <code>sum()</code> 求和：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.<span class="hljs-built_in">sum</span>()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">24</span>)</code></pre></div><p>用 <code>axis=0</code> 指定沿列求和：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>])</code></pre></div><p>用 <code>axis=1</code> 指定沿行求和：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>])</code></pre></div><p>用 <code>keepdims=True</code> 非降维求和（保持原有行/列的形状）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">4</span>],        [ <span class="hljs-number">8</span>],        [<span class="hljs-number">12</span>]])</code></pre></div><p>用 <code>numel()</code> 获取总元素个数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.numel()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">12</span></code></pre></div><p>四则运算：形状相同，按元素操作</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.tensor([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>x + y, x - y, x * y, x / y, x ** y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">( tensor([ <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">10</span>]),   tensor([-<span class="hljs-number">1</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">6</span>]),   tensor([ <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]),   tensor([<span class="hljs-number">0.5000</span>, <span class="hljs-number">1.0000</span>, <span class="hljs-number">2.0000</span>, <span class="hljs-number">4.0000</span>]),   tensor([ <span class="hljs-number">1</span>,  <span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">64</span>]) )</code></pre></div><p>其中，单纯两个矩阵中每个值按元素相乘，称为 <code>Hadamard 积</code>。</p><p><code>x.exp()</code> <span class="math inline">\(\to\)</span> <spanclass="math inline">\(e^x\)</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.exp()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">2.7183e+00</span>, <span class="hljs-number">7.3891e+00</span>, <span class="hljs-number">5.4598e+01</span>, <span class="hljs-number">2.9810e+03</span>])</code></pre></div><p>用 <code>dtype</code> 指定元素类型：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>, dtype=torch.float32).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>],        [ <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>]])</code></pre></div><p>用 <code>cat</code> 沿行（轴 0）拼接张量：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.tensor([[<span class="hljs-number">1.0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],        [<span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.cat((x, y), dim=<span class="hljs-number">0</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>],        [ <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>],        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],        [ <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>],        [ <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>]])</code></pre></div><p>用 <code>cat</code> 沿列（轴 1）拼接张量：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.cat((x, y), dim=<span class="hljs-number">1</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">2.</span>],        [ <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">3.</span>]])</code></pre></div><p>按元素比较：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x == y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],        [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>],        [<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>]])</code></pre></div><p>利用广播机制使得不同形状的张量执行按元素操作，<code>tensor</code>会自动扩充维度。</p><p>两个“可广播的” <code>tensor</code> 满足以下条件： * 每个<code>tensor</code> 至少一个维度。</p><ul><li>从末尾遍历 <code>tensor</code> 所有维度时，出现以下情况：<ul><li><p>维度相等。</p></li><li><p>维度不等 &amp;&amp; 其中一个维度为 <spanclass="math inline">\(1\)</span>。</p></li><li><p>维度不等 &amp;&amp; 其中一个维度不存在。</p></li></ul></li></ul><p>满足规则，将小的扩展成大的 <code>tensor</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">2</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.arange(<span class="hljs-number">4</span>).reshape((<span class="hljs-number">1</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x, y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">(tensor([[<span class="hljs-number">0</span>],        [<span class="hljs-number">1</span>]]), tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x + y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])</code></pre></div><p>这时候就体现非降维求和的优势了：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>sum_x = x.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>sum_x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">6</span>],        [<span class="hljs-number">22</span>],        [<span class="hljs-number">38</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x / sum_x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1667</span>, <span class="hljs-number">0.3333</span>, <span class="hljs-number">0.5000</span>],        [<span class="hljs-number">0.1818</span>, <span class="hljs-number">0.2273</span>, <span class="hljs-number">0.2727</span>, <span class="hljs-number">0.3182</span>],        [<span class="hljs-number">0.2105</span>, <span class="hljs-number">0.2368</span>, <span class="hljs-number">0.2632</span>, <span class="hljs-number">0.2895</span>]])</code></pre></div><p>可以看到对每一行/列求了平均，而不会因维度对不上而报错。</p><p>与 python 字符串类似地进行索引。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>],        [ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x[-<span class="hljs-number">1</span>]</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>],        [ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])</code></pre></div><p>将指定元素写入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>] = <span class="hljs-number">114514</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[     <span class="hljs-number">0</span>,      <span class="hljs-number">1</span>,      <span class="hljs-number">2</span>,      <span class="hljs-number">3</span>],        [     <span class="hljs-number">4</span>,      <span class="hljs-number">5</span>,      <span class="hljs-number">6</span>,      <span class="hljs-number">7</span>],        [     <span class="hljs-number">8</span>,      <span class="hljs-number">9</span>, <span class="hljs-number">114514</span>,     <span class="hljs-number">11</span>]])</code></pre></div><p>多元素赋值，先 0 轴后 1 轴。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-number">3</span>] = <span class="hljs-number">1919810</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1919810</span>, <span class="hljs-number">1919810</span>, <span class="hljs-number">1919810</span>,       <span class="hljs-number">3</span>],        [<span class="hljs-number">1919810</span>, <span class="hljs-number">1919810</span>, <span class="hljs-number">1919810</span>,       <span class="hljs-number">7</span>],        [      <span class="hljs-number">8</span>,       <span class="hljs-number">9</span>,  <span class="hljs-number">114514</span>,      <span class="hljs-number">11</span>]])</code></pre></div><p>以分配新内存的方式分配 <span class="math inline">\(x\)</span>的副本给 <span class="math inline">\(y\)</span>：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = x.clone()</code></pre></div><p>用 <code>mean()</code> 求所有均值（注意必须是浮点型）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">12</span>, dtype=torch.float32).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>],        [ <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.mean()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">5.5000</span>)</code></pre></div><p><code>x.mean(axis=0)</code> 等价于<code>x.sum(axis=0) / x.shape[0]</code></p><p>用 <code>cumsum</code> 沿着某个维度计算累计总和：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.cumsum(axis=<span class="hljs-number">0</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">10.</span>],        [<span class="hljs-number">12.</span>, <span class="hljs-number">15.</span>, <span class="hljs-number">18.</span>, <span class="hljs-number">21.</span>]])</code></pre></div><p>用 <code>torch.unsqueeze()</code> 增加数据维度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4</span>)  <span class="hljs-comment"># tensor([0, 1, 2, 3])</span><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.unequeeze(x, <span class="hljs-number">0</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])</code></pre></div><p>可以看到最外层增加了一维。</p><div class="note note-info">            <p>参数列表：<code>new_tensor = torch.unsqueeze(input, dim)</code></p><p><code>input</code>：需要操作的张量。</p><p><code>dim</code>：要在哪个维度上增加一个维度。</p><p>返回值是一个新的张量。</p>          </div><h2 id="线性代数操作">线性代数操作</h2><p>矩阵转置：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>A = torch.arange(<span class="hljs-number">20</span>, dtype=torch.float32).reshape(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>A</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>],        [ <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>],        [<span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>, <span class="hljs-number">12.</span>, <span class="hljs-number">13.</span>, <span class="hljs-number">14.</span>],        [<span class="hljs-number">15.</span>, <span class="hljs-number">16.</span>, <span class="hljs-number">17.</span>, <span class="hljs-number">18.</span>, <span class="hljs-number">19.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>A.T</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">5.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">15.</span>],        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">6.</span>, <span class="hljs-number">11.</span>, <span class="hljs-number">16.</span>],        [ <span class="hljs-number">2.</span>,  <span class="hljs-number">7.</span>, <span class="hljs-number">12.</span>, <span class="hljs-number">17.</span>],        [ <span class="hljs-number">3.</span>,  <span class="hljs-number">8.</span>, <span class="hljs-number">13.</span>, <span class="hljs-number">18.</span>],        [ <span class="hljs-number">4.</span>,  <span class="hljs-number">9.</span>, <span class="hljs-number">14.</span>, <span class="hljs-number">19.</span>]])</code></pre></div><p>点积（Dot Product）<span class="math inline">\(\textbf{x}^\top\textbf{y} = \sum x_iy_i\)</span>：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">5</span>, dtype=torch.float32)<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.ones(<span class="hljs-number">5</span>, dtype = torch.float32)<span class="hljs-meta">&gt;&gt;&gt; </span>x, y</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">(tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">4.</span>]), tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.dot(x, y)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">10.</span>)</code></pre></div><p>等效表达 <code>torch.sum(x * y)</code> 。</p><p>矩阵-向量积：</p><p>对于一个矩阵 <span class="math inline">\(^{mn}\)</span>，和向量 <spanclass="math inline">\(\textbf{x}\in \mathbb{R}^{n}\)</span>。<spanclass="math inline">\(\textbf{Ax} = \begin{bmatrix} a_{11} &amp; a_{12}&amp; \ldots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \ldots &amp;a_{2n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{m1} &amp;a_{m2} &amp; \ldots &amp; a_{mn} \end{bmatrix}\)</span> <spanclass="math inline">\(\begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_m\end{bmatrix}\)</span> <span class="math inline">\(= \begin{bmatrix}\left\langle a_1x\right\rangle \\ \left\langle a_2x\right\rangle \\\vdots \\ \left\langle a_mx\right\rangle \end{bmatrix}\)</span></p><p><span class="math inline">\(\left\langle a_ix \right\rangle\)</span>表示矩阵的第 <span class="math inline">\(i\)</span> 行构成的行向量和向量<span class="math inline">\(x\)</span> 的点积。</p><p>利用 <code>mv(A, x)</code> 进行矩阵-向量积：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>A, x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">(tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>],        [ <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>],        [<span class="hljs-number">10.</span>, <span class="hljs-number">11.</span>, <span class="hljs-number">12.</span>, <span class="hljs-number">13.</span>, <span class="hljs-number">14.</span>],        [<span class="hljs-number">15.</span>, <span class="hljs-number">16.</span>, <span class="hljs-number">17.</span>, <span class="hljs-number">18.</span>, <span class="hljs-number">19.</span>]]), tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">4.</span>]))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.mv(A, x)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([ <span class="hljs-number">30.</span>,  <span class="hljs-number">80.</span>, <span class="hljs-number">130.</span>, <span class="hljs-number">180.</span>])</code></pre></div><p>利用 <code>mm(A, B)</code> 矩阵乘法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>B = torch.ones(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.mm(A, B)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([[<span class="hljs-number">10.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">10.</span>],        [<span class="hljs-number">35.</span>, <span class="hljs-number">35.</span>, <span class="hljs-number">35.</span>, <span class="hljs-number">35.</span>],        [<span class="hljs-number">60.</span>, <span class="hljs-number">60.</span>, <span class="hljs-number">60.</span>, <span class="hljs-number">60.</span>],        [<span class="hljs-number">85.</span>, <span class="hljs-number">85.</span>, <span class="hljs-number">85.</span>, <span class="hljs-number">85.</span>]])</code></pre></div><div class="note note-success">            <p>更加通用地，有库函数<code>torch.matmul(input, other, out=None)</code> 执行矩阵相乘。</p><p><code>input</code> ：要进行矩阵相乘的第一个张量（或标量）。</p><p><code>other</code> ：要进行矩阵相乘的第二个张量（或标量）。</p><p><code>out</code>：如果提供了输出张量，结果将存储在这个张量中，而不是创建一个新的张量。</p><p><code>torch.normal()</code> 的行为取决于输入张量的维度。</p><ol type="1"><li><p>若两个张量均一维，执行内积（点积）操作，返回一个标量。</p></li><li><p>若两个张量均二维，它执行矩阵乘法，返回一个二维矩阵。</p></li><li><p>若至少一个张量高维，它执行广义矩阵乘法操作，根据广播规则计算结果。</p></li></ol>          </div><p>利用 <code>norm(x)</code> 求 <span class="math inline">\(L_2\)</span>范数： <span class="math display">\[\| \mathbf{v} \|_2 = \sqrt{v_1^2 + v_2^2 + \ldots + v_n^2}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>v = torch.tensor([<span class="hljs-number">3.0</span>,-<span class="hljs-number">4.0</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>torch.norm(v)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">5.</span>)</code></pre></div><p><span class="math inline">\(L_1\)</span> 范数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.<span class="hljs-built_in">abs</span>(v).<span class="hljs-built_in">sum</span>()</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">7.</span>)</code></pre></div><p>矩阵的 <span class="math inline">\(L_2\)</span>范数：（Frobenius范数） <span class="math display">\[\|A\|_2=\sqrt{\sum_{i=1}^{m}\sum_{j=1}^{n}|a_{ij}|^2}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>torch.norm(torch.ones((<span class="hljs-number">4</span>, <span class="hljs-number">9</span>)))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor(<span class="hljs-number">6.</span>)</code></pre></div><h2 id="微分操作">微分操作</h2><p>用 <code>requires_grad = True</code> 为张量启动梯度计算：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad = <span class="hljs-literal">True</span>) <span class="hljs-meta">&gt;&gt;&gt; </span>x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>])</code></pre></div><p>另一种写法：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.requires_grad_(<span class="hljs-literal">True</span>)</code></pre></div><p>利用 <code>backward()</code> 计算梯度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.dot(x, x)<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward()</code></pre></div><div class="note note-warning">            <p>注意，使用点积而不是乘法，因为 pytorch 只能对标量求梯度。</p><p>不过可以使用 <code>y.sum().backward()</code> 。</p><p>效果和 <code>y.backward(torch.ones_like(y))</code> 等同。</p>          </div><p>利用 <code>.grad</code> 显示梯度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.grad</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">6.</span>])</code></pre></div><p>由 <span class="math inline">\(\nabla\textbf{x}^\top\textbf{x}=2\textbf{x}\)</span>得知答案正确，也可以利用程序验证。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.grad == <span class="hljs-number">2</span> * x</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>])</code></pre></div><p>重置梯度值为 0 ，以便后续计算其它梯度：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x.grad.zero_()</code></pre></div><p>利用 <code>.detach()</code> 停止梯度传播：对比两个例子：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad = <span class="hljs-literal">True</span>) <span class="hljs-comment"># [0, 1, 2, 3]</span><span class="hljs-meta">&gt;&gt;&gt; </span>y = x * x<span class="hljs-meta">&gt;&gt;&gt; </span>y1 = y * x<span class="hljs-meta">&gt;&gt;&gt; </span>y1.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-meta">&gt;&gt;&gt; </span>x.grad</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">3.</span>, <span class="hljs-number">12.</span>, <span class="hljs-number">27.</span>])</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad = <span class="hljs-literal">True</span>) <span class="hljs-comment"># [0, 1, 2, 3]</span><span class="hljs-meta">&gt;&gt;&gt; </span>y = x * x<span class="hljs-meta">&gt;&gt;&gt; </span>y2 = y.detach() * x<span class="hljs-meta">&gt;&gt;&gt; </span>y2.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-meta">&gt;&gt;&gt; </span>x.grad</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">9.</span>])</code></pre></div><p>可以看到前者计算的是 <span class="math inline">\(y1=x\times x \timesx\)</span> 的偏导数为 <span class="math inline">\(3x^2\)</span>。</p><p>而后者则是 <span class="math inline">\(y2=u\times x\)</span>（<spanclass="math inline">\(u\)</span> 看作常量，数值等于 <spanclass="math inline">\(y\)</span>）的偏导数，即为 <spanclass="math inline">\(u=x^2\)</span>。</p><div class="note note-info">            <p>此外，还可以用一个上下文管理器 <code>torch.no_grad()</code>来禁止梯度传播。</p><p>例如以下是第二个例子的等价形式：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad = <span class="hljs-literal">True</span>) <span class="hljs-comment"># [0, 1, 2, 3]</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():        y = x * x;    <span class="hljs-meta">&gt;&gt;&gt; </span>y2 = y * x;<span class="hljs-meta">&gt;&gt;&gt; </span>y2.<span class="hljs-built_in">sum</span>().backward()<span class="hljs-meta">&gt;&gt;&gt; </span>x.grad</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">9.</span>])</code></pre></div>          </div><p>利用 <code>retain_graph=True</code> 保留计算图，以便再次<code>backward()</code> ：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="hljs-number">4.0</span>, requires_grad=<span class="hljs-literal">True</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.dot(x, x)<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward(retain_graph=<span class="hljs-literal">True</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward()</code></pre></div><p>若第三行换成 <code>y.backward()</code> 则会报错。</p><h2 id="线性回归">线性回归</h2><p>模块导入</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn</code></pre></div><p>用 <code>nn.Linear</code> 定义一个线性层：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>model = nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># 输入特征数为2,输出特征数为1(标量)</span></code></pre></div><div class="note note-info">            <p>参数列表：<code>torch.nn.Linear(in_features, out_features, bias=True)</code></p><p><code>in_features</code> ：输入神经元个数，即输入特征数。</p><p><code>out_features</code> ：输出神经元个数，即输出特征数。</p><p><code>bias</code> ：是否包含偏置。</p><p>本质是执行了一个线性变换： <span class="math display">\[\textbf{Y}_{n\times out} = \textbf{X}_{n\times in}\textbf{W}_{in\timesout}+\textbf{b}\]</span></p><p>其中 <span class="math inline">\(n\)</span> 是样本数量，或者说<code>batch_size</code> 。<span class="math inline">\(in,out\)</span>为输入和输出的特征维度，<span class="math inline">\(\textbf{b}\)</span>为 <span class="math inline">\(out\)</span>维的向量偏置，使用了广播机制。</p>          </div><p>用 <code>nn.Sequential</code> 定义神经网络容器：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>net = nn.Sequential(model)</code></pre></div><p>作用是按顺序组织一系列神经网络的层（layer），例如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>model = nn.Sequential(        nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>),        nn.ReLU(),        nn.Conv2d(<span class="hljs-number">20</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>),        nn.ReLU()        )</code></pre></div><p>我们可以通过下标访问元素，如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>net = nn.Sequential(        nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)        <span class="hljs-comment"># other</span>    )<span class="hljs-meta">&gt;&gt;&gt; </span>net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)</code></pre></div><p>通过 <code>net[0]</code> 去访问了 <code>Linear</code>类中的函数，使模型参数初始化。</p><p>其中 <code>weight</code> 和 <code>bias</code>指明要访问权值还是偏置数据，<code>normal_</code> 和 <code>fill_</code>则是 pytorch 的两个张量方法。</p><p><code>tensor.normal_(mean=0, std=1)</code>指定随机抽样的正态分布均值和标准差。</p><p><code>tensor.fill_(value)</code> 则直接填充 <code>value</code>值。</p><p>调用损失函数：</p><div class="code-wrapper"><pre><code class="hljs cpp">&gt;&gt;&gt; nn.<span class="hljs-built_in">MSELoss</span>() # 均方误差，或称平方L2范数PYTHON</code></pre></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        常见损失函数    </div>    <div class='spoiler-content'>        <p><code>L1Loss()</code> ：L1 范数损失（MAE）</p><p><code>MSELoss()</code> : 均方误差（MSE）</p><p><code>SmoothL1Loss()</code> ：L1 平滑损失。</p><p><code>CrossEntyopyLoss()</code> ：交叉熵损失</p><p><code>NLLloss()</code> ：负对数似然损失。</p><p><code>BCELoss()</code> ：二元交叉熵损失。</p>    </div></div><p>用 <code>torch.optim.SGD</code>执行小批量随机梯度下降算法并更新：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>trainer.step()</code></pre></div><p><code>parameters()</code> 用于自动读取参数，<code>lr</code>为学习率（LearningRate）。</p><p>完整实例（《动手学深度学习》章节3.3）：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> torch<span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nntrue_w = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>])true_b = <span class="hljs-number">4.2</span><span class="hljs-comment"># 生成多个噪声数据</span>features, labels = d2l.synthetic_data(true_w, true_b, <span class="hljs-number">1000</span>)<span class="hljs-comment"># 构建PyTorch数据迭代器</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_array</span>(<span class="hljs-params">data_arrays, batch_size, is_train=<span class="hljs-literal">True</span></span>):  <span class="hljs-comment">#@save</span>    dataset = data.TensorDataset(*data_arrays)    <span class="hljs-keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)batch_size = <span class="hljs-number">10</span>data_iter = load_array((features, labels), batch_size)<span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data_iter))<span class="hljs-comment"># 创建神经网络</span>net = nn.Sequential(nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<span class="hljs-comment"># 初始化参数</span>net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)loss = nn.MSELoss()trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)num_epochs = <span class="hljs-number">3</span><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:        l = loss(net(X) ,y)        trainer.zero_grad()        l.backward()        trainer.step()    l = loss(net(features), labels)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span>, loss <span class="hljs-subst">&#123;l:f&#125;</span>&#x27;</span>)w = net[<span class="hljs-number">0</span>].weight.data<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;w的估计误差：&#x27;</span>, true_w - w.reshape(true_w.shape))b = net[<span class="hljs-number">0</span>].bias.data<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b的估计误差：&#x27;</span>, true_b - b)<span class="hljs-comment"># 访问线性回归的梯度</span>w_grad = net[<span class="hljs-number">0</span>].weight.grad<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;w的梯度：&#x27;</span>, w_grad)b_grad = net[<span class="hljs-number">0</span>].bias.grad<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b的梯度：&#x27;</span>, b_grad)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">epoch <span class="hljs-number">1</span>, loss <span class="hljs-number">0.000232</span>epoch <span class="hljs-number">2</span>, loss <span class="hljs-number">0.000101</span>epoch <span class="hljs-number">3</span>, loss <span class="hljs-number">0.000100</span>w的估计误差： tensor([ <span class="hljs-number">0.0002</span>, -<span class="hljs-number">0.0003</span>])b的估计误差： tensor([-<span class="hljs-number">0.0003</span>])w的梯度： tensor([[-<span class="hljs-number">0.0041</span>, -<span class="hljs-number">0.0147</span>]])b的梯度： tensor([<span class="hljs-number">0.0073</span>])</code></pre></div><h2 id="激活函数">激活函数</h2><ol type="1"><li><span class="math inline">\(\text{ReLU}(x)\)</span> 函数</li></ol><p><span class="math display">\[\text{ReLU}(x)=\max(x,0)\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.arange(-<span class="hljs-number">3.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">0.5</span>, requires_grad=<span class="hljs-literal">True</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.relu(x)<span class="hljs-meta">&gt;&gt;&gt; </span>x, y<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward(torch.ones_like(x), retain_graph=<span class="hljs-literal">True</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">(tensor([-<span class="hljs-number">3.0000</span>, -<span class="hljs-number">2.5000</span>, -<span class="hljs-number">2.0000</span>, -<span class="hljs-number">1.5000</span>, -<span class="hljs-number">1.0000</span>, -<span class="hljs-number">0.5000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.5000</span>,          <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.5000</span>,  <span class="hljs-number">2.0000</span>,  <span class="hljs-number">2.5000</span>], requires_grad=<span class="hljs-literal">True</span>), tensor([<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5000</span>, <span class="hljs-number">1.0000</span>,         <span class="hljs-number">1.5000</span>, <span class="hljs-number">2.0000</span>, <span class="hljs-number">2.5000</span>], grad_fn=&lt;ReluBackward0&gt;))</code></pre></div><p><imgsrc="https://zh-v2.d2l.ai/_images/output_mlp_76f463_21_0.svg" /></p><p>一个显著的性质是对 <spanclass="math inline">\(\text{ReLU}(x)\)</span> 求导后非 <spanclass="math inline">\(0\)</span> 即 <spanclass="math inline">\(1\)</span>，即要么让参数消失，要么让参数通过。</p><p><imgsrc="https://zh-v2.d2l.ai/_images/output_mlp_76f463_36_0.svg" /></p><p>变体：（即使参数是负的，某些信息仍然可以通过） <spanclass="math display">\[\text{pReLU}(x)=\max(0,x) + \alpha\min(0,x)\]</span></p><ol start="2" type="1"><li><span class="math inline">\(\text{sigmoid}(x)\)</span>函数（“S”型函数）</li></ol><p><span class="math display">\[\text{sigmoid}(x)=\dfrac{1}{1+e^{-x}}\]</span></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.sigmoid(x)<span class="hljs-meta">&gt;&gt;&gt; </span>x.grad.zero_()<span class="hljs-meta">&gt;&gt;&gt; </span>y.backward(torch.ones_like(x), retain_graph=<span class="hljs-literal">True</span>)</code></pre></div><p><imgsrc="https://zh-v2.d2l.ai/_images/output_mlp_76f463_51_0.svg" /></p><p><span class="math display">\[\dfrac{d}{dx}\text{sigmoid}(x)=\dfrac{e^{-x}}{(1+e^{-x})^2}=\text{sigmoid}(x)(1-\text{sigmoid}(x))\]</span></p><p><imgsrc="https://zh-v2.d2l.ai/_images/output_mlp_76f463_66_0.svg" /></p><p>易知 <span class="math inline">\(x=0\)</span> 时有导数最大值 <spanclass="math inline">\(\dfrac{1}{4}\)</span>。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> ML </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】 python3</title>
      <link href="/posts/91245943.html"/>
      <url>/posts/91245943.html</url>
      
        <content type="html"><![CDATA[<p>以下只提及与 C++ 差异较大的定义和语法。</p><h2 id="语言特色">语言特色</h2><p>python 属于解释型语言：最大的特色莫过于使用 <code>exec()</code>函数直接解释括号中的字符串并运行。</p><p>python 有很多库：如 NumPy 用于数学运算，Pandas用于数据处理，Matplotlib 用于画图等。python 不调库就好比 C++ 没有 STL(雾) 。</p><h2 id="关键字">关键字</h2><p>相比 C++，以下字符也属于 python 的保留字。</p><ul><li><p><code>False</code> <code>True</code><code>None</code>：表示布尔值，空值（注意是大写）。</p></li><li><p><code>def</code> ：用于函数定义。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function_name</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hrdg kawaii!&quot;</span>)</code></pre></div></li><li><p><code>assert</code> ：检查条件真假。</p><div class="code-wrapper"><pre><code class="hljs PYTHON">x = -<span class="hljs-number">1</span><span class="hljs-keyword">assert</span> x &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;靠&quot;</span><span class="hljs-built_in">print</span>(x)</code></pre></div><p>运行时会报错 <code>AssertionError: 靠</code> 而不会执行<code>print</code> 。</p></li><li><p><code>del</code> ：用于删除变量或对象。</p><div class="code-wrapper"><pre><code class="hljs python">x = <span class="hljs-number">1</span><span class="hljs-keyword">del</span> x<span class="hljs-built_in">print</span>(x)</code></pre></div><p>运行时报错 <code>NameError: name 'x' is not defined</code>。</p></li><li><p><code>elif</code> ：等同于 C++ 的 <code>else if</code> 。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-1&quot;</span>)<span class="hljs-keyword">elif</span> x == <span class="hljs-number">0</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>)</code></pre></div></li><li><p><code>except</code> ：用于异常处理时捕获异常。</p></li><li><p><code>finally</code> ：异常处理中必须执行。</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">try</span>:    result = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><span class="hljs-keyword">except</span> ZeroDivisionError:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;除以零错误&quot;</span>)<span class="hljs-keyword">finally</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无论如何都会执行这里的代码&quot;</span>)</code></pre></div><p>其中 <code>ZeroDivisionError</code> 是一个内置异常。</p></li></ul><div class='spoiler collapsed'>    <div class='spoiler-title'>        其它内置异常    </div>    <div class='spoiler-content'>        <ol type="1"><li><p><code>SyntaxError</code>：语法错误，通常发生在代码编写时，如拼写错误、缺少冒号等。</p></li><li><p><code>IndentationError</code>：缩进错误，通常发生在代码块的缩进不一致或不正确时。</p></li><li><p><code>NameError</code>：名称错误，通常发生在尝试访问不存在的变量或名称时。</p></li><li><p><code>TypeError</code>：类型错误，通常发生在操作不兼容的数据类型时，如将字符串和数字相加。</p></li><li><p><code>ValueError</code>：值错误，通常发生在操作正确类型的对象，但值无效或不合法时，如尝试将无效的字符串转换为数字。</p></li><li><p><code>ZeroDivisionError</code>：除以零错误，通常发生在除法操作中的除数为零时。</p></li><li><p><code>IndexError</code>：索引错误，通常发生在尝试访问列表、元组或其他序列中不存在的索引时。</p></li><li><p><code>KeyError</code>：键错误，通常发生在尝试访问字典中不存在的键时。</p></li><li><p><code>FileNotFoundError</code>：文件未找到错误，通常发生在尝试打开不存在的文件时。</p></li><li><p><code>IOError</code>：输入/输出错误，通常发生在文件操作失败或无法读取或写入文件时。</p></li><li><p><code>ImportError</code>：导入错误，通常发生在尝试导入不存在的模块或无效的模块时。</p></li><li><p><code>AttributeError</code>：属性错误，通常发生在尝试访问对象上不存在的属性时。</p></li><li><p><code>TypeError</code>：类型错误，通常发生在函数或方法接收到不正确类型的参数时。</p></li><li><p><code>AssertionError</code>：断言错误，通常发生在<code>assert</code> 语句中的条件不满足时。</p></li><li><p><code>ArithmeticError</code>：算术错误的基类，包括<code>ZeroDivisionError</code> 和 <code>OverflowError</code>等。</p></li><li><p><code>EOFError</code>：文件末尾错误，通常发生在尝试从已经读取到文件末尾的文件读取更多数据时。</p></li></ol>    </div></div><ul><li><p><code>from</code> <code>import</code>：从模块中导入函数，变量或类。</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt</code></pre></div></li><li><p><code>global</code> ：声明全局变量。</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<span class="hljs-keyword">global</span> xx = <span class="hljs-number">10</span>func()<span class="hljs-built_in">print</span>(x)</code></pre></div></li><li><p><code>in</code>：检查一个值是否存在于一个容器中，如列表，元组，字典等。</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">if</span> <span class="hljs-number">5</span> <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;5 存在于列表中&quot;</span>)</code></pre></div></li><li><p><code>is</code>：比较两个对象是否是同一个对象。（比较的不是值而是内存地址）</p><div class="code-wrapper"><pre><code class="hljs PYTHON">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]y = x<span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> y:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x 和 y 是同一个对象&quot;</span>)</code></pre></div></li><li><p><code>lambda</code> ：创建匿名函数。</p><ul><li><p>语法：<code>lambda arguments: expression</code>，依次对应关键字，函数参数和表达式。</p><div class="code-wrapper"><pre><code class="hljs PYTHON">add = <span class="hljs-keyword">lambda</span> x, y: x + y * <span class="hljs-number">2</span><span class="hljs-built_in">print</span>(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 输出 8</span></code></pre></div></li></ul></li><li><p><code>nonlocal</code>：在嵌套函数中声明一个外部（封闭）函数的变量，而不是创建一个新的局部变量。</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer_function</span>():    x = <span class="hljs-number">10</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner_function</span>():        <span class="hljs-keyword">nonlocal</span> x        x = <span class="hljs-number">20</span>    inner_function()    <span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># 输出 20</span></code></pre></div></li><li><p><code>pass</code> ：占位符，表示一个空的代码块或函数体。</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():    <span class="hljs-keyword">pass</span></code></pre></div></li><li><p><code>with</code>：用于创建一个上下文管理器，通常用于管理资源，如文件或数据库连接。</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> file:    data = file.read()</code></pre></div></li><li><p><code>yield</code>：允许你编写一种特殊类型的函数，这种函数可以在迭代时逐个产生值，而不是一次性生成所有值。</p><ul><li><p>如以下程序会输出前10个斐波那契数。</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_generator</span>(<span class="hljs-params">n</span>):    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>    count = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> count &lt; n:        <span class="hljs-keyword">yield</span> a        a, b = b, a + b        count += <span class="hljs-number">1</span><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> fib_generator(<span class="hljs-number">10</span>):    <span class="hljs-built_in">print</span>(value,end=<span class="hljs-string">&quot; &quot;</span>)  <span class="hljs-comment"># 0 1 1 2 3 5 8 13 21 34</span></code></pre></div><p>可以发现程序遇到 <code>yield</code> 时立即返回对应值。</p></li></ul></li></ul><h2 id="注释">注释</h2><ul><li><p>单行注释：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 啊?OP?</span></code></pre></div></li><li><p>多行注释：</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">原来你也玩原神?</span><span class="hljs-string">原神怎么你了?</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div></li></ul><h2 id="多行语句">多行语句</h2><p>运用反斜杠 <code>\</code> 。</p><div class="code-wrapper"><pre><code class="hljs python">a,b,c = <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>t = a + b + \+c<span class="hljs-built_in">print</span>(t)  <span class="hljs-comment"># 3</span></code></pre></div><h2 id="字符串">字符串</h2><ul><li><p>不同于 C++ 中的 “单引号括字符，双引号括字符串” ，python中单引号与双引号用法<strong>完全相同</strong>。</p></li><li><p>三引号：指定多行字符串。</p><div class="code-wrapper"><pre><code class="hljs PYTHON">word = <span class="hljs-string">&#x27;&#x27;&#x27;这合</span><span class="hljs-string">理吗&#x27;&#x27;&#x27;</span><span class="hljs-built_in">print</span>(word)</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs python">这合理吗</code></pre></div></li><li><p>使用 <code>r</code> 以防止转义。</p><div class="code-wrapper"><pre><code class="hljs PYTHON">word = <span class="hljs-string">r&#x27;hrdg yyds\n&#x27;</span><span class="hljs-built_in">print</span>(word)  <span class="hljs-comment"># &quot;hrdg yyds\n&quot;</span></code></pre></div></li></ul><div class='spoiler collapsed'>    <div class='spoiler-title'>        常见转义符    </div>    <div class='spoiler-content'>        <ol type="1"><li><p><code>\\</code>：表示一个反斜杠字符。</p></li><li><p><code>\'</code>：表示一个单引号字符。</p></li><li><p><code>\"</code>：表示一个双引号字符。</p></li><li><p><code>\n</code>：表示换行符，用于在字符串中创建新的一行。</p></li><li><p><code>\t</code>：表示制表符，用于在字符串中创建水平制表位。</p></li><li><p><code>\r</code>：表示回车符，通常与 <code>\n</code>一起使用，用于在字符串中创建新行并将光标移到行首。</p></li><li><p><code>\b</code>：表示退格符，用于在字符串中删除前一个字符。</p></li><li><p><code>\f</code>：表示换页符，通常用于在字符串中创建新的一页。</p></li><li><p><code>\v</code>：表示垂直制表符，通常用于在字符串中创建垂直制表位。</p></li><li><p><code>\ooo</code>：表示一个八进制值，其中 <code>ooo</code>是三个八进制数字，用于表示特定的字符。</p></li><li><p><code>\xhh</code>：表示一个十六进制值，其中 <code>hh</code>是两个十六进制数字，用于表示特定的字符。</p></li></ol>    </div></div><ul><li><p>可以用 <code>*</code> 使字符串重复。</p><div class="code-wrapper"><pre><code class="hljs PYTHON">a = <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-built_in">print</span>(a * <span class="hljs-number">3</span>) <span class="hljs-comment"># aaa</span></code></pre></div></li><li><p>字符串的索引与截取</p><ul><li><p>从左往右索引以 <code>0</code> 开始，从右往左以 <code>-1</code>开始。</p></li><li><p>截取格式：<code>[Begin:End:Step]</code> ：截取 <code>Begin</code>到 <code>End-1</code> 的字符，步长为 <code>Step</code> 。</p></li><li><p>以下是一个实例：</p><div class="code-wrapper"><pre><code class="hljs PYTHON">s = <span class="hljs-string">&#x27;123456789&#x27;</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>])     <span class="hljs-comment"># 1</span><span class="hljs-built_in">print</span>(s[-<span class="hljs-number">1</span>])    <span class="hljs-comment"># 9</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>])   <span class="hljs-comment"># 456</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 12345678</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">2</span>:])    <span class="hljs-comment"># 3456789</span><span class="hljs-built_in">print</span>(s[:<span class="hljs-number">2</span>])    <span class="hljs-comment"># 12</span><span class="hljs-built_in">print</span>(s[:-<span class="hljs-number">1</span>])   <span class="hljs-comment"># 12345678</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment"># 24</span><span class="hljs-built_in">print</span>(s[<span class="hljs-number">1</span>::<span class="hljs-number">3</span>])  <span class="hljs-comment"># 258</span><span class="hljs-built_in">print</span>(s[:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment"># 1357</span></code></pre></div></li></ul></li><li><p>字符串格式化</p><div class="code-wrapper"><pre><code class="hljs PYTHON">name = <span class="hljs-built_in">input</span>()greeting = <span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span><span class="hljs-built_in">print</span>(greeting)</code></pre></div></li></ul><h2 id="输入输出">输入输出</h2><ul><li><p>使用 <code>input()</code> 输入</p><ul><li><p>基本用法： <code>a = input()</code></p></li><li><p>传递字符串作为输入提示： <code>a = input("a = ")</code></p></li><li><p>类型转换： <code>a = int(input())</code></p></li><li><p>运用 <code>.split()</code> 分隔</p><div class="code-wrapper"><pre><code class="hljs PYTHON">a,b,c = <span class="hljs-built_in">input</span>().split() <span class="hljs-comment"># 输入“1 2 3”</span><span class="hljs-built_in">print</span>(b) <span class="hljs-comment"># 输出2</span></code></pre></div></li></ul></li><li><p>使用 <code>print()</code> 输出</p><ul><li><p>换行： <code>print(x)</code></p></li><li><p>不换行： <code>print(x,end="")</code></p><div class="code-wrapper"><pre><code class="hljs PYTHON">a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(a, end=<span class="hljs-string">&quot; &quot;</span>)<span class="hljs-built_in">print</span>(b, end=<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-built_in">print</span>(a) <span class="hljs-comment">#输出 &quot;0 10&quot;</span></code></pre></div></li></ul></li><li><p>其它输出方式</p><ul><li><p>文件输出</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> file:    file.write(<span class="hljs-string">&quot;This is written to a file.&quot;</span>)</code></pre></div></li><li><p>格式化字符串输出</p><div class="code-wrapper"><pre><code class="hljs PYTHON">name = <span class="hljs-string">&quot;学生&quot;</span>age = <span class="hljs-number">24</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;岁,是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(age,name))<span class="hljs-comment"># 24岁,是学生</span></code></pre></div><p>或者使用 f-strings 等价：</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;age&#125;</span>岁,是<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<span class="hljs-comment"># 24岁,是学生</span></code></pre></div></li><li><p>标准错误输出（一般输出至终端或命令行）</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">import</span> syssys.stderr.write(<span class="hljs-string">&quot;寄了,哈哈\n&quot;</span>)</code></pre></div></li></ul></li></ul><h2 id="模块导入">模块导入</h2><ul><li><p>只导入模块： <code>import somemodule</code></p><ul><li>后续调用使用 <code>somemodule.func_a</code> 形式</li></ul></li><li><p>导入模块成员：<code>from somemodule import func_a,func_b</code></p><ul><li>后续直接调用 <code>func_a</code> <code>func_b</code></li></ul></li><li><p>导入模块中的全部函数：<code>from somemodule import *</code></p></li><li><p>什么是 <code>if __name__ == "__main__":</code> ?</p><ul><li><p>当你创建了一个模块（比如一个 .py文件），这个模块就会有一个内置属性 <code>name</code> 生成。当你 import一个模块时，<code>name</code> 通常是文件名。如果你直接运行该模块，那么<code>__name__ == "__main__"</code> ，否则不等。</p></li><li><p>例如你创建了两个 .py 文件：</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-comment"># test1.py</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a&#x27;</span>,end=<span class="hljs-string">&quot; &quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b&#x27;</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-comment"># test2.py</span><span class="hljs-keyword">import</span> test1</code></pre></div><p>直接运行 <code>test1.py</code> 输出 <code>a b</code> ;</p><p>而运行 <code>test2.py</code> 则输出 <code>a</code> 。</p></li></ul></li><li><p>模块搜索顺序：</p><ul><li>当前目录</li><li>shell 变量 PYTHONPATH 下的每个目录（PYTHONPATH由装在一个列表里的许多目录组成）</li><li>查看默认路径（UNIX下，默认路径一般为/usr/local/lib/python/）</li></ul></li><li><p>利用 <code>dir(somemodule)</code>查看模块中定义的子模块，变量，函数。</p></li><li><p>利用 <code>locals()</code>访问<strong>局部</strong>命名空间，<code>globals()</code>访问<strong>全局</strong>命名空间。</p></li><li><p>利用 <code>reload(somemodule)</code>重新执行顶层导入代码。</p></li></ul><h2 id="数值对象">数值对象</h2><ul><li><p>乘方用 <code>**</code> ，如 <code>2 ** 3 = 8</code></p></li><li><p>数值除法包括：</p><ul><li><code>/</code> 返回一个<strong>浮点数</strong>。<code>3 / 2 = 1.5</code></li><li><code>//</code> 类似 C 整数除法，<strong>下取整</strong>。<code>3 // 2 = 1</code></li></ul></li><li><p>混合计算时，整型会被转化为浮点数。</p></li><li><p>利用 <code>type(object)</code> 获取对象类型</p><div class="code-wrapper"><pre><code class="hljs PYTHON">a = <span class="hljs-number">2.0</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))<span class="hljs-comment"># 输出“&lt;class &#x27;float&#x27;&gt;”</span></code></pre></div></li><li><p>利用 <code>isinstance(object, classinfo)</code>检查一个对象是否是特定类或类型的实例。其返回一个布尔值。</p><ul><li><p>类型判断：</p><div class="code-wrapper"><pre><code class="hljs PYTHON">a = <span class="hljs-number">2.0</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(a,<span class="hljs-built_in">int</span>)) <span class="hljs-comment"># False</span></code></pre></div></li><li><p>实例判断：</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">op</span>:qiye_nana7 = <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(op(),op)) <span class="hljs-comment"># True</span></code></pre></div><p>那如果想判断 <code>qiye_nana7</code> 是否属于 <code>op</code>怎么办呢？</p><p>其中<code>qiye_nana7</code> 属于类属性，那么使用<code>hasattr(class_name,attribute_name)</code> 判断：</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">class</span> <span class="hljs-title class_">op</span>:qiye_nana7 = <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(op, <span class="hljs-string">&#x27;qiye_nana7&#x27;</span>)) <span class="hljs-comment"># True</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(op, <span class="hljs-string">&#x27;KisuraOP&#x27;</span>)) <span class="hljs-comment"># False</span></code></pre></div></li></ul></li></ul><h2 id="列表list">列表（List）</h2><ul><li><p>类似数组，是有序对象集合。</p></li><li><p>中括号定义：<code>list = [123, 1.0, 'str', 'nmsl']</code></p></li><li><p>调用和截取与字符串相同，略。</p></li><li><p>与字符串不同的是，列表中的元素可以改变：</p><div class="code-wrapper"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;cnm&#x27;</span><span class="hljs-comment"># a[0] = &#x27;a&#x27; # 编译错误</span>a = [<span class="hljs-string">&#x27;原神&#x27;</span>, <span class="hljs-string">&#x27;牛批&#x27;</span>]<span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])  <span class="hljs-comment"># 原批</span>a[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;o&#x27;</span>a[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;p&#x27;</span><span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>]+a[<span class="hljs-number">1</span>])  <span class="hljs-comment"># op</span></code></pre></div></li></ul><h2 id="元组tuple">元组（Tuple）</h2><ul><li><p>与列表类似，元组一样可以通过 <code>+</code> 连接，<code>*</code>重复，不过其<strong>元素不能修改</strong>。</p></li><li><p>小括号定义：<code>tup = (123, 1.0, 'str', 'nmsl')</code>。</p></li><li><p>只包含一个元素时，需添加逗号。<code>tup2 = (114514,)</code></p></li></ul><h2 id="集合set">集合（Set）</h2><ul><li><p>特点：无序，可变，元素不会重复。</p></li><li><p>大括号定义：<code>setA = &#123;'Codeforces', 'Atcoder', 'Luogu'&#125;</code></p></li><li><p>函数定义：<code>setB = set('AAACMCA')</code> <spanclass="math inline">\(\to\)</span><code>setB = &#123;'A', 'C', 'M'&#125;</code></p></li><li><p>集合运算：</p><div class="code-wrapper"><pre><code class="hljs PYTHON">A = &#123;<span class="hljs-string">&#x27;Codeforces&#x27;</span>, <span class="hljs-string">&#x27;Atcoder&#x27;</span>, <span class="hljs-string">&#x27;Luogu&#x27;</span>, <span class="hljs-string">&#x27;Lutece&#x27;</span>&#125;B = &#123;<span class="hljs-string">&#x27;Lutece&#x27;</span>, <span class="hljs-string">&#x27;TopCoder&#x27;</span>&#125;<span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Atcoder&#x27;</span> <span class="hljs-keyword">in</span> A:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<span class="hljs-comment"># Yes</span><span class="hljs-built_in">print</span>(A - B)  <span class="hljs-comment"># 差集 &#123;&#x27;Luogu&#x27;, &#x27;Codeforces&#x27;, &#x27;Atcoder&#x27;&#125;</span><span class="hljs-built_in">print</span>(B - A)  <span class="hljs-comment"># 差集 &#123;&#x27;TopCoder&#x27;&#125;</span><span class="hljs-built_in">print</span>(A | B)  <span class="hljs-comment"># 并集 &#123;&#x27;Codeforces&#x27;, &#x27;Atcoder&#x27;, &#x27;TopCoder&#x27;, &#x27;Luogu&#x27;, &#x27;Lutece&#x27;&#125;</span><span class="hljs-built_in">print</span>(A &amp; B)  <span class="hljs-comment"># 交集 &#123;&#x27;Lutece&#x27;&#125;</span><span class="hljs-built_in">print</span>(A ^ B)  <span class="hljs-comment"># 异或,不同时出现 &#123;&#x27;Codeforces&#x27;, &#x27;Atcoder&#x27;, &#x27;TopCoder&#x27;, &#x27;Luogu&#x27;&#125;</span></code></pre></div></li></ul><h2 id="字典dict">字典（Dict）</h2><ul><li><p>无序对象集合，键值对存储，键必须唯一。类似 STL 中的<code>map</code> 。</p><div class="code-wrapper"><pre><code class="hljs python">a = &#123;    <span class="hljs-string">&#x27;op&#x27;</span>: <span class="hljs-string">&#x27;我&#x27;</span>,    <span class="hljs-number">55</span>: <span class="hljs-string">&#x27;芙宁娜大人&#x27;</span>,    <span class="hljs-string">&#x27;啊&#x27;</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-built_in">print</span>(a[<span class="hljs-string">&#x27;op&#x27;</span>] + <span class="hljs-built_in">str</span>(a[<span class="hljs-string">&#x27;啊&#x27;</span>]) + a[<span class="hljs-number">55</span>] + <span class="hljs-string">&#x27;的狗&#x27;</span>)<span class="hljs-comment"># 我4芙宁娜大人的狗</span><span class="hljs-built_in">print</span>(a)<span class="hljs-comment"># &#123;&#x27;op&#x27;: &#x27;我&#x27;, 55: &#x27;芙宁娜大人&#x27;, &#x27;啊&#x27;: 4&#125;</span><span class="hljs-built_in">print</span>(a.keys())<span class="hljs-comment"># dict_keys([&#x27;op&#x27;, 55, &#x27;啊&#x27;])</span><span class="hljs-built_in">print</span>(a.values())<span class="hljs-comment"># dict_values([&#x27;我&#x27;, &#x27;芙宁娜大人&#x27;, 4])</span>a[<span class="hljs-string">&#x27;op&#x27;</span>] = <span class="hljs-string">&#x27;芙宁娜&#x27;</span>  <span class="hljs-comment"># 更改键值对</span>a[<span class="hljs-number">44</span>] = <span class="hljs-string">&#x27;我&#x27;</span>  <span class="hljs-comment"># 增添键值对</span><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&#x27;op&#x27;</span>] + <span class="hljs-built_in">str</span>(a[<span class="hljs-string">&#x27;啊&#x27;</span>]) + a[<span class="hljs-number">44</span>] + <span class="hljs-string">&#x27;的狗&#x27;</span>)<span class="hljs-comment"># 芙宁娜4我的狗</span><span class="hljs-built_in">print</span>(a)<span class="hljs-comment"># &#123;&#x27;op&#x27;: &#x27;芙宁娜&#x27;, 55: &#x27;芙宁娜大人&#x27;, &#x27;啊&#x27;: 4, 44: &#x27;我&#x27;&#125;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment"># op55啊44</span><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> a.items():    <span class="hljs-built_in">print</span>(i, j, end=<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment"># op 芙宁娜55 芙宁娜大人啊 444 我</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(a))  <span class="hljs-comment"># 4</span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;我&#x27;</span> <span class="hljs-keyword">in</span> a:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;oh yeah&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<span class="hljs-comment"># No</span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;op&#x27;</span> <span class="hljs-keyword">in</span> a:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;oh yeah&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<span class="hljs-comment"># oh yeah</span>a.clear()  <span class="hljs-comment"># 清空字典</span><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># &#123;&#125;</span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;op&#x27;</span> <span class="hljs-keyword">in</span> a:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这河里吗&quot;</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;op似光辣&quot;</span>)<span class="hljs-comment"># op似光辣</span></code></pre></div></li></ul><h2 id="数据类型转换">数据类型转换</h2><ol type="1"><li><p><code>int(x[,base])</code> ：将 <code>x</code> 作为<code>base</code> 进制转换。</p><ul><li><code>int('101') = 101</code> , <code>int('101',2) = 5</code>。</li></ul></li><li><p><code>float(x)</code> ：转换为浮点数</p></li><li><p><code>str(x)</code> <code>repr(x)</code>：转换为字符串/字符串字面量。</p><ul><li><p>有什么区别？</p><div class="code-wrapper"><pre><code class="hljs PYTHON">s=<span class="hljs-string">&quot;校区 \t清水河\t沙河\n提档线\t629 \t631&quot;</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(s))<span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(s))</code></pre></div><p>将会输出：</p><div class="code-wrapper"><pre><code class="hljs python">校区 清水河沙河提档线<span class="hljs-number">629</span>   <span class="hljs-number">631</span><span class="hljs-string">&#x27;校区 \t清水河\t沙河\n提档线\t629 \t631&#x27;</span></code></pre></div></li></ul></li><li><p><code>complex(real[,imag])</code>：创建一个复数（实虚部）</p></li><li><p><code>tuple(x)</code> <code>list(x)</code> <code>set(x)</code><code>dict(x)</code> ：转换为元组/列表/集合/字典</p></li><li><p><code>chr(x)</code> <code>ord(x)</code> <code>hex(x)</code><code>oct(x)</code> ：整数转字符/字符转整数/转十六进制/转八进制</p></li><li><p><code>eval(x)</code> ：表达式计算</p><div class="code-wrapper"><pre><code class="hljs PYTHON">a = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;2 ** 5&quot;</span>)<span class="hljs-built_in">print</span>(a) <span class="hljs-comment"># 32</span></code></pre></div><p>和 <code>exec()</code> 的区别在于 <code>eval()</code><strong>只能执行表达式而不能执行代码块</strong> 。</p></li></ol><h2 id="对象的可更改性">对象的可更改性</h2><ul><li><p>可变：类似 C++ 引用传递，如列表，字典。</p></li><li><p>不可变：类似 C++ 值传递，如数字，字符串，元组。</p></li><li><p>区别：</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_num</span>(<span class="hljs-params">x</span>):x = x + <span class="hljs-number">1</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_list</span>(<span class="hljs-params">x</span>):x.append([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])A = <span class="hljs-number">3</span>;change_num(A)<span class="hljs-built_in">print</span>(A)   <span class="hljs-comment"># 3</span>B = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]change_list(B)<span class="hljs-built_in">print</span>(B)   <span class="hljs-comment"># [1, 2, 3, 4, [1, 2]]</span></code></pre></div></li></ul><h2 id="python包">python包</h2><p>包是一个分层次文件目录结构，基础构成如下：</p><div class="code-wrapper"><pre><code class="hljs cpp">test.pypackageA|-- __init__.py|-- A.py|-- B.pypackageB|-- __init__.py|-- A.py|-- B.pyVIM</code></pre></div><p>可以通过以下方法调用模块：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta"># test.py</span>from packageB.A <span class="hljs-keyword">import</span> funcion_namefrom packageA.B <span class="hljs-keyword">import</span> funcion_namePYTHON</code></pre></div><p>其中 <code>__init__.py</code>是必须的，目的是标识当前目录是一个包。</p><h2 id="内置函数">内置函数</h2><ul><li><p><code>enumerate(sequence, [start = 0])</code></p><ul><li><p><code>sequence</code>：一个序列，迭代器等支持迭代的对象。</p></li><li><p><code>start</code> ：下标起始位置的值。</p></li><li><p>将一个可迭代对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和数据下标。</p><div class="code-wrapper"><pre><code class="hljs PYTHON">a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):    <span class="hljs-built_in">print</span>(i)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">(0, &#x27;a&#x27;)</span><span class="hljs-string">(1, &#x27;b&#x27;)</span><span class="hljs-string">(2, &#x27;d&#x27;)</span><span class="hljs-string">(3, &#x27;c&#x27;)</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):    <span class="hljs-built_in">print</span>(i, j)<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">0 a</span><span class="hljs-string">1 b</span><span class="hljs-string">2 d</span><span class="hljs-string">3 c</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div></li></ul></li><li><p><code>map(function, iterable, ...)</code></p><ul><li><p><code>function</code> ：要应用于每个元素的函数。</p></li><li><p><code>iterable</code> ：输入到 <code>function</code>的可迭代对象，可以是一个或多个。</p></li><li><p>将一个函数应用于可迭代对象（如列表、元组或字符串）的所有元素，返回一个迭代器。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]squared_numbers = <span class="hljs-built_in">map</span>(square, numbers)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(squared_numbers)) <span class="hljs-comment"># 1, 4, 9, 16, 25</span></code></pre></div></li><li><p>一个应用是求出一个数 <span class="math inline">\(x\)</span>的各数位之和（将 <code>int</code> 作为 <code>function</code> 应用到<span class="math inline">\(x\)</span> 每一位）</p><div class="code-wrapper"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">digit_sum</span>(<span class="hljs-params">n</span>):    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>(n)))</code></pre></div></li></ul></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Programming Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】洛谷基础赛 5 &amp; QFOI Round 1</title>
      <link href="/posts/31577138.html"/>
      <url>/posts/31577138.html</url>
      
        <content type="html"><![CDATA[<h2 id="a.-qfoi-r1贴贴">A. 「QFOI R1」贴贴</h2><p><a href="https://www.luogu.com.cn/problem/P9712">Problem</a></p><div class="note note-success">            <p>可以使用 <code>std::isupper()</code> 和 <code>std::tolower()</code>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;string s;cin&gt;&gt;s;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;_&#x27;</span>) &#123;s[i]=<span class="hljs-string">&#x27;-&#x27;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(s[i])) &#123;s[i]=<span class="hljs-built_in">tolower</span>(s[i]);&#125;&#125;s=<span class="hljs-string">&quot;solution-&quot;</span>+s;cout&lt;&lt;s&lt;&lt;endl;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-qfoi-r1抱抱">B. 「QFOI R1」抱抱</h2><p><a href="https://www.luogu.com.cn/problem/P9713">Problem</a></p><div class="note note-success">            <p>可以想象，无论怎么切，最后剩下的一定是完整的一个长方体。</p><p>分别记录当前切出去的最大 <spanclass="math inline">\(x_m,y_m,z_m\)</span>，答案即 <spanclass="math inline">\((a-x_m)(b-y_m)(c-z_m)\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(m)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>(),c=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> xmax=<span class="hljs-number">0</span>,ymax=<span class="hljs-number">0</span>,zmax=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> opt=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>) &#123;xmax=<span class="hljs-built_in">max</span>(xmax,k);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">2</span>) &#123;ymax=<span class="hljs-built_in">max</span>(ymax,k);&#125; <span class="hljs-keyword">else</span> &#123;zmax=<span class="hljs-built_in">max</span>(zmax,k);&#125;<span class="hljs-type">int</span> res=(a-xmax)*(b-ymax)*(c-zmax);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-qfoi-r1摸摸">C. 「QFOI R1」摸摸</h2><p><a href="https://www.luogu.com.cn/problem/P9714">Problem</a></p><div class="note note-info">            <p>题意：给出长度为 <span class="math inline">\(n\)</span> 的数列 <spanclass="math inline">\(b,t\)</span>，每次操作可以将 <spanclass="math inline">\(t\)</span> 与其翻转数列相加得到新 <spanclass="math inline">\(t\)</span>，或将 <spanclass="math inline">\(t\)</span> 累加到一开始为空的数列 <spanclass="math inline">\(a\)</span> 上，问若干次操作后是否能将 <spanclass="math inline">\(a\rightarrow b\)</span>。</p><p><span class="math inline">\(1\le n,b_i,t_i \le 2\times10^3\)</span>。</p>          </div><div class="note note-success">            <p>对于一个初始数列我们考虑它经过若干次翻转相加操作后变成什么样。</p><p>初始 <spanclass="math inline">\([a_1,a_2,\dots,a_{n-1},a_n]\)</span>。</p><p>第一次 <spanclass="math inline">\([a_1+a_n,a_2+a_{n-1},\dots,a_{n-1}+a_2,a_n+a_1]\)</span>。（设为数列<span class="math inline">\(s\)</span>）</p><p>第二次 <spanclass="math inline">\([2(a_1+a_n),2(a_2+a_{n-1}),\dots,2(a_{n-1}+a_2),2(a_n+a_1)]\)</span>。</p><p>第三次 <spanclass="math inline">\([4(a_1+a_n),4(a_2+a_{n-1}),\dots,4(a_{n-1}+a_2),4(a_n+a_1)]\)</span>。</p><p>第 <span class="math inline">\(m\)</span> 次 <spanclass="math inline">\([2^{m-1}(a_1+a_n),2^{m-1}(a_2+a_{n-1}),\dots,2^{m-1}(a_{n-1}+a_2),2^{m-1}(a_n+a_1)]\)</span>。</p><p>由此发现，后续无论将多少个经历几次迭代的 <spanclass="math inline">\(t\)</span> 加到 <spanclass="math inline">\(a\)</span> 上，一定等价于将若干个 <spanclass="math inline">\(s\)</span> 乘以一定倍数再累加到 <spanclass="math inline">\(a\)</span> 上。</p><p>令 <span class="math inline">\(t_0\)</span> 为初始 <spanclass="math inline">\(t\)</span> 数列。于是我们可以枚举 <spanclass="math inline">\(k_1,k_2\)</span>，判断 <spanclass="math inline">\(k_1\cdot t_{0i}+k_2\cdot s_i\)</span> 是否与 <spanclass="math inline">\(b_i\)</span> 相等。</p><p>时间复杂度为 <span class="math inline">\(O(nw)\)</span>，<spanclass="math inline">\(w\)</span> 为值域。</p>          </div><div class="note note-warning">            <p>涉及整个数列/区间操作的问题可以试着手推操作过程，尝试发现性质。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t1</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">t2</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-type">int</span> max1=inf,max2=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;t1[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;t2[i]=t1[n-i<span class="hljs-number">+1</span>]+t1[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();max1=<span class="hljs-built_in">min</span>(max1,b[i]/t1[i]);max2=<span class="hljs-built_in">min</span>(max2,b[i]/t2[i]);&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=max1;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=max2;++j) &#123;<span class="hljs-type">bool</span> ok=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) &#123;<span class="hljs-keyword">if</span>(t1[k]*i+t2[k]*j!=b[k]) &#123;ok=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(ok) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;&#125;&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-qfoi-r1头">D. 「QFOI R1」头</h2><p><a href="https://www.luogu.com.cn/problem/P9715">Problem</a></p><div class="note note-info">            <p>题意：初始一个没有颜色的 <span class="math inline">\(n\timesm\)</span> 网格，现有 <span class="math inline">\(k\)</span> 种颜色编号<span class="math inline">\(1\sim k\)</span>，以及 <spanclass="math inline">\(q\)</span> 次操作。</p><p>每次操作给定 <span class="math inline">\(op,l,r,c,t\)</span>五个参数： * <span class="math inline">\(op=1/2\)</span> 代表将第 <spanclass="math inline">\(l\sim r\)</span> 行 <spanclass="math inline">\(/\)</span> 列 的所有格子涂成颜色 <spanclass="math inline">\(c\)</span>。</p><ul><li><span class="math inline">\(t=0/1\)</span>代表若遇到已被染色的格子，不再染色 <spanclass="math inline">\(/\)</span> 覆盖染色。</li></ul><p>最后输出 <span class="math inline">\(k\)</span> 个整数，每个整数<span class="math inline">\(x\)</span> 代表被染成颜色 <spanclass="math inline">\(x\)</span> 的格子数量。</p><p><span class="math inline">\(1\le n,m,q,\le 2\times10^6\)</span>，<span class="math inline">\(1\le k \le 5\times10^5\)</span>。</p>          </div><div class="note note-success">            <p>考虑将操作离线。</p><p>对于 <span class="math inline">\(t=0\)</span>的操作，越排在前面优先级越大。</p><p>对于 <span class="math inline">\(t=1\)</span>的操作，越排在后面优先级越大。</p><p>并且先执行完所有 <span class="math inline">\(t=1\)</span> 的操作对<span class="math inline">\(t=0\)</span>的操作没有任何影响，因为要被覆盖的早晚被覆盖。</p><p>因此可以安排一个操作顺序（先从后往前执行 <spanclass="math inline">\(t=1\)</span> 操作，再从前往后执行 <spanclass="math inline">\(t=0\)</span>操作），使得后面的操作不影响前面的操作。</p><p>接着，我们可以维护每一行是否全被染色（记为 <spanclass="math inline">\(R_i\)</span>）和每一列是否全被染色（记为 <spanclass="math inline">\(C_i\)</span>）。</p><p>以染色第 <span class="math inline">\([l,r]\)</span> 行为例，贡献是<spanclass="math inline">\([(r-l+1)-\sum\limits_{i=l}^{r}R_i](m-\sum\limits_{i=1}^{m}C_i)\)</span>。列染色同理。</p><p>每次计算完贡献后，对于 <spanclass="math inline">\(i\in[l,r]\)</span>，<spanclass="math inline">\(R_i\leftarrow 1\)</span>。</p><p>如此一来，转化为区间赋值和区间求和问题。</p><p>但线段树的对数时间还是不足以通过，我们可以用链表模拟这个过程。</p><p>用两个单向链表维护行列，修改时变更 <spanclass="math inline">\(nxt\)</span>，询问时暴跳 <spanclass="math inline">\(nxt\)</span>，均摊时间复杂度是线性的。</p><p>透过代码可能更好理解。</p><p>总时间复杂度 <span class="math inline">\(O(n+m+q)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span><span class="hljs-number">+10</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chain</span> &#123;<span class="hljs-type">int</span> covered;vector&lt;<span class="hljs-type">int</span>&gt; a,nxt; <span class="hljs-built_in">Chain</span>() &#123;&#125;<span class="hljs-built_in">Chain</span>(<span class="hljs-type">int</span> n) &#123;a.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>);nxt.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>);<span class="hljs-built_in">iota</span>(nxt.<span class="hljs-built_in">begin</span>(),nxt.<span class="hljs-built_in">end</span>(),<span class="hljs-number">1</span>);covered=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,lst=<span class="hljs-number">0</span>;i&lt;=r;i=nxt[i]) &#123;<span class="hljs-keyword">if</span>(!a[i]) &#123;covered++;a[i]=<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span>(lst) &#123;nxt[lst]=nxt[r];&#125;lst=i;&#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-comment">//[l,r]内有多少已被占用</span><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i=nxt[i]) &#123;res+=(a[i]==<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">return</span> (r-l<span class="hljs-number">+1</span>)-res;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();vector&lt;array&lt;<span class="hljs-type">int</span>,5&gt;&gt; <span class="hljs-built_in">qry</span>(q<span class="hljs-number">+1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;qry[i]=&#123;<span class="hljs-built_in">read</span>(),<span class="hljs-built_in">read</span>(),<span class="hljs-built_in">read</span>(),<span class="hljs-built_in">read</span>(),<span class="hljs-built_in">read</span>()&#125;;&#125;<span class="hljs-function">Chain <span class="hljs-title">tr</span><span class="hljs-params">(n)</span>,<span class="hljs-title">tc</span><span class="hljs-params">(m)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(k<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">auto</span> work = [&amp;](<span class="hljs-type">int</span> id) &#123;<span class="hljs-keyword">auto</span> [opt,l,r,c,t]=qry[id];<span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>) &#123;ans[c]+=(r-l<span class="hljs-number">+1</span>-tr.<span class="hljs-built_in">query</span>(l,r))*(m-tc.covered);tr.<span class="hljs-built_in">update</span>(l,r);&#125; <span class="hljs-keyword">else</span> &#123;ans[c]+=(r-l<span class="hljs-number">+1</span>-tc.<span class="hljs-built_in">query</span>(l,r))*(n-tr.covered);tc.<span class="hljs-built_in">update</span>(l,r);&#125;&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=q;i&gt;=<span class="hljs-number">1</span>;--i) &#123;<span class="hljs-keyword">if</span>(qry[i][<span class="hljs-number">4</span>]) &#123;<span class="hljs-built_in">work</span>(i);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;++i) &#123;<span class="hljs-keyword">if</span>(!qry[i][<span class="hljs-number">4</span>]) &#123;<span class="hljs-built_in">work</span>(i);&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】洛谷基础赛 4</title>
      <link href="/posts/26a0ed02.html"/>
      <url>/posts/26a0ed02.html</url>
      
        <content type="html"><![CDATA[<h2 id="a.-judg.">A. Judg.</h2><p><ahref="https://www.luogu.com.cn/problem/P9686?contestId=133572">Problem</a></p><div class="note note-success">            <p>逐个判断即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;string s;cin&gt;&gt;s;<span class="hljs-keyword">if</span>(s!=<span class="hljs-string">&quot;AC&quot;</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,i);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-maps.">B. Maps.</h2><p><ahref="https://www.luogu.com.cn/problem/P9687?contestId=133572">Problem</a></p><div class="note note-success">            <p>要让字典序最小，答案必然是一段前缀 <spanclass="math inline">\(0\)</span> <span class="math inline">\(+\)</span>一段 <span class="math inline">\(01\)</span> 交替的序列。</p><p>满状态是 <span class="math inline">\(1010\dots0101\)</span>，所以<span class="math inline">\(2p+1&gt; n\)</span> 时无解。</p><p>后续直接从后往前模拟。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-type">int</span> s[<span class="hljs-number">100000</span><span class="hljs-number">+5</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),p=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(p*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&gt;n) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,tot=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(s));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;--i) &#123;<span class="hljs-keyword">if</span>((++tot)&amp;<span class="hljs-number">1</span>) &#123;s[i]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(++cnt==p) &#123;s[i<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,s[i]);&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-colo."><ahref="https://kisuraop.github.io/posts/26a0ed02.html#c.-colo.">C.Colo.</a></h2><p><ahref="https://www.luogu.com.cn/problem/P9688?contestId=133572">Problem</a></p><div class="note note-info">            <p>题意：给定个长度为 <span class="math inline">\(n\)</span> 的序列<span class="math inline">\(a,b\)</span>分别代表颜色和价值，你可以挑一些不同的颜色 <spanclass="math inline">\(a_i\)</span> 进集合 <spanclass="math inline">\(S\)</span> 中，获得 <spanclass="math inline">\(b_{a_i}\)</span> 价值，但需要使所有 <spanclass="math inline">\(x\in S\)</span> 从 <spanclass="math inline">\(a\)</span> 中按顺序取出后形成的序列单调不降。 求<span class="math inline">\(|S|=k\)</span> 时能获得的最大价值。</p><p><span class="math inline">\(1\le n,k \le 500\)</span>，<spanclass="math inline">\(1\le a_i\le n\)</span>，<spanclass="math inline">\(1\le b_i\le10^9\)</span>。</p>          </div><div class="note note-success">            <p>把每种不同的颜色看成一个线段 <spanclass="math inline">\([\text{fir}_{a[i]},\text{end}_{a[i]}]\)</span>，其中<span class="math inline">\(\text{fir}_{a[i]}\)</span> 和 <spanclass="math inline">\(\text{end}_{a[i]}\)</span> 分别是颜色 <spanclass="math inline">\(a[i]\)</span>第一次出现的地方和最后一次出现的地方。不难发现如果当前保留了两种及以上的颜色，那么所有线段都应该是互相隔离的（即既不包含也不相交），这样才能确保最终序列的单调性。</p><p>现在相当于确定了一种 <spanclass="math inline">\(a[i]\)</span>，我们可以去区间 <spanclass="math inline">\([1,\text{fir}_{a[i]})\)</span> 去寻找一个 <spanclass="math inline">\(\text{end}_{a[j]}\)</span>，这样 <spanclass="math inline">\(a[i]\)</span> 就可以从 <spanclass="math inline">\(a[j]\)</span> 那转移过来。</p><p>这样就转化为了一个类背包问题，用 dp 求解。</p><p>令 <span class="math inline">\(dp[\text{end}_{i}][len]\)</span>表示目前选择到了颜色 <span class="math inline">\(i\)</span>，已经选了<span class="math inline">\(len\)</span> 种颜色。</p><p>转移方程如下： <span class="math display">\[\normalsize{dp[\text{end}_i][len]=\max\limits_{j=\text{end}_{a[j]}\text{},\text{ }j\in [1,\text{fir}_i)}(dp[j][len-1]+b[i])}\]</span></p><p>答案即为 <span class="math inline">\(\max\limits_{i\in[1,n]}dp[i][k]\)</span>。</p><p>有点抽象，看代码可能更直观。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fir</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">end</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(!vis[a[i]]) &#123;vis[a[i]]=<span class="hljs-literal">true</span>;fir[a[i]]=i;&#125;end[a[i]]=i;&#125;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k<span class="hljs-number">+1</span>,-inf));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123; <span class="hljs-comment">//表示当前枚举到颜色i </span><span class="hljs-keyword">if</span>(vis[i]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;fir[i];++j) &#123;<span class="hljs-keyword">if</span>(j==end[a[j]]) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=k;++len) &#123;<span class="hljs-keyword">if</span>(dp[j][len<span class="hljs-number">-1</span>]!=-inf) &#123;dp[end[i]][len]=<span class="hljs-built_in">max</span>(dp[end[i]][len],dp[j][len<span class="hljs-number">-1</span>]+b[i]);&#125;&#125;&#125;&#125;dp[end[i]][<span class="hljs-number">1</span>]=b[i]; <span class="hljs-comment">//只选它自身</span>&#125;&#125;<span class="hljs-type">int</span> res=-inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;res=<span class="hljs-built_in">max</span>(res,dp[i][k]);&#125;<span class="hljs-keyword">if</span>(res==-inf) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-success">            <p>这和一般的 dp 有点不一样，所以看起来很奇怪。</p><p>我们分析它的正确性是如何保证的： 1. 外层从小到大枚举颜色 <spanclass="math inline">\(i\)</span>，保证不会从比它大的颜色转移过来，使序列单调不降。</p><ol start="2" type="1"><li>用右端点 <span class="math inline">\(\text{end}_{i}\)</span>代表该种颜色，只保留有用的部分，符合最优子结构性质。</li></ol><p>时间复杂度 <span class="math inline">\(O(n^2k)\)</span>。</p>          </div><h2 id="d.-bina."><ahref="https://kisuraop.github.io/posts/26a0ed02.html#d.-bina.">D.Bina.</a></h2><p><ahref="https://www.luogu.com.cn/problem/P9689?contestId=133572">Problem</a></p><div class="note note-info">            <p>题意：给定正整数 <spanclass="math inline">\(n,m\)</span>，依照给定代码建一棵构建参数为 <spanclass="math inline">\(n\)</span>二叉树。你可以从二叉树底部开始往上砍节点（或不砍），一次砍一层，至少砍<span class="math inline">\(m\)</span> 个点。令美丽值 <spanclass="math inline">\(=\)</span> 所有节点编号之和 <spanclass="math inline">\(\div\)</span>这棵树的深度（向下取整），求最大美丽值。</p>          </div><div class="note note-success">            <p>很难下手，但你可以把 <span class="math inline">\(n=1\sim 16\)</span>的图都手玩出来，找到一些性质。</p><p>这是 <span class="math inline">\(n=13\)</span> 的图。</p><p><img src="https://kisuraop.github.io/image/academic/1.png" alt="1" />最明显的是这颗树除去最后一层必然是满二叉树，而且最后一层的叶子节点必然成对出现。</p><p>再进一步，<span class="math inline">\(n\leftarrow n+1\)</span>时就会多出两个节点，所以总节点数量 <spanclass="math inline">\(2n-1\)</span> 是已知的，进而树的深度 <spanclass="math inline">\(d\)</span> 也能推出。</p><p>其次一颗 <span class="math inline">\(d\)</span>层的满二叉树，其美丽值为 <spanclass="math inline">\(\frac{(1+2^{n}-1)(2^n-1)}{2}\times\frac{1}{d}=\frac{2^{n-1}(2^n-1)}{d}\)</span>，单调增。</p><p>意味着尽可能保留满二叉树层数是最优的。</p><p>故 <span class="math inline">\(m&gt;0\)</span>时，最后一层必砍，在此基础上砍够 <span class="math inline">\(m\)</span>就马上停手，答案最优。</p><p>麻烦的是 <spanclass="math inline">\(m=0\)</span>，这意味着答案是从砍最后一层和一点不砍之间取较大者。</p><p>前者可以预处理，后者我们需要知晓最后一层的节点编号和。</p><p>找规律。</p><p>打印出 <span class="math inline">\(n=2^3\sim 2^4\)</span>时是哪些编号（设为 <spanclass="math inline">\(x\)</span>）的节点下挂了两个新节点。</p><table><thead><tr><th><span class="math inline">\(n=\)</span></th><th><span class="math inline">\(8\)</span></th><th><span class="math inline">\(9\)</span></th><th><span class="math inline">\(10\)</span></th><th><span class="math inline">\(11\)</span></th><th><span class="math inline">\(12\)</span></th><th><span class="math inline">\(13\)</span></th><th><span class="math inline">\(14\)</span></th><th><span class="math inline">\(15\)</span></th></tr></thead><tbody><tr><td><span class="math inline">\(x=\)</span></td><td>8</td><td>12</td><td>10</td><td>14</td><td>9</td><td>13</td><td>11</td><td>15</td></tr></tbody></table><p>都减去 <span class="math inline">\(2^3\)</span> 有：</p><table><thead><tr><th><span class="math inline">\(n=\)</span></th><th><span class="math inline">\(0\)</span></th><th><span class="math inline">\(1\)</span></th><th><span class="math inline">\(2\)</span></th><th><span class="math inline">\(3\)</span></th><th><span class="math inline">\(4\)</span></th><th><span class="math inline">\(5\)</span></th><th><span class="math inline">\(6\)</span></th><th><span class="math inline">\(7\)</span></th></tr></thead><tbody><tr><td><span class="math inline">\(x=\)</span></td><td>0</td><td>4</td><td>2</td><td>6</td><td>1</td><td>5</td><td>3</td><td>7</td></tr></tbody></table><p>此时我们发现 <span class="math inline">\(x\)</span> 是对应 <spanclass="math inline">\(n\)</span> 的二进制翻转。</p><p>设 <span class="math inline">\(k=n-2^p-1\)</span>，<spanclass="math inline">\(rev(i)\)</span> 为 <spanclass="math inline">\(i\)</span> 的二进制翻转。</p><p>又由于 <span class="math inline">\(x\)</span> 下挂的两个节点编号为<span class="math inline">\(2x\)</span> 和 <spanclass="math inline">\(2x+1\)</span>，最后一层的总编号和即为： <spanclass="math display">\[\begin{align}&amp;\text{ }\text{ }\text{}\sum\limits_{i=0}^{k}(((2^p+rev(i))\times 2)+(2^p+rev(i))\times2+1)\\&amp;=(k+1)(2^{p+2}+1)+4\sum_{i=0}^k rev(i)\end{align}\]</span></p><p>由表推出 <span class="math inline">\(p=d-1\)</span>。那么如何求 <spanclass="math inline">\(\sum\limits_{i=0}^k rev(i)\)</span>？</p><p>拆位考虑，考虑 <span class="math inline">\(0\sim k\)</span>中每个数的第 <span class="math inline">\(x\in[0,p)\)</span> 位为 <spanclass="math inline">\(1\)</span> 的个数 <spanclass="math inline">\(cnt\)</span>，对翻转后的贡献即 <spanclass="math inline">\(cnt\times 2^{p-x-1}\)</span>。</p><p>单组总时间复杂度 <span class="math inline">\(O(\log n)\)</span>。</p>          </div><div class="note note-warning">            <p>利用二进制下第 <span class="math inline">\(x\)</span> 位每隔 <spanclass="math inline">\(2^x\)</span> 个就改变一次的特性，统计循环节，可以<span class="math inline">\(O(1)\)</span> 统计每一位的 <spanclass="math inline">\(cnt\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> all=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>,depth=<span class="hljs-number">0</span>;  <span class="hljs-comment">//all:总节点数,depth:总深度</span><span class="hljs-keyword">while</span>((<span class="hljs-number">1ll</span>&lt;&lt;depth)&lt;all) &#123;depth++;&#125;<span class="hljs-keyword">if</span>(m&gt;all) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-type">int</span> lastnum=all-((<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>))<span class="hljs-number">-1</span>); <span class="hljs-comment">//最后一层节点数</span><span class="hljs-keyword">if</span>(m&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-type">int</span> tmp=depth,cut=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(tmp==depth) &#123;cut+=lastnum;&#125; <span class="hljs-keyword">else</span> &#123;cut+=(<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>));&#125;depth--;<span class="hljs-keyword">if</span>(cut&gt;=m) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(!depth) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> res=(<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>))*((<span class="hljs-number">1ll</span>&lt;&lt;depth)<span class="hljs-number">-1</span>)/depth;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;&#125; <span class="hljs-keyword">else</span> &#123;depth--;  <span class="hljs-comment">//此时depth是满二叉树层数</span><span class="hljs-type">int</span> res=(<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>))*((<span class="hljs-number">1ll</span>&lt;&lt;depth)<span class="hljs-number">-1</span>)/depth;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,tmp_n=n-(<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;depth<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> cnt=tmp_n/(<span class="hljs-number">1ll</span>&lt;&lt;i);<span class="hljs-type">int</span> left=tmp_n%(<span class="hljs-number">1ll</span>&lt;&lt;i);<span class="hljs-type">int</span> ano_cnt=cnt;<span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) &#123;ano_cnt--;&#125;ano_cnt/=<span class="hljs-number">2</span>;ano_cnt*=(<span class="hljs-number">1ll</span>&lt;&lt;i);<span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) &#123;ano_cnt+=left;&#125;sum+=ano_cnt*(<span class="hljs-number">1ll</span>&lt;&lt;(depth-i<span class="hljs-number">-2</span>));&#125;sum=tmp_n*((<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">+1</span>))<span class="hljs-number">+1</span>)<span class="hljs-number">+4</span>*sum; <span class="hljs-comment">//操作后sum为最后一层节点编号和</span><span class="hljs-type">int</span> res2=((<span class="hljs-number">1ll</span>&lt;&lt;(depth<span class="hljs-number">-1</span>))*((<span class="hljs-number">1ll</span>&lt;&lt;depth)<span class="hljs-number">-1</span>)+sum)/(depth<span class="hljs-number">+1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">max</span>(res,res2));&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】2023 NOI 春季测试 3 of 4</title>
      <link href="/posts/a073199c.html"/>
      <url>/posts/a073199c.html</url>
      
        <content type="html"><![CDATA[<h2 id="a.-涂色游戏">A. 涂色游戏</h2><p><a href="https://www.luogu.com.cn/problem/P9117">Problem</a></p><div class="note note-info">            <p>题意：<span class="math inline">\(n\times m\)</span> 的网格，<spanclass="math inline">\(q\)</span>次询问，每次涂一行或一列，新颜色会覆盖旧颜色，输出最终形态。</p><p><span class="math inline">\(1\le \sum nm\)</span>，<spanclass="math inline">\(\sum q\le 10^6\)</span>。</p>          </div><div class="note note-success">            <p>考虑倒序执行这 <span class="math inline">\(q\)</span> 个操作。</p><p>对每一行和每一列用 <code>std::unordered_map</code>存当前还有哪一些方格未被涂色。</p><p>因为反着执行涂色时旧颜色一定不会被覆盖，故对于一个操作遍历该行/列对应的容器，未涂色的涂色，再将该方格编号从容器中删掉即可。</p><p>时间复杂度 <span class="math inline">\(O(mn)\)</span>。</p>          </div><div class="note note-warning">            <p><code>std::unordered_map</code> 插值和删值的均摊时间复杂度是 <spanclass="math inline">\(O(1)\)</span> 的。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();vector&lt;array&lt;<span class="hljs-type">int</span>,3&gt;&gt; <span class="hljs-built_in">query</span>(q);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q;++i) &#123;<span class="hljs-type">int</span> opt=<span class="hljs-built_in">read</span>(),x=<span class="hljs-built_in">read</span>(),c=<span class="hljs-built_in">read</span>();query[i]=&#123;opt,x,c&#125;;&#125;vector&lt;unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">line</span>(n<span class="hljs-number">+1</span>),<span class="hljs-built_in">col</span>(m<span class="hljs-number">+1</span>);vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>));<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;line[i][j]=j;col[j][i]=i;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=q<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-keyword">auto</span> [opt,x,c]=query[i];<span class="hljs-keyword">if</span>(!opt) &#123;vector&lt;<span class="hljs-type">int</span>&gt; id;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [fir,sec]:line[x]) &#123;id.<span class="hljs-built_in">push_back</span>(sec);col[sec].<span class="hljs-built_in">erase</span>(x);ans[x][sec]=c;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:id) &#123;line[x].<span class="hljs-built_in">erase</span>(k);&#125;&#125; <span class="hljs-keyword">else</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; id;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [fir,sec]:col[x]) &#123;id.<span class="hljs-built_in">push_back</span>(sec);line[sec].<span class="hljs-built_in">erase</span>(x);ans[sec][x]=c;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:id) &#123;col[x].<span class="hljs-built_in">erase</span>(k);&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i][j]);&#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-幂次">B. 幂次</h2><p><a href="https://www.luogu.com.cn/problem/P9118">Problem</a></p><div class="note note-info">            <p>题意：给定正整数 <span class="math inline">\(n,k\)</span>，求 <spanclass="math inline">\(1\sim n\)</span> 中有多少正整数 <spanclass="math inline">\(x\)</span> 可以表示为 <spanclass="math inline">\(x=a^b\)</span> 的形式，其中 <spanclass="math inline">\(a,b\in \mathbb N^+\)</span> 且 <spanclass="math inline">\(b\ge k\)</span>。</p><p><span class="math inline">\(1\le n \le 10^{18}\)</span>，<spanclass="math inline">\(1\le k \le 100\)</span>。</p>          </div><div class="note note-success">            <p>按照 <span class="math inline">\(k\)</span> 范围分治。</p><p>首先，当 <span class="math inline">\(k=1\)</span> 时，<spanclass="math inline">\(ans=n\)</span>。因为所有 <spanclass="math inline">\(x\)</span> 都能表示为 <spanclass="math inline">\(x^1\)</span>。</p><p>其次，当 <span class="math inline">\(k\ge 3\)</span>时，可以暴力枚举底数 <span class="math inline">\(a\)</span>，因为 <spanclass="math inline">\((10^6)^3=10^{18}\)</span>，底数十分有限。</p><p>最后，<span class="math inline">\(k=2\)</span> 时，一个结论是小于等于<span class="math inline">\(x\)</span> 的完全平方数有 <spanclass="math inline">\(sqrt(x)\)</span> 个，但其中有一些和指数大于 <spanclass="math inline">\(2\)</span> 时的计算结果重复，考虑容斥。在统计<span class="math inline">\(k\ge 3\)</span>的过程中顺便记录哪些计入答案的数属于完全平方数，令 <spanclass="math inline">\(k\ge 3\)</span> 时的答案为 <spanclass="math inline">\(cnt\)</span>，有 <spanclass="math inline">\(num\)</span> 个完全平方数，则 <spanclass="math inline">\(ans=cnt+sqrt(x)-num\)</span>。</p><p>容易爆 <code>long long</code> ，可以开 <code>__int128</code> 。</p>          </div><div class="note note-warning">            <p>小心精度问题，用 <code>std::sqrtl()</code> 而不是<code>std::sqrt()</code> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int __int128</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k*=k) <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) s*=k;<span class="hljs-keyword">return</span> s;&#125;map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt; mp;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">write</span>(n);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,sqrt_num=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i*i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;;++j) &#123;x*=i;<span class="hljs-keyword">if</span>(x&gt;n) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span>(j&gt;=k &amp;&amp; !mp[x]) &#123;<span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrtl</span>(x)*(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrtl</span>(x)==x) &#123;sqrt_num++;&#125;mp[x]=<span class="hljs-number">1</span>;cnt++;&#125;&#125;&#125;<span class="hljs-keyword">if</span>(k==<span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">write</span>(cnt+<span class="hljs-built_in">sqrtl</span>(n)-sqrt_num);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">write</span>(cnt<span class="hljs-number">+1</span>);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-圣诞树">C. 圣诞树</h2><p><a href="https://www.luogu.com.cn/problem/P9119">Problem</a></p><div class="note note-info">            <p>题意：给定二维坐标系上 <span class="math inline">\(n\)</span>个点构成的凸多边形，求从 <span class="math inline">\(y\)</span>轴最高点出发的一条最短路径，要求经过 <spanclass="math inline">\(n\)</span>个点且每个点仅能经过一次，依次输出编号。</p><p><span class="math inline">\(3\le n\le 1000\)</span>，<spanclass="math inline">\(|x_i|,|y_i|\le 10^7\)</span>。</p>          </div><div class="note note-success">            <p>正解是区间 dp，不是很会。</p><p>只会 <span class="math inline">\(3\len\le18\)</span>，不过加上两个特殊性质一共能拿到 80pts。</p><p>套路题，最短哈密顿路径，考虑状压dp。</p><p>令起点为 <span class="math inline">\(s\)</span>，则 <spanclass="math inline">\(dp[i][j]\)</span> 代表从 <spanclass="math inline">\(s\)</span> 到 <spanclass="math inline">\(j\)</span>，且经过 <spanclass="math inline">\(i\)</span> 的二进制为 <spanclass="math inline">\(1\)</span> 的位数对应编号的点的最短路径长度。</p><p>则 <spanclass="math inline">\(dp[i][j]=\mathop\min\limits_{k\in[1,n]}(dp[i\oplus2^j][k]+dis[k][j])\)</span>。</p><p>答案为 <spanclass="math inline">\(\min\limits_{i\in[1,n]}(dp[2^n-1][i])\)</span>。</p><p>接下来考虑如何记录路径。</p><p>令 <span class="math inline">\(pre[mask][j]=k\)</span> 表示状态为<span class="math inline">\(mask\)</span>，当前点 <spanclass="math inline">\(j\)</span> 从点 <spanclass="math inline">\(k\)</span> 转移过来最优。</p><p>状态转移时 <span class="math inline">\(pre\)</span> 与 <spanclass="math inline">\(dp\)</span> 同步。</p><p>统计答案时，<span class="math inline">\(mask\)</span> 对应为 <spanclass="math inline">\(1\)</span> 的位异或变成 <spanclass="math inline">\(0\)</span>，即可回溯到上一状态。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dis</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(n));<span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">X</span><span class="hljs-params">(n)</span>,<span class="hljs-title">Y</span><span class="hljs-params">(n)</span></span>;<span class="hljs-type">int</span> top=<span class="hljs-number">0</span>;<span class="hljs-type">double</span> maxn=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;cin&gt;&gt;X[i]&gt;&gt;Y[i];<span class="hljs-keyword">if</span>(Y[i]&gt;maxn) &#123;maxn=Y[i];top=i;&#125;&#125; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) &#123;dis[i][j]=<span class="hljs-built_in">sqrtl</span>((X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j]));&#125;&#125;vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">1</span>&lt;&lt;n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(n,<span class="hljs-number">1.0</span>*inf));vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pre</span>(<span class="hljs-number">1</span>&lt;&lt;n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">-1</span>));dp[<span class="hljs-number">1</span>&lt;&lt;top][top]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j) &#123;<span class="hljs-keyword">if</span>(i&gt;&gt;j&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k) &#123;<span class="hljs-keyword">if</span>(i&gt;&gt;k&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)][k]+dis[k][j]&lt;dp[i][j]) &#123;dp[i][j]=dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)][k]+dis[k][j];pre[i][j]=k;&#125;&#125;&#125;&#125;&#125;&#125;<span class="hljs-type">double</span> res=<span class="hljs-number">1.0</span>*inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(i!=top) &#123;res=<span class="hljs-built_in">min</span>(res,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]);&#125;&#125;vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]-res)&lt;<span class="hljs-number">1e-14</span>) &#123;path.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-type">int</span> mask=(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>,j=i;<span class="hljs-keyword">while</span>(pre[mask][j]!=<span class="hljs-number">-1</span>) &#123;<span class="hljs-type">int</span> tmp=j;j=pre[mask][j];mask^=(<span class="hljs-number">1</span>&lt;&lt;tmp);path.<span class="hljs-built_in">push_back</span>(j);&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(),path.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:path) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,i<span class="hljs-number">+1</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】Codeforces Round 901 (Div.2) 4 of 7</title>
      <link href="/posts/80b55541.html"/>
      <url>/posts/80b55541.html</url>
      
        <content type="html"><![CDATA[<h2 id="a.-jellyfish-and-undertale">A. Jellyfish and Undertale</h2><p><ahref="https://codeforces.com/contest/1875/problem/A">Problem</a></p><div class="note note-success">            <p>显然每当倒计时仅剩 <span class="math inline">\(1\)</span>时依次使用工具会最优。</p><p>则第 <span class="math inline">\(i\)</span> 个工具对时间的贡献就是<span class="math inline">\(\min(a-1,x_i)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>(),n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;x[i]=<span class="hljs-built_in">read</span>();sum+=<span class="hljs-built_in">min</span>(x[i],a<span class="hljs-number">-1</span>);&#125;<span class="hljs-type">int</span> res=b+sum;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-jellyfish-and-game">B. Jellyfish and Game</h2><p><ahref="https://codeforces.com/contest/1874/problem/A">Problem</a></p><div class="note note-info">            <p>题意：<span class="math inline">\(A\)</span> 有 <spanclass="math inline">\(n\)</span> 个物品，<spanclass="math inline">\(B\)</span> 有 <spanclass="math inline">\(m\)</span> 个，每个物品有价值。游戏进行 <spanclass="math inline">\(k\)</span> 轮，奇数轮 <spanclass="math inline">\(A\)</span> 可以选择与 <spanclass="math inline">\(B\)</span> 的一个物品交换(或不交换)，偶数轮 <spanclass="math inline">\(B\)</span> 可以选择与 <spanclass="math inline">\(A\)</span> 的一个物品交换(或不交换)，问最终 <spanclass="math inline">\(A\)</span> 拥有物品的总价值。</p><p><span class="math inline">\(1\le n,m\le 50\)</span>，<spanclass="math inline">\(1\le k \le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>一开始，<span class="math inline">\(A\)</span>显然会拿自己的最小价值的和 <span class="math inline">\(B\)</span>的最大价值进行交换，而 <span class="math inline">\(B\)</span> 的回合会拿<span class="math inline">\(\min(自己原本的最小价值,\A\  给的物品价值)\)</span> 和 <span class="math inline">\(\max(A \原本最大价值,\ A \ 从\  B\  这拿走的物品价值)\)</span>进行交换。一个直觉是当游戏进行两轮以上后，双方的决策(即拿的物品的价值)都达到最优，因此游戏最终结果仅和<span class="math inline">\(k\)</span> 的奇偶性相关。我们只需要暴力模拟<span class="math inline">\(k=1,2\)</span> 时的结果。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();vector&lt;<span class="hljs-type">int</span>&gt; a,b;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();a.<span class="hljs-built_in">push_back</span>(x);sum+=x;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();b.<span class="hljs-built_in">push_back</span>(x);&#125;<span class="hljs-type">int</span> res=sum;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=(k&amp;<span class="hljs-number">1</span>?<span class="hljs-number">1</span>:<span class="hljs-number">2</span>);++i) &#123;<span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">auto</span> posa=<span class="hljs-built_in">min_element</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">auto</span> posb=<span class="hljs-built_in">max_element</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> mina=a[posa-a.<span class="hljs-built_in">begin</span>()];<span class="hljs-type">int</span> maxb=b[posb-b.<span class="hljs-built_in">begin</span>()];<span class="hljs-keyword">if</span>(mina&gt;maxb) &#123;<span class="hljs-keyword">continue</span>;&#125;res-=mina;res+=maxb;a.<span class="hljs-built_in">erase</span>(posa);b.<span class="hljs-built_in">erase</span>(posb);a.<span class="hljs-built_in">push_back</span>(maxb);b.<span class="hljs-built_in">push_back</span>(mina);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">auto</span> posa=<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">auto</span> posb=<span class="hljs-built_in">min_element</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<span class="hljs-type">int</span> maxa=a[posa-a.<span class="hljs-built_in">begin</span>()];<span class="hljs-type">int</span> minb=b[posb-b.<span class="hljs-built_in">begin</span>()];<span class="hljs-keyword">if</span>(maxa&lt;minb) &#123;<span class="hljs-keyword">continue</span>;&#125;res-=maxa;res+=minb;a.<span class="hljs-built_in">erase</span>(posa);b.<span class="hljs-built_in">erase</span>(posb);a.<span class="hljs-built_in">push_back</span>(minb);b.<span class="hljs-built_in">push_back</span>(maxa);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-jellyfish-and-green-apple">C. Jellyfish and Green Apple</h2><p><ahref="https://codeforces.com/contest/1875/problem/C">Problem</a></p><div class="note note-info">            <p>题意：<span class="math inline">\(n\)</span> 个苹果分给 <spanclass="math inline">\(m\)</span> 个人，每个苹果 <spanclass="math inline">\(1kg\)</span>，每切一刀会均分成重量相同的两瓣，问最少切几刀能使每个人分到的苹果重量都相等，若无法均分输出<span class="math inline">\(-1\)</span>。</p><p><span class="math inline">\(1\le n,m\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>当 <span class="math inline">\(n\ge m\)</span> 时，可以把 <spanclass="math inline">\(n\)</span> 个中的若干个 <spanclass="math inline">\(m\)</span> 分出去，剩下 <spanclass="math inline">\(n\%m\)</span> 个。而剩下不足 <spanclass="math inline">\(m\)</span>个的为了能均分必然选择每个切一刀进行加倍，因此可以用递归进行模拟。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> &amp;res,<span class="hljs-type">int</span> times)</span> </span>&#123;<span class="hljs-keyword">if</span>(times&gt;<span class="hljs-number">1000</span>) &#123;res=<span class="hljs-number">-1</span>;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">while</span>(n&lt;m) &#123;res+=n;n*=<span class="hljs-number">2</span>;&#125;<span class="hljs-type">int</span> div=n%m;<span class="hljs-keyword">if</span>(!div) &#123;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">divide</span>(div,m,res,times<span class="hljs-number">+1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-built_in">divide</span>(n,m,res,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><div class="note note-success">            <p>但这样无解条件并不明显，借用官方题解进行形式化的思考。由于苹果 <spanclass="math inline">\(1kg\)</span>，以下用数量指代重量，完全等价。</p><p>若能均分，那么必有 <span class="math inline">\(n\times2^k\equiv0\pmod{m}\)</span>，因为只考虑什么时候无解时”先分再加倍”和”先加倍再分”是等价的。接着推出<span class="math inline">\(n\times 2^k\equiv0\pmod{m} \rightarrow2^k\equiv 0 \pmod{\frac{m}{\gcd(n,m)}}\)</span> .</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Why?    </div>    <div class='spoiler-content'>        <p>定理：若 <span class="math inline">\(ac\equiv bc\pmod{m},c\neq0\)</span>，则 <span class="math inline">\(a\equiv b\pmod{\frac{m}{\gcd(c,m)}}\)</span></p><p>证明：</p><ul><li><p>当 <span class="math inline">\(\gcd(c,m)=1\)</span> 时：</p><p>由定理 “整数 <span class="math inline">\(a,b\)</span> 对模 <spanclass="math inline">\(m\)</span> 同余的充要条件是 <spanclass="math inline">\(m\mid (a-b)\)</span>” (比较显然，证明略)</p><p><span class="math inline">\(\begin{align}\textbf{那么}&amp;\text{}ac\equiv bc\pmod{m}\\&amp;\rightarrow m\mid(ac-bc)\\&amp;\rightarrowm\mid (a-b)c \\&amp;\rightarrow m\mid (a-b) \\&amp;\rightarrow a\equivb\pmod{m}\end{align}\)</span></p><p>又此时 <span class="math inline">\(\gcd(c,m)=1\)</span>，故相当于<span class="math inline">\(a\equiv b\pmod{\frac{m}{\gcd(c,m)}}\)</span>.</p></li><li><p>当 <span class="math inline">\(\gcd(c,m)\neq 1\)</span> 时：</p><p>设 <span class="math inline">\(\gcd(c,m)=d &gt; 1\)</span>，令 <spanclass="math inline">\(c=c&#39;d\)</span> 和 <spanclass="math inline">\(m=m&#39;d\)</span>，则 <spanclass="math inline">\(\gcd(c&#39;,m&#39;)=1\)</span> .</p><p><span class="math inline">\(\begin{align}\textbf{那么}&amp;\text{}ac\equiv bc \pmod{m} \\&amp;\rightarrow ac&#39;\equiv bc&#39;\pmod{m&#39;} \\&amp;\rightarrow a\equiv b \pmod{m&#39;}\(由上文另一点的证明)\\&amp;\rightarrow a\equiv b\pmod{\frac{m}{d}}\\&amp;\rightarrow a\equivb\pmod{\frac{m}{\gcd(c,m)}}\end{align}\)</span></p></li></ul>    </div></div><div class="note note-success">            <p>也就是说，当 <span class="math inline">\(\frac{m}{\gcd(n,m)}\)</span>不是 <span class="math inline">\(2\)</span> 的整数幂时无解，可以用 <spanclass="math inline">\(\text{std::}\)</span> <spanclass="math inline">\(\underline{}\underline{}\text{builtin}\)</span><span class="math inline">\(\underline{}\text{popcount()}\)</span>快速验证。</p><p>接着，若有解，那么每个人分到的苹果数量应该是实数 <spanclass="math inline">\(\frac{n}{m}\)</span>，而具体的，每次一个人得到的苹果数量应该是<span class="math inline">\(2\)</span> 的整数幂，即存在集合 <spanclass="math inline">\(S\)</span> 使 <spanclass="math inline">\(\frac{n}{m}=\sum_{i\in S}\frac{1}{2^i}\)</span>。而 <span class="math inline">\(|S|\)</span>即每个人得到的苹果数量，答案即为 <span class="math inline">\(m\times|S|-n\)</span>。</p><p>减去 <span class="math inline">\(n\)</span> 是因为苹果总数量 <spanclass="math inline">\(-\)</span> 原有数量 <spanclass="math inline">\(=\)</span> 切的刀数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m); n %= m;<span class="hljs-type">int</span> a = n / __gcd(n, m), b = m / __gcd(n, m);<span class="hljs-keyword">if</span>(__builtin_popcount(b) &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-number">1ll</span> * __builtin_popcount(a) * m - n);&#125;<span class="hljs-type">int</span> T = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; T ; i ++) <span class="hljs-built_in">solve</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-jellyfish-and-mex">D. Jellyfish and Mex</h2><p><ahref="https://codeforces.com/contest/1875/problem/D">Problem</a></p><div class="note note-info">            <p>题意：一个有 <span class="math inline">\(n\)</span>个数的非负数组，<span class="math inline">\(n\)</span>次操作每次选一个数删掉后计算 <spanclass="math inline">\(\text{MEX}\)</span>并累加，问能达到的最小价值。</p><p><span class="math inline">\(1\le n \le 5000\)</span>，<spanclass="math inline">\(1\le a_i\le10^9\)</span>。</p>          </div><div class="note note-success">            <p>根据样例就能看明白，让总价值最小就是以最小的价值让 <spanclass="math inline">\(\text{MEX}\)</span> 变为 <spanclass="math inline">\(0\)</span>，并且我们只关心小于一开始 <spanclass="math inline">\(\text{MEX}\)</span> 的数的出现次数。</p><p>一开始我想假了，认为最优解一定是从小于 <spanclass="math inline">\(\text{MEX}\)</span> 的某个数开始删一路删到 <spanclass="math inline">\(0\)</span>，喜提 2WA。</p><p>耽误了很多时间，直到拍到一组样例：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">9</span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span>Wrong Answer: <span class="hljs-number">8</span>Correct Answer: <span class="hljs-number">6</span></code></pre></div><p>删法是先删掉 <span class="math inline">\(2\)</span>，然后删 <spanclass="math inline">\(0\)</span>，答案并不连续，所以考虑 dp。</p><p><span class="math inline">\(dp[i]\)</span> 表示目前从 <spanclass="math inline">\(\text{MEX}\)</span> 开始删到 <spanclass="math inline">\(i\)</span> 的最小价值，则 <spanclass="math inline">\(dp[i]=\mathop\min\limits_{j\in[i+1,\text{MEX}]}(dp[i],dp[j]+cnt[i]\timesj)\)</span> .</p><p>因为一开始有一个数是没有贡献的，所以答案是 <spanclass="math inline">\(dp[0]-\text{MEX}\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">cnt</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(a[i]&lt;=n) &#123;cnt[a[i]]++;&#125;&#125;<span class="hljs-type">int</span> mex=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(cnt[mex]) &#123;mex++;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,inf)</span></span>;dp[mex]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mex;i&gt;=<span class="hljs-number">0</span>;--i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;=mex;++j) &#123;dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[j]+cnt[i]*j);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[<span class="hljs-number">0</span>]-mex);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">// fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;C++</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【随笔】有关一道数列高考题求和表达式的思考</title>
      <link href="/posts/97008555.html"/>
      <url>/posts/97008555.html</url>
      
        <content type="html"><![CDATA[<div class="note note-info">            <p>【467】（2020 · 新课标Ⅰ卷 · 文 · 16）</p><p>数列 <span class="math inline">\(\{a_n\}\)</span> 满足 <spanclass="math inline">\(a_{n+2}+(-1)^na_n=3n-1\)</span>，前 <spanclass="math inline">\(16\)</span> 项和为 <spanclass="math inline">\(540\)</span>，则 <spanclass="math inline">\(a_1=\underline{\qquad\qquad}\)</span> .</p>          </div><p>这是刷题时碰到的一道有意思的题目。</p><p>因为该题数据范围小，故在现行参考答案中都是清一色的分奇偶讨论然后枚举相加。</p><p>但实际上，其求和表达式是可求的：</p><p>当 <span class="math inline">\(n\)</span> 为奇数时，运用累加法 <spanclass="math display">\[\begin{align}a_{n+2}-a_n&amp;=3n-1 \\a_n-a_{n-2}&amp;=3(n-2)-1 \\a_{n-2}-a_{n-4}&amp;=3(n-4)-1 \\&amp;\dots \\a_5-a_3&amp;=3\times3-1=8 \\a_3-a_1&amp;=3\times1-1=2 \\\end{align}\]</span></p><p>则</p><p><span class="math display">\[\begin{align}a_{n+2}&amp;=(3n-1)+(3n-7)+\dots+8+2+a_{1} \\&amp;= \dfrac{(2+3n-1)\dfrac{n+1}{2}}{2}+a_1 \\&amp;= \dfrac{(n+1)(3n+1)}{4}+a_1\end{align}\]</span></p><p>令 <span class="math inline">\(b_n=\dfrac{(n+1)(3n+1)}{4}\)</span> .因为只研究奇数项，</p><p>令 <spanclass="math inline">\(c_n=b_{2n-1}=\dfrac{2n(6n-2)}{4}=n(3n-1)=3n-n^2\)</span>.</p><p>对于两个等差数列相乘的形式，展开分别求和，于是有 <spanclass="math display">\[\begin{align}S_{c_n}&amp;=3\times\dfrac{n(n+1)(2n+1)}{6}-\dfrac{n(n+1)}{2} \\&amp;=\dfrac{n(n+1)\times 2n}{2} \\&amp;=n^2(n+1)\end{align}\]</span></p><p>注意到</p><p><span class="math display">\[\begin{align}a_{n+2}=b_n&amp;+a_1 \\a_{2n+1}=b_{2n-1}+&amp;a_1=c_n+a_1 \\a_1+a_3+a_5+\dots+a_{2n-1}&amp;=S_{c_n}+(n+1)a_1 \\&amp;=n^2(n+1)+(n+1)a_1\end{align}\]</span></p><p>令 <span class="math inline">\(T_1\)</span> 为奇数项前 <spanclass="math inline">\(n\)</span> 项和，因此</p><p><span class="math display">\[\begin{align}T_1 &amp;= a_1+a_3+a_5+\dots+a_{2n-1} \\&amp;= (n-1)^2n + na_1 \\&amp;= n[(n-1)^2+a_1]\end{align}\]</span></p><p>当 <span class="math inline">\(n\)</span> 为偶数时，有 <spanclass="math inline">\(a_{n+2}+a_n=3n-1\)</span> .</p><p>令 <spanclass="math inline">\(d_n=a_n+a_{n+2}\)</span>，又只取偶数项，可列出大概示意<span class="math display">\[\begin{align}a_{16}\quad a_{14} \to d_{14} \to \ &amp;e_4 \\a_{12}\quad a_{10} \to d_{10} \to \ &amp;e_3 \\a_{8}\quad a_{6} \to d_{6} \to \ &amp;e_2 \\a_{4}\quad a_{2} \to d_{2} \to \ &amp;e_1 \\\end{align}\]</span></p><p>箭头左边即为所需 <span class="math inline">\(a_n\)</span> 的和</p><p>故可令 <spanclass="math inline">\(e_n=d_{4n-2}=3(4n-2)-1=12n-7\)</span> . <spanclass="math display">\[\begin{align}S_{e_n}&amp;=12\times\dfrac{n(n+1)}{2}-7n \\&amp;=n(6n-1)\end{align}\]</span></p><p>由示意图看出 <span class="math inline">\(e_n\)</span> 即对应 <spanclass="math inline">\(a_{4n}\)</span>，令 <spanclass="math inline">\(T_2\)</span> 为偶数项前 <spanclass="math inline">\(n\)</span> 项和，则</p><p><span class="math display">\[\begin{align}T_2 &amp;= a_2+a_4+a_6+\dots+a_{2n} \\&amp;= \dfrac{n}{2}(6\times \dfrac{n}{2}-1) \\&amp;= \dfrac{n(3n-1)}{2}\end{align}\]</span></p><p>综上，令 <span class="math inline">\(T_n\)</span> 表示 <spanclass="math inline">\(a_n\)</span> 的前 <spanclass="math inline">\(2n\)</span> 项和</p><p><span class="math display">\[T_n=T_1+T_2=\dfrac{1}{2}n(2n^2-n+2a_1+1)\]</span></p><p>对于本题，将 <span class="math inline">\(n=8\)</span> 和 <spanclass="math inline">\(T_n=540\)</span> 代入即得答案 <spanclass="math inline">\(a_1=7\)</span> .</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Sundry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】背包问题</title>
      <link href="/posts/c17bf70d.html"/>
      <url>/posts/c17bf70d.html</url>
      
        <content type="html"><![CDATA[<h1 id="背包">1. <span class="math inline">\(01\)</span> 背包</h1><div class="note note-info">            <p>Q：有 <span class="math inline">\(N\)</span> 件物品和一个容量为 <spanclass="math inline">\(V\)</span> 的背包。第 <spanclass="math inline">\(i\)</span> 件物品的体积是 <spanclass="math inline">\(v_i\)</span>，价值是 <spanclass="math inline">\(w_i\)</span>。求解将哪些物品装入背包可使价值总和最大。</p>          </div><div class="note note-success">            <p>规定：<span class="math inline">\(f_{i,j}\)</span> 表示前 <spanclass="math inline">\(i\)</span> 件物品放入容量为 <spanclass="math inline">\(j\)</span> 的背包可以获得的最大价值，所以</p><p><span class="math display">\[\large{f_{i,j}=\max_{i\in [1,N],j\in[v_i,V]}(f_{i-1,j},f_{i-1,j-v_i}+w_i)}\]</span></p><p>在此基础上，还可以降维打击，考虑将 <spanclass="math inline">\(f\)</span> 第一维去掉，此时 <spanclass="math inline">\(f_j=\max(f_j,f_{j-v_i}+w_i)\)</span>，但此时我们需要将内层循环<span class="math inline">\(j\)</span> 逆序循环。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.NFor j=V..v[i]f[j]=max&#123;f[j],f[j-v[i]]+w[i]&#125;;result: f[V]</code></pre></div>          </div><div class="note note-warning">            <p><strong>为什么逆序 ？</strong></p><p>对比上面的递推式，<span class="math inline">\(f_j\)</span> 为第 <spanclass="math inline">\(i\)</span> 时刻的 <spanclass="math inline">\(f_j\)</span>，<spanclass="math inline">\(f_{j-v_i}\)</span> 为第 <spanclass="math inline">\(i-1\)</span> 时刻的 <spanclass="math inline">\(f_{j-v_i}\)</span>。</p><p>当外层循环执行到 <spanclass="math inline">\(i\)</span>，内层循环还没开始执行时，<spanclass="math inline">\(f_{j-v_i}\)</span> 为 <spanclass="math inline">\(i-1\)</span> 时刻的。</p><p>我们要保留这个 <span class="math inline">\(i-1\)</span> 时刻的 <spanclass="math inline">\(f_{j-v_i}\)</span>，就要 <spanclass="math inline">\(i-1\)</span> 时刻的 <spanclass="math inline">\(f_j\)</span> 在 <spanclass="math inline">\(f_{j-v_i}\)</span> 更新前率先更新为 <spanclass="math inline">\(i\)</span> 时刻的 <spanclass="math inline">\(f_j\)</span>，即在 <spanclass="math inline">\(j-v_i\)</span> 前更新 <spanclass="math inline">\(j\)</span>，所以逆序循环。</p>          </div><h1 id="完全背包">2. 完全背包</h1><div class="note note-info">            <p>Q：在 01 背包的基础上规定每个物品可用无限次，求最大价值。</p>          </div><div class="note note-success">            <p>一个朴素的方法是用多一重循环 <span class="math inline">\(k\)</span>记录每个物品所用的数量，状态转移： <span class="math display">\[\large{f_{i,j}=\max_{k\times v_i\in [0,j]}(f_{i-1,j},f_{i-1,j-k\timesv_i}+k\times w_i)}\]</span></p><p>不过时间复杂度较大，于是就诞生了一个巧妙的方法：把完全背包转化为 01背包求解。</p><p>首先我们要知道，任何一个数都可以通过 2 的幂次方数表示，如 <spanclass="math inline">\(11=2^3+2^1+2^0\)</span>，并且每一个幂次方数都能够仅出现一次。</p><p>然后我们发现，一个体积为 <span class="math inline">\(V\)</span>的背包中最多能装下 <span class="math inline">\(\left \lfloor \dfrac{V}{v_i}\right \rfloor\)</span> 个体积为 <spanclass="math inline">\(v_i\)</span>的物品。每一种物品数量是有限的，这意味着我们可以把每一种物品拆分。</p><p>具体的说，可以把第 <span class="math inline">\(i\)</span>种物品拆成体积为 <span class="math inline">\(v_i\times2^k\)</span>，价值为 <span class="math inline">\(w_i\times 2^k\)</span>的若干件物品，其中 <span class="math inline">\(v_i\times 2^k\leq V,k\inZ\)</span>。</p><p>如此时间复杂度降为 <span class="math inline">\(O(N\times \sum log\dfrac {V}{v_i})\)</span>。</p><p>但我们还是不想扩大时间复杂度，所以仍然有一个 <spanclass="math inline">\(O(NV)\)</span> 的解决方法：将 01背包中的内层循环由逆序再改回正序。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.NFor j=v[i]..Vf[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);result: f[V]</code></pre></div>          </div><div class="note note-warning">            <p><strong>为什么正序可以满足题意 ？</strong></p><p>反过来想 01 背包为什么要逆序？因为 <spanclass="math inline">\(i\)</span> 时刻的 <spanclass="math inline">\(f_j\)</span> 需要 <spanclass="math inline">\(i-1\)</span> 时刻的 <spanclass="math inline">\(f_{j-v_i}\)</span> 更新，所以在第 <spanclass="math inline">\(i\)</span> 时刻时 <spanclass="math inline">\(f_j\)</span> 要率先被遍历到。</p><p>换句话说，这是为了保证递推唯一，即每件物品只选一次。</p><p>而完全背包恰好相反，或许确实需要那个可能选入第 <spanclass="math inline">\(i\)</span> 件物品的结果，即第 <spanclass="math inline">\(i\)</span> 时刻的 <spanclass="math inline">\(f_{j-v_i}\)</span>，因此采用顺序循环便是最简单的解决方式。</p>          </div><h1 id="多重背包">3. 多重背包</h1><div class="note note-info">            <p>Q：在 01 背包的基础上规定第 <span class="math inline">\(i\)</span>件物品最多有 <span class="math inline">\(s_i\)</span>件，求最大价值。</p>          </div><div class="note note-success">            <p>很容易想到把 <span class="math inline">\(s_i\)</span>件物品全部拆分，转化为 01背包问题，但如果每种物品限定数量很多，时间复杂度就过大。</p><p>于是我们想到了上面完全背包用2的幂次方数拆分的二进制拆分法，但要稍加改动：</p><p>假设 <span class="math inline">\(s=13\)</span>，在 <spanclass="math inline">\(0\sim13\)</span> 中选一个数，例如 <spanclass="math inline">\(11\)</span>，我们需要拆分出 <spanclass="math inline">\(2^0,2^1,2^2,2^3\)</span>，然后选出 <spanclass="math inline">\(2^0,2^1,2^3\)</span> 来组成。</p><p>但程序可以组出 <spanclass="math inline">\(2^0+2^1+2^2+2^3=15\)</span> 这样大于 <spanclass="math inline">\(s=13\)</span> 的数，不符合限制。</p><p>所以正确的做法是：保证拆分出的 <span class="math inline">\(2\)</span>的幂次方数之和始终不大于 <spanclass="math inline">\(s\)</span>，余下部分通过相减来补齐。</p><p><span class="math inline">\(e.g.\text{ } 13\)</span> 可以拆分出 <spanclass="math inline">\(2^0,2^1,2^2\)</span> 和 <spanclass="math inline">\(13-2^0-2^1-2^2=6\)</span>，即 <spanclass="math inline">\(1,2,4,6\)</span>。</p><p>代码：（vector Q 存储拆分出物品的体积和价值）</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.N&#123;k=<span class="hljs-number">1</span>;While k&lt;=s[i] <span class="hljs-keyword">do</span>&#123;s[i]-=k;Q.<span class="hljs-built_in">pushback</span>(&#123;v[i]*k,w[i]*k&#125;);k&lt;&lt;=<span class="hljs-number">1</span>; <span class="hljs-comment">//指数+1</span>&#125;<span class="hljs-built_in">If</span>(s&gt;<span class="hljs-number">0</span>) Q.<span class="hljs-built_in">pushback</span>(&#123;v[i]*s,w[i]*s&#125;);&#125;For <span class="hljs-keyword">auto</span> QFor j=V..Q.vf[j]=<span class="hljs-built_in">max</span>(f[j],f[j-Q.v]+Q.w);result: f[V]</code></pre></div>          </div><div class="note note-danger">            <p><strong>单调队列优化 <span class="math inline">\(O(NV)\)</span></strong></p><p>试写出多重背包的朴素转移： <span class="math display">\[\large{f_{i,j}=\max(f_{i-1,j},f_{i-1,j-k\times v_i}+k\times w_i)}\]</span></p><p>其中 <span class="math inline">\(k\in[ 1,min(\left \lfloor \dfrac{V}{v_i} \right \rfloor,s_i) ]\)</span>，仿照 01 背包的想法，考虑 <spanclass="math inline">\(f_{i,j}\)</span> 对其它状态的影响：</p><p>我们发现如果往体积为 <span class="math inline">\(j-(k+1)\timesv_i\)</span> 的背包中填充体积为 <span class="math inline">\(v_i\)</span>的物品，体积变化为 <span class="math inline">\(j-k\timesv_i\)</span>。</p><p>归纳来看，<span class="math inline">\(f_{i,j}\)</span> 会影响 <spanclass="math inline">\(f_{i,j+k\times v_i}\)</span>（<spanclass="math inline">\(j+k\times v_i \leq V\)</span>。</p><p>那么，<span class="math inline">\(j+k\times v_i\)</span>能联想到什么？是等差数列，并且公差就是 <spanclass="math inline">\(v_i\)</span>，举个例子：</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/rgd8liiq.png" /></p><p>图中每一种颜色构成的数列均为公差为 <spanclass="math inline">\(v_i=4\)</span>的等差数列，意味着同一种颜色的格子对 <spanclass="math inline">\(v_i\)</span> 取模得到的余数相同。</p><p>即通项公式为 $j=kv_i+取模得到的余数$，所以我们可以通过取模得到的余数分出 <spanclass="math inline">\(0,1,2,..,v_i-1\)</span> 共 <spanclass="math inline">\(v_i\)</span> 组， 令公差为 <spanclass="math inline">\(d=v_i\)</span>，全选状态下物品个数 <spanclass="math inline">\(a=\left \lfloor \dfrac {j}{v_i} \right\rfloor\)</span>，余数 <span class="math inline">\(b=j \%v_i\)</span>，所以写成 <span class="math inline">\(j=a\timesd+b\)</span>，带回得： <span class="math display">\[\normalsize{j-k\times d=a\times d+b-k\times d=(a-k)\times d+b}\]</span></p><p>回想转移方程中 <span class="math inline">\(f_{i,j-k\timesv_i}+k\times w_i\)</span> 代表选择 <spanclass="math inline">\(k\)</span> 件第 <spanclass="math inline">\(i\)</span> 种物品，全选是 <spanclass="math inline">\(a\)</span>，所以不选择 <spanclass="math inline">\(a-k\)</span> 件物品。</p><p>如果令 <span class="math inline">\(a-k=k&#39;\)</span>，则状态变成：<span class="math display">\[\large{f_{i,j}=\max(f_{i-1,k&#39;\times d+b}+a\times w_i-k&#39;\timesw_i )}\]</span></p><p>其中 <span class="math inline">\(a\times w_i\)</span> 为常量，将其从<span class="math inline">\(\max\)</span> 中移出。则： <spanclass="math display">\[\large{f_{i,j}=\max(f_{i-1,k&#39;\times d+b}-k&#39;\times w_i )+a\timesw_i}\]</span></p><p>如果把 <span class="math inline">\(f_{i,j}\)</span> 之前所有的 <spanclass="math inline">\(f_{i-1,k&#39;d+b}-k&#39;w_i\)</span>放入一个队列，答案转化为求这个最长为 <spanclass="math inline">\(\min(\left \lfloor \dfrac {V}{v_i} \right\rfloor,s_i)+1\)</span> 的队列的最大值 + <spanclass="math inline">\(a\times w_i\)</span>。</p><p>所以考虑单调队列优化。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000010</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mylist</span> &#123;<span class="hljs-type">int</span> val,pos;&#125;que[N];<span class="hljs-type">int</span> n,V,head,tail,f[N],c[N],w[N],num[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;V);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;w[i],&amp;c[i],&amp;num[i]); <span class="hljs-comment">//c[i]代表体积，w[i]代表价值，num[i]代表数量 </span><span class="hljs-keyword">if</span>(V/c[i]&lt;num[i]) &#123;num[i]=V/c[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> mo=<span class="hljs-number">0</span>;mo&lt;c[i];mo++) &#123;head=tail=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=(V-mo)/c[i];k++) &#123;<span class="hljs-type">int</span> x=k;<span class="hljs-type">int</span> y=f[k*c[i]+mo]-k*w[i];<span class="hljs-keyword">while</span>(head&lt;tail &amp;&amp; que[head].pos&lt;k-num[i]) head++;<span class="hljs-keyword">while</span>(head&lt;tail &amp;&amp; que[tail<span class="hljs-number">-1</span>].val&lt;=y)tail--;que[tail].pos=x;que[tail].val=y;tail++; f[k*c[i]+mo]=que[head].val+k*w[i];&#125;&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[V]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>          </div><h1 id="混合背包">4.混合背包</h1><div class="note note-info">            <p>Q：有些物品只能放一次，有些物品可以放无限次，有些物品可以放 <spanclass="math inline">\(s_i\)</span> 次，求最大价值。</p>          </div><div class="note note-success">            <p>其实就是上面三中背包合在一起。</p><p>把可以放 <span class="math inline">\(s_i\)</span>次的二进制拆分，当作 01 背包，和只能放一次的倒序循环处理。</p><p>然后把可以放无限次的正序循环处理就行了。</p>          </div><h1 id="二维费用背包">5.二维费用背包</h1><div class="note note-info">            <p>Q：在 01 背包基础上，每件物品都有一个重量 <spanclass="math inline">\(m_i\)</span>，要求所选物品还要满足总重量不超过背包核载<span class="math inline">\(M\)</span>，求最大价值。</p>          </div><div class="note note-success">            <p>其实感觉就像两个 01背包，一个限制体积，一个限制重量，事实上也差不多（多定义一维）。<spanclass="math inline">\(f_{i,j}\)</span> 表示背包体积为 <spanclass="math inline">\(i\)</span>，重量为 <spanclass="math inline">\(j\)</span> 时的最大价值。相同地： <spanclass="math display">\[\large{f_{j,k}=max(f_{j,k},f_{j-v_i,k-m_i}+w_i)}\]</span></p><p>所以内层两个循环都是逆序循环。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.NFor j=V..v[i]For k=M..m[i]f[j][k]=<span class="hljs-built_in">max</span>(f[j][k],f[j-v[i]][k-m[i]]+w[i]);result: f[V][M]</code></pre></div>          </div><h1 id="分组背包">6.分组背包</h1><div class="note note-info">            <p>Q：有 <span class="math inline">\(N\)</span> 组物品和容量为 <spanclass="math inline">\(V\)</span>的背包，每一组内最多只能选一个物品，求最大价值。</p>          </div><div class="note note-success">            <p>和多重背包问题很像，多重背包是考虑选多少个物品，分组背包是考虑每一组选哪个物品。</p><p>对每一组的 <span class="math inline">\(n\)</span> 个物品有 <spanclass="math inline">\(n+1\)</span>种方案，即不选，选第一个，选第二个…以此类推。多一重循环枚举即可。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.N&#123;read n;For j=<span class="hljs-number">1.</span>.n read v[j],w[j];For j=V.<span class="hljs-number">.0</span>For k=<span class="hljs-number">0.</span>.n<span class="hljs-keyword">if</span>(j&gt;=v[k]) f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[k]]+w[k]);&#125;result: f[V];</code></pre></div>          </div><h1 id="树形依赖背包">7.树形依赖背包</h1><div class="note note-info">            <p>Q：有 <span class="math inline">\(N\)</span> 件物品和容量为 <spanclass="math inline">\(V\)</span>的背包。物品间形成依赖关系，且依赖关系组成一棵树。如果选择一个物品，则必须选择它的父节点。其中每个物品有体积 <span class="math inline">\(v_i\)</span>，价值 <spanclass="math inline">\(w_i\)</span>，和所依赖的父节点编号 <spanclass="math inline">\(p_i\)</span>，求最大价值。</p>          </div><div class="note note-success">            <p>对于一棵树，如何去表示状态？普通的背包用 <spanclass="math inline">\(f_i\)</span> 表示体积为 <spanclass="math inline">\(i\)</span>时的最大价值，但放到一棵树中，为了定位到我们需要选的一个子树，还需要记录根节点。</p><p>定义 <span class="math inline">\(f_{i,j}\)</span> 表示以 <spanclass="math inline">\(i\)</span> 为根节点并包含 <spanclass="math inline">\(i\)</span> 的一棵子树，当体积为 <spanclass="math inline">\(j\)</span> 时的最大价值。试着写出状态转移： <spanclass="math display">\[\large{f_{x,j}=\max(f_{x,j},f_{x,j-k}+f_{son,k})_{(x为当前节点，son为儿子节点)}}\]</span></p><p>整个过程是递归到叶子节点再自下向上的。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    f[x][<span class="hljs-number">1</span>]=a[x];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=nxt[i])    &#123;        <span class="hljs-type">int</span> y=ver[i];        <span class="hljs-built_in">dfs</span>(y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m<span class="hljs-number">+1</span>;j&gt;=<span class="hljs-number">1</span>;--j)            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;j;++k)                f[x][j]=<span class="hljs-built_in">max</span>(f[x][j],f[x][j-k]+f[y][k]);    &#125;&#125;</code></pre></div><p>看上去很不错，但还可以上下界优化，优化之后被严格证明为 <spanclass="math inline">\(O(NV)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    siz[x]=<span class="hljs-number">1</span>;    f[x][<span class="hljs-number">1</span>]=a[x];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=nxt[i])    &#123;        <span class="hljs-type">int</span> y=ver[i];        <span class="hljs-built_in">dfs</span>(y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-built_in">min</span>(m<span class="hljs-number">+1</span>,siz[x]+siz[y]);j&gt;=<span class="hljs-number">1</span>;--j)            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,j-siz[x]);k&lt;=<span class="hljs-built_in">min</span>(siz[y],j);++k)                f[x][j]=<span class="hljs-built_in">max</span>(f[x][j],f[x][j-k]+f[y][k]);        siz[x]+=siz[y];    &#125;&#125;</code></pre></div><p>相比自下向上的dp，可以转变思路：对于一个节点，分为选和不选。假定选这个节点，往下递归，最后和不选的进行比较。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> fa)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//当前节点编号，背包剩余体积，父节点编号 </span><span class="hljs-keyword">if</span>(m&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=next[i])&#123;<span class="hljs-type">int</span> y=ver[i];<span class="hljs-keyword">if</span>(y==fa)<span class="hljs-keyword">continue</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=m;++k)        f[y][k]=f[x][k]+v[y];<span class="hljs-comment">//选 </span><span class="hljs-built_in">dp</span>(y,m-p[y],x);<span class="hljs-comment">//由上至下 </span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=p[y];k&lt;=m;++k)            f[x][k]=<span class="hljs-built_in">max</span>(f[x][k],f[y][k-p[y]]);<span class="hljs-comment">//和不选的比较，留取最大值 </span>&#125;&#125;</code></pre></div><p>复杂度为 <span class="math inline">\(O(NV)\)</span>。</p>          </div><h1 id="泛化物品背包">8.泛化物品背包</h1><h1 id="背包最优方案总数">9-1.背包最优方案总数</h1><div class="note note-success">            <p>一个可行的方案是：用 <span class="math inline">\(g_i\)</span>表示背包容量为 <span class="math inline">\(i\)</span>时的方案数，然后常规背包得出最优解，遍历 <spanclass="math inline">\(f_i\)</span>，若和最优解相同，答案就加上 <spanclass="math inline">\(g_i\)</span>。</p><p>那么如何预处理出 <spanclass="math inline">\(g_i\)</span>？只要确定状态转移时来自哪一种决策即可。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">g[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">1.</span>.V]=-INF;<span class="hljs-comment">//当背包容量为0时只有“不选”这1种方案</span>For i=<span class="hljs-number">1.</span>.NFor j=V..v[i]&#123;<span class="hljs-type">int</span> tmp_f,tmp_g;tmp_f=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);tmp_f==f[j] ? tmp+=g[j] : tmp+=g[j-v[i]] ;<span class="hljs-comment">//判断来自哪一种决策，注意方案数不需要加w[i];</span>f[j]=tmp_f;g[j]=tmp_g;&#125;<span class="hljs-type">int</span> maxw=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;For i=<span class="hljs-number">0.</span>.V  maxw=<span class="hljs-built_in">max</span>(maxw,f[i]);For i=<span class="hljs-number">0.</span>.V<span class="hljs-keyword">if</span>(maxw==f[i])ans+=g[i];result: ans</code></pre></div>          </div><div class="note note-warning">            <p><strong>为什么 <span class="math inline">\(f_{1..V}\)</span>要预处理成极小值？为什么最优解不是 <spanclass="math inline">\(f[m]\)</span> 了 ？</strong></p><p>因为要统计 <span class="math inline">\(g_i\)</span>，这里的 <spanclass="math inline">\(f_i\)</span> 的意义并不是背包容量为 <spanclass="math inline">\(i\)</span> 时的最大价值，而是背包容量恰好为 <spanclass="math inline">\(i\)</span> 时的最大价值，因此最优解并不是 <spanclass="math inline">\(f[m]\)</span>。</p><p>为了达成恰好为 <span class="math inline">\(i\)</span> 的目的，<spanclass="math inline">\(f_{1..V}\)</span> 应赋值为极小值，原因见下文。</p>          </div><h1 id="背包具体方案">9-2.背包具体方案</h1><div class="note note-success">            <p>和求方案总数一样，需要确定状态转移时来自哪一种决策，在此用 <spanclass="math inline">\(g_{i,j}\)</span> 记录。</p><p>由于 <span class="math inline">\(f_{i,j}=f_{i-1,j}\)</span>表示不选第 <span class="math inline">\(i\)</span> 件物品，令 <spanclass="math inline">\(g_{i,j}=0\)</span>。反之，若 <spanclass="math inline">\(f_{i,j}=f_{i-1,j-v_i}+w_i\)</span>，则令 <spanclass="math inline">\(g_{i,j}=1\)</span>。</p><p>最后从后往前用 <span class="math inline">\(g_{i,j}\)</span>来判断是否选择了该物品即可。</p><p>不过既然需要记录物品和容量，<span class="math inline">\(g\)</span>数组只能是二维，但 <span class="math inline">\(f\)</span>数组仍可保留一维。</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp">For i=<span class="hljs-number">1.</span>.NFor j=V..v[i]&#123;f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<span class="hljs-keyword">if</span>(f[j]==f[j-v[i]]+w[i])g[i][j]=<span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> i=N,lf=V;<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(g[i][lf])<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,i),lf-=v[i];i--;&#125;CPP</code></pre></div><p>注：此时输出的物品选择方案是降序的。</p>          </div><h1 id="背包k优解">9-3.背包k优解</h1><h1 id="背包状态与初始化">10.背包状态与初始化</h1><div class="note note-success">            <p>背包恰好装满：<span class="math inline">\(f[0]=0\)</span>，<spanclass="math inline">\(f[1\sim V]=-inf\)</span>。</p><p>背包不要求恰好装满：<span class="math inline">\(f[0\simV]=0\)</span>。</p>          </div><div class="note note-warning">            <p><strong>为什么 ？</strong></p><p>初始化的 <span class="math inline">\(f\)</span>数组实际就是在没有任何物品可以放入背包时的合法状态，或者说初始化 <spanclass="math inline">\(f[i]=0\)</span> 代表最后还剩 <spanclass="math inline">\(i\)</span> 的体积是合法的。</p>          </div><div class="note note-primary">            <p>参考链接：</p><p>https://www.cnblogs.com/jbelial/articles/2116074.html<code>《dd大牛的背包九讲》</code></p><p>https://www.bilibili.com/video/BV1qt411Z7nE<code>闫学灿'背包九讲专题'</code></p><p>https://www.luogu.com.cn/blog/RPdreamer/bei-bao-wen-ti<code>洛谷日报#61 背包问题</code></p><p>https://oi-wiki.org/dp/knapsack/ <code>OIwiki 背包dp</code></p>          </div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】AtCoder Regular Contest 124 (4 of 6)</title>
      <link href="/posts/79e649ee.html"/>
      <url>/posts/79e649ee.html</url>
      
        <content type="html"><![CDATA[<h2 id="a.-lr-constraints">A. LR Constraints</h2><p><ahref="https://atcoder.jp/contests/arc124/tasks/arc124_a">Problem</a></p><div class="note note-info">            <p>题意：从左到右 <span class="math inline">\(n\)</span>个空卡片，需要在每个卡片上写一个 <spanclass="math inline">\(x\in[1,k]\)</span>，且满足 <spanclass="math inline">\(k\)</span> 个限制条件。第 <spanclass="math inline">\(i\)</span> 个条件限定第 <spanclass="math inline">\(k_i\)</span> 个卡片必须是最左/最右边的写有 <spanclass="math inline">\(i\)</span> 的卡片。问填写方案数。</p><p><span class="math inline">\(1\le n,k \le 1000\)</span>。</p>          </div><div class="note note-success">            <p>直接模拟。开一个桶 <span class="math inline">\(a\)</span>统计每个卡片能填的数字数量，初始化全为 <spanclass="math inline">\(a_i=k\)</span>。</p><p>对于一个限制条件，若限制第 <span class="math inline">\(k_i\)</span>个卡片是最左边的写有 <span class="math inline">\(i\)</span> 的卡片，则<span class="math inline">\(a_{j\in[1,k_i-1]}\leftarrowa_{j\in[1,k_i-1]}-1\)</span>。</p><p>若限制第 <span class="math inline">\(k_i\)</span>个卡片是最右边的写有 <span class="math inline">\(i\)</span> 的卡片，则<span class="math inline">\(a_{j\in[k_i+1,n]}\leftarrowa_{j\in[k_i+1,n]}-1\)</span>。</p><p>最后 <span class="math inline">\(ans = \prod a_i\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=k;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i) &#123;<span class="hljs-type">char</span> opt[<span class="hljs-number">3</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;opt);<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">if</span>(opt[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;L&#x27;</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;x;++j) &#123;<span class="hljs-keyword">if</span>(a[j]!=<span class="hljs-number">1</span>) &#123;a[j]--;&#125;&#125;a[x]=<span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=x<span class="hljs-number">+1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(a[j]!=<span class="hljs-number">1</span>) &#123;a[j]--;&#125;&#125;a[x]=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;ans*=a[i];ans%=modp;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-xor-matching-2">B. XOR Matching 2</h2><p><ahref="https://atcoder.jp/contests/arc124/tasks/arc124_b">Problem</a></p><div class="note note-info">            <p>题意：给定两个长为 <span class="math inline">\(n\)</span> 的序列<span class="math inline">\(a,b\)</span>。找到所有的 <spanclass="math inline">\(x\)</span> 使得能使 <spanclass="math inline">\(b\)</span> 按一定顺序重排后对于所有 <spanclass="math inline">\(1\le i\le n\)</span> 都有 <spanclass="math inline">\(a_i\oplus b_i = x\)</span>。</p><p><span class="math inline">\(1\le n\le 2000\)</span>，<spanclass="math inline">\(0\le a_i,b_i\le 2^{30}\)</span>。</p>          </div><div class="note note-success">            <p>略加思考，如果要对所有 <span class="math inline">\(i\)</span> 都满足<span class="math inline">\(a_i \oplus b_i=x\)</span>，那么 <spanclass="math inline">\(x\)</span> 的可能值最多就 <spanclass="math inline">\(n\)</span> 个，且一定是 <spanclass="math inline">\(a_1\oplus b_1,a_1\oplus b_2,\dots ,a_1\oplusb_n\)</span> 中的若干。逐个去试即可。</p><p>最方便的方法是对 <span class="math inline">\(b\)</span> 排序，用<span class="math inline">\(a\)</span> 的每一项去异或可能的 <spanclass="math inline">\(x\)</span> 得到 <spanclass="math inline">\(c\)</span>，再将 <spanclass="math inline">\(c\)</span> 排序后和 <spanclass="math inline">\(b\)</span> 比较。</p><p>一个坑点是答案需要去重。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">c</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>,b.<span class="hljs-built_in">end</span>());vector&lt;<span class="hljs-type">int</span>&gt; ans;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-type">int</span> x=a[<span class="hljs-number">1</span>]^b[i];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;c[j]=a[j]^x;&#125;<span class="hljs-built_in">sort</span>(c.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>,c.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span>(c==b) &#123;ans.<span class="hljs-built_in">push_back</span>(x);&#125;&#125;ans.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>()),ans.<span class="hljs-built_in">end</span>());<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans.<span class="hljs-built_in">size</span>());<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,i);&#125;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><div class="note note-warning">            <p><code>std::vector</code> 去重方法：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());res.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>()),res.<span class="hljs-built_in">end</span>());</code></pre></div>          </div><h2 id="c.-lcm-of-gcds">C. LCM of GCDs</h2><p><ahref="https://atcoder.jp/contests/arc124/tasks/arc124_c">Problem</a></p><div class="note note-info">            <p>题意：给定 <span class="math inline">\(n\le 50\)</span>对数。对于每一对数，选一个放入集合 <spanclass="math inline">\(A\)</span>，另一个则放入集合 <spanclass="math inline">\(B\)</span>，最后对两个集合里所有数求 <spanclass="math inline">\(\gcd\)</span> 得到 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>，求最大的 <spanclass="math inline">\(\text{lcm}(a,b)\)</span>。</p>          </div><div class="note note-success">            <p>经典 trick。</p><p>如果直接暴力搜索，复杂度将会是 <spanclass="math inline">\(O(2^n)\)</span>。</p><p>但这里最后是拿两个集合的 <span class="math inline">\(\gcd\)</span> 做<span class="math inline">\(\text{lcm}\)</span>，而实际上这 <spanclass="math inline">\(50\)</span> 对数的 <spanclass="math inline">\(\gcd\)</span> 个数并没有那么多。</p><p>所以还是暴搜，用一个 <code>std::set</code>记录选到当前位置的集合里是否有与当前相同的 <spanclass="math inline">\(\gcd\)</span>，有就跳过，否则把当前两个集合里的<span class="math inline">\(\gcd\)</span> 用一个 <code>std::pair</code>记录到 <code>std::set</code> 里。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q[<span class="hljs-number">55</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;a[i]=<span class="hljs-built_in">read</span>();b[i]=<span class="hljs-built_in">read</span>();&#125;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> self,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) &#123;<span class="hljs-keyword">if</span>(p==n<span class="hljs-number">+1</span>) &#123;res=<span class="hljs-built_in">max</span>(res,x/__gcd(x,y)*y);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">if</span>(q[p].<span class="hljs-built_in">count</span>(&#123;x,y&#125;)) &#123;<span class="hljs-keyword">return</span> ;&#125;q[p].<span class="hljs-built_in">insert</span>(&#123;x,y&#125;);<span class="hljs-built_in">self</span>(self,p<span class="hljs-number">+1</span>,__gcd(x,a[p]),__gcd(y,b[p]));<span class="hljs-built_in">self</span>(self,p<span class="hljs-number">+1</span>,__gcd(x,b[p]),__gcd(y,a[p]));&#125;;<span class="hljs-built_in">dfs</span>(dfs,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,res);&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-yet-another-sorting-problem">D. Yet Another SortingProblem</h2><p><ahref="https://atcoder.jp/contests/arc124/tasks/arc124_d">Problem</a></p><div class="note note-info">            <p>题意：给定一个长 <span class="math inline">\(n+m\)</span>的排列，每次可以从前边 <span class="math inline">\(n\)</span> 个数和后边<span class="math inline">\(m\)</span>个数里挑一个出来交换，问至少交换多少次能使整个序列呈升序。</p><p><span class="math inline">\(1\le n,m\le 10^5\)</span>。</p>          </div><div class="note note-success">            <p>挺新颖的思路。先考虑如果没有左边 <spanclass="math inline">\(n\)</span> 个和右边 <spanclass="math inline">\(m\)</span>个的限制，从整个序列里挑两个数交换的最少方案数。</p><p>我们将每个数和它对应的下标连边，那么最终升序的状态是每个点和自己连边，即一共<span class="math inline">\(n+m\)</span>个连通块。我们再考虑交换两个数会发生什么。</p><ol type="1"><li><p>如果 <span class="math inline">\(i,a_i\)</span> 和 <spanclass="math inline">\(j,a_j\)</span>位于两个连通块，那么交换会让它们合并成一个连通块。</p></li><li><p>如果 <span class="math inline">\(i,a_i\)</span> 和 <spanclass="math inline">\(j,a_j\)</span>位于同一连通块，交换之后仍为一个连通块。</p></li><li><p>如果 <span class="math inline">\(i,j,a_i,a_j\)</span>中有两个数相等，那这四个数一定位于一个连通块，交换之后会把相等的那个数移出该连通块，连通块数<span class="math inline">\(+1\)</span>。比如 <spanclass="math inline">\(i=a_j\)</span>，则连边情况为 <spanclass="math inline">\(a_i -a_j/i-j\)</span>，交换后 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(i\)</span> 连边，<spanclass="math inline">\(a_j\)</span> 和 <spanclass="math inline">\(j\)</span> 连边，变成两个连通块。</p></li><li><p>如果 <spanclass="math inline">\(i=a_j,j=a_i\)</span>，交换后分离，变成两个连通块，连通块数目<span class="math inline">\(+1\)</span>。</p></li></ol><p>因为最终目标是 <span class="math inline">\(n+m\)</span>个连通块，所以只需要用后两个操作不断增加连通块即可。</p><p>再考虑有限制怎么做 ：因为我们只能对前 <spanclass="math inline">\(n\)</span> 个数和后 <spanclass="math inline">\(m\)</span> 个数成对操作，所以将前 <spanclass="math inline">\(n\)</span> 个点染成红色，后 <spanclass="math inline">\(m\)</span>个点染成蓝色，每次只能对红色点和蓝色点执行交换操作。</p><p>那么对于只有红色或蓝色的纯色且大小大于 <spanclass="math inline">\(1\)</span> 的连通块，只能执行操作 <spanclass="math inline">\(1\)</span>合并在一起变成杂色连通块，再用后两个操作分开。</p><p>假设大小 <span class="math inline">\(&gt;1\)</span> 的纯红色连通块有<span class="math inline">\(a\)</span> 个，纯蓝色连通块有 <spanclass="math inline">\(b\)</span> 个，总连通块个数为 <spanclass="math inline">\(cnt\)</span>，那么 ： <spanclass="math display">\[\text{ans}=n+m-cnt+2\times \max(a,b)\]</span></p><p>假设 <spanclass="math inline">\(a&lt;b\)</span>，因为把红色连通块与蓝色连通块合并的需要<span class="math inline">\(a\)</span>步，把剩下的蓝色连通块合并到杂色连通块要 <spanclass="math inline">\(b-a\)</span> 步，一共少了 <spanclass="math inline">\(a+(b-a)=b\)</span> 个连通块，所以还需要 <spanclass="math inline">\(b\)</span> 次分离操作，那么现在一共 <spanclass="math inline">\(2\times b\)</span> 次操作。<spanclass="math inline">\(a&gt;b\)</span> 同理。</p><p>前面的 <span class="math inline">\(n+m-cnt\)</span>即本来需要分离的连通块数量。</p><p>整个过程都可以用并查集维护。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);freopen(#x<span class="hljs-string">&quot;.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;vector&lt;<span class="hljs-type">int</span>&gt; f,siza,sizb;<span class="hljs-built_in">DSU</span>() &#123;&#125;<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-built_in">init</span>(n);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;f.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+2</span>);siza.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+2</span>);sizb.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+2</span>);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n<span class="hljs-number">+1</span>;++i)f[i]=i,siza[i]=sizb[i]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">if</span>(x==f[x]) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;x=<span class="hljs-built_in">find</span>(x);y=<span class="hljs-built_in">find</span>(y);<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;siza[x]+=siza[y];sizb[x]+=sizb[y];f[y]=x;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sizea</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> siza[<span class="hljs-built_in">find</span>(x)];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sizeb</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> sizb[<span class="hljs-built_in">find</span>(x)];&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n+m)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) &#123;i&lt;=n ? dsu.siza[i]++ : dsu.sizb[i]++;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();dsu.<span class="hljs-built_in">merge</span>(x,i);&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+m<span class="hljs-number">+1</span>)</span></span>;<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,cnta=<span class="hljs-number">0</span>,cntb=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+m;++i) &#123;<span class="hljs-type">int</span> x = dsu.<span class="hljs-built_in">find</span>(i);<span class="hljs-keyword">if</span>(!vis[x]) &#123;vis[x]=<span class="hljs-literal">true</span>;cnt++;cnta+=(dsu.<span class="hljs-built_in">sizea</span>(x)&gt;=<span class="hljs-number">2</span> &amp;&amp; !dsu.<span class="hljs-built_in">sizeb</span>(x));cntb+=(dsu.<span class="hljs-built_in">sizeb</span>(x)&gt;=<span class="hljs-number">2</span> &amp;&amp; !dsu.<span class="hljs-built_in">sizea</span>(x));&#125;&#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,n+m-cnt<span class="hljs-number">+2</span>*<span class="hljs-built_in">max</span>(cnta,cntb));&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">fre</span>(test);<span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(T--) &#123;<span class="hljs-built_in">solve</span>();<span class="hljs-comment">//fflush(stdout);</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Atcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】Codeforces Round 729 (Div.2) 4 of 6</title>
      <link href="/posts/49b078d6.html"/>
      <url>/posts/49b078d6.html</url>
      
        <content type="html"><![CDATA[<h2 id="a.-odd-set">A. Odd Set</h2><p><ahref="https://codeforces.com/contest/1542/problem/A">Problem</a></p><div class="note note-info">            <p>题意：给出长为 <span class="math inline">\(2n\)</span>的数组，问是否能分成 <span class="math inline">\(n\)</span> 个长度为<span class="math inline">\(2\)</span>的组使每组内两数之和均为奇数。</p>          </div><div class="note note-success">            <p>若和为奇数，则两数一奇一偶，即判断原数列中奇数个数是否等于偶数个数。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> re register int</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)     &#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(re i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;++i) &#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();cnt+=(x%<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">if</span>(cnt==n) &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-plus-and-multiply">B. Plus and Multiply</h2><p><ahref="https://codeforces.com/contest/1542/problem/B">Problem</a></p><div class="note note-info">            <p>题意：<span class="math inline">\(T\le 10^5\)</span>组数据，给定正整数 <spanclass="math inline">\(n,a,b\)</span>，每次能将一个数 <spanclass="math inline">\(\times a\)</span> 或 <spanclass="math inline">\(+b\)</span>，问是否能将 <spanclass="math inline">\(1\)</span> 经过若干次操作得到 <spanclass="math inline">\(n\)</span>。</p><p><span class="math inline">\(1\le n,a,b\le 10^9\)</span>。</p>          </div><div class="note note-success">            <p>若得到了某个数 <span class="math inline">\(x\)</span> 满足 <spanclass="math inline">\((n-x)\% b=0\)</span> 那么显然符合要求。</p><p>对于 <span class="math inline">\(+b\)</span> 操作，<spanclass="math inline">\(\%b\)</span> 后余数不变。</p><p>意味着只有 <span class="math inline">\(\times a\)</span> 操作会使<span class="math inline">\(\%b\)</span> 的余数改变。</p><p>枚举不超过 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(a\)</span> 的次方数 <spanclass="math inline">\(x\)</span> 判断是否满足 <spanclass="math inline">\((n-x)\%b=0\)</span> 即可。</p><p>特判 <span class="math inline">\(a=1\)</span> 的情况。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> re register int</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();<span class="hljs-type">int</span> tmp=a,flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>((x<span class="hljs-number">-1</span>)%b==<span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);            &#125;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span>(tmp&gt;x) &#123;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">if</span>((x-tmp)%b==<span class="hljs-number">0</span>) &#123;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;tmp*=a;&#125;<span class="hljs-keyword">if</span>(flag || (x<span class="hljs-number">-1</span>)%b==<span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);        &#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-strange-function">C. Strange Function</h2><p><ahref="https://codeforces.com/contest/1542/problem/C">Problem</a></p><div class="note note-info">            <p>题意：求 <span class="math inline">\(\sum\limits_{i=1}^nf_i\)</span>，<span class="math inline">\(f_i\)</span> 为满足 <spanclass="math inline">\(x\nmid i\)</span> 的最小正整数 <spanclass="math inline">\(x\)</span>。</p><p><span class="math inline">\(1\le T\le 10^4\)</span>，<spanclass="math inline">\(1\le n\le 10^{16}\)</span>。</p>          </div><div class="note note-success">            <p>没什么思路，打表得到 <spanclass="math inline">\(2,3,2,3,2,4,2,3,2,3,2,5,2,\dots\)</span>。</p><p>令 <span class="math inline">\(p_i\)</span> 为第一次出现 <spanclass="math inline">\(i\)</span> 的位置，观察有 <spanclass="math inline">\(p_3=2,p_4=6,p_5=12\)</span>，类比得 <spanclass="math inline">\(p_i=\text{lcm} (1\sim i-1)\)</span>。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Why?    </div>    <div class='spoiler-content'>        <p>因为对于 <span class="math inline">\(f_x\)</span>，<spanclass="math inline">\(1\sim (f_x-1)\)</span> 必然是 <spanclass="math inline">\(p_{f_x}\)</span>的因子，故最优选择就是它们的最小公倍数。</p>    </div></div><div class="note note-success">            <p>其中每个位置贡献至少为 <spanclass="math inline">\(2\)</span>，故初始化 <spanclass="math inline">\(\text{ans}=2n\)</span>。</p><p>又若 <span class="math inline">\(i\)</span> 在位置 <spanclass="math inline">\(pos\)</span> 有贡献，则在 <spanclass="math inline">\(pos\)</span> 的倍数处也必有贡献，且每次贡献为<span class="math inline">\(1\)</span>。</p><p>而每个 <span class="math inline">\(i\)</span> 在 <spanclass="math inline">\(1\sim n\)</span> 中出现 <spanclass="math inline">\(\left\lfloor\dfrac{n}{p_i}\right\rfloor\)</span>次，故 <spanclass="math inline">\(\text{ans}=2n+\sum\limits_{i=3}^{p_i\len}\left\lfloor\dfrac{n}{p_i}\right\rfloor\)</span> .</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> re register int</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e16</span><span class="hljs-number">+10</span>,modp=<span class="hljs-number">1e9</span><span class="hljs-number">+7</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> !y?x:<span class="hljs-built_in">gcd</span>(y,x%y);&#125;<span class="hljs-type">int</span> Lcm[<span class="hljs-number">50</span>];<span class="hljs-comment">//lcm[i]表示1~i-1的最小公倍数 </span><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> tmp=<span class="hljs-number">1</span>,x=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;Lcm[tmp]=x;x=x*tmp/<span class="hljs-built_in">gcd</span>(x,tmp);<span class="hljs-keyword">if</span>(x&gt;maxn)<span class="hljs-keyword">break</span>;tmp++;    &#125;<span class="hljs-type">int</span> T=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(T--)&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>(),ans=<span class="hljs-number">2</span>*n%modp;<span class="hljs-keyword">for</span>(re i=<span class="hljs-number">3</span>;i&lt;=tmp;++i)ans=(ans+n/Lcm[i])%modp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-priority-queue">D. Priority Queue</h2><p><ahref="https://codeforces.com/contest/1542/problem/D">Problem</a></p><div class="note note-info">            <p>题意：给定长为 <span class="math inline">\(n\)</span> 的操作序列<span class="math inline">\(A\)</span>，定义操作序列 <spanclass="math inline">\(B\)</span> 是 <spanclass="math inline">\(A\)</span> 的一个子序列，并维护一个可重集 <spanclass="math inline">\(T\)</span>。若操作形如 <code>+ x</code> 则将 <spanclass="math inline">\(x\)</span> 插入 <spanclass="math inline">\(T\)</span>，若操作形如 <code>-</code> 则将 <spanclass="math inline">\(T\)</span> 中最小元素删去(若为空则忽略)。令 <spanclass="math inline">\(f(B)\)</span> 为经过 <spanclass="math inline">\(B\)</span> 的操作后 <spanclass="math inline">\(T\)</span> 中剩余元素的和，求 <spanclass="math inline">\(\sum f(B)\)</span>。</p><p><span class="math inline">\(1\le n \le 500\)</span>。</p>          </div><div class="note note-success">            <p>类计数 dp，因为我们对于每一个<code>+ x</code> 操作只关心数 <spanclass="math inline">\(x\)</span> 最终出现在多少个 <spanclass="math inline">\(B\)</span> 中。因为最多有 <spanclass="math inline">\(n\)</span> 个 <code>+ x</code>，所以可以最多进行<span class="math inline">\(n\)</span> 次 dp 得到结果，每次 <spanclass="math inline">\(O(n^2)\)</span>，一共 <spanclass="math inline">\(O(n^3)\)</span>。</p><p>令 <span class="math inline">\(f_{i,j}\)</span> 为前 <spanclass="math inline">\(i\)</span> 个数中有 <spanclass="math inline">\(j\)</span> 个数比 <spanclass="math inline">\(x\)</span> 小的方案数，设当前第 <spanclass="math inline">\(i\)</span> 位读到 <code>-</code>，比 <spanclass="math inline">\(x\)</span> 大的数和比 <spanclass="math inline">\(x\)</span>小的数，由该位选或不选分类讨论写出转移方程。若 <spanclass="math inline">\(A[k]=x\)</span> :</p><p><span class="math display">\[f_{i,j}=\begin{cases}f_{i-1,j}+f_{i-1,j+1}&amp;,A[i]=\text{&#39;-&#39;}\\f_{i-1,j}+f_{i-1,j}&amp;,A[i]&gt;x \text{ or}A[i]=x,i&gt;k \\f_{i-1,j}+f_{i-1,j-1}&amp;,A[i]&lt;x,j\neq0 \text{ or}A[i]=x,i&lt;k\\f_{i-1,j}&amp;,A[i]&lt;x,j=0 \text{ or}A[i]=x,i&lt;k\end{cases}\]</span></p><p>特别注意第一种情况当 <span class="math inline">\(i&lt;k\)</span> 且<span class="math inline">\(j=0\)</span> 时需要加上 <spanclass="math inline">\(f_{i-1,0}\)</span>，因为此时选上 <code>-</code>不会使 <span class="math inline">\(j\)</span> 变小。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> re register int</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> modp=<span class="hljs-number">998244353</span>; <span class="hljs-type">int</span> A[<span class="hljs-number">500</span><span class="hljs-number">+10</span>],f[<span class="hljs-number">500</span><span class="hljs-number">+10</span>][<span class="hljs-number">500</span><span class="hljs-number">+10</span>];<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(re i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<span class="hljs-type">char</span> x[<span class="hljs-number">3</span>];<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;x);<span class="hljs-keyword">if</span>(x[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;+&#x27;</span>) A[i]=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">else</span> A[i]=<span class="hljs-number">-1</span>;&#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(re k=<span class="hljs-number">1</span>;k&lt;=n;++k)&#123;<span class="hljs-keyword">if</span>(A[k]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> f);f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(re i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<span class="hljs-keyword">if</span>(i==k)&#123;<span class="hljs-built_in">memcpy</span>(f[i],f[i<span class="hljs-number">-1</span>],<span class="hljs-keyword">sizeof</span> f[i]);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">for</span>(re j=<span class="hljs-number">0</span>;j&lt;=n;++j)&#123;<span class="hljs-keyword">if</span>(A[i]==<span class="hljs-number">-1</span>)&#123;f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">+1</span>])%modp;<span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> &amp;&amp; i&lt;k) f[i][j]=(f[i][j]+f[i<span class="hljs-number">-1</span>][j])%modp;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A[i]&lt;A[k] || (A[i]==A[k] &amp;&amp; i&lt;k))&#123;<span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)f[i][j]=f[i<span class="hljs-number">-1</span>][j];<span class="hljs-keyword">else</span> f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%modp;&#125;<span class="hljs-keyword">else</span> f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j])%modp;&#125;&#125;<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(re j=<span class="hljs-number">0</span>;j&lt;=n;++j)sum=(sum+f[n][j])%modp;ans=(ans+sum*A[k]%modp)%modp;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】摩尔投票法及其扩展</title>
      <link href="/posts/be35d7b0.html"/>
      <url>/posts/be35d7b0.html</url>
      
        <content type="html"><![CDATA[<p>摩尔投票法是用来解决以下问题的一类方法。</p><h3 id="q-在一个长度为-n-的数组中找出出现次数大于一半的元素">Q :在一个长度为 <span class="math inline">\(n\)</span>的数组中找出出现次数大于一半的元素。</h3><p>很明显，利用<strong>开桶</strong>，<strong>排序找中位数</strong>等多种多样的方法都可以轻松解决，但摩尔投票法厉害之处在于它的<strong>空间复杂度</strong>仅为 <span class="math inline">\(O(1)\)</span>，意味着数组都不用开。</p><p>摩尔投票法的核心如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (!cnt) ans = <span class="hljs-built_in">read</span>(), cnt = <span class="hljs-number">1</span>;   <span class="hljs-keyword">else</span> cnt += <span class="hljs-built_in">read</span>() == ans ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;&#125;</code></pre></div><p>我们可以借助文字来帮助理解上面这段话：</p><p>摩尔投票法本质上是<strong>每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。</strong></p><p>所以，<span class="math inline">\(cnt\)</span>存储的是<strong>当前暂时无法删除的数字的个数</strong>，表现为和上一个记录的数字相等，所以当<span class="math inline">\(ans=read()\)</span> 时 <spanclass="math inline">\(cnt\)</span> 自增，反之自减，而 <spanclass="math inline">\(cnt=0\)</span> 的意思就是“没有数字无法删除了”，即能删的都删完了，或者说没有数可以用来抵消了，只能拿当前的数放到<span class="math inline">\(ans\)</span> 中和后面的数抵消了。</p><p>所以我们要做的仅仅就是每次拿读入的数字和 <spanclass="math inline">\(ans\)</span> 去抵消而已。</p><hr /><h3 id="扩展相关">扩展相关</h3><h3id="q-在一个长度为n的数组中找出出现次数大于-left-lfloordfrac-nk-right-rfloor-的元素">Q: 在一个长度为n的数组中找出出现次数大于 <spanclass="math inline">\(\left \lfloor\dfrac nk \right \rfloor\)</span>的元素。</h3><p>为方便理解，先讨论 <span class="math inline">\(k=3\)</span>时的情况：</p><p>如果理解了上面 <span class="math inline">\(k=2\)</span>的那一段话，那么我们发现摩尔投票法是基于这样一个原理：如果一个数组里有一元素超过<span class="math inline">\(\frac {\ 1\ }{2}\)</span>，那么同时删除<span class="math inline">\(2\)</span> 个不同的数，数量超过 <spanclass="math inline">\(\frac {\ 1\ }{2}\)</span> 的数仍然超过 <spanclass="math inline">\(\frac {\ 1\ }{2}\)</span>。</p><p>稍加修改我们可以猜想：如果一个数组里有一元素超过 <spanclass="math inline">\(\frac {\ 1\ }{3}\)</span>，那么同时删除 <spanclass="math inline">\(3\)</span> 个不同的数，数量超过 <spanclass="math inline">\(\frac {\ 1\ }{3}\)</span> 的数仍然超过 <spanclass="math inline">\(\frac {\ 1\ }{3}\)</span>。</p><p>我们可以尝试证明它的正确性： * 如果删除的 <spanclass="math inline">\(3\)</span> 个不同的数都不是超过 <spanclass="math inline">\(\frac {\ 1\ }{3}\)</span> 的元素，显然成立。</p><ul><li>如果删除的 <span class="math inline">\(3\)</span>个不同的数有一个是超过 <span class="math inline">\(\frac {\ 1\}{3}\)</span> 的元素，设该元素有 <span class="math inline">\(m&gt; \frac{\ 1\ }{3}\)</span> 个，即需要证： <span class="math display">\[\dfrac {m-1}{n-3}&gt; \dfrac {n}{3}\Longrightarrow m&gt; \dfrac{n(n-3)}{3}+1\]</span></li></ul><p>而： <span class="math display">\[\dfrac {n(n-3)}{3}+1 \ge \dfrac {n}{3} \Longrightarrow (n-2)^2-1\ge0\quad\{n\ge 3\}\]</span></p><p>故命题成立。</p><p>同样的证明方法可以推广到 <spanclass="math inline">\(k\)</span>，得出：若一个数组里有一元素超过 <spanclass="math inline">\(\frac {\ 1\ }{k}\)</span>，那么同时删除 <spanclass="math inline">\(k\)</span> 个不同的数，数量超过 <spanclass="math inline">\(\frac {\ 1\ }{k}\)</span> 的数仍然超过 <spanclass="math inline">\(\frac {\ 1\ }{k}\)</span>。</p><p>不过很遗憾，如果 <span class="math inline">\(k\)</span>很大，只能用数组去存 <spanclass="math inline">\(cnt_i\)</span>，但其内核仍然值得我们思考。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】等差数列与二阶前缀和</title>
      <link href="/posts/854283fe.html"/>
      <url>/posts/854283fe.html</url>
      
        <content type="html"><![CDATA[<p>设 <span class="math inline">\(a\)</span> 是原数组，<spanclass="math inline">\(b\)</span> 是一阶差分数组，<spanclass="math inline">\(c\)</span> 是二阶差分数组。</p><p>首先，公差 <span class="math inline">\(d=(t-s)/(R-L)\)</span>。</p><p>考虑给一个区间 <span class="math inline">\([L,R]\)</span> 加上首项为<span class="math inline">\(s\)</span>，末项为 <spanclass="math inline">\(t=s+(R-L)\times d\)</span> 的等差数列对 <spanclass="math inline">\(a\)</span> 的影响。 <span class="math display">\[a_x=a_x+s+(x-L)\times d\]</span></p><p>由于 <span class="math inline">\(b_i=a_i-a_{i-1}\)</span>，那么：<span class="math display">\[\begin{align}&amp;\text{} \\b_L&amp;=(a_L+s)-a_{L-1}\\&amp;=b_L+s \\&amp;\text{}\\b_x&amp;=[a_x+(x-L)\times d]-[a_{x-1}+(x-1-L)\timesd]\\&amp;=b_x+d\quad(x\in[L+1,R]) \\&amp;\text{}\\b_{R+1}&amp;=a_{R+1}-(a_R+t)\\&amp;=b_{R+1}-t\end{align}\]</span></p><p>又 <span class="math inline">\(c_i=b_i-b_{i-1}\)</span>： <spanclass="math display">\[\begin{align}&amp;\text{} \\c_L&amp;=(b_L+s)-b_{L-1}\\&amp;=c_L+s \\&amp;\text{}\\c_{L+1}&amp;=(b_{L+1}+d)-(b_L+s)\\&amp;=c_{L+1}+d-s \\&amp;\text{}\\c_x&amp;=(b_x+d)-(b_{x-1}+d)\\&amp;=c_x\quad(x\in [L+2,R]) \\&amp;\text{}\\c_{R+1}&amp;=(b_{R+1}-t)-(b_R+d)\\&amp;=c_{R+1}-d-t \\&amp;\text{}\\c_{R+2}&amp;=b_{R+2}-(b_{R+1}-t)\\&amp;=c_{R+2}+t \\\end{align}\]</span></p><p>所以，相当于改变 <span class="math inline">\(L,L+1,R+1,R+2\)</span>四个位置的数值再求两遍前缀和。</p><p>注意：差分数组需要开大。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】NOIP 2007 提高组</title>
      <link href="/posts/7f934b5.html"/>
      <url>/posts/7f934b5.html</url>
      
        <content type="html"><![CDATA[<h2 id="a.-统计数字">A. 统计数字</h2><p><a href="https://www.luogu.com.cn/problem/P1097">Problem</a></p><div class="note note-success">            <p>按照题意模拟即可。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125; <span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<span class="hljs-type">int</span> a[N],n;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;n=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        a[i]=<span class="hljs-built_in">read</span>();    &#125;<span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a+n<span class="hljs-number">+1</span>);<span class="hljs-type">int</span> tot=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">+1</span>;++i) &#123;<span class="hljs-keyword">if</span>(a[i]==a[i<span class="hljs-number">-1</span>]) &#123;            tot++;        &#125;<span class="hljs-keyword">if</span>(a[i]!=a[i<span class="hljs-number">-1</span>] &amp;&amp; i!=<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,a[i<span class="hljs-number">-1</span>],tot);tot=<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="b.-字符串的展开">B. 字符串的展开</h2><p><a href="https://www.luogu.com.cn/problem/P1098">Problem</a></p><div class="note note-success">            <p>按照题意模拟即可。</p><p>注意一些特判： * 开头字符也可能为 ’ <spanclass="math inline">\(-\)</span> ’。</p><ul><li>可能有连续的 ‘ <span class="math inline">\(-\)</span> ’。</li></ul>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125;<span class="hljs-type">int</span> p1,p2,p3;string s;stack&lt;<span class="hljs-type">char</span>&gt; q;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;-&#x27;</span> || s[i]!=<span class="hljs-string">&#x27;-&#x27;</span> || (s[i]==<span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; i==<span class="hljs-number">0</span>) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((s[i]==<span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; ((<span class="hljs-type">int</span>)s[i<span class="hljs-number">-1</span>]&gt;=(<span class="hljs-type">int</span>)s[i<span class="hljs-number">+1</span>])) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//&#x27;-&#x27;之后的字符ascll比前面大 </span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-string">&#x27;z&#x27;</span> &amp;&amp; s[i<span class="hljs-number">+1</span>]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i<span class="hljs-number">+1</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//&#x27;-&#x27;前后同为数字或字母 </span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; s[i<span class="hljs-number">+1</span>]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i<span class="hljs-number">+1</span>]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;p1=<span class="hljs-built_in">read</span>(),p2=<span class="hljs-built_in">read</span>(),p3=<span class="hljs-built_in">read</span>();cin&gt;&gt;s;<span class="hljs-type">int</span> lst;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i) &#123;<span class="hljs-type">char</span> x=s[i];<span class="hljs-keyword">if</span>(x!=<span class="hljs-string">&#x27;-&#x27;</span> ||(x==<span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; i==<span class="hljs-number">0</span>)|| <span class="hljs-built_in">check</span>(i)) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,x),lst=x;        &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;lst++;x=s[++i];<span class="hljs-keyword">while</span>(lst&lt;(<span class="hljs-type">int</span>)x) &#123;<span class="hljs-keyword">if</span>(p1==<span class="hljs-number">1</span> || (p1==<span class="hljs-number">2</span>&amp;&amp;(<span class="hljs-type">char</span>)lst&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;(<span class="hljs-type">char</span>)lst&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p2;++i) &#123;    <span class="hljs-keyword">if</span>(p3==<span class="hljs-number">1</span>) &#123;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,(<span class="hljs-type">char</span>)lst);                        &#125; <span class="hljs-keyword">else</span> &#123;                            q.<span class="hljs-built_in">push</span>(lst);                        &#125;                    &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p1==<span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p2;++i) &#123;    <span class="hljs-keyword">if</span>(p3==<span class="hljs-number">1</span>) &#123;                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,(<span class="hljs-type">char</span>)(lst<span class="hljs-number">-32</span>));                        &#125; <span class="hljs-keyword">else</span> &#123;                            q.<span class="hljs-built_in">push</span>(lst<span class="hljs-number">-32</span>);                        &#125;                    &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p1==<span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p2;++i) &#123;                       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*&quot;</span>);                   &#125;lst++;                &#125;&#125;<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,(<span class="hljs-type">char</span>)q.<span class="hljs-built_in">top</span>());                q.<span class="hljs-built_in">pop</span>();            &#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,x);&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="c.-矩阵取数游戏">C. 矩阵取数游戏</h2><p><a href="https://www.luogu.com.cn/problem/P1005">Problem</a></p><div class="note note-info">            <p>题意：在 <span class="math inline">\(n\times m\)</span>的非负矩阵中取数，需要满足以下条件： * 每次从每一行取走一个元素，共<span class="math inline">\(n\)</span> 个。经过 <spanclass="math inline">\(m\)</span> 次后取完矩阵内所有元素。</p><ul><li><p>每次只能在一行的行首或行尾取数。</p></li><li><p>每行取数的得分 = 被取走的元素 <span class="math inline">\(\times2^i\)</span>，其中 <span class="math inline">\(i\)</span> 表示第 <spanclass="math inline">\(i\)</span>次取数。最后的总得分为各行得分之和。</p></li></ul><p>求最大总得分。</p><p><span class="math inline">\(1\le n,m\le 80\)</span>，<spanclass="math inline">\(0\le a_{ij}\le1000\)</span>。</p>          </div><div class="note note-success">            <p>不妨先观察样例：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">82</span></code></pre></div><p>其中 <spanclass="math inline">\(82=2^1\times(1+2)+2^2\times(2+3)+2^3\times(3+4)\)</span></p><p>即 <spanclass="math inline">\(82=(2^1\times1+2^2\times2+2^3\times3)+(2^1\times2+2^2\times3+2^3\times4)\)</span></p><p>发现每行之间取数都互不干扰，即可以一行一行dp，最后对每行答案求和。</p><p>容易想到令 <span class="math inline">\(f[i][j]\)</span> 为左边取<span class="math inline">\(i\)</span> 个数，右边取 <spanclass="math inline">\(j\)</span> 个数的最大得分。</p><p>故 <span class="math inline">\(f[i][j]=\max(f[i-1][j]+2^{i+j}\timesa[i],f[i][j-1]+2^{i+j}\times a[m-j+1])\)</span>。</p><p>答案为 <spanclass="math inline">\(\max(f[i][m-i]),i\in[1,m]\)</span>。</p>          </div><div class="note note-warning">            <p>爆 <code>long long</code> ，记得用 <code>__int128</code> 。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int __int128</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125; <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>),x=-x;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x/<span class="hljs-number">10</span>);<span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(;n;n&gt;&gt;=<span class="hljs-number">1</span>,k=k*k)<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)s*=k;<span class="hljs-keyword">return</span> s;&#125;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<span class="hljs-type">int</span> n,m,a[N][N],f[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> q[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>*q[<span class="hljs-number">1</span>],f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>*q[m];<span class="hljs-comment">//第一次取数 </span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;i+j&lt;=m;++j) &#123;        f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j]+<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,i+j)*q[i],f[i][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,i+j)*q[m-j<span class="hljs-number">+1</span>]);        &#125;    &#125;<span class="hljs-type">int</span> maxf=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i) &#123;    maxf=<span class="hljs-built_in">max</span>(maxf,f[i][m-i]);    &#125;<span class="hljs-keyword">return</span> maxf;&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) &#123;    a[i][j]=<span class="hljs-built_in">read</span>();        &#125;    &#125;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;        ans+=<span class="hljs-built_in">dp</span>(a[i]);    &#125;<span class="hljs-built_in">write</span>(ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><h2 id="d.-树网的核">D. 树网的核</h2><p><a href="https://www.luogu.com.cn/problem/P1099">Problem</a></p><div class="note note-info">            <p>题意：给出一颗 <span class="math inline">\(n\)</span>个节点的无根树，有如下定义。</p><p><strong>偏心距(ECC)</strong> ：路径 <spanclass="math inline">\(F\)</span> 的 ECC 指树网中距路径 <spanclass="math inline">\(F\)</span> 最远的点到路径 <spanclass="math inline">\(F\)</span> 的距离。</p><p><strong>树网的核</strong> ：在直径上找一段路径 <spanclass="math inline">\(F\)</span> 使长度不超过 <spanclass="math inline">\(s\)</span> 且 ECC 最小，必要时可以为一个节点。</p><p>求满足上述条件的最小 ECC 。</p><p><span class="math inline">\(2\le n \le 300\)</span>，<spanclass="math inline">\(0\le s \le 10^3\)</span>，<spanclass="math inline">\(1\le u,v\le n\)</span>，<spanclass="math inline">\(0\le w \le 10^3\)</span>。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/7luiueve.png" /></p><p>图中直径为：<span class="math inline">\(A\sim B,A\simC\)</span>。</p><p>若 <span class="math inline">\(s=11\)</span>，树网的核为 <spanclass="math inline">\(DEFG\)</span>，偏心距为 <spanclass="math inline">\(8\)</span>。</p><p>若 <span class="math inline">\(s=0\sim2\)</span>，树网的核为 <spanclass="math inline">\(F\)</span>，偏心距为 <spanclass="math inline">\(12\)</span>。</p>          </div><div class="note note-success">            <p>首先，可以看到 <span class="math inline">\(n\)</span>究极小，所以考虑暴力：</p><p>考虑找到树的直径，记录两个端点，枚举每一段长度不超过 <spanclass="math inline">\(s\)</span> 的路径，逐一比较 <spanclass="math inline">\(ECC\)</span>。</p><p>那么如何求一段路径的偏心距？</p><p>我们以图中 <span class="math inline">\(s=11\)</span>时的情况为例，树网的核为 <spanclass="math inline">\(DEFG\)</span>，偏心距为路径 <spanclass="math inline">\(BF(4+2+2=8)\)</span>。</p><p>看图容易推出 <span class="math inline">\(dis(B,F)=(dis(B,D)+dis(G,B)-dis(D,G) )\)</span>。</p><p>于是我们得到：<span class="math inline">\(ECC(i,j)=(dis(i,k)+dis(j,k)-dis(i,j))\div2\)</span>。</p><p>其中 <spanclass="math inline">\(k\in[1,n]\)</span>，可以用一层循环枚举 <spanclass="math inline">\(k\)</span>，求出最小 <spanclass="math inline">\(ECC\)</span>。</p><p>至于 <span class="math inline">\(dis(i,k)\)</span>，<spanclass="math inline">\(dis(j,k)\)</span>，<spanclass="math inline">\(dis(i,j)\)</span>，我们只需跑 floyd 即可。</p><p>但由于 floyd 用邻接矩阵，所以我们只能 <spanclass="math inline">\(O(n^2)\)</span> 求直径，整个算法复杂度为 <spanclass="math inline">\(O(n^3)\)</span>。</p>          </div><div class="note note-warning">            <p>细节：容易得到一个点 <span class="math inline">\(k\)</span> 在直径<span class="math inline">\(i\sim j\)</span> 上，那么 <spanclass="math inline">\(dis[i][k]+dis[k][j]=dis[i][j]\)</span>，否则continue。</p>          </div><div class='spoiler collapsed'>    <div class='spoiler-title'>        Code    </div>    <div class='spoiler-content'>        <div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch))&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<span class="hljs-keyword">return</span> f==<span class="hljs-number">1</span>?x:-x;&#125; <span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">300</span><span class="hljs-number">+10</span>,inf=<span class="hljs-number">0x7fffffff</span>;<span class="hljs-type">int</span> n,s,dis[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)    <span class="hljs-keyword">if</span>(i!=j) dis[i][j]=inf;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)     <span class="hljs-keyword">if</span>(dis[i][j]&gt;dis[i][k]+dis[k][j])        dis[i][j]=dis[i][k]+dis[k][j];&#125;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;n=<span class="hljs-built_in">read</span>(),s=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">init</span>();<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;++i) &#123;<span class="hljs-type">int</span> u=<span class="hljs-built_in">read</span>(),v=<span class="hljs-built_in">read</span>(),w=<span class="hljs-built_in">read</span>();dis[u][v]=dis[v][u]=w;&#125;<span class="hljs-built_in">floyd</span>();<span class="hljs-type">int</span> pl,pr,len=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;      <span class="hljs-keyword">if</span>(dis[i][j]&gt;=inf || dis[i][j]&lt;=len) &#123;                <span class="hljs-keyword">continue</span>;            &#125;      len=dis[i][j],pl=i,pr=j;<span class="hljs-comment">//求树的直径，记录两个端点 </span>    &#125;&#125;  <span class="hljs-type">int</span> ecc,ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;<span class="hljs-keyword">if</span>(dis[pl][i]+dis[i][pr]!=len) &#123;            <span class="hljs-keyword">continue</span>;        &#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) &#123;<span class="hljs-keyword">if</span>(dis[pl][j]+dis[j][pr]!=len) &#123;                <span class="hljs-keyword">continue</span>;            &#125;<span class="hljs-keyword">if</span>(dis[i][j]&gt;s) &#123;                <span class="hljs-keyword">continue</span>;            &#125;ecc=-inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;++k) &#123;ecc=<span class="hljs-built_in">max</span>(ecc,(dis[i][k]+dis[j][k]-dis[i][j])/<span class="hljs-number">2</span>);&#125;ans=<span class="hljs-built_in">min</span>(ans,ecc);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Competitive Programming </category>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
