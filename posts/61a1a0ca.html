

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/bg/mugeng.ico">
  <link rel="icon" href="/image/bg/mugeng.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="KisuraOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="菜。">
<meta property="og:type" content="article">
<meta property="og:title" content="【游记】2024 UESTC 暑假集训 第一轮">
<meta property="og:url" content="https://kisuraop.github.io/posts/61a1a0ca.html">
<meta property="og:site_name" content="KisuraOP">
<meta property="og:description" content="菜。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.rmb.bdstatic.com/bjh/f25d0738efd2d2e6a6c37052a67f9b43.jpeg">
<meta property="article:published_time" content="2024-07-08T04:35:35.000Z">
<meta property="article:modified_time" content="2024-07-08T04:35:35.000Z">
<meta property="article:author" content="KisuraOP">
<meta property="article:tag" content="ICPC">
<meta property="article:tag" content="UESTC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic.rmb.bdstatic.com/bjh/f25d0738efd2d2e6a6c37052a67f9b43.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【游记】2024 UESTC 暑假集训 第一轮 - KisuraOP</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_4277703_p4cthydttt.css">
<link rel="stylesheet" href="/css/vemoji.css">
<link rel="stylesheet" href="/css/bg_cover.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kisuraop.github.io","root":"/","version":"1.9.5-a","typing":{"enable":false,"typeSpeed":55,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"c++"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/image/other/loading.mp4","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><script src="https://kisuraop.github.io/js/mouseclick.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>KisuraOPのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/site/">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>收藏夹</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/waiting/">
                <i class="iconfont icon-plan"></i>
                <span>待办</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/example/">
                <i class="iconfont icon-comment"></i>
                <span>留言</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://moe.jitsu.top/img/?sort=pc') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">【游记】2024 UESTC 暑假集训 第一轮</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        KisuraOP
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-08 12:35" pubdate>
          2024年7月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          103k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【游记】2024 UESTC 暑假集训 第一轮</h1>
            
            
              <div class="markdown-body">
                
                <p>半年没写过游记了，因为懒。</p>
<p>感觉还是要写点什么才行。</p>
<h3 id="day--2">【7.5】 Day -2</h3>
<p>我暑假呢？</p>
<h3 id="day--1">【7.6】 Day -1</h3>
<p>我暑假呢？我暑假呢？</p>
<h3 id="day-0">【7.7】 Day 0</h3>
<p>我暑假呢？我暑假呢？我暑假呢？</p>
<h3 id="day-1">【7.8】 Day 1</h3>
<p>前一晚因为不可抗力没睡着。</p>
<p>唉，暑假结束了（？）</p>
<p>本来预定的是早上 7 点 10 分的校车，结果开窗一看下了很大的雨，倒霉！</p>
<p>干脆取消了改成 8 点的校车，好在雨停了，但我有衣服还没干，唉先上车再说。</p>
<p>到清水河了，脑浆都要颠出来了，体验最差的一次班车，还贼堵。</p>
<p>到宿舍了，怎么是 6 楼阿！累晕了，也气晕了。</p>
<p>光是上楼就满身汗，唉。</p>
<p>早上 10 点，有 yp 讲话。到了立人楼发现里面又挤又热，直接把凳子搬出来坐门边了。</p>
<p>刚坐出来，怎么专题开了鸭，看了一眼感觉都好难鸭qwq。</p>
<p>听 yp 讲零基础逆袭故事，有点自卑。</p>
<p>继续听，更自卑了。</p>
<p>下午的开盒环节提前了，要说自己有没有高中信息学基础。思索了一下，挺可笑的，参加了几次 csp 和 noip 结果只是稍微会写签到题，甚至不会写签到题的水平，这能叫有基础么。</p>
<p>于是说了零基础，但大家好像不是很理解我。</p>
<p>听 yp 讲暑假集训有多残酷，感觉要拿到 div.1 的资格我还差得远。</p>
<p>不知不觉真的讲了一个半小时，期间 lyc 还率先开卷。我把所有题都阅览了一遍，感觉都入手不能，遂放弃。</p>
<p>后面合照不知道为什么不拍了，商量了一下去朝阳吃午饭。</p>
<p>朝阳二楼吃的 ¥17 原汤五谷牛肉，淡而无味。而且这粉我吃不惯，不知道是不是地域原因，这种细而溜的像粉丝一样的东西能有啥味？不理解。</p>
<p>当时阿姨本来想多给一块牛肉，结果夹了三次夹不上她直接放弃了，可惜！</p>
<p>如果能打 1~5 星的话这玩意最多 2 星。</p>
<p>回宿舍吹空调，但只吹了 15 分钟，又要赶 1 点的车回沙河搬东西。烦死了。</p>
<p>不过好在这一来一回比上午那班车体验好多了，补了一点觉，但又感觉没补。</p>
<p>6 点，终于把行李搬上 6 楼了，虽然我带的行李应该是最少的，但这也太为难大胖子了。</p>
<p>床板质量令人堪忧，感觉一踩上去就会裂成几大块，不过铺上凉席之后感觉还行鸭。</p>
<p>7 点收到了波波王的果茶！好喝捏，幸福捏。</p>
<p>然后不知道干什么了，不知道是专题启动还是 tr 启动。</p>
<p>室友是不是都在学阿！</p>
<p>打成共识，开泰！</p>
<p>怎么群号被群主复读了，这下似摸Q了。</p>
<h3 id="day-2">【7.9】 Day 2</h3>
<p>8 点 05 准时起床，看了眼专题过题情况，大家都好努力。但不计一血，我也不急。</p>
<p>早餐没吃，感觉以后也没什么必要。</p>
<p>xcy 讲课，感觉 ppt 做的好认真鸭，出乎意料的除了势能分析都听懂了，虽然讲的是最基础的 kmp。</p>
<p>接着 lxy 讲课，我爆了，z 函数听不懂一点，上面板书也小小的看不清。讲到后面写的更小了，这我听集贸啊，就不听了。</p>
<p>翻了下 oiwiki，写的一般鸭，更加认真地看了看，还是放弃了，去翻洛谷题解了。</p>
<p>稍微会了点，果然有点图示会好很多。</p>
<p>提前下课！好也不好，外卖点了个 ¥20 的猪脚饭。时间还早，冒雨去便利店买了点物资，这便利店完爆沙河。</p>
<p>外卖被偷了。骑手找了半天，说一分钟前刚放。我不知道该说什么，到了清水河这边干啥都不顺，心态感觉不出几天就垮完了。</p>
<p>中午补了一下课件上提到的四题。</p>
<hr />
<div class="note note-info">
            <p>【CF1200E Compress Words】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个单词，需要依次合并他们，使得最终单词尽可能短。</p><p><span class="math inline">\(\sum|S|\le 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>需要尽可能短，那对于合并后的母串 <span class="math inline">\(S\)</span> 和待并入的子串 <span class="math inline">\(T\)</span>，要找到 <span class="math inline">\(S\)</span> 的最长后缀使之和 <span class="math inline">\(T\)</span> 相应长度的前缀等同。</p><p>不难发现所求即为 <span class="math inline">\(T + S\)</span> 的 border。</p><p>对于每一个串都要对 <span class="math inline">\(T+S\)</span> 做一次 KMP 是不能接受的，因为 <span class="math inline">\(S\)</span> 会随着合并越来越长。</p><p>由于我们只关心 border，所以只需要截取 <span class="math inline">\(S[\max(0,|S|-|T|),|S|]\)</span>。</p><p>故每回合用来跑 KMP 的串为 <span class="math inline">\(T + @ + S[\max(0,|S|-|T|),|S|]\)</span>。</p><p>中间的特殊字符是用来防止相交的，例如 <span class="math inline">\(S =aba\)</span>，<span class="math inline">\(T = aaba\)</span>，若使用 <span class="math inline">\(aabaaba\)</span>，border 是 <span class="math inline">\(4\)</span>，而 <span class="math inline">\(1\)</span> 是正确的，所以使用 <span class="math inline">\(aaba@aba\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	string ans = <span class="hljs-string">&quot;&quot;</span>;
	<span class="hljs-keyword">while</span> (n--) &#123;
		string s;
		cin &gt;&gt; s;
		string t = <span class="hljs-string">&quot; &quot;</span> + s + <span class="hljs-string">&quot;@&quot;</span> + ans.<span class="hljs-built_in">substr</span>(ans.<span class="hljs-built_in">size</span>() - <span class="hljs-built_in">min</span>(ans.<span class="hljs-built_in">size</span>(), s.<span class="hljs-built_in">size</span>()));

		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(t.size())</span></span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;
			<span class="hljs-keyword">while</span> (p &amp;&amp; t[i] != t[p + <span class="hljs-number">1</span>]) &#123;
				p = fail[p];
			&#125;
			<span class="hljs-keyword">if</span> (t[i] == t[p + <span class="hljs-number">1</span>]) &#123;
				p++;
			&#125;
			fail[i] = p;
		&#125;

		ans += s.<span class="hljs-built_in">substr</span>(fail[t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【P2375 [NOI2014] 动物园】</p><p>题意：求出一个 <span class="math inline">\(\text{num}\)</span> 数组，<span class="math inline">\(\text{num}[i]\)</span> 代表字符串 <span class="math inline">\(S[1,i]\)</span> 的子串中既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重合。</p><p><span class="math inline">\(1 \le |S| \le 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>暴力做法是跑 KMP，对每个 <span class="math inline">\(i\)</span> 跳 fail，找出所有的 border。跳了几次 <span class="math inline">\(\text{num[i]}\)</span> 就是多少。</p><p>不重叠也就是只把长度小于原串一半的 border 计入答案。</p><p>倍增优化，<span class="math inline">\(jp[i][j]\)</span> 代表字符串第 <span class="math inline">\(i\)</span> 个位置跳了 <span class="math inline">\(2^j\)</span> 次后的 border 长度。</p><p>时间复杂度 <span class="math inline">\(O(|S|\log |S|)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	string s;
	cin &gt;&gt; s;
	s = <span class="hljs-string">&quot; &quot;</span> + s;
	<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-function">vector <span class="hljs-title">jp</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;
			p = fail[p];
		&#125;
		<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;
			p++;
		&#125;
		fail[i] = p;
		jp[i][<span class="hljs-number">0</span>] = fail[i];
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">25</span>; j++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
			jp[i][j] = jp[ jp[i][j - <span class="hljs-number">1</span>] ][j - <span class="hljs-number">1</span>];
		&#125;
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x = i;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">24</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;
			<span class="hljs-keyword">if</span> (jp[x][j] * <span class="hljs-number">2</span> &gt; i) &#123;
				x = jp[x][j];
			&#125;
		&#125;
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">24</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;
			<span class="hljs-keyword">if</span> (jp[x][j]) &#123;
				res += <span class="hljs-number">1LL</span> &lt;&lt; j;
				x = jp[x][j];
			&#125;
		&#125;
		ans *= (res + <span class="hljs-number">1</span>) % modp;
		ans %= modp;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class="note note-success">
            <p>但这个跳了几次的问题在预处理时就能记录。</p><p>因为每转移一次相当于跳了的次数 <span class="math inline">\(+1\)</span>，假如更新了 <code>fail[i] = p</code>，那么直接 <code>num[i] = num[p] + 1</code> 即可。</p><p>不重叠同上处理，跳到长度符合要求为止。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	string s;
	cin &gt;&gt; s;
	s = <span class="hljs-string">&quot; &quot;</span> + s;
	<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n)</span>, <span class="hljs-title">num</span><span class="hljs-params">(n)</span></span>;
	num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;
			p = fail[p];
		&#125;
		<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;
			p++;
		&#125;
		fail[i] = p;
		num[i] = num[p] + <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;
			p = fail[p];
		&#125;
		<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;
			p++;
		&#125;
		<span class="hljs-keyword">while</span> (p * <span class="hljs-number">2</span> &gt; i) &#123;
			p = fail[p];
		&#125;
		ans *= (num[p] + <span class="hljs-number">1</span>) % modp;
		ans %= modp;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【P3435 [POI2006] OKR-Periods of Words】</p><p>题意：给定字符串 <span class="math inline">\(S\)</span>，对于字符串 <span class="math inline">\(T\)</span>，称 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(S\)</span> 的周期当且仅当 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(S\)</span> 的真前缀且 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(T + T\)</span> 的前缀。</p><p>求给定 <span class="math inline">\(S\)</span> 的所有前缀的最大周期长度之和。</p><p><span class="math inline">\(1 \le |S| \le 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p><span class="math inline">\(S\)</span> 是 <span class="math inline">\(T+T\)</span> 的前缀可以理解为把 <span class="math inline">\(S\)</span> 的一个前缀复制一份之后能完全包含 <span class="math inline">\(S\)</span>。</p><p>设这个前缀为 <span class="math inline">\(S[1,i]\)</span>，那么 <span class="math inline">\(S[i+1,|S|]\)</span> 必然和 <span class="math inline">\(S[1,|S|-i]\)</span> 相等，即把前缀拿走之后剩余的部分必须是原串的一个 border。</p><p>这个前缀又要最长，那么就是最短 border。</p><p>根据 fail 数组的性质，一直跳到空串之前即可。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	string s;
	cin &gt;&gt; n &gt;&gt; s;
	s = <span class="hljs-string">&quot; &quot;</span> + s;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;
			p = fail[p];
		&#125;
		<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;
			p++;
		&#125;
		fail[i] = p;
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> p = i;
		<span class="hljs-keyword">while</span> (fail[p]) &#123;
			p = fail[p];
		&#125;
		<span class="hljs-keyword">if</span> (fail[i]) &#123;
			fail[i] = p;
		&#125;
		ans += i - p;
	&#125;

	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【P5829 【模板】失配树】</p><p>题意：给定一个字符串 <span class="math inline">\(S\)</span>，<span class="math inline">\(m\)</span> 组询问。每次给定 <span class="math inline">\(p,q\)</span>，求 <span class="math inline">\(S\)</span> 的 <span class="math inline">\(p\)</span> 前缀和 <span class="math inline">\(q\)</span> 前缀的最长公共 border 的长度。</p><p><span class="math inline">\(1\le p,q\le |S| \le 10^6\)</span>，<span class="math inline">\(1\le m \le 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>fail 树，顾名思义就是连边 <span class="math inline">\(fail[i] \to i\)</span> 形成的树，不断往上跳父亲跳到根就能得到这个字符串所有的 border。</p><p>那题目所求相当于 fail 树上点 <span class="math inline">\(p\)</span> 和点 <span class="math inline">\(q\)</span> 的 <span class="math inline">\(\text{LCA}\)</span>。</p><p>特别注意：如果求出来的 <span class="math inline">\(\text{LCA}\)</span> 是 <span class="math inline">\(p\)</span> 或者 <span class="math inline">\(q\)</span>，那么还要往上跳一格，因为自己不是自己的 border。</p><p>时间复杂度 <span class="math inline">\(O(m\log |S|)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	string s;
	cin &gt;&gt; s;
	<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();
	s = <span class="hljs-string">&quot; &quot;</span> + s;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fail</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	adj[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, p = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">while</span> (p &amp;&amp; s[i] != s[p + <span class="hljs-number">1</span>]) &#123;
			p = fail[p];
		&#125;
		<span class="hljs-keyword">if</span> (s[i] == s[p + <span class="hljs-number">1</span>]) &#123;
			p++;
		&#125;
		fail[i] = p;
		adj[fail[i]].<span class="hljs-built_in">push_back</span>(i);
	&#125;

	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fa</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>, <span class="hljs-number">0</span>));
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">depth</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;
		fa[x][<span class="hljs-number">0</span>] = fath;
		depth[x] = depth[fath] + <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= __lg(depth[x]) + <span class="hljs-number">1</span>; i++) &#123;
			fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y != fath) &#123;
				<span class="hljs-built_in">self</span>(self, y, x);
			&#125;
		&#125;
	&#125;;
	<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;
		<span class="hljs-keyword">if</span> (depth[x] &lt; depth[y]) &#123;
			<span class="hljs-built_in">swap</span>(x, y);
		&#125;
		<span class="hljs-keyword">while</span> (depth[x] &gt; depth[y]) &#123;
			x = fa[x][__lg(depth[x] - depth[y])];
		&#125;
		<span class="hljs-keyword">if</span> (x == y) &#123;
			<span class="hljs-keyword">return</span> x;
		&#125; 
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(depth[x]); i &gt;= <span class="hljs-number">0</span>; i--) &#123;
			<span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i]) &#123;
				x = fa[x][i];
				y = fa[y][i];
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

	<span class="hljs-type">int</span> m;
	cin &gt;&gt; m;
	<span class="hljs-keyword">while</span> (m--) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		<span class="hljs-type">int</span> res = <span class="hljs-built_in">LCA</span>(x, y);
		<span class="hljs-keyword">if</span> (res == x || res == y) &#123;
			res = fa[res][<span class="hljs-number">0</span>];
		&#125;
		cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;



<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>下午 QHJ 讲计算几何，没睡过，但雨一直下，走过去还要 20 分钟，摆！</p>
<p>看了看集训计划确认了每个专题第一节不点名，就呆在宿舍听了。</p>
<p>然后就后悔了，声音断断续续的，基本就是看 PPT。</p>
<p>怎么感觉都是套板子鸭，很符合我之前对计算几何的印象。</p>
<p>但我怎么例题都不会做鸭（</p>
<p>正好有一段声音几乎没了，估计是在黑板上涂涂写写，我听着也难受，就去做了两个 PPT 上的题。</p>
<p>感觉下午亏麻了鸭！</p>
<hr />
<div class="note note-info">
            <p>【2024 四川省赛】F. Isoball: 2D Version</p><p>题意：给定一个圆和一个平行坐标轴的矩形，现给定一组方向向量，该圆开始沿此方向运动，问是否存在一个时刻使得圆完全包含在给定矩形中。</p>
          </div>
<div class="note note-success">
            <p>当圆完全被矩形包含时，圆心到该矩形四条边的距离均 <span class="math inline">\(\ge r\)</span>。</p><p>那么我们可以把这个矩形的四条边向彼此均移动 <span class="math inline">\(r\)</span>，得到一个缩小版矩形。</p><p>此时只需要判断圆心是否在这个缩小版矩形中。</p><p>圆心的轨迹是一条射线，题目也转化为该射线是否和矩形的某一条边有交点。</p><p>射线求交即可。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;
    T x, y;
    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;
    
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;
    <span class="hljs-keyword">operator</span> <span class="hljs-built_in">Point</span>&lt;U&gt;() &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>&lt;U&gt;(<span class="hljs-built_in">U</span>(x), <span class="hljs-built_in">U</span>(y));
    &#125;
    Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;
        x += p.x;
        y += p.y;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;
        x -= p.x;
        y -= p.y;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;
        x *= v;
        y *= v;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a += b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a -= b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;
        <span class="hljs-keyword">return</span> a *= b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;
        <span class="hljs-keyword">return</span> b *= a;
    &#125;
    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;
    &#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;
    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;
&#125;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;
    Point&lt;T&gt; a, b;
    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;
&#125;;


<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">lineIntersection</span><span class="hljs-params">(Line&lt;T&gt; l1, Line&lt;T&gt; l2)</span> </span>&#123;
    <span class="hljs-keyword">return</span> l1.a + (l1.b - l1.a) * (<span class="hljs-built_in">cross</span>(l2.b - l2.a, l1.a - l2.a) / <span class="hljs-built_in">cross</span>(l2.b - l2.a, l1.a - l1.b));
&#125;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pointOnSegment</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">cross</span>(p - l.a, l.b - l.a) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">min</span>(l.a.x, l.b.x) &lt;= p.x &amp;&amp; p.x &lt;= <span class="hljs-built_in">max</span>(l.a.x, l.b.x)
    &amp;&amp; <span class="hljs-built_in">min</span>(l.a.y, l.b.y) &lt;= p.y &amp;&amp; p.y &lt;= <span class="hljs-built_in">max</span>(l.a.y, l.b.y);
&#125;


<span class="hljs-comment">// 0 : not intersect</span>
<span class="hljs-comment">// 1 : strictly intersect</span>
<span class="hljs-comment">// 2 : overlap</span>
<span class="hljs-comment">// 3 : intersect at endpoint</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
tuple&lt;<span class="hljs-type">int</span>, Point&lt;T&gt;, Point&lt;T&gt;&gt; <span class="hljs-built_in">segmentIntersection</span>(Line&lt;T&gt; l1, Line&lt;T&gt; l2) &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(l1.a.x, l1.b.x) &lt; <span class="hljs-built_in">min</span>(l2.a.x, l2.b.x)) &#123;
        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;
    &#125;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(l1.a.x, l1.b.x) &gt; <span class="hljs-built_in">max</span>(l2.a.x, l2.b.x)) &#123;
        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;
    &#125;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(l1.a.y, l1.b.y) &lt; <span class="hljs-built_in">min</span>(l2.a.y, l2.b.y)) &#123;
        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;
    &#125;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(l1.a.y, l1.b.y) &gt; <span class="hljs-built_in">max</span>(l2.a.y, l2.b.y)) &#123;
        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;
    &#125;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cross</span>(l1.b - l1.a, l2.b - l2.a) == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cross</span>(l1.b - l1.a, l2.a - l1.a) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">auto</span> maxx1 = <span class="hljs-built_in">max</span>(l1.a.x, l1.b.x);
            <span class="hljs-keyword">auto</span> minx1 = <span class="hljs-built_in">min</span>(l1.a.x, l1.b.x);
            <span class="hljs-keyword">auto</span> maxy1 = <span class="hljs-built_in">max</span>(l1.a.y, l1.b.y);
            <span class="hljs-keyword">auto</span> miny1 = <span class="hljs-built_in">min</span>(l1.a.y, l1.b.y);
            <span class="hljs-keyword">auto</span> maxx2 = <span class="hljs-built_in">max</span>(l2.a.x, l2.b.x);
            <span class="hljs-keyword">auto</span> minx2 = <span class="hljs-built_in">min</span>(l2.a.x, l2.b.x);
            <span class="hljs-keyword">auto</span> maxy2 = <span class="hljs-built_in">max</span>(l2.a.y, l2.b.y);
            <span class="hljs-keyword">auto</span> miny2 = <span class="hljs-built_in">min</span>(l2.a.y, l2.b.y);
            <span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">p1</span><span class="hljs-params">(max(minx1, minx2), max(miny1, miny2))</span></span>;
            <span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(min(maxx1, maxx2), min(maxy1, maxy2))</span></span>;
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">pointOnSegment</span>(p1, l1)) &#123;
                <span class="hljs-built_in">swap</span>(p1.y, p2.y);
            &#125;
            <span class="hljs-keyword">if</span> (p1 == p2) &#123;
                <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">3</span>, p1, p2&#125;;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">2</span>, p1, p2&#125;;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">auto</span> cp1 = <span class="hljs-built_in">cross</span>(l2.a - l1.a, l2.b - l1.a);
    <span class="hljs-keyword">auto</span> cp2 = <span class="hljs-built_in">cross</span>(l2.a - l1.b, l2.b - l1.b);
    <span class="hljs-keyword">auto</span> cp3 = <span class="hljs-built_in">cross</span>(l1.a - l2.a, l1.b - l2.a);
    <span class="hljs-keyword">auto</span> cp4 = <span class="hljs-built_in">cross</span>(l1.a - l2.b, l1.b - l2.b);
    
    <span class="hljs-keyword">if</span> ((cp1 &gt; <span class="hljs-number">0</span> &amp;&amp; cp2 &gt; <span class="hljs-number">0</span>) || (cp1 &lt; <span class="hljs-number">0</span> &amp;&amp; cp2 &lt; <span class="hljs-number">0</span>) || (cp3 &gt; <span class="hljs-number">0</span> &amp;&amp; cp4 &gt; <span class="hljs-number">0</span>) || (cp3 &lt; <span class="hljs-number">0</span> &amp;&amp; cp4 &lt; <span class="hljs-number">0</span>)) &#123;
        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-built_in">Point</span>&lt;T&gt;(), <span class="hljs-built_in">Point</span>&lt;T&gt;()&#125;;
    &#125;
    
    Point p = <span class="hljs-built_in">lineIntersection</span>(l1, l2);
    <span class="hljs-keyword">if</span> (cp1 != <span class="hljs-number">0</span> &amp;&amp; cp2 != <span class="hljs-number">0</span> &amp;&amp; cp3 != <span class="hljs-number">0</span> &amp;&amp; cp4 != <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, p, p&#125;;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">3</span>, p, p&#125;;
    &#125;
&#125;



<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">double</span> x, y, r, vx, vy;
	cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; vx &gt;&gt; vy;
	<span class="hljs-type">double</span> lx, ly, rx, ry;
	cin &gt;&gt; lx &gt;&gt; ly &gt;&gt; rx &gt;&gt; ry;

	lx += r;
	rx -= r;
	ly += r;
	ry -= r;
	<span class="hljs-keyword">if</span> (lx &gt; rx || ly &gt; ry) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;
		<span class="hljs-keyword">return</span> ;
	&#125;
	<span class="hljs-type">double</span> mx = <span class="hljs-number">1e7</span>;
	<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(&#123;x, y&#125;, &#123;x + vx * mx, y + vy * mx&#125;)</span></span>;
	vector&lt;Line&lt;<span class="hljs-type">double</span>&gt;&gt; lines = &#123;
		&#123;&#123;lx, ly&#125;, &#123;rx, ly&#125;&#125;,
		&#123;&#123;rx, ly&#125;, &#123;rx, ry&#125;&#125;,
		&#123;&#123;rx, ry&#125;, &#123;lx, ry&#125;&#125;,
		&#123;&#123;lx, ry&#125;, &#123;lx, ly&#125;&#125;
	&#125;;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> line : lines) &#123;
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-built_in">segmentIntersection</span>(l, line)) &gt; <span class="hljs-number">0</span>) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;
			<span class="hljs-keyword">return</span> ;
		&#125;
	&#125;
	cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>晚饭还是点外卖，一雪前耻。点了个 ¥27 的麻辣香锅，好吃捏好吃捏，分量也足，能有 4 星半（?）</p>
<p>专题还是不想做，动力全无。</p>
<p>研究了一下 PPT，本来想搞一套自己的板子，最后还是直接扒的 jiangly 的，因为哥哥写的代码实在是太好看了鸭。不过流传的版本缺失了很多内容，我照葫芦画瓢补了点上去。</p>
<p>专题有几题过了挺多人了，跟下榜？</p>
<p>十分钟写了个签到 pick 定理，然后坐了两小时牢。</p>
<p>菜输了，感觉还没到能徒手干专题的水平，先放着好了。</p>
<h3 id="day-3">【7.10】 Day 3</h3>
<p>起床，洗漱。</p>
<p>然后发现不对。</p>
<p>我趣，怎么我 8 点 05 的闹钟定成 7 点 05 了，太难崩了。</p>
<p>不知道舍友是不是被我吵醒了，脑子越来越不好使了，完蛋。</p>
<p>不想睡回笼觉，溜了一遍昨天学的 z 函数和 manacher。</p>
<p>到教室了，感觉今天讲的内容挺重要的，就坐在了前排。</p>
<p>结果中间想爆一下群巨被抓包了qwq。</p>
<p>徐神讲课还是讲得超级棒口牙，都听懂了（吗？）</p>
<p>甚至细到现写代码，好贴心鸭/se/se/se</p>
<p>后面 lxy 讲课一如既往的听不懂：讲序列自动机，嗯，开始听，讲完了？讲最小表示法，开始听，听不懂，讲完了？到 Lyndon 分解，讲完了？问我们听没听懂，此时的我 belike：<del>（数据删除）</del></p>
<p>中午想着要不要去图书馆借个词典，但懒了，希望下午不要伏笔回收。</p>
<p>又点了一次昨天那个麻辣香锅，只不过换了个口味，爽爽爽。</p>
<p>今天还是不想睡午觉，正好 xjj 问我第二次队内赛的 H，我想起那题之前我线段树优化建图被卡爆了，就稍微写了写。</p>
<p>对着题解搓了一发前后缀优化建图，直接 AC，爽！</p>
<hr />
<div class="note note-info">
            <p>【2024 - 暑假前集训队内赛 2 - H. 金铲铲，启动！】</p><p><a target="_blank" rel="noopener" href="https://121-48-165-90.vpn.uestc.edu.cn:8118/contest/253/problem/H">Link</a></p>
          </div>
<div class="note note-success">
            <p>和图论专题 L 很类似，看题识 2sat，对于拥有小羁绊的奕子 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span>，有 <span class="math inline">\(u \lor v\)</span>。</p><p>而对于拥有相同大羁绊的奕子集合 <span class="math inline">\(s\)</span>，<span class="math inline">\(\forall x,y\in s\)</span>，<span class="math inline">\(\lnot x \lor \lnot y\)</span>。</p><p>可以线段树优化建图，每个集合中的第 <span class="math inline">\(i\)</span> 个点向第 <span class="math inline">\([1,i-1]\)</span> 和第 <span class="math inline">\([i+1,|s|]\)</span> 的点连边。</p><p>但这样连的边还是太多了，需要采用前后缀优化建图。</p><figure><img src="/image/academic/5.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>如图连边即可。第一次见到，很智慧。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        线段树优化建图
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf INT_MAX</span>


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegEdge</span> &#123;
	<span class="hljs-type">int</span> n, K, all;
	vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; adj;
	vector&lt;<span class="hljs-type">int</span>&gt; id;
	<span class="hljs-built_in">SegEdge</span>() &#123;&#125;
	<span class="hljs-built_in">SegEdge</span>(<span class="hljs-type">int</span> n) &#123;
		<span class="hljs-keyword">this</span>-&gt;n = n;
		K = <span class="hljs-number">4</span> * n;
		all = <span class="hljs-number">8</span> * n;
		adj.<span class="hljs-built_in">resize</span>(all + <span class="hljs-number">1</span>);
		id.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
		<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
		<span class="hljs-built_in">init</span>(n);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			adj[id[i]].<span class="hljs-built_in">push_back</span>(&#123;id[i] + K, <span class="hljs-number">0</span>&#125;);
			adj[id[i] + K].<span class="hljs-built_in">push_back</span>(&#123;id[i], <span class="hljs-number">0</span>&#125;);
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> id[l] = p, <span class="hljs-built_in">void</span>();
		adj[p].<span class="hljs-built_in">push_back</span>(&#123;p &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);
		adj[p].<span class="hljs-built_in">push_back</span>(&#123;p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);
		adj[(p &lt;&lt; <span class="hljs-number">1</span>) + K].<span class="hljs-built_in">push_back</span>(&#123;p + K, <span class="hljs-number">0</span>&#125;);
		adj[(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>) + K].<span class="hljs-built_in">push_back</span>(&#123;p + K, <span class="hljs-number">0</span>&#125;);
		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
		<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);
		<span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> lx, <span class="hljs-type">int</span> rx, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> opt)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (lx &lt;= l &amp;&amp; r &lt;= rx) &#123;
			<span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) adj[x + K].<span class="hljs-built_in">push_back</span>(&#123;p, w&#125;);
			<span class="hljs-keyword">else</span> adj[p + K].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (lx &lt;= mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, lx, rx, x, w, opt);
		<span class="hljs-keyword">if</span> (rx &gt; mid) <span class="hljs-built_in">addEdge</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, lx, rx, x, w, opt);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtoP</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;
		adj[id[x] + K].<span class="hljs-built_in">push_back</span>(&#123;id[y], w&#125;);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtoS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> w)</span> </span>&#123;
		<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, id[x], w, <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StoP</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> w)</span> </span>&#123;
		<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, id[x], w, <span class="hljs-number">2</span>);
	&#125;
&#125;;


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoSat</span> &#123;
	<span class="hljs-type">int</span> n;
	<span class="hljs-built_in">TwoSat</span>(<span class="hljs-type">int</span> n) &#123;
		<span class="hljs-keyword">this</span>-&gt;n = n;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addbind</span><span class="hljs-params">(SegEdge &amp;seg, <span class="hljs-type">int</span> x, <span class="hljs-type">bool</span> ok1, <span class="hljs-type">int</span> y, <span class="hljs-type">bool</span> ok2)</span> </span>&#123;
		seg.<span class="hljs-built_in">PtoP</span>(x + n / <span class="hljs-number">8</span> * (!ok1), y + n / <span class="hljs-number">8</span> * ok2, <span class="hljs-number">1</span>);
		seg.<span class="hljs-built_in">PtoP</span>(y + n / <span class="hljs-number">8</span> * (!ok2), x + n / <span class="hljs-number">8</span> * ok1, <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">(SegEdge &amp;seg)</span> </span>&#123;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;
		<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;
		function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;
			dfn[x] = low[x] = ++tim;
			vis[x] = <span class="hljs-literal">true</span>;
			stack_[++top] = x;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : seg.adj[x]) &#123;
				<span class="hljs-keyword">if</span> (!dfn[y]) &#123;
					<span class="hljs-built_in">tarjan</span>(y);
					low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);
				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;
					low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);
				&#125;
			&#125;
			<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;
				<span class="hljs-type">int</span> now; ++cnt;
				<span class="hljs-keyword">do</span>&#123;
					now = stack_[top--];
					vis[now] = <span class="hljs-literal">false</span>;
					c[now] = cnt;
				&#125; <span class="hljs-keyword">while</span> (x != now);
			&#125;
		&#125;;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;
			<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / <span class="hljs-number">8</span>; i++) &#123;
			<span class="hljs-keyword">if</span> (c[seg.id[i]] == c[seg.id[i + n / <span class="hljs-number">8</span>]]) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, k;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		a[i] = &#123;x, i&#125;;
	&#125;
	<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ys</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">R</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		R[a[i][<span class="hljs-number">0</span>]] = <span class="hljs-built_in">max</span>(R[a[i][<span class="hljs-number">0</span>]], i);
		ys[a[i][<span class="hljs-number">1</span>]] = i;
	&#125;
	<span class="hljs-function">SegEdge <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;
	<span class="hljs-function">TwoSat <span class="hljs-title">ts</span><span class="hljs-params">(<span class="hljs-number">8</span> * n)</span></span>;
	<span class="hljs-keyword">auto</span> Add = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;
		seg.<span class="hljs-built_in">PtoS</span>(x + n, l, r, <span class="hljs-number">1</span>);
		seg.<span class="hljs-built_in">StoP</span>(l + n, r + n, x, <span class="hljs-number">1</span>);
	&#125;;
	<span class="hljs-type">int</span> now = n;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (R[a[i][<span class="hljs-number">0</span>]] != i) &#123;
			<span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>;
			<span class="hljs-type">int</span> r = R[a[i][<span class="hljs-number">0</span>]];
			<span class="hljs-built_in">Add</span>(i, l, r);
		&#125;
	&#125;
	<span class="hljs-keyword">while</span> (m--) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		x = ys[x];
		y = ys[y];
		ts.<span class="hljs-built_in">addbind</span>(seg, x, <span class="hljs-number">1</span>, y, <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-type">int</span> ans = ts.<span class="hljs-built_in">work</span>(seg);
	<span class="hljs-keyword">if</span> (ans) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;Teamfight Tactics\n&quot;</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;Crown Legends: Battlefury\n&quot;</span>;
	&#125;
&#125;



<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-comment">// fre(test);</span>
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        前后缀优化建图
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf INT_MAX</span>



<span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoSat</span> &#123;
	<span class="hljs-type">int</span> n;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;
	vector&lt;<span class="hljs-type">int</span>&gt; ans;
	<span class="hljs-built_in">TwoSat</span>(<span class="hljs-type">int</span> n) &#123;
		<span class="hljs-keyword">this</span>-&gt;n = n;
		adj.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
		ans.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addbind</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">bool</span> ok1, <span class="hljs-type">int</span> y, <span class="hljs-type">bool</span> ok2)</span> </span>&#123;
		adj[x + n * (!ok1)].<span class="hljs-built_in">push_back</span>(y + n * ok2);
		adj[y + n * (!ok2)].<span class="hljs-built_in">push_back</span>(x + n * ok1);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;
		vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
		<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;
		function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;
			dfn[x] = low[x] = ++tim;
			vis[x] = <span class="hljs-literal">true</span>;
			stack_[++top] = x;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (!dfn[y]) &#123;
					<span class="hljs-built_in">tarjan</span>(y);
					low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);
				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vis[y]) &#123;
					low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);
				&#125;
			&#125;
			<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;
				<span class="hljs-type">int</span> now; ++cnt;
				<span class="hljs-keyword">do</span>&#123;
					now = stack_[top--];
					vis[now] = <span class="hljs-literal">false</span>;
					c[now] = cnt;
					scc[cnt].<span class="hljs-built_in">push_back</span>(now);
				&#125; <span class="hljs-keyword">while</span> (x != now);
			&#125;
		&#125;;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;
			<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			<span class="hljs-keyword">if</span> (c[i] == c[i + n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			ans[i] = c[i] &gt; c[i + n] ? <span class="hljs-number">1ll</span> : <span class="hljs-number">0ll</span>;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getans</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> ans;
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, k;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(k + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
		b[a[i]].<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-function">TwoSat <span class="hljs-title">ts</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;
		<span class="hljs-keyword">if</span> (b[i].<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; b[i].<span class="hljs-built_in">size</span>(); j++) &#123;

			ts.adj[b[i][j] + <span class="hljs-number">2</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j] + <span class="hljs-number">3</span> * n);
			ts.adj[b[i][j] + n].<span class="hljs-built_in">push_back</span>(b[i][j]);

			<span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; b[i].<span class="hljs-built_in">size</span>()) &#123;
				ts.adj[b[i][j] + <span class="hljs-number">3</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j + <span class="hljs-number">1</span>] + <span class="hljs-number">3</span> * n);
			&#125;
			<span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;
				ts.adj[b[i][j] + n].<span class="hljs-built_in">push_back</span>(b[i][j - <span class="hljs-number">1</span>] + n);
			&#125;

			<span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; b[i].<span class="hljs-built_in">size</span>()) &#123;
				ts.adj[b[i][j] + <span class="hljs-number">3</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j + <span class="hljs-number">1</span>]);
			&#125;
			<span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;
				ts.adj[b[i][j] + <span class="hljs-number">2</span> * n].<span class="hljs-built_in">push_back</span>(b[i][j - <span class="hljs-number">1</span>] + n);
			&#125;

		&#125;
	&#125;
	<span class="hljs-keyword">while</span> (m--) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		ts.<span class="hljs-built_in">addbind</span>(x, <span class="hljs-number">1</span>, y, <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-keyword">if</span> (ts.<span class="hljs-built_in">work</span>()) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;Teamfight Tactics\n&quot;</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;Crown Legends: Battlefury\n&quot;</span>;
	&#125;
&#125;



<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>下午队内赛，寄完了，3/10（Rank 5）</p>
<p>一开始随机开题，感觉 C 一眼，然后开始写，然后就不会写了，最后也没写出来。</p>
<p>F 题意挂了一个半小时，最后终于读懂了是 “开始和移动过程可能在同一个位置，最后不能在同一个位置，也就是一串连续的坐标，然后除了递增还可能是递减”。</p>
<p>E 题意至少读了 10 遍，还是搞不懂这题想求什么。我怎么感觉只有每个字符串的首字母有用，样例我也搞不懂。</p>
<p>挺唐的，赛时感觉很多题都能猜到是怎么做的，但写不出来。</p>
<p>菜。</p>
<hr />
<p>晚饭在商业街吃了个炸鸡，一般，三星。</p>
<p>回到宿舍 emo 完洗完澡就 10 点了（？？？中间干了什么？？？）。</p>
<p>补了两题就过 12 点了，AC 自动机的例题还没看（</p>
<p>完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了完蛋了。</p>
<hr />
<div class="note note-info">
            <p>【队内赛 1E - gym104022 K. Browser Games】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个字符串 <span class="math inline">\(\{s\}\)</span>，对于每个 <span class="math inline">\(i\in[1, n]\)</span> 回答最少用几个字符串组成字符串集 <span class="math inline">\(T\)</span>，才能使第 <span class="math inline">\(1\sim i\)</span> 个字符串在 <span class="math inline">\(T\)</span> 中都至少有一个前缀，且第 <span class="math inline">\(i + 1\sim n\)</span> 个字符串的所有前缀在 <span class="math inline">\(T\)</span> 中不存在。</p><p><span class="math inline">\(1 \le n \le 5\cdot 10^4\)</span>，<span class="math inline">\(|s| \le 50\)</span>，字符串含 <span class="math inline">\(a\sim z\)</span>，小数点和斜杠。</p>
          </div>
<div class="note note-success">
            <p>考虑增加了一个字符串，那么这个字符串在增加之前造成的限制消失了，消失了多少？</p><p>我们把字符串放到 trie 树上考虑，记录每个节点最近一次的访问来自于哪个字符串（<code>flag</code>）以及字符串末尾标记（<code>id</code>）。增加字符串 <span class="math inline">\(i\)</span> 时，可以从 <code>id[i]</code> 不断向上跳父亲，直到节点 <code>flag</code> 不为 <span class="math inline">\(i\)</span> 为止，目前这段链就是使得答案增加的罪魁祸首。</p><p>为了统计增加了多少，我们再为 trie 树上的每个节点引入标记 <code>cnt</code>。意为该节点确认作为 <span class="math inline">\(T\)</span> 中的一个答案：每次跳父亲之后，所在的满足 <code>flag</code> 不为 <code>i</code> 的节点就确认作为一个前缀，因此 <code>cnt++</code>；而每次答案也减少了这条链上的 <code>cnt</code> 个数。</p><p>时间复杂度 <span class="math inline">\(O(n|s|)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;
	<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">28</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
		<span class="hljs-type">int</span> fa, flag, cnt;
		array&lt;<span class="hljs-type">int</span>, S&gt; nxt;
		<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, flag&#123;<span class="hljs-number">-1</span>&#125;, cnt&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;
	&#125;;
	vector&lt;Node&gt; t;

	<span class="hljs-built_in">Trie</span>() &#123;
		t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());
		t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);
		t[<span class="hljs-number">1</span>].fa = <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;
		t.<span class="hljs-built_in">emplace_back</span>();
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> i)</span> </span>&#123;
		<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;
			<span class="hljs-type">int</span> x;
			<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;
				x = <span class="hljs-number">26</span>;
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;
				x = <span class="hljs-number">27</span>;
			&#125; <span class="hljs-keyword">else</span> &#123;
				x = c - <span class="hljs-string">&#x27;a&#x27;</span>;
			&#125;
			<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;
				t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();
				t[t[p].nxt[x]].fa = p;
			&#125;
			p = t[p].nxt[x];
			t[p].flag = i;
		&#125;
		<span class="hljs-keyword">return</span> p;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].nxt[x];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].flag;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].cnt;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].fa;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	Trie tr;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		string s;
		cin &gt;&gt; s;
		id[i] = tr.<span class="hljs-built_in">add</span>(s, i);
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-type">int</span> j = id[i];
		<span class="hljs-keyword">while</span> (i == tr.<span class="hljs-built_in">flag</span>(j)) &#123;
			res += tr.<span class="hljs-built_in">cnt</span>(j);
			j = tr.<span class="hljs-built_in">fa</span>(j);
		&#125;
		tr.t[j].cnt++;
		ans += <span class="hljs-number">1</span> - res;
		cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-comment">// fre(test);</span>
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<p>但它 MLE 了，所以还要提前 reserve 一下（唉，卡常。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>



<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;
	<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">28</span>;
	<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2.5e6</span> + <span class="hljs-number">2</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
		<span class="hljs-type">int</span> fa, flag, cnt;
		array&lt;<span class="hljs-type">int</span>, S&gt; nxt;
		<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, flag&#123;<span class="hljs-number">-1</span>&#125;, cnt&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;
	&#125;;
	vector&lt;Node&gt; t;

	<span class="hljs-built_in">Trie</span>() &#123;
		t.<span class="hljs-built_in">reserve</span>(N);
		t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());
		t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);
		t[<span class="hljs-number">1</span>].fa = <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;
		t.<span class="hljs-built_in">emplace_back</span>();
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> i)</span> </span>&#123;
		<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;
			<span class="hljs-type">int</span> x;
			<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;
				x = <span class="hljs-number">26</span>;
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;
				x = <span class="hljs-number">27</span>;
			&#125; <span class="hljs-keyword">else</span> &#123;
				x = c - <span class="hljs-string">&#x27;a&#x27;</span>;
			&#125;
			<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;
				t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();
				t[t[p].nxt[x]].fa = p;
			&#125;
			p = t[p].nxt[x];
			t[p].flag = i;
		&#125;
		<span class="hljs-keyword">return</span> p;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].nxt[x];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].flag;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].cnt;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].fa;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	Trie tr;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		string s;
		cin &gt;&gt; s;
		id[i] = tr.<span class="hljs-built_in">add</span>(s, i);
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-type">int</span> j = id[i];
		<span class="hljs-keyword">while</span> (i == tr.<span class="hljs-built_in">flag</span>(j)) &#123;
			res += tr.<span class="hljs-built_in">cnt</span>(j);
			j = tr.<span class="hljs-built_in">fa</span>(j);
		&#125;
		tr.t[j].cnt++;
		ans += <span class="hljs-number">1</span> - res;
		cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 1B - gym104022 B. The Great Wall】</p><p>题意：给定长为 <span class="math inline">\(n\)</span> 的数组，你需要将其划分为 <span class="math inline">\(k\)</span> 段，定义每段的权值为该段元素的极差，总权值为各段的权值和。对每个 <span class="math inline">\(k=1\sim n\)</span> 给出最大总权值。</p><p><span class="math inline">\(1 \le n \le 10^4\)</span>，<span class="math inline">\(1 \le a_i \le 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>妙妙题，第一步转化就十分 amazing。</p><p>一眼 dp，但每段的极差不好处理。不妨把极差转化为 <span class="math inline">\(\max(将该段一个数 \times 1，一个数 \times -1 后二者的和)\)</span>。</p><p>令 <span class="math inline">\(dp[i][j][k=0\sim3]\)</span> 表示处理了前 <span class="math inline">\(i\)</span> 个数，分成了 <span class="math inline">\(j\)</span> 段，且此时第 <span class="math inline">\(j\)</span> 段的状态为 <span class="math inline">\(k\)</span>。</p><ul><li><span class="math inline">\(k = 0\)</span>：既没有选 <span class="math inline">\(\times1\)</span> 的数，也没有选 <span class="math inline">\(\times -1\)</span> 的数。</li><li><span class="math inline">\(k = 1\)</span>：已经选了 <span class="math inline">\(\times -1\)</span> 的数，但没选 <span class="math inline">\(\times 1\)</span> 的数。</li><li><span class="math inline">\(k = 2\)</span>：已经选了 <span class="math inline">\(\times 1\)</span> 的数，但没选 <span class="math inline">\(\times -1\)</span> 的数。</li><li><span class="math inline">\(k = 3\)</span>：已经选了 <span class="math inline">\(\times 1\)</span> 的数，也选了 <span class="math inline">\(\times -1\)</span> 的数。</li></ul><p>这样就可以转移了，第一维可以滚动。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, vector(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, -inf)))</span></span>;
	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		t ^= <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;
			dp[t][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], 
							  dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);

			dp[t][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>], 
							   dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + a[i], 
							   dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] + a[i]&#125;);

			dp[t][j][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">2</span>], 
							   dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] - a[i], 
							   dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] - a[i]&#125;);

			dp[t][j][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(&#123;dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">3</span>], 
							   dp[t ^ <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], 
							   dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">2</span>] + a[i], 
							   dp[t ^ <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] - a[i]&#125;);
		&#125;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cout &lt;&lt; dp[t][i][<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 1J - gym102920 H. Needle】</p><p>题意：有三条平行 <span class="math inline">\(x\)</span> 轴直线，直线上有缺口，三条直线上的缺口坐标分别给定为 <span class="math inline">\(\{a\},\{b\},\{c\}\)</span>，问有多少组三点共线。</p><p><span class="math inline">\(1 \le n_a,n_b,n_c \le 5\cdot 10^4\)</span>，<span class="math inline">\(-3\cdot10^4 \le a_i,b_i,c_i \le 3\cdot 10^4\)</span>。</p>
          </div>
<div class="note note-success">
            <p>结论：等效于求满足 <span class="math inline">\(a_i+c_k=2\cdot b_j\)</span> 的三元组 <span class="math inline">\((i, j, k)\)</span> 的数量。由中点性质易证。</p><p>移项，得 <span class="math inline">\(a_i - b_j = -c_k + b_j\)</span>。</p><p>将 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(-c_k\)</span> 存到 bitset 中，一个左移 <span class="math inline">\(b_j\)</span> 一个右移 <span class="math inline">\(b_j\)</span>，之后 <span class="math inline">\(\&amp;\)</span> 起来为 <span class="math inline">\(1\)</span> 的位置数目就是所求。</p><p>可以直接调用 bitset 中的 <code>count()</code> 函数，时间复杂度 <span class="math inline">\(O(\frac{n^2}{w})\)</span>。</p><p>注意负数，需要整体加一个数全变为正数。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>



<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6e4</span> + <span class="hljs-number">5</span>;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> eps = <span class="hljs-number">3e4</span>;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> A;
	cin &gt;&gt; A;
	bitset&lt;N&gt; a;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= A; i++) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		a[x + eps] = <span class="hljs-number">1</span>;
	&#125;

	<span class="hljs-type">int</span> B;
	cin &gt;&gt; B;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(B + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= B; i++) &#123;
		cin &gt;&gt; b[i];
	&#125;

	<span class="hljs-type">int</span> C;
	cin &gt;&gt; C;
	bitset&lt;N&gt; c;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= C; i++) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		c[-x + eps] = <span class="hljs-number">1</span>;
	&#125;

	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= B; i++) &#123;
		<span class="hljs-keyword">if</span> (b[i] &gt; <span class="hljs-number">0</span>) &#123;
			ans += ( (a &gt;&gt; b[i]) &amp; (c &lt;&lt; b[i]) ).<span class="hljs-built_in">count</span>();
		&#125; <span class="hljs-keyword">else</span> &#123;
			ans += ( (a &lt;&lt; (-b[i]) ) &amp; (c &gt;&gt; (-b[i]) ) ).<span class="hljs-built_in">count</span>();
		&#125;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>凌晨两点多了，AC 自动机的例题明天再说叭。</p>
<h3 id="day-4">【7.11】 Day 4</h3>
<p>被闹钟闹醒了，困困困，困困困。</p>
<p>上午听课，两个人讲课听起来都很舒服鸭，也不会很困。</p>
<p>一个是 lg，另一个是 QHJ 还是 pmh？昨天没来，不知道 QHJ 长啥样，不知道是谁。</p>
<p>凸包进阶那块感觉理解还差一点，计算几何我认为结合代码来学理论才能有更深的理解。</p>
<p>圆这部分同样，听能听懂，但代码就不知道怎么写了，后面还要自己摸索一下。</p>
<p>11 点不到就结束了。</p>
<p>中午在朝阳吃 ￥16 水煮牛肉，本来想打四星，但肉不过瘾，那就三星半。</p>
<p>回去没补例题，去做昨天队内赛的 C 了，一个多小时调不出来，红温了，睡了半小时。</p>
<hr />
<p>下午队内赛2，我怎么又寄了。5/8（Rank 9）</p>
<p>开完两道究极签到，然后看了眼榜，有人过 D 了，就去看了 D，然后我怎么就看了一个半小时。</p>
<p>怎么大家都会 D，自闭了。一开始想的是也许构造一个 <span class="math inline">\(2 \times 2\)</span> 的就可以。然后脑子烧了，绕来绕去的。</p>
<p>过了一个小时才想到研究一下样例，感觉 <span class="math inline">\(2\times 3\)</span> 可行，就是从 <span class="math inline">\((1, 1)\)</span> 到 <span class="math inline">\((2,2)\)</span> 决策的时候选择错误的 <span class="math inline">\((2,1)\)</span> 而不是 <span class="math inline">\((1,2)\)</span>，但脑子又烧了。</p>
<p>看了下榜，怎么就到第二页了，急了。</p>
<p>去看了 E 和 F，E 马上能注意到满足条件的是一个矩形，但后面没想清楚就交，WA 了两发，不过马上就想清楚了。F 秒了。</p>
<p>直到这会稍微冷静了才会了 D，唉。</p>
<p>又急了，排名还是拉跨，看了下 C，但怎么只剩半小时了，乱交几发，不出意外过不了一点（</p>
<hr />
<p>晚上￥26 炙烤蟹柳寿司，好吃，四星。</p>
<p>然后继续和昨天队内赛 C 搏斗，搏斗完怎么九点了？？？？？</p>
<p>一想到还有好多工作没做就难受。</p>
<hr />
<div class="note note-info">
            <p>【队内赛 1C - gym104022 D. Farm】</p><p>题意：给定一个 <span class="math inline">\(n\)</span> 个点的图，一开始没有边。再给定 <span class="math inline">\(m\)</span> 条边，边有边权，意为联通代价。你需要花最少的代价让图联通，同时必须满足 <span class="math inline">\(q\)</span> 个限制条件。第 <span class="math inline">\(i\)</span> 个条件形如从编号为 <span class="math inline">\(u_i\)</span> 和 <span class="math inline">\(v_i\)</span> 的边中至少选择一条。输出最小代价。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<span class="math inline">\(1 \le m \le 5 \cdot 10^5\)</span>，<span class="math inline">\(0 \le q\le 16\)</span>。</p>
          </div>
<div class="note note-success">
            <p>看 <span class="math inline">\(q\)</span> 范围知二进制枚举，此时直接枚举边做最小生成树，是 <span class="math inline">\(O(2^q \cdot q\cdot m\alpha)\)</span>。</p><p>瓶颈是枚举的边太多了，可以想象 <span class="math inline">\(q\)</span> 既然小，那么在最后的生成树中一定有很多边是确定的，不受限制条件的约束。</p><p>考虑将所有限制条件中的边（即每一个 <span class="math inline">\(u_i\)</span> 和每一个 <span class="math inline">\(v_i\)</span>）都建出来，然后跑最小生成树，此时新建出来的边（以下称作固定边）就是必须要选的。</p><p>那我们继续考虑一个只有固定边的新图 <span class="math inline">\(G\)</span>，此时需要枚举的边是 “两个端点在 <span class="math inline">\(G\)</span> 中不连通的边”。用一个可持久化并查集执行每次加边，到新的二进制状态就回退，能过吗？还是不能，因为边还是太多了，如果每一个孤立点都和其它所有点连边，就是 <span class="math inline">\(O(nq)\)</span> 的边。</p><p>但我们注意到除了孤立点以外的 <span class="math inline">\(G\)</span> 是一个大的连通块，我们用一个 <code>std::map</code> 存联通任意两个连通块的最小边，这样边数就是 <span class="math inline">\(O(q^2)\)</span> 的了。</p><p>时间复杂度 <span class="math inline">\(O(m\log m+2^q \cdot q^2)\)</span> 。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span>


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;
	vector&lt;<span class="hljs-type">int</span>&gt; f, siz;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; ver;
	<span class="hljs-built_in">DSU</span>() &#123;&#125;
	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
		f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);
		<span class="hljs-built_in">iota</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);
		siz.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(f[x]);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		x = <span class="hljs-built_in">find</span>(x);
		y = <span class="hljs-built_in">find</span>(y);
		<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;
			<span class="hljs-built_in">swap</span>(x, y);
		&#125;
		ver.<span class="hljs-built_in">push_back</span>(&#123;x, y, siz[x]&#125;);
		siz[x] += siz[y];
		f[y] = x;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">roll</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;
		<span class="hljs-keyword">while</span> (ver.<span class="hljs-built_in">size</span>() &gt; v) &#123;
			<span class="hljs-keyword">auto</span> [x, y, szx] = ver.<span class="hljs-built_in">back</span>();
			ver.<span class="hljs-built_in">pop_back</span>();
			f[y] = y;
			siz[x] = szx;
		&#125;
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; a;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> x, y, w;
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
		a.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);
	&#125;
	<span class="hljs-type">int</span> q;
	cin &gt;&gt; q;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; choose;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">have_choosed</span><span class="hljs-params">(m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		x--; y--;
		choose.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);
		have_choosed[x] = <span class="hljs-literal">true</span>;
		have_choosed[y] = <span class="hljs-literal">true</span>;
	&#125;

	<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-keyword">if</span> (have_choosed[i]) &#123;
			dsu.<span class="hljs-built_in">merge</span>(a[i][<span class="hljs-number">1</span>], a[i][<span class="hljs-number">2</span>]);
		&#125;
	&#125;

	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; sorted_a = a;
	<span class="hljs-built_in">sort</span>(sorted_a.<span class="hljs-built_in">begin</span>(), sorted_a.<span class="hljs-built_in">end</span>());

	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; must_choose;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : sorted_a) &#123;
		<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">merge</span>(x, y)) &#123;
			must_choose.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);
		&#125;
	&#125;
	
	<span class="hljs-function">DSU <span class="hljs-title">dsu2</span><span class="hljs-params">(n)</span></span>; 
	<span class="hljs-type">int</span> ori_w = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : must_choose) &#123;
		dsu2.<span class="hljs-built_in">merge</span>(x, y);
		ori_w += w;
	&#125;
	<span class="hljs-type">int</span> ori_ver = dsu2.ver.<span class="hljs-built_in">size</span>(); 

	map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; minw;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; waiting_choose;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : sorted_a) &#123;
		<span class="hljs-type">int</span> xx = dsu2.<span class="hljs-built_in">find</span>(x);
		<span class="hljs-type">int</span> yy = dsu2.<span class="hljs-built_in">find</span>(y);
		<span class="hljs-keyword">if</span> (xx == yy) &#123;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-keyword">if</span> (!minw.<span class="hljs-built_in">count</span>(&#123;xx, yy&#125;)) &#123;
			minw[&#123;xx, yy&#125;] = minw[&#123;yy, xx&#125;] = w;
			waiting_choose.<span class="hljs-built_in">push_back</span>(&#123;w, x, y&#125;);
		&#125;
	&#125;

	<span class="hljs-type">int</span> ans = inf;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; q); i++) &#123;
		dsu2.<span class="hljs-built_in">roll</span>(ori_ver);
		<span class="hljs-type">int</span> res = ori_w;
		unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; q; j++) &#123;
			<span class="hljs-type">int</span> edge = choose[j][i &gt;&gt; j &amp; <span class="hljs-number">1</span>];
			<span class="hljs-keyword">if</span> (mp[edge]) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			mp[edge] = <span class="hljs-literal">true</span>;

			<span class="hljs-keyword">auto</span> [w, x, y] = a[edge];
			dsu2.<span class="hljs-built_in">merge</span>(x, y);
			res += w;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, x, y] : waiting_choose) &#123;
			<span class="hljs-keyword">if</span> (dsu2.<span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) == n) &#123;
				<span class="hljs-keyword">break</span>;
			&#125;
			<span class="hljs-keyword">if</span> (dsu2.<span class="hljs-built_in">merge</span>(x, y)) &#123;
				res += w;
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (dsu2.<span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>) == n) &#123;
			ans = <span class="hljs-built_in">min</span>(ans, res);
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> (ans == inf) &#123;
		ans = <span class="hljs-number">-1</span>;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;



<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<p>今天的队内赛明天再补好了，明天又是字符串专题，上次字符串专题还没搞懂一点。</p>
<p>写了下 AC 自动机课件上的五个例题。</p>
<hr />
<div class="note note-info">
            <p>【P5357 【模板】AC 自动机】</p><p>题意：给定一个文本串 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(n\)</span> 个模式串 <span class="math inline">\(T_{1\sim n}\)</span>。求每个模式串在文本串中的出现次数。</p><p><span class="math inline">\(1 \le n,\sum|T| \le 2\cdot 10^5\)</span>，<span class="math inline">\(1\le |S| \le 2\cdot 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>AC 自动机上 fail 指针指向的是最长真后缀。fail 指针构成一棵树。</p><p>那么当一个节点被匹配时，其祖先也被匹配。相当于每次将根到某个单词末尾的一条链上的点 +1。</p><p>可以在树上维护 <code>sz[x]</code>，给 <span class="math inline">\(S\)</span> 对应的链上的点 <code>sz[x]++</code>。</p><p>那么单词末尾对应的节点的 <code>sz</code> 就是它在文本串中的出现次数。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> die(x) &#123; cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;return ;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;
	<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">26</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
		<span class="hljs-type">int</span> len, fail;
		array&lt;<span class="hljs-type">int</span>, S&gt; nxt;
		<span class="hljs-built_in">Node</span>() : len&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;
	&#125;;
	vector&lt;Node&gt; t;

	<span class="hljs-built_in">ACTree</span>() &#123;
		t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());
		t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);
		t[<span class="hljs-number">0</span>].len = <span class="hljs-number">-1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;
		t.<span class="hljs-built_in">emplace_back</span>();
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;
		<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;
			<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;
			<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;
				t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();
				t[t[p].nxt[x]].len = t[p].len + <span class="hljs-number">1</span>;
			&#125;
			p = t[p].nxt[x];
		&#125;
		<span class="hljs-keyword">return</span> p;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;
		queue&lt;<span class="hljs-type">int</span>&gt; q;
		q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;
				<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;
					t[x].nxt[i] = t[t[x].fail].nxt[i];
				&#125; <span class="hljs-keyword">else</span> &#123;
					t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];
					q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);
				&#125;
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].nxt[x];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].fail;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].len;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();
	&#125;
&#125;;


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	ACTree G;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		string s;
		cin &gt;&gt; s;
		id[i] = G.<span class="hljs-built_in">add</span>(s);
	&#125;
	G.<span class="hljs-built_in">work</span>();
	string t;
	cin &gt;&gt; t;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;
		<span class="hljs-type">int</span> x = t[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
		p = G.<span class="hljs-built_in">next</span>(p, x);
		sz[p]++;
	&#125;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;
		adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-built_in">self</span>(self, y);
			sz[x] += sz[y];
		&#125;
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		cout &lt;&lt; sz[id[i]] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;



<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-comment">// fre(test);</span>
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;<span class="hljs-comment">//</span></code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【P3966 [TJOI2013] 单词】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个单词，对每个单词询问在这 <span class="math inline">\(n\)</span> 个单词组成的文章中出现了多少次。</p><p>例如给定 <code>a</code> <code>aa</code> <code>aaa</code>，则第二个单词出现了 <span class="math inline">\(3\)</span> 遍。</p><p><span class="math inline">\(1 \le n \le 200\)</span>，<span class="math inline">\(单词总长度 \le 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>看了样例才读明白题。</p><p>和 AC 自动机模板的区别就是单词之间不能跨越。</p><p>那我们直接在中间插一个特殊字符就行了，其它都一样。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;
	<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">27</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
		<span class="hljs-type">int</span> len, fail;
		array&lt;<span class="hljs-type">int</span>, S&gt; nxt;
		<span class="hljs-built_in">Node</span>() : len&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;
	&#125;;
	vector&lt;Node&gt; t;

	<span class="hljs-built_in">ACTree</span>() &#123;
		t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());
		t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);
		t[<span class="hljs-number">0</span>].len = <span class="hljs-number">-1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;
		t.<span class="hljs-built_in">emplace_back</span>();
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;
		<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;
			<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;
			<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;
				t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();
				t[t[p].nxt[x]].len = t[p].len + <span class="hljs-number">1</span>;
			&#125;
			p = t[p].nxt[x];
		&#125;
		<span class="hljs-keyword">return</span> p;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;
		queue&lt;<span class="hljs-type">int</span>&gt; q;
		q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;
				<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;
					t[x].nxt[i] = t[t[x].fail].nxt[i];
				&#125; <span class="hljs-keyword">else</span> &#123;
					t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];
					q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);
				&#125;
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].nxt[x];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].fail;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].len;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	string t = <span class="hljs-string">&quot;&quot;</span>;

	ACTree G;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		string s;
		cin &gt;&gt; s;
		t += s + <span class="hljs-string">&quot;@&quot;</span>;
		id[i] = G.<span class="hljs-built_in">add</span>(s);
	&#125;
	G.<span class="hljs-built_in">work</span>();
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;
		<span class="hljs-type">int</span> x = t[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
		<span class="hljs-keyword">if</span> (t[i] == <span class="hljs-string">&#x27;@&#x27;</span>) &#123;
			x = <span class="hljs-number">26</span>;
		&#125;
		p = G.<span class="hljs-built_in">next</span>(p, x);
		sz[p]++;
	&#125;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;
		adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-built_in">self</span>(self, y);
			sz[x] += sz[y];
		&#125;
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		cout &lt;&lt; sz[id[i]] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【P2414 [NOI2011] 阿狸的打字机】</p><p>题意：给定一个含 <span class="math inline">\(a\sim z,B,P\)</span> 的字符串 <span class="math inline">\(T\)</span>，现按规则生成字符串集合 <span class="math inline">\(S\)</span>：</p><ul><li>有一个 Cache，初始为空，开始从左到右读取 <span class="math inline">\(T\)</span> 中字符。</li><li>若读取到 <span class="math inline">\(a\sim z\)</span>，在 Cache 中加入相应字符。</li><li>若读取到 <span class="math inline">\(P\)</span>，将 Cache 中的字符串拷贝一份到 <span class="math inline">\(S\)</span> 中。</li><li>若读取到 <span class="math inline">\(B\)</span>，删除 Cache 中最后一次加入的字符。</li></ul><p>给定 <span class="math inline">\(m\)</span> 个询问，每次给定 <span class="math inline">\(x, y\)</span>，询问 <span class="math inline">\(S\)</span> 中的第 <span class="math inline">\(x\)</span> 个字符串在第 <span class="math inline">\(y\)</span> 个字符串中出现了几次。</p><p><span class="math inline">\(1 \le x, y \le 10^5\)</span>，<span class="math inline">\(1 \le m \le 10^5\)</span>，<span class="math inline">\(1 \le |T| \le 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>暴力是对于每一个询问都建 AC 自动机并询问。</p><p>进阶一点可以对于相同的 <span class="math inline">\(y\)</span> 记录所有的 <span class="math inline">\(x\)</span>，这样是一次建树多次询问。</p><p>这里的 “建树” 是指给字符串 <span class="math inline">\(y\)</span> 在 fail 树上对应的链设置 <code>sz</code>。</p><p>还可以更聪明一点，我们思考 <span class="math inline">\(P\)</span> 操作和 <span class="math inline">\(B\)</span> 操作的本质：</p><ul><li><span class="math inline">\(P\)</span> 操作拷贝了一份 Cache，但迫于空间限制我们肯定不能显式储存，于是只储存该字符串的 endpos。</li><li><span class="math inline">\(B\)</span> 操作 “退格” 相当于将当前指针移动到父亲节点的位置。</li></ul><p>这样我们就可以像读取一般字符串一样读取 <span class="math inline">\(T\)</span> 了！</p><p>将 <span class="math inline">\(T\)</span> 放到 AC 自动机上跑，对于 <span class="math inline">\(a\sim z\)</span> 就直接 <code>sz[p]++</code>，删除操作就 <code>sz[p]--</code>。</p><p>对于询问，我们知道 endpos，相当于子树求和，而上一行的两个操作相当于单点加，就有用树状数组维护 <code>sz</code> 的思路了。对着 fail 树进行 dfs，记录 dfn 即可。</p><p>时间复杂度 <span class="math inline">\(O(|T|+m)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fenwick</span> &#123;
	<span class="hljs-type">int</span> n;
	vector&lt;T&gt; tr;
	<span class="hljs-built_in">Fenwick</span>() &#123;&#125;
	<span class="hljs-built_in">Fenwick</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n + <span class="hljs-number">1</span>);&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
		<span class="hljs-keyword">this</span>-&gt;n = n;
		tr.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, (T)&#123;&#125;);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, T x)</span> </span>&#123;
		<span class="hljs-keyword">while</span> (pos &lt;= n) &#123;
			tr[pos] += x;
			pos += pos &amp; -pos;
		&#125;
	&#125;
	<span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;
		T res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> (pos) &#123;
			res += tr[pos];
			pos -= pos &amp; -pos;
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;
	<span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>);
	&#125;
&#125;;


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;
	<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">26</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
		<span class="hljs-type">int</span> fa, fail;
		array&lt;<span class="hljs-type">int</span>, S&gt; nxt;
		<span class="hljs-built_in">Node</span>() : fa&#123;<span class="hljs-number">-1</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;
	&#125;;
	vector&lt;Node&gt; t;
	vector&lt;<span class="hljs-type">int</span>&gt; endpos;

	<span class="hljs-built_in">ACTree</span>() &#123;
		t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());
		t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;
		t.<span class="hljs-built_in">emplace_back</span>();
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;
		<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;
			<span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;P&#x27;</span>) &#123;
				endpos.<span class="hljs-built_in">push_back</span>(p);
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;
				p = t[p].fa;
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;a&#x27;</span>;
				<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;
					t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();
					t[t[p].nxt[x]].fa = p;
				&#125;
				p = t[p].nxt[x];
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;
		queue&lt;<span class="hljs-type">int</span>&gt; q;
		q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;
				<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;
					t[x].nxt[i] = t[t[x].fail].nxt[i];
				&#125; <span class="hljs-keyword">else</span> &#123;
					t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];
					q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);
				&#125;
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].nxt[x];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].fail;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fa</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].fa;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	string t;
	cin &gt;&gt; t;
	ACTree G;
	G.<span class="hljs-built_in">add</span>(t);
	G.<span class="hljs-built_in">work</span>();
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(G.<span class="hljs-built_in">size</span>());
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.<span class="hljs-built_in">size</span>(); i++) &#123;
		adj[G.<span class="hljs-built_in">fail</span>(i)].<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(G.size())</span>, <span class="hljs-title">dfn</span><span class="hljs-params">(G.size())</span></span>;
	<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;
		dfn[x] = ++tim;
		sz[x] = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-built_in">self</span>(self, y);
			sz[x] += sz[y];
		&#125;
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);

	<span class="hljs-type">int</span> m;
	cin &gt;&gt; m;
	vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">qry</span>(G.endpos.<span class="hljs-built_in">size</span>());
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		x--; y--;
		qry[y].<span class="hljs-built_in">push_back</span>(&#123;x, i&#125;);
	&#125;

	<span class="hljs-function">Fenwick&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fen</span><span class="hljs-params">(G.size())</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>, tot = <span class="hljs-number">-1</span>, i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;
		<span class="hljs-keyword">if</span> (t[i] == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;
			fen.<span class="hljs-built_in">add</span>(dfn[p], <span class="hljs-number">-1</span>);
			p = G.<span class="hljs-built_in">fa</span>(p);
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[i] != <span class="hljs-string">&#x27;P&#x27;</span>) &#123;
			p = G.<span class="hljs-built_in">next</span>(p, t[i] - <span class="hljs-string">&#x27;a&#x27;</span>);
			fen.<span class="hljs-built_in">add</span>(dfn[p], <span class="hljs-number">1</span>);
		&#125; <span class="hljs-keyword">else</span> &#123;
			tot++;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [id, qid] : qry[tot]) &#123;
				<span class="hljs-type">int</span> x = G.endpos[id];
				ans[qid] = fen.<span class="hljs-built_in">query</span>(dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>);
			&#125;
		&#125;
	&#125;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;
		cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【P2444 [POI2000] 病毒】</p><p>题意：给定 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(01\)</span> 串，问是否存在一个无限长的 <span class="math inline">\(01\)</span> 串不包含任何一个给定的 <span class="math inline">\(01\)</span> 串作为子串。</p><p><span class="math inline">\(1 \le n \le 2000\)</span>，<span class="math inline">\(1\le \sum|S| \le 3\cdot 10^4\)</span>。</p>
          </div>
<div class="note note-success">
            <p>假定存在这么一个无限长的 <span class="math inline">\(01\)</span> 串，记作 <span class="math inline">\(T\)</span>。</p><p>那么把 <span class="math inline">\(T\)</span> 放到这 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(01\)</span> 串构成的 AC 自动机上跑，一定是不断失配，并且跳 fail 指针跳到的点不在任何 endpos 的子树中。</p><p>为此，我们把所有的 endpos 及其子树都标记为危险节点。具体的，bfs 构建 fail 指针的时候，如果 fail 指针指向的点（最长后缀）是危险节点，那么当前节点就标记为危险。</p><p>因为是无限，所以指针肯定是在一个不存在危险节点的环上绕圈。</p><p>在 next 指针上跑 dfs 找环即可，注意避开危险节点。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ACTree</span> &#123;
	<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> S = <span class="hljs-number">2</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
		<span class="hljs-type">int</span> end, fail;
		array&lt;<span class="hljs-type">int</span>, S&gt; nxt;
		<span class="hljs-built_in">Node</span>() : end&#123;<span class="hljs-number">0</span>&#125;, fail&#123;<span class="hljs-number">0</span>&#125;, nxt&#123;&#125; &#123;&#125;
	&#125;;
	vector&lt;Node&gt; t;

	<span class="hljs-built_in">ACTree</span>() &#123;
		t.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">Node</span>());
		t[<span class="hljs-number">0</span>].nxt.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;
		t.<span class="hljs-built_in">emplace_back</span>();
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(string s)</span> </span>&#123;
		<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;
			<span class="hljs-type">int</span> x = c - <span class="hljs-string">&#x27;0&#x27;</span>;
			<span class="hljs-keyword">if</span> (t[p].nxt[x] == <span class="hljs-number">0</span>) &#123;
				t[p].nxt[x] = <span class="hljs-built_in">newNode</span>();
			&#125;
			p = t[p].nxt[x];
		&#125;
		t[p].end = <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;
		queue&lt;<span class="hljs-type">int</span>&gt; q;
		q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;
				<span class="hljs-keyword">if</span> (t[x].nxt[i] == <span class="hljs-number">0</span>) &#123;
					t[x].nxt[i] = t[t[x].fail].nxt[i];
				&#125; <span class="hljs-keyword">else</span> &#123;
					t[t[x].nxt[i]].fail = t[t[x].fail].nxt[i];
					<span class="hljs-keyword">if</span> (t[t[t[x].nxt[i]].fail].end) &#123;
						t[t[x].nxt[i]].end = <span class="hljs-literal">true</span>;
					&#125;
					q.<span class="hljs-built_in">push</span>(t[x].nxt[i]);
				&#125;
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].nxt[x];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].fail;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isend</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">return</span> t[p].end;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> t.<span class="hljs-built_in">size</span>();
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	ACTree G;
	<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		cin &gt;&gt; s[i];
		G.<span class="hljs-built_in">add</span>(s[i]);
	&#125;
	G.<span class="hljs-built_in">work</span>();

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(G.size())</span>, <span class="hljs-title">circle</span><span class="hljs-params">(G.size())</span></span>;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">int</span> &#123;
		circle[x] = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : &#123;G.<span class="hljs-built_in">next</span>(x, <span class="hljs-number">0</span>), G.<span class="hljs-built_in">next</span>(x, <span class="hljs-number">1</span>)&#125;) &#123;
			<span class="hljs-keyword">if</span> (circle[y]) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			&#125;
			<span class="hljs-keyword">if</span> (vis[y] || G.<span class="hljs-built_in">isend</span>(y)) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			vis[y] = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>(self, y)) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			&#125;
		&#125;	
		circle[x] = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;;
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>)) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;TAK\n&quot;</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;NIE\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>还有一题，但是太难了，我先放着。</p>
<h3 id="day-5">【7.12】 Day 5</h3>
<p>醒了，下床，趴桌上继续睡。</p>
<p>上午按安排徐神讲后缀数组，包大爷讲后缀自动机。因为听起来就高级，我也没接触过，所以打起了十二分精神捏。</p>
<p>先讲后缀数组，刚开始听觉得很有道理，但怎么逐渐听不懂了。也不算逐渐，就徐神讲怎么从长度为 <span class="math inline">\(d\)</span> 扩展到长度为 <span class="math inline">\(2d\)</span> 的时候就懵了（</p>
<p>感觉再听听就懂了，就没问，结果一直懵，懵到最后我不好意思让徐神重新讲了QAQ。</p>
<p>我认为也许是后缀数组本身就很难不容易讲明白。</p>
<p>后面讲后缀自动机我状态就好多了，包大爷发音清晰思维缜密我坐第一排<del>看着它真是大帅辣</del>听它讲真是幸福捏。</p>
<p>中午朝阳￥15 可乐鸡饭，很牛啊，4 星。这个默认给你的饭很少，下次得向阿姨要多一点。</p>
<p>回到宿舍水了下群直接睡了。以往中午我都不怎么睡，但可能昨晚睡比较晚？</p>
<hr />
<p>下午第三次队内赛，我怎么又白给了。4/8（Rank16）</p>
<p>一个小时开了 ABI，然后怎么 C 又坐牢了鸭。</p>
<p>不能算坐牢，这个是刚开始就有思路，但写了一坨还调不对（</p>
<p>wa5，wa6，wa10，tle61...</p>
<p>唉，没想清楚导致的。</p>
<p>D 红晕了，上手就搞了个 <span class="math inline">\(\text{dp[2][N]}\)</span>，我在写什么？？？？</p>
<p>赛后发现 D 和 F 都是 ez，前者一个 dfs，后者直接把差值扔进优先队列。<a target="_blank" rel="noopener" href="https://codeforces.com/gym/535326/submission/270158995">Link-D</a> <a target="_blank" rel="noopener" href="https://codeforces.com/gym/535326/submission/270160661">Link-F</a></p>
<p>这下遥遥落后了。</p>
<p>更自卑了。想似，就这样吧，说不定我的实力真的止于 div2C 了。</p>
<hr />
<p>晚上没吃。</p>
<div class="note note-info">
            <p>【队内赛 3E - CF406D. Hill Climbing】</p><p>题意：有 <span class="math inline">\(n\)</span> 座山，第 <span class="math inline">\(i\)</span> 座山山顶在 <span class="math inline">\((x_i,y_i)\)</span>。如果两个人站在两座山的山顶可以互相看到，则这两座山之间有绳子连接。有 <span class="math inline">\(m\)</span> 支队伍，每队有两个人，每个人都可以通过绳子到达直连的最右边的山顶。现给定每支队伍两个人初始所在的山的编号 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，问他们在哪座山的山顶相遇。</p><p><span class="math inline">\(1 \le n,m \le 10^5\)</span>，<span class="math inline">\(1 \le x_i \le10^7\)</span>，<span class="math inline">\(1 \le y_i \le 10^{11}\)</span>。</p>
          </div>
<div class="note note-success">
            <p>题图画的很清楚，因为选的是尽可能往后连的绳子，所以两个人通过绳子攀爬的路径都是凸的。</p><p>换言之，每座山选择向右到达的山的编号（*）是唯一的，连边能构成一棵树。</p><p>那么答案就是两个人所在点的 LCA。</p><p>（*）可以在求上凸包的过程中处理出来，即栈顶编号。</p><p>时间复杂度 <span class="math inline">\(O(n\log n+m\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;
    <span class="hljs-type">int</span> x, y;
    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;
&#125;;

<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;
    <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;
&#125;
Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(a.x + b.x, a.y + b.y);
&#125;
Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(a.x - b.x, a.y - b.y);
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cross</span><span class="hljs-params">(<span class="hljs-type">const</span> Point &amp;a, <span class="hljs-type">const</span> Point &amp;b)</span> </span>&#123;
    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;
&#125;

<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getUpHull</span><span class="hljs-params">(vector&lt;Point&gt; p)</span> </span>&#123;
    <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">size</span>();
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n)</span></span>;
    vector&lt;<span class="hljs-type">int</span>&gt; h;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
    	<span class="hljs-keyword">while</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">cross</span>(p[i] - p[h.<span class="hljs-built_in">back</span>()], p[i] - p[h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]]) &gt; <span class="hljs-number">0</span>) &#123;
            h.<span class="hljs-built_in">pop_back</span>();
        &#125;
        <span class="hljs-keyword">if</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;
        	nxt[i] = h.<span class="hljs-built_in">back</span>();
        &#125; <span class="hljs-keyword">else</span> &#123;
        	nxt[i] = n - <span class="hljs-number">1</span>;
        &#125;
        h.<span class="hljs-built_in">push_back</span>(i);
    &#125;
    <span class="hljs-keyword">return</span> nxt;
&#125;



<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;Point&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		a[i] = &#123;x, y&#125;;
	&#125;
	vector&lt;<span class="hljs-type">int</span>&gt; nxt = <span class="hljs-built_in">getUpHull</span>(a);
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		adj[nxt[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(i);
	&#125;

	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fa</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>, <span class="hljs-number">0</span>));
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;
		fa[x][<span class="hljs-number">0</span>] = fath;
		dep[x] = dep[fath] + <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= __lg(dep[x]) + <span class="hljs-number">1</span>; i++) &#123;
			fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y != fath) &#123;
				<span class="hljs-built_in">self</span>(self, y, x);
			&#125;
		&#125;
	&#125;;
	<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;
		<span class="hljs-keyword">if</span> (dep[x] &lt; dep[y]) &#123;
			<span class="hljs-built_in">swap</span>(x, y);
		&#125;
		<span class="hljs-keyword">while</span> (dep[x] &gt; dep[y]) &#123;
			x = fa[x][__lg(dep[x] - dep[y])];
		&#125;
		<span class="hljs-keyword">if</span> (x == y) &#123;
			<span class="hljs-keyword">return</span> x;
		&#125; 
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = __lg(dep[x]); i &gt;= <span class="hljs-number">0</span>; i--) &#123;
			<span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i]) &#123;
				x = fa[x][i];
				y = fa[y][i];
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, n, <span class="hljs-number">0</span>);

	<span class="hljs-type">int</span> m;
	cin &gt;&gt; m;
	<span class="hljs-keyword">while</span> (m--) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		cout &lt;&lt; <span class="hljs-built_in">LCA</span>(x, y) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>剩下一个 G，本来不想写的，但题解的做法让人称奇道妙。</p>
<p>但一个多小时了还有几处细节想不清楚，先欠着。</p>
<p>昨天的队内赛还没补，那就补两题。</p>
<hr />
<div class="note note-info">
            <p>【队内赛 2C - CF337D. Book of Evil】</p><p>题意：给定一棵 <span class="math inline">\(n\)</span> 个节点的树，树上有 <span class="math inline">\(m\)</span> 个关键点，点集设为 <span class="math inline">\(S\)</span>。再给定一个整数 <span class="math inline">\(d\)</span>，求满足 <span class="math inline">\(\forall i\in S,dis(x,i)\le d\)</span> 的节点 <span class="math inline">\(x\)</span> 的个数。</p><p><span class="math inline">\(1 \le m\le n\le 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>等价于对于每个点判断离它半径为 <span class="math inline">\(d\)</span> 的范围内是否有 <span class="math inline">\(m\)</span> 个关键点。</p><p>将关键点权值设为 <span class="math inline">\(1\)</span>，其余为 <span class="math inline">\(0\)</span>。就变成了以某个点为中心的范围权值和。</p><p>点分树即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span>


<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mx = <span class="hljs-number">5e6</span>;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
    <span class="hljs-type">int</span> sum;
    Node *ch[<span class="hljs-number">2</span>];
&#125; node[mx]; 
<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;
    Node *rt;
    <span class="hljs-built_in">SegmentTree</span>() &#123;
    	rt = <span class="hljs-literal">NULL</span>;
    &#125;
    <span class="hljs-function">Node *<span class="hljs-title">New</span><span class="hljs-params">()</span> </span>&#123;
    	<span class="hljs-keyword">return</span> &amp;node[cnt++];
    &#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node *&amp;p, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (!p) &#123;
			p = <span class="hljs-built_in">New</span>();
		&#125;
		<span class="hljs-keyword">if</span> (l == r) &#123;
			p-&gt;sum += val;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;
			<span class="hljs-built_in">add</span>(p-&gt;ch[<span class="hljs-number">0</span>], pos, val, l, mid);
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-built_in">add</span>(p-&gt;ch[<span class="hljs-number">1</span>], pos, val, mid + <span class="hljs-number">1</span>, r);
		&#125;
		p-&gt;sum = (p-&gt;ch[<span class="hljs-number">0</span>] ? p-&gt;ch[<span class="hljs-number">0</span>]-&gt;sum : <span class="hljs-number">0</span>) + 
				 (p-&gt;ch[<span class="hljs-number">1</span>] ? p-&gt;ch[<span class="hljs-number">1</span>]-&gt;sum : <span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node *p, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (!p) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		&#125;
		<span class="hljs-keyword">if</span> (l == ql &amp;&amp; r == qr) &#123;
			<span class="hljs-keyword">return</span> p-&gt;sum;
		&#125;
		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (qr &lt;= mid) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">0</span>], ql, qr, l, mid);
		&#125;
		<span class="hljs-keyword">if</span> (ql &gt; mid) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">1</span>], ql, qr, mid + <span class="hljs-number">1</span>, r);
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">0</span>], ql, mid, l, mid) + 
			   <span class="hljs-built_in">query</span>(p-&gt;ch[<span class="hljs-number">1</span>], mid + <span class="hljs-number">1</span>, qr, mid + <span class="hljs-number">1</span>, r);
	&#125;;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, d;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		a[x] = <span class="hljs-number">1</span>;
	&#125;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;

	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">st</span>(<span class="hljs-number">18</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>));
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">lg2</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;
		dep[x] = dep[fath] + <span class="hljs-number">1</span>;
		st[<span class="hljs-number">0</span>][++tim] = x;
		id[x] = tim;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y != fath) &#123;
				<span class="hljs-built_in">self</span>(self, y, x);
				st[<span class="hljs-number">0</span>][++tim] = x;
			&#125;
		&#125;
	&#125;;
	<span class="hljs-keyword">auto</span> Lower = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;
		<span class="hljs-keyword">return</span> dep[x] &lt; dep[y] ? x : y;
	&#125;;
	<span class="hljs-keyword">auto</span> getST = [&amp;] () &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= tim; i++) &#123;
			lg2[i] = lg2[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= tim; i++) &#123;
			<span class="hljs-type">int</span> w = (<span class="hljs-number">1</span> &lt;&lt; i);
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j + w - <span class="hljs-number">1</span> &lt;= tim; j++) &#123;
				st[i][j] = <span class="hljs-built_in">Lower</span>(st[i - <span class="hljs-number">1</span>][j], st[i - <span class="hljs-number">1</span>][j + w / <span class="hljs-number">2</span>]);
			&#125;
		&#125;
	&#125;;
	<span class="hljs-keyword">auto</span> LCA = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;
		x = id[x];
		y = id[y];
		<span class="hljs-keyword">if</span> (x &gt; y) &#123;
			<span class="hljs-built_in">swap</span>(x, y);
		&#125;
		<span class="hljs-type">int</span> i = lg2[y - x + <span class="hljs-number">1</span>];
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Lower</span>(st[i][x], st[i][y - (<span class="hljs-number">1</span> &lt;&lt; i) + <span class="hljs-number">1</span>]);
	&#125;;
	<span class="hljs-keyword">auto</span> dist = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;
		<span class="hljs-keyword">return</span> dep[x] + dep[y] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">LCA</span>(x, y)];
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
	<span class="hljs-built_in">getST</span>();


	<span class="hljs-type">int</span> all = n, rt = <span class="hljs-number">-1</span>;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mx</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> getsz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
        sz[x] = <span class="hljs-number">1</span>;
        mx[x] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
            <span class="hljs-keyword">if</span> (y == fa || vis[y]) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-built_in">self</span>(self, y, x);
            sz[x] += sz[y];
            mx[x] = <span class="hljs-built_in">max</span>(mx[x], sz[y]);
        &#125;
        mx[x] = <span class="hljs-built_in">max</span>(mx[x], all - sz[x]);
        <span class="hljs-keyword">if</span> (mx[x] &lt; mx[rt]) &#123;
            rt = x;
        &#125;
    &#125;;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dsz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dfa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
    <span class="hljs-keyword">auto</span> dfz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
    	vis[x] = <span class="hljs-literal">true</span>;
    	dsz[x] = all;
    	dfa[x] = fa;
    	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
    		<span class="hljs-keyword">if</span> (y == fa || vis[y]) &#123;
    			<span class="hljs-keyword">continue</span>;
    		&#125;
    		all = sz[y];
            mx[rt = <span class="hljs-number">0</span>] = inf;
            <span class="hljs-built_in">getsz</span>(getsz, y, x);
            <span class="hljs-built_in">getsz</span>(getsz, rt, <span class="hljs-number">0</span>);
            <span class="hljs-built_in">self</span>(self, rt, x);
    	&#125;
    &#125;;
    mx[rt = <span class="hljs-number">0</span>] = inf;
    <span class="hljs-built_in">getsz</span>(getsz, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">getsz</span>(getsz, rt, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">dfz</span>(dfz, rt, <span class="hljs-number">0</span>);


    <span class="hljs-function">vector&lt;SegmentTree&gt; <span class="hljs-title">seg1</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">seg2</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
    <span class="hljs-keyword">auto</span> Add = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> val) -&gt; <span class="hljs-type">void</span> &#123;
    	<span class="hljs-type">int</span> now = x;
    	<span class="hljs-keyword">while</span> (now) &#123;
    		<span class="hljs-type">int</span> fa = dfa[now];
    		seg1[now].<span class="hljs-built_in">add</span>(seg1[now].rt, <span class="hljs-built_in">dist</span>(now, x), val, <span class="hljs-number">0</span>, dsz[now]);
    		<span class="hljs-keyword">if</span> (fa) &#123;
    			seg2[now].<span class="hljs-built_in">add</span>(seg2[now].rt, <span class="hljs-built_in">dist</span>(fa, x), val, <span class="hljs-number">0</span>, dsz[fa]);
    		&#125;
    		now = fa;
    	&#125;
    &#125;;
    <span class="hljs-keyword">auto</span> Query = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k) -&gt; <span class="hljs-type">int</span> &#123;
    	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
    	<span class="hljs-type">int</span> now = x, lst = <span class="hljs-number">0</span>;
    	<span class="hljs-keyword">while</span> (now) &#123;
    		<span class="hljs-type">int</span> dt = <span class="hljs-built_in">dist</span>(now, x);
    		<span class="hljs-keyword">if</span> (dt &gt; k) &#123;
    			lst = now;
    			now = dfa[now];
    			<span class="hljs-keyword">continue</span>;
    		&#125;
    		res += seg1[now].<span class="hljs-built_in">query</span>(seg1[now].rt, <span class="hljs-number">0</span>, k - dt, <span class="hljs-number">0</span>, dsz[now]);
    		<span class="hljs-keyword">if</span> (lst) &#123;
    			res -= seg2[lst].<span class="hljs-built_in">query</span>(seg2[lst].rt, <span class="hljs-number">0</span>, k - dt, <span class="hljs-number">0</span>, dsz[now]);
    		&#125;
    		lst = now;
    		now = dfa[now];
    	&#125;
    	<span class="hljs-keyword">return</span> res;
    &#125;;


    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
    	<span class="hljs-keyword">if</span> (a[i]) <span class="hljs-built_in">Add</span>(i, a[i]);
    &#125;
    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
    	ans += <span class="hljs-built_in">Query</span>(i, d) == m;
    &#125;
    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class="note note-success">
            <p>但这题显然有更简单的结论做法。</p><p>类比树的直径的性质：距离树上任意一点最远的点一定是直径两个端点中的一个。</p><p>可以得到结论：距离树上任意一点最远的关键点一定是 “树上距离最远的两个关键点” 中的一个。</p><p>证明需要分类讨论，见 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/bqixrrho">Link</a>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, d;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;	
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;
	<span class="hljs-keyword">auto</span> getdis = [&amp;] (<span class="hljs-type">int</span> rt) &#123;
		vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">dis</span>(n + <span class="hljs-number">1</span>);
		<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
			dis[x] = dis[fa] + <span class="hljs-number">1</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (y == fa) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				<span class="hljs-built_in">self</span>(self, y, x);
			&#125;
		&#125;;
		dis[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;
		<span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);
		<span class="hljs-keyword">return</span> dis;
	&#125;;
	vector&lt;<span class="hljs-type">int</span>&gt; dis1 = <span class="hljs-built_in">getdis</span>(<span class="hljs-number">1</span>);
	<span class="hljs-type">int</span> ml = <span class="hljs-number">0</span>, mr = <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> mxdis = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;
		<span class="hljs-keyword">if</span> (dis1[x] &gt; mxdis) &#123;
			mxdis = dis1[x];
			ml = x;
		&#125;
	&#125;
	vector&lt;<span class="hljs-type">int</span>&gt; dis2 = <span class="hljs-built_in">getdis</span>(ml);
	mxdis = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;
		<span class="hljs-keyword">if</span> (dis2[x] &gt; mxdis) &#123;
			mxdis = dis2[x];
			mr = x;
		&#125;
	&#125;
	dis1 = <span class="hljs-built_in">getdis</span>(mr);

	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (dis1[i] &lt;= d &amp;&amp; dis2[i] &lt;= d) &#123;
			ans++;
		&#125;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class="note note-success">
            <p>上面两种方法一个写起来复杂，一个取巧，那么还有一个比较套路的换根 dp 做法。</p><p>我们钦定 <span class="math inline">\(i\)</span> 为根，定义 <span class="math inline">\(dp_{i,0/1}\)</span>。</p><ul><li><span class="math inline">\(dp_{i,0}\)</span> 代表 <span class="math inline">\(i\)</span> 离与它最远的关键点 <span class="math inline">\(j\)</span> 之间的距离，即最后答案。</li><li><span class="math inline">\(dp_{i,1}\)</span> 代表除 <span class="math inline">\(j\)</span> 所在的 <span class="math inline">\(i\)</span> 的子树外，与 <span class="math inline">\(i\)</span> 距离最远的关键点和 <span class="math inline">\(i\)</span> 之间的距离。</li></ul><p>第一次以 <span class="math inline">\(1\)</span> 为根进行 dfs，同时 <span class="math inline">\(fr_i\)</span> 记录 <span class="math inline">\(dp_{i,0}\)</span> 从哪个节点转移而来：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, -inf))</span></span>;
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">from</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
	<span class="hljs-keyword">if</span> (a[x]) &#123;
		dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
		<span class="hljs-keyword">if</span> (y == fa) &#123;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-built_in">self</span>(self, y, x);
		<span class="hljs-type">int</span> t = dp[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;
			dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];
			dp[x][<span class="hljs-number">0</span>] = t;
			from[x] = y;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;
			dp[x][<span class="hljs-number">1</span>] = t;
		&#125;
	&#125;
&#125;;</code></pre></div><p>此时的 <span class="math inline">\(dp_{i}\)</span> 从节点 <span class="math inline">\(1\)</span> 辐向 <span class="math inline">\(i\)</span> 的一侧拥有符合上述意义的答案。</p><p>考虑换根，从 <span class="math inline">\(fa\to x\)</span>，根据 <span class="math inline">\(fr_{fa}\)</span> 是否等于 <span class="math inline">\(x\)</span>，选择 <span class="math inline">\(dp_{fa,0}\)</span> 或 <span class="math inline">\(dp_{fa,1}\)</span> 进行转移。</p><p>记得此时更新 <span class="math inline">\(dp_{x,0}\)</span> 时也要同步更新 <span class="math inline">\(fr_x\)</span>。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-type">int</span> t;
		<span class="hljs-keyword">if</span> (from[fa] != x) &#123;
			t = dp[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			t = dp[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
		&#125;
		<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;
			dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];
			dp[x][<span class="hljs-number">0</span>] = t;
			from[x] = fa;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;
			dp[x][<span class="hljs-number">1</span>] = t;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fa) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x); 
		&#125;
	&#125;;</code></pre></div><p>不理解可以模拟一下题目的样例，以及将节点 <span class="math inline">\(4\)</span> 也变为关键点的情况。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, d;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		a[x] = <span class="hljs-number">1</span>;
	&#125;	
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;

	<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, -inf))</span></span>;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">from</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">if</span> (a[x]) &#123;
			dp[x][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fa) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x);
			<span class="hljs-type">int</span> t = dp[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;
				dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];
				dp[x][<span class="hljs-number">0</span>] = t;
				from[x] = y;
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;
				dp[x][<span class="hljs-number">1</span>] = t;
			&#125;
		&#125;
	&#125;;
	<span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

	<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-type">int</span> t;
		<span class="hljs-keyword">if</span> (from[fa] != x) &#123;
			t = dp[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			t = dp[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
		&#125;
		<span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">0</span>]) &#123;
			dp[x][<span class="hljs-number">1</span>] = dp[x][<span class="hljs-number">0</span>];
			dp[x][<span class="hljs-number">0</span>] = t;
			from[x] = fa;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; dp[x][<span class="hljs-number">1</span>]) &#123;
			dp[x][<span class="hljs-number">1</span>] = t;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fa) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x); 
		&#125;
	&#125;;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[<span class="hljs-number">1</span>]) &#123;
		<span class="hljs-built_in">dfs2</span>(dfs2, y, <span class="hljs-number">1</span>);
	&#125;

	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (dp[i][<span class="hljs-number">0</span>] &lt;= d) &#123;
			ans++;
		&#125;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>还有一题但是点分树折磨了我两个小时，我要睡觉了。</p>
<p>骗自己罢了，不眠之夜。</p>
<h3 id="day-6">【7.13】 Day 6</h3>
<p>雨一直下。</p>
<h3 id="day-7">【7.14】 Day 7</h3>
<p>雨一直下。</p>
<p>晚上躺在床上突然想通了什么，伟大的一步。</p>
<p>晚上快 22 点多了才下床，笔记本充电器不知道去哪了，应该是在 234。骑车过去拿，但灯都黑了，无功而返，跟 xxx 借了一个。</p>
<p>0 点 35，vp 了昨天的 abc，6/7，G 把板子喂到嘴里了。</p>
<p>就 F 有点意思，写一下。</p>
<hr />
<div class="note note-info">
            <p>题意：给定一棵 <span class="math inline">\(n\)</span> 个点的树，定义 <span class="math inline">\(dis(x, y)\)</span> 为树上 <span class="math inline">\(x,y\)</span> 间的距离。有一个 <span class="math inline">\(n\)</span> 个点的完全图 <span class="math inline">\(G\)</span>，其中 <span class="math inline">\(w(x,y)=dis(x,y)\)</span>。求这个完全图的一个最大权匹配，输出匹配方案。</p><p><span class="math inline">\(2 \le n \le 2\cdot 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>结论：令 <span class="math inline">\(c\)</span> 为树的重心，则满足以下条件的匹配 <span class="math inline">\(S\)</span> 为答案：</p><ul><li><span class="math inline">\(\forall (x_i,y_i)\in S\)</span>，<span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(y_i\)</span> 位于重心两侧。</li></ul>
          </div>
<div class="note note-success">
            <p>证明：拆贡献，令一条边两侧的点数为 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(n-a\)</span>，则该边的贡献为 <span class="math inline">\(\min(a,n-a)\)</span>。因为理想情况点少的这一侧的所有点都能跨过这条边寻找自己的匹配。那么答案的上界就是所有边的贡献和，即 <span class="math inline">\(\sum\min(a,n-a)\)</span>。</p><p>对于重心 <span class="math inline">\(c\)</span>，我们令 <span class="math inline">\(e\)</span> 为以 <span class="math inline">\(c\)</span> 为根的某个子树中的某一条边，此时 <span class="math inline">\(e\)</span> 的两侧中点比较少的一定是远离重心方向的这一侧。 按照我们的理论，这一侧的点只要跨越了这条边寻找匹配就成功了，此时它们匹配了重心另一侧的点，满足条件。</p><p>不难发现对于以 <span class="math inline">\(c\)</span> 为根的每一个子树中的所有边都满足上述条件，达到了贡献最大值，证毕。</p>
          </div>
<div class="note note-success">
            <p>于是我们可以进行如下构造：</p><ul><li>找到树的重心 <span class="math inline">\(c\)</span>，令 <span class="math inline">\(c\)</span> 的若干子树为 <span class="math inline">\(T_1,T_2,\cdots\)</span>。</li><li>令数组 <span class="math inline">\(A=\{T_1 中点的编号,T_2 中点的编号,\cdots\}\)</span>。</li><li>若 <span class="math inline">\(n\)</span> 为偶数，将 <span class="math inline">\(c\)</span> 补在 <span class="math inline">\(A\)</span> 的末尾。</li><li><span class="math inline">\(\forall i\in[0,\frac{n}{2})\)</span>，<span class="math inline">\((A_i,A_{i+\frac{n}{2}})\)</span> 为一个匹配。<span class="math inline">\((0-\text{index})\)</span></li></ul>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mx</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-type">int</span> rt = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">auto</span> getsz = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
		sz[x] = <span class="hljs-number">1</span>;
		mx[x] = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fa) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x);
			sz[x] += sz[y];
			mx[x] = <span class="hljs-built_in">max</span>(mx[x], sz[y]);
		&#125;
		mx[x] = <span class="hljs-built_in">max</span>(mx[x], n - sz[x]);
		<span class="hljs-keyword">if</span> (mx[x] &lt; mx[rt]) &#123;
			rt = x;
		&#125;
	&#125;;	
	<span class="hljs-built_in">getsz</span>(getsz, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

	vector&lt;<span class="hljs-type">int</span>&gt; a;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
		a.<span class="hljs-built_in">push_back</span>(x);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fa) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x);
		&#125;
	&#125;;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;
		<span class="hljs-built_in">dfs</span>(dfs, x, rt);
	&#125;

	<span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;
		a.<span class="hljs-built_in">push_back</span>(rt);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;
		cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[i + n / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h3 id="day-8">【7.15】 Day 8</h3>
<p>10 点 30 的闹钟，10 点 28 醒了，正好提前两分钟下床等着关闹钟（</p>
<p>中午大伙一起去朝阳吃饭，点了个￥16 叉烧鸡，很一般，两星半或者三星。</p>
<p>吃完到 234 打队内赛五。开始前几分钟发现 <code>solved 1 of 11</code>，很乐，截个图发到了群里，然后发现大伙怎么都做过。结果比赛开始就被菜猫换掉了，虽然没换掉也是当成新题做的说。</p>
<hr />
<p>开局直接 A 上手，写着写着怎么不会了。看来以后写题还是得养成想好再动笔的习惯（后有伏笔</p>
<p>第一个小时开了四道签到，唉，爽！再看榜怎么大伙签得比我快这么多鸭。我主要是被那个字符串奇数位升序偶数位降序卡手了，后面灵机一动字母换成数字，然后偶数位取反。唉，差点就没签出来。</p>
<p>J 也是一眼，但怎么又开始 wa3，wa4 了。干脆直接跳转到 F，这不是龙数吗，咔咔咔一顿码，样例忒弱，疯狂提交，最好的结果是 tle6，自闭了。冷静分析了一下但感觉最多就是 2log，更何况还有神秘的势能分析加持，怎么会事呢？</p>
<p>那干脆再跳转到 E，哎呀这不是每个点向直连的编号最小点连边吗，怎么 wa9。红晕了。</p>
<p>中途发现 J 原来是有个 special 的情况，判掉就好了。E 又一通交，终于发现自己连最小生成树都不会写了（</p>
<p>B 过了一堆，但我不是很懂。I 也过了一堆，怎么大伙都会构造。</p>
<p>6/11（Rank 23）收尾，蒸蒸日下了。</p>
<hr />
<p>晚上回朝阳吃了个可乐鸡饭。</p>
<p>回宿舍本来想着洗个澡就回 234 补题，但碰了床就想睡，就睡到了八点多。</p>
<p>洗完澡回到 234，补一题就差不多 CF 了。</p>
<hr />
<div class="note note-info">
            <p>【队内赛 5i. 唉，构造 - gym104160 F. Half Mixed】</p><p>题意：给定正整数 <span class="math inline">\(n,m\)</span>，你需要构造一个 <span class="math inline">\(n\times m\)</span> 的 <span class="math inline">\(01\)</span> 矩阵，使得纯子矩阵个数 <span class="math inline">\(=\)</span> 杂子矩阵个数。</p><p>纯子矩阵指内部只有 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span> 的矩阵。杂子矩阵指内部既有 <span class="math inline">\(0\)</span> 又有 <span class="math inline">\(1\)</span> 的矩阵。</p><p>输出构造方案或报告不存在。</p><p><span class="math inline">\(1\le n,m\le 10^6\)</span>，<span class="math inline">\(1\le \sum n\cdot m\le 5\cdot10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>对于一个 <span class="math inline">\(1\times m\)</span> 的矩形，其子矩阵个数为 <span class="math inline">\(A=\dfrac{m(m + 1)}{2}\)</span>。</p><p>对于一个 <span class="math inline">\(n\times 1\)</span> 的矩形，其子矩阵个数为 <span class="math inline">\(B=\dfrac{n(n + 1)}{2}\)</span>。</p><p>乘法原理，对于 <span class="math inline">\(n\times m\)</span> 的矩形，子矩阵个数为 <span class="math inline">\(C=\dfrac{n(n + 1)}{2}\cdot\dfrac{m(m + 1)}{2}\)</span>。</p><p>那么，纯子矩阵个数 <span class="math inline">\(=\)</span> 杂子矩阵个数 <span class="math inline">\(= \dfrac{C}{2}\)</span>。若 <span class="math inline">\(C\)</span> 为奇数，无法构造。</p><p>否则，<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 至少有一个偶数，不妨令 <span class="math inline">\(A\)</span> 为偶数。根据乘法原理，如果我们能够构造一个拥有 <span class="math inline">\(\dfrac{A}{2}\)</span> 个纯子矩阵（杂子矩阵）的 <span class="math inline">\(1\times m\)</span> 的矩阵。复制 <span class="math inline">\(n\)</span> 份，总纯子矩阵个数就是 <span class="math inline">\(\dfrac{A}{2}\cdot B=\dfrac{C}{2}\)</span>，满足题意。</p><p>而这 <span class="math inline">\(1\times m\)</span> 的矩阵必然由若干 <span class="math inline">\(01\)</span> 段组成，设每段的长度为 <span class="math inline">\(d_i\)</span>，则需要构造 <span class="math inline">\(d_i\)</span> 满足：</p><ul><li><span class="math inline">\(\sum d_i=m\)</span></li><li><span class="math inline">\(\sum \dfrac{d_i(d_i+1)}{2}=\dfrac{A}{2}=\dfrac{m(m+1)}{4}\)</span></li></ul><p>按题解的说法此时贪心从大到小枚举 <span class="math inline">\(d_i\)</span>，就一定会有合适的取值，正确性我并没有想得很透彻。</p><p>我的做法是二分 <span class="math inline">\(d_i\)</span>，设二分出的 <span class="math inline">\(d_i=mid\)</span>，此时剩下 <span class="math inline">\(left-mid\)</span> 段，二式剩下 <span class="math inline">\(T\)</span>。假设每段独立，即 <span class="math inline">\(01010\cdots\)</span>，产生 <span class="math inline">\(left-mid\)</span> 的贡献。那么只要 <span class="math inline">\(\dfrac{mid(mid+1)}{2} \le T-(left-mid)\)</span> 就往更大的方向更新。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	<span class="hljs-type">int</span> all = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
	<span class="hljs-keyword">if</span> (all &amp; <span class="hljs-number">1</span>) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;
		<span class="hljs-keyword">return</span> ;
	&#125;
	cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;
	<span class="hljs-type">bool</span> rev = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span> ((n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;
		<span class="hljs-built_in">swap</span>(n, m);
		rev = <span class="hljs-number">1</span>;
	&#125;

	<span class="hljs-type">int</span> T = m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">4</span>, left = m;
	vector&lt;<span class="hljs-type">int</span>&gt; a;
	<span class="hljs-keyword">while</span> (T) &#123;
		<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = left, res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> (l &lt;= r) &#123;
			<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (mid * (mid + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;= T - (left - mid)) &#123;
				res = mid;
				l = mid + <span class="hljs-number">1</span>;
			&#125; <span class="hljs-keyword">else</span> &#123;
				r = mid - <span class="hljs-number">1</span>;
			&#125;
		&#125;
		T -= res * (res + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
		left -= res;
		a.<span class="hljs-built_in">push_back</span>(res);
	&#125;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-type">int</span> now = <span class="hljs-number">1</span>, ths = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;
		ths ^= <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now; i &lt;= now + x - <span class="hljs-number">1</span>; i++) &#123;
			ans[i] = ths;
		&#125;
		now += x;
	&#125;
	<span class="hljs-keyword">while</span> (now &lt;= m) &#123;
		ths ^= <span class="hljs-number">1</span>;
		ans[now] = ths;
		now++;
	&#125;
	
	<span class="hljs-keyword">if</span> (!rev) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
				cout &lt;&lt; ans[j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m];
			&#125;
		&#125;
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
				cout &lt;&lt; ans[j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];
			&#125;
		&#125;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>晚上打 CF，前三题基本都挺顺利的。</p>
<p>A 冷静了一分钟感觉直接用个 <code>std::multiset</code> 模拟就成，只要不把分离出的 <span class="math inline">\(1\)</span> 塞回去就不会很慢。（赛后发现就我最笨了）</p>
<p>B 注意到一段 <span class="math inline">\(0\)</span> 可以缩成一个 <span class="math inline">\(0\)</span>，<span class="math inline">\(1\)</span> 自然是越多越好，不用处理，最后比较 <span class="math inline">\(1\)</span> 的个数是否 <span class="math inline">\(&gt;\)</span> <span class="math inline">\(0\)</span> 的个数就行。</p>
<p>C 卡了 10 分钟，但很快把样例 <code>bitset</code> 输出了一下，就发现端倪了，每次只要 <span class="math inline">\(0\)</span> 的位次从高位向地位移动就行。</p>
<p>长度就是 <code>popcount(n) + 1</code>。</p>
<p>你说得对，但是：</p>
<div class="note note-warning">
            <p><code>std::__builtin_popcount(S)</code> 不彳亍！</p><p><code>std::__builtin_popcountll(S)</code> 彳亍！</p>
          </div>
<p>浪费了十分钟，警钟长鸣。</p>
<p>D 上手就写了个取两次取完所有点的，看了下榜发现 lyc 和 wbc 都瞬 wa 了，就发现不对劲。</p>
<p>思考了一下，三次取完所有点是不是就行了！很牛啊，写写写，唉，wa 了。</p>
<p>怎么会是呢，是不是要钦定若干条边 dp，看看第三次取哪些。</p>
<p>然后时间很快就过了，唉，好像三次不彳亍！唉，这下不牛了。</p>
<p>怎么大伙都过 D 了，又垫底了。</p>
<hr />
<p>赛后发现这题有 2log，1log，甚至线性的做法，都写写看好了。</p>
<div class="note note-info">
            <p>【CF1988 - D. The Omnipotent Monster Killer】</p><p>题意：给定一棵树，点有点权，意为将该点留下所需的代价。你可以分若干轮将这棵树的所有节点删空，要求每一轮次中，每条边两侧的顶点不能同时被删，每轮结束剩下的点结算代价。问将树删空的最小代价。</p><p><span class="math inline">\(1 \le n \le 3\cdot 10^5\)</span>，<span class="math inline">\(1 \le a_i \le 10^{12}\)</span>。</p>
          </div>
<div class="note note-success">
            <p>【solution - <span class="math inline">\(O(n\log^2n)/O(n\log n)\)</span>】</p><p>可以想象贪心必不优。同时猜测删空所需的轮数并不多，实际不超过 <span class="math inline">\(O(\log n)\)</span> 轮。</p><p>令 <span class="math inline">\(dp_{x, t}\)</span> 代表删空 <span class="math inline">\(x\)</span> 的子树，且在第 <span class="math inline">\(t\)</span> 轮删去 <span class="math inline">\(x\)</span> 的最小代价。</p><p>得到以下转移方程： <span class="math display">\[dp_{x,t}=\sum_{y\in son_x}\left(\min_{t&#39;\neq t}dp_{y, t&#39;}\right)+w_x\times(t+1)\]</span> 答案为 <span class="math inline">\(\min\limits_{i=1}^{\log_n} dp_{1,i}\)</span>。</p><p>暴力枚举 <span class="math inline">\(t\)</span> 和 <span class="math inline">\(t&#39;\)</span> 进行转移，时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><p>虽然 <span class="math inline">\(t&#39;=t\)</span> 不计入答案，但 <span class="math inline">\(t&#39;&lt;t\)</span> 和 <span class="math inline">\(t&#39; &gt; t\)</span> 计入答案。故记录前缀 <span class="math inline">\(\min\)</span> 和后缀 <span class="math inline">\(\min\)</span>，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2log
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;
	<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>))</span></span>;

	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
			dp[x][i] = (i + <span class="hljs-number">1</span>) * a[x];
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fa) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x);
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
				<span class="hljs-type">int</span> mn = inf;
				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">20</span>; j++) &#123;
					<span class="hljs-keyword">if</span> (i == j) &#123;
						<span class="hljs-keyword">continue</span>;
					&#125;
					mn = <span class="hljs-built_in">min</span>(mn, dp[y][j]);
				&#125;
				dp[x][i] += mn;
			&#125;
		&#125;
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
	cout &lt;&lt; *<span class="hljs-built_in">min_element</span>(dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        1log
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;
	<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>))</span></span>;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;

	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
			dp[x][i] = (i + <span class="hljs-number">1</span>) * a[x];
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fa) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x);

			pre[<span class="hljs-number">0</span>] = dp[y][<span class="hljs-number">0</span>];
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
				pre[i] = <span class="hljs-built_in">min</span>(pre[i - <span class="hljs-number">1</span>], dp[y][i]);
			&#125;
			suf[<span class="hljs-number">19</span>] = dp[y][<span class="hljs-number">19</span>];
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">18</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
				suf[i] = <span class="hljs-built_in">min</span>(suf[i + <span class="hljs-number">1</span>], dp[y][i]);
			&#125;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
				<span class="hljs-type">int</span> t = inf;
				<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
					t = <span class="hljs-built_in">min</span>(t, pre[i - <span class="hljs-number">1</span>]);
				&#125;
				<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">19</span>) &#123;
					t = <span class="hljs-built_in">min</span>(t, suf[i + <span class="hljs-number">1</span>]);
				&#125;
				dp[x][i] += t;
			&#125;
		&#125;
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
	cout &lt;&lt; *<span class="hljs-built_in">min_element</span>(dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), dp[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<p>线性我还不会，明日再补。</p>
<hr />
<h3 id="day-9">【7.16】 Day 9</h3>
<p>10 点 35 被闹醒，下床继续睡到 11 点。</p>
<p>朝阳，￥15 烤肉饭两荤两素，感觉素菜和荤菜品种都不如沙河阳光餐厅。</p>
<p>烤肉饭就是烤肉饭的味道，本来是三星，但它那个鸡腿搞得挺好吃，三星半把。</p>
<p>预感到又是坐牢的一天呐米娜桑。</p>
<hr />
<p>猜对了，继续蒸蒸日下。</p>
<p>先是 A 维护得一坨，再是两个半小时没做出 F，糖丸了。</p>
<p>赛后发现 <span class="math inline">\(n\)</span> 怎么是 <span class="math inline">\(5000\)</span> 鸭，下意识以为是 <span class="math inline">\(1e5\)</span> 之类的了。虽然正解也不是 <span class="math inline">\(O(n^2)\)</span> 的，但没准 <span class="math inline">\(O(n^2)\)</span> 就恰好会呢？呜呜。</p>
<p>被 F 红晕了，H 都没仔细看。赛后发现就是 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 互相问，十五分钟秒了（</p>
<p>菜，直接补题吧，没什么好说的。</p>
<hr />
<div class="note note-info">
            <p>【队内赛 6 - F. 迫近的客星 - CF370C. Mittens】</p><p>题意：给定一个 <span class="math inline">\(n\)</span> 个数的数组 <span class="math inline">\(\{a\}\)</span>，你需要寻找 <span class="math inline">\(\{a\}\)</span> 的一个排列 <span class="math inline">\(\{b\}\)</span>（指 <span class="math inline">\(\{b\}\)</span> 和 <span class="math inline">\(\{a\}\)</span> 仅有元素排列顺序不同） 使得满足 <span class="math inline">\(a_i \neq b_i\)</span> 的下标数量尽可能多。</p><p><span class="math inline">\(1 \le n \le 5000\)</span>，<span class="math inline">\(1 \le m \le 100\)</span>。</p>
          </div>
<div class="note note-success">
            <p>结论：将 <span class="math inline">\(\{a\}\)</span> 排序后右移 <span class="math inline">\(\dfrac{n}{2}\)</span> 再复原排序得到 <span class="math inline">\(\{b\}\)</span>。（该题只要求输出映射方案，不需要复原排序）</p><p>很智慧的构造，设 <span class="math inline">\(\{a\}\)</span> 排序之后最长连续段长度为 <span class="math inline">\(d\)</span>，分两种情况讨论：</p><ul><li><p>若 <span class="math inline">\(d \le \left\lfloor\dfrac{n}{2}\right\rfloor\)</span>，如下图。最长段（蓝色）可以错开，剩下的连续段长度都不超过 <span class="math inline">\(d\)</span>，因此可以用其它段（红色）补足空隙，此时上下两个数组就没有重合的地方了。</p><figure><img src="/image/academic/11.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li><li><p>考虑右移 <span class="math inline">\(\dfrac{n}{2}\)</span>，如下图。最长段显然不会重合，其它段用不同颜色进行了标明，意在说明若在空隙的地方（即 <span class="math inline">\(l_2\)</span> 右端）<span class="math inline">\(\{a\}\)</span>，<span class="math inline">\(\{b\}\)</span> 有重合，那么其他段的长度至少要从 <span class="math inline">\(l_1\)</span> 右端开始直到 <span class="math inline">\(l_2\)</span> 右端，长度 <span class="math inline">\(&gt; \dfrac{n}{2}\)</span>，与假设相悖。</p><figure><img src="/image/academic/12.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li><li><p>若 <span class="math inline">\(d &gt; \dfrac{n}{2}\)</span>，如下图。最长段（蓝色）已经不可避免地相交，剩下段（红色）不可能再重叠，因此最大匹配的下标数量为 <span class="math inline">\(n-d\)</span>。</p><figure><img src="/image/academic/13.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li><li><p>考虑右移 <span class="math inline">\(\dfrac{n}{2}\)</span>，如下图。因为右移之后蓝色段 <span class="math inline">\((&gt;\dfrac{n}{2})+\dfrac{n}{2}\to (&gt;n)\)</span> 必然超出右边界，因此剩下的区域仍然要么被 <span class="math inline">\(\{a\}\)</span> 的蓝色段覆盖，要么被 <span class="math inline">\(\{b\}\)</span> 的蓝色段覆盖，取到最大匹配。</p><figure><img src="/image/academic/14.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure></li></ul>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		ans += a[i] != a[(i + n / <span class="hljs-number">2</span>) % n];
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[(i + n / <span class="hljs-number">2</span>) % n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 6 - E. 辞行久远之躯 - CF1242B. 0-1 MST】</p><p>题意：给定一个包含 <span class="math inline">\(n\)</span> 个节点的完全图，以及图中的 <span class="math inline">\(m\)</span> 条长度为 <span class="math inline">\(1\)</span> 的边，其它边长度均为 <span class="math inline">\(0\)</span>。求该图最小生成树的权值。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<span class="math inline">\(1 \le m\le \min(\frac{n(n-1)}{2}, 10^5)\)</span>。</p>
          </div>
<div class="note note-success">
            <p>我们发现大部分的边都是 <span class="math inline">\(0\)</span> 边，换种说法如果只保留图上的 <span class="math inline">\(0\)</span> 边，之后只有少量的边需要我们连接。对于两个全 <span class="math inline">\(0\)</span> 连通块，若用一条 <span class="math inline">\(1\)</span> 边连接它们，那么这一大苟的连通块相当于拥有权值为 <span class="math inline">\(1\)</span> 的最小生成树。</p><p>同理，若该图全 <span class="math inline">\(0\)</span> 连通块的个数为 <span class="math inline">\(c\)</span>，那么需要用 <span class="math inline">\(c-1\)</span> 条 <span class="math inline">\(1\)</span> 边连接它们使整个图联通，这个图的最小生成树的权值自然就是 <span class="math inline">\(c-1\)</span>。</p><p>现在考虑求 <span class="math inline">\(c\)</span>。以下面的 <span class="math inline">\(K_4\)</span> 完全图（图A）为例：</p><figure><img src="/image/academic/21.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>其中红色虚边为 <span class="math inline">\(0\)</span> 边，绿色实边为 <span class="math inline">\(1\)</span> 边。我们按照编号顺序依次遍历 <span class="math inline">\(1\sim n\)</span>，关注连通块的变化。</p><p>一开始有节点 <span class="math inline">\(1\)</span>，全 <span class="math inline">\(0\)</span> 连通块默认为 <span class="math inline">\(1\)</span>。现在加进来节点 <span class="math inline">\(2\)</span>，如何判断全 <span class="math inline">\(0\)</span> 连通块个数是否增加？</p><p>要知道，<span class="math inline">\(0\)</span> 边数量是极多的，我们不能遍历 <span class="math inline">\(0\)</span> 边，我们能操作的只有 <span class="math inline">\(1\)</span> 边。那么遍历与 <span class="math inline">\(2\)</span> 相连的 <span class="math inline">\(1\)</span> 边，发现没有（目前只考虑节点 <span class="math inline">\(1,2\)</span> 构成的子图，所以连向右侧的 <span class="math inline">\(1\)</span> 边暂不考虑）。那么自然全是 <span class="math inline">\(0\)</span> 边，用并查集把 <span class="math inline">\(1,2\)</span> 连起来，全 <span class="math inline">\(0\)</span> 连通块个数不变。</p><p>现在加进来节点 <span class="math inline">\(3\)</span>，发现存在 <span class="math inline">\(1\)</span> 边 <span class="math inline">\((1,3)\)</span> 和 <span class="math inline">\((2,3)\)</span>。我们不妨用一个标记数组 <code>cnt</code> 标记一下，即对于 <span class="math inline">\(1\)</span> 边 <span class="math inline">\(x\to y(y &lt; x)\)</span> 有 <code>cnt[dsu.find(y)]++</code>。接着我们遍历先前的连通块，判断是否有连通块 <span class="math inline">\(x\)</span> 的大小 <code>dsu.size(x)</code> 比 <code>cnt[x]</code> 大。因为两个点之间不是 <span class="math inline">\(1\)</span> 边就是 <span class="math inline">\(0\)</span> 边，如果 <code>dsu.size(x)</code> 更大，说明向这个连通块连的边有 <span class="math inline">\(0\)</span> 边，进一步说明全 <span class="math inline">\(0\)</span> 连通块的个数没有增加，如下图（图B）。</p><figure><img src="/image/academic/22.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>该图满足 <code>dsu.size(1) = 2 &gt; cnt[1] = 1</code>。此时节点 <span class="math inline">\(3\)</span> 的加入不影响全 <span class="math inline">\(0\)</span> 连通块个数，直接用并查集并起来。</p><p>而图 A 则是 <code>dsu.size(1) = 2 &lt;= cnt[1] = 2</code>。此时全 <span class="math inline">\(0\)</span> 连通块个数 <span class="math inline">\(+1\)</span>。</p><p>现在会了怎么判断全 <span class="math inline">\(0\)</span> 连通块个数增加，那会不会减少呢？</p><figure><img src="/image/academic/23.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>这是添加节点 <span class="math inline">\(5\)</span> 之后的另一个例子，不难看出此时全 <span class="math inline">\(0\)</span> 连通块数量发生了 <span class="math inline">\(2\to 1\)</span> 的变化。</p><p>那我们动态维护这个数值就有点困难了。但我们只关心最后的结果：节点 <span class="math inline">\(5\)</span> 添加，老样子判断 <code>dsu.size(1) = 2 &gt; cnt[1] = 0</code> 且 <code>dsu.size(3) = 2 &gt; cnt[3] = 0</code>，就把 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(5\)</span>，<span class="math inline">\(3\)</span> 和 <span class="math inline">\(5\)</span> 所在的连通块并起来了。此时对于节点 <span class="math inline">\(1\sim 5\)</span>，恰有一个满足 <code>dsu.find(i) = i</code>。这启示我们最后的答案就是 <code>dsu.find(i) = i</code> 的节点的个数，不必动态维护连通块个数。</p><p>复杂度分析：对于每个节点，都有并或不并。合并显然最多 <span class="math inline">\(n\)</span> 次；而不合并，那么该节点至少和先前的连通块存在一条 <span class="math inline">\(1\)</span> 边，<span class="math inline">\(1\)</span> 边一共有 <span class="math inline">\(m\)</span> 条。因此是 <span class="math inline">\(O(n\alpha+m)\)</span> 的。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;
	vector&lt;<span class="hljs-type">int</span>&gt; f, siz;
	<span class="hljs-built_in">DSU</span>() &#123;&#125;
	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
		f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);
		siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;
			f[i] = i;
			siz[i] = <span class="hljs-number">1</span>;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;
		<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		x = <span class="hljs-built_in">find</span>(x);
		y = <span class="hljs-built_in">find</span>(y);
		<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;
			<span class="hljs-built_in">swap</span>(x, y);
		&#125;
 		siz[x] += siz[y];
		f[y] = x;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];
	&#125;
&#125;;



<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;
	<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;
	vector&lt;<span class="hljs-type">int</span>&gt; rt;
	map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cnt.<span class="hljs-built_in">clear</span>();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[i]) &#123;
			<span class="hljs-keyword">if</span> (x &lt; i) &#123;
				cnt[dsu.<span class="hljs-built_in">find</span>(x)]++;
			&#125;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : rt) &#123;
			x = dsu.<span class="hljs-built_in">find</span>(x);
			<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">size</span>(x) &gt; cnt[x]) &#123;
				dsu.<span class="hljs-built_in">merge</span>(x, i);
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">find</span>(i) == i) &#123;
			rt.<span class="hljs-built_in">push_back</span>(i);
		&#125;
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		ans += dsu.<span class="hljs-built_in">find</span>(i) == i;
	&#125;
	cout &lt;&lt; ans - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 6 - G. 我们终将重逢 - CF1117D. Magic Gems】</p><p>题意：有无数个魔法宝石，每个魔法宝石可以分解成 <span class="math inline">\(m\)</span> 个普通宝石，两种宝石都占据 <span class="math inline">\(1\)</span> 的空间，后者不能再被分解。问有多少种分解方案，可以使最后得到的宝石恰好占据 <span class="math inline">\(n\)</span> 个空间。两种分解方案不同当且仅当分解的魔法宝石数量不同，或者是所用宝石的编号不同。答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p><p><span class="math inline">\(1 \le n \le 10^{18}\)</span>，<span class="math inline">\(2 \le m \le 100\)</span>。</p>
          </div>
<div class="note note-success">
            <p>可以将题目概括为用若干个 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(0\)</span> 和若干个 <span class="math inline">\(1\)</span> 组成的长为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 串计数。</p><p>不妨令 <span class="math inline">\(f_i\)</span> 代表长为 <span class="math inline">\(i\)</span> 的这样的串的数目，则转移为： <span class="math display">\[f_i = \begin{cases}1&amp;, i &lt; m \\f_{i - 1} + f_{i - m}&amp;, \text{otherwise}\end{cases}\]</span> 意为可以在长为 <span class="math inline">\(i-1\)</span> 的串末尾加 <span class="math inline">\(1\)</span> 或长为 <span class="math inline">\(i-m\)</span> 的串末尾加 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(0\)</span> 来达到该状态。</p><p>取其中 <span class="math inline">\(f_i\)</span> 和 <span class="math inline">\(f_{i-m}\)</span>，列出在它们之间的转移式如下： <span class="math display">\[\begin{align}f_i = 1\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 1\cdot f_{i - m} \\f_{i-1} = 1\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\f_{i-2} = 0\cdot f_{i - 1}+1\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\f_{i-3} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 1\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\\vdots \\f_{i-m+2} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+1\cdot f_{i - m + 2} + 0\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\f_{i-m+1} = 0\cdot f_{i - 1}+0\cdot f_{i - 2}+ 0\cdot f_{i - 3} + \cdots&amp;+0\cdot f_{i - m + 2} + 1\cdot f_{i - m + 1} + 0\cdot f_{i - m} \\\end{align}\]</span> 取系数矩阵，得到可以用矩阵快速幂加速的转移形式： <span class="math display">\[\begin{bmatrix}f_i \\f_{i-1} \\\vdots \\f_{i-m+2} \\f_{i+m-1}\end{bmatrix}=\begin{bmatrix}1&amp; &amp; &amp; &amp; &amp;1\\1&amp; &amp; &amp; &amp; &amp; \\ &amp;1&amp; &amp; &amp; &amp; \\ &amp; &amp;\ddots&amp; &amp; &amp;\\ &amp; &amp; &amp;1&amp; &amp; \\ &amp; &amp; &amp; &amp;1&amp; \\\end{bmatrix}\begin{bmatrix}f_{i-1} \\f_{i-2} \\\vdots \\f_{i-m+1} \\f_{i-m}\end{bmatrix}\]</span> 时间复杂度 <span class="math inline">\(O(m^3\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span> &#123;
	<span class="hljs-type">int</span> n, m;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a;
	<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(n), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)) &#123;&#125;
	<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)) &#123;&#125;
	<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, k)) &#123;&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;
				cin &gt;&gt; a[i][j];
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;
				cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(n, m); i++) &#123;
			a[i][i] = <span class="hljs-number">1</span>;
		&#125;
	&#125;
	<span class="hljs-function">matrix <span class="hljs-title">tp</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(m, n)</span></span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;
				z.a[j][i] = a[i][j];
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> z;
	&#125;
&#125;;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> matrix &amp;x, <span class="hljs-type">const</span> matrix &amp;y) &#123;
	<span class="hljs-built_in">assert</span>(x.m == y.n);
	<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(x.n, y.m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; x.m; k++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.n; i++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; y.m; j++) &#123;
				z.a[i][j] += x.a[i][k] * y.a[k][j] % modp;
				z.a[i][j] %= modp;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> z;
&#125;
<span class="hljs-function">matrix <span class="hljs-title">qpow</span><span class="hljs-params">(matrix a, <span class="hljs-type">int</span> k)</span> </span>&#123;
	<span class="hljs-built_in">assert</span>(a.n == a.m);
	<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(a.n)</span></span>;
	z.<span class="hljs-built_in">build</span>();
	<span class="hljs-keyword">for</span> ( ; k; k &gt;&gt;= <span class="hljs-number">1</span>, a = a * a) &#123;
		<span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) z = z * a;
	&#125;
	<span class="hljs-keyword">return</span> z;
&#125;



<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	<span class="hljs-keyword">if</span> (n &lt; m) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;1\n&quot;</span>;
		<span class="hljs-keyword">return</span> ;
	&#125;
	<span class="hljs-function">matrix <span class="hljs-title">G</span><span class="hljs-params">(m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;
		G.a[i + <span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;
	&#125;
	G.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
	G.a[<span class="hljs-number">0</span>][m - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
	matrix ans = <span class="hljs-built_in">qpow</span>(G, n - m + <span class="hljs-number">1</span>) * <span class="hljs-built_in">matrix</span>(m, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
	cout &lt;&lt; ans.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="day-10">【7.17】 Day 10</h3>
<p>床起晚了，还下雨，直接赶到教室了。</p>
<p>上午徐神和包爷讲字符串专题。</p>
<p>虽然此前想象过，但事实是除了 C 这个签到之外其它题都没听懂 QAQ</p>
<p>甚至 C 的证明也没怎么懂，不知道会字符串的那帮人脑子是怎么转的。</p>
<p>慢慢来吧。</p>
<p>午饭外卖搞了个￥22 方便面炒鸡，肉给的很多，性价比在线，吃起来也香，四星半。</p>
<p>中午倒头就睡，一直在梦里的感觉真好鸭。</p>
<hr />
<p>又到了悲闻哀见的队内赛时间。</p>
<p>开局 wa，难崩。</p>
<p>半小时开完三道签到，然后转向 C。一看就是分类讨论，这种题我一直捏不准，所以写的格外有条理。</p>
<p>大概写了二十来分钟，交！wa3！尼玛！果断拍！卧槽怎么十万组没拍出来！啊？</p>
<p>后面终于发现是最开始的特判错了！因为对拍很难拍无解我就略过了！唉，浪费了半小时左右。</p>
<p>然后看 B，啊？又是分类讨论？写！交！wa50！啊？？？？？？？？？？</p>
<p>不知道为什么刚刚 C 拍的这么果断我这时候又犹豫了，开始手动检查逻辑，不出意外没检查出来。</p>
<p>磨磨唧唧了半天才拍，结果一下就拍出来了，是一个非常细的地方。</p>
<p>这次竟然浪费了 40 分钟，尼玛的。那只剩 25 分钟看 H 那个构造了，思前想后感觉只能知道后 <span class="math inline">\(n-k+1\)</span> 个数和第 <span class="math inline">\(k\)</span> 个数的大小关系，不知道前 <span class="math inline">\(1\sim k-1\)</span> 个数。结束了，后面看了题解大呼智慧。</p>
<hr />
<p>晚上和沙河的大伙一起去吃了 Kingburger！拼了鸡块和汉堡，我又搞了个 9.9 的 1+1，爽了。</p>
<p>味道不知道怎么评价，毕竟汉堡就是汉堡的味道，薯条就是薯条的味道，甜辣酱就是甜辣酱的味道。就好比在广西三品王就是三品王味，粉之都就是粉之都味一样，从小吃到大的东西，平时啥时候灵机一动就想吃，吃了上顿又不想吃下顿。</p>
<p>吃完和 xxx 回到基础实验大楼补题。</p>
<hr />
<div class="note note-info">
            <p>【队内赛 7 - H. 再多看一眼就会爆炸 - CF1720D. Strange Device】</p><p>题意：交互题。系统初始一个长为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(\{a\}\)</span>，保证所有元素互不相同。给定正整数 <span class="math inline">\(k\)</span>，你每次可以询问 <span class="math inline">\(k\)</span> 个不同的下标，系统会返回对应的 <span class="math inline">\(k\)</span> 个数中的第 <span class="math inline">\(m\)</span> 小的数的下标和值。最多可以询问 <span class="math inline">\(n\)</span> 次，需要让你猜出 <span class="math inline">\(m\)</span>。</p><p><span class="math inline">\(1 \le k &lt; n \le 500\)</span>，<span class="math inline">\(1 \le a_i \le 10^9\)</span>。保证 <span class="math inline">\(1 \le m \le k\)</span>。</p>
          </div>
<div class="note note-success">
            <p>据说有做法能只用下标而不用值，很牛。这里只说最简单的做法（不一定最容易想）</p><p>一种消耗 <span class="math inline">\(k+1\le n\)</span> 次询问的方案如下：</p><ul><li>只取前 <span class="math inline">\(k+1\)</span> 个数，其余部分可以扔掉。</li><li>第 <span class="math inline">\(i\)</span> 次询问序列：<span class="math inline">\([1,i-1]\land[i+1,k+1]\)</span>。</li><li>不难发现答案只会有两个值，分别是这 <span class="math inline">\(k+1\)</span> 个数的第 <span class="math inline">\(m\)</span> 小数和第 <span class="math inline">\(m+1\)</span> 小数。当去掉的数 <span class="math inline">\(a_i \le m\)</span> 时询问到的就是后者，否则前者。</li><li>那么第 <span class="math inline">\(m + 1\)</span> 小数被询问到的次数恰好是 <span class="math inline">\(m\)</span>。取这上述两个值中的较大者，出现次数就是答案。</li></ul>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, k;
	cin &gt;&gt; n &gt;&gt; k;
	<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;! 1&quot;</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> ;
	&#125;
	<span class="hljs-keyword">auto</span> query = [&amp;] (<span class="hljs-type">int</span> pos) -&gt; array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) &#123;
			<span class="hljs-keyword">if</span> (i == pos) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
		&#125;
		cout &lt;&lt; endl;
		<span class="hljs-type">int</span> id, x;
		cin &gt;&gt; id &gt;&gt; x;
		<span class="hljs-keyword">return</span> &#123;id, x&#125;;
	&#125;;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(k + <span class="hljs-number">2</span>);
	map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) &#123;
		a[i] = <span class="hljs-built_in">query</span>(i);
		mp[a[i][<span class="hljs-number">1</span>]]++;
	&#125; 
	<span class="hljs-type">int</span> ans;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, x] : mp) &#123;
		ans = x;
	&#125;
	cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();		
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 7 - D. 这种感觉我从未有 - CF1720D. Cut and Stick】</p><p>题意：给定长为 <span class="math inline">\(n\)</span> 的数组以及 <span class="math inline">\(q\)</span> 次询问。每次询问一个区间 <span class="math inline">\([l, r]\)</span>，问把该区间最少分为几个子序列，使每个子序列（设长度为 <span class="math inline">\(len\)</span>）众数的出现次数 <span class="math inline">\(\le \left\lceil\frac{len}{2}\right\rceil\)</span>。</p><p><span class="math inline">\(1\le n,q,a_i \le 3\cdot 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>设区间长度为 <span class="math inline">\(len\)</span>，众数的出现次数是 <span class="math inline">\(x\)</span>。若 <span class="math inline">\(x\le \left\lceil\frac{len}{2}\right\rceil\)</span>，答案是 <span class="math inline">\(1\)</span>。否则考虑分组，一种最优方案如下：</p><ul><li>其它非众数一共有 <span class="math inline">\(len-x\)</span> 个，将其与 <span class="math inline">\(len-x+1\)</span> 个众数组合，因为此时长度是奇数，故组合后的序列是合法的。</li><li>剩下的众数有 <span class="math inline">\(x-(len-x+1)=2x-len-1\)</span> 个，每个众数单独一组。</li><li>此时有了 <span class="math inline">\(2x-len\)</span> 组，可以证明这是最优的。</li></ul><p>证明就是此时划分成的每个子序列 "众数 <span class="math inline">\(-\)</span> 非众数" 都达到了最大值 <span class="math inline">\(1\)</span>，为最饱和的状态。</p><p>剩下的问题就变成了典题 “求区间众数个数“，常用莫队和主席树。</p><p>同时众数因为有比较强的数量特征，随机化取众数也是十分可行的。这在数据结构专题 <span class="math inline">\(L\)</span> 题有充分体现。</p><p>两种方法的时间复杂度分别是 <span class="math inline">\(O((n+q)\log n)\)</span> <span class="math inline">\(\text{and}\)</span> <span class="math inline">\(O(n+Aq\log n)\)</span>，<span class="math inline">\(A\)</span> 为常数。</p><p>我这里糅合<del>(懒)</del>了一下，写了个莫队 <span class="math inline">\(+\)</span> 随机化，<span class="math inline">\(O(q\log n+Aq\sqrt{n})\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>

<span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rand</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">rng</span>() % (r - l + <span class="hljs-number">1</span>) + l;
&#125;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, q;
	cin &gt;&gt; n &gt;&gt; q;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">qry</span>(q);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;
		<span class="hljs-type">int</span> l, r;
		cin &gt;&gt; l &gt;&gt; r;
		qry[i] = &#123;l, r, i&#125;;
	&#125;

	<span class="hljs-type">int</span> sz = n / <span class="hljs-built_in">sqrtl</span>(<span class="hljs-number">1.0</span> * q * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>);
	<span class="hljs-built_in">sort</span>(qry.<span class="hljs-built_in">begin</span>(), qry.<span class="hljs-built_in">end</span>(),
		 [&amp;] (array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; i, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; j) &#123;
		 <span class="hljs-keyword">if</span> (i[<span class="hljs-number">0</span>] / sz == j[<span class="hljs-number">0</span>] / sz) &#123;
		 	<span class="hljs-keyword">if</span> ((i[<span class="hljs-number">0</span>] / sz) % <span class="hljs-number">2</span>) &#123;
		 		<span class="hljs-keyword">return</span> i[<span class="hljs-number">1</span>] &lt; j[<span class="hljs-number">1</span>];
		 	&#125; <span class="hljs-keyword">else</span> &#123;
		 		<span class="hljs-keyword">return</span> i[<span class="hljs-number">1</span>] &gt; j[<span class="hljs-number">1</span>];
		 	&#125;
		 &#125; <span class="hljs-keyword">else</span> &#123;
		 	<span class="hljs-keyword">return</span> i[<span class="hljs-number">0</span>] / sz &lt; j[<span class="hljs-number">0</span>] / sz;
		 &#125;
	&#125;) ;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;

	<span class="hljs-keyword">auto</span> add = [&amp;] (<span class="hljs-type">int</span> x) &#123;
		cnt[a[x]]++;
	&#125;;
	<span class="hljs-keyword">auto</span> del = [&amp;] (<span class="hljs-type">int</span> x) &#123;
		cnt[a[x]]--;
	&#125;;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;
	<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [ql, qr, id] : qry) &#123;
		<span class="hljs-keyword">while</span> (l &gt; ql) &#123;
			<span class="hljs-built_in">add</span>(--l);
		&#125;
		<span class="hljs-keyword">while</span> (l &lt; ql) &#123;
			<span class="hljs-built_in">del</span>(l++);
		&#125;
		<span class="hljs-keyword">while</span> (r &lt; qr) &#123;
			<span class="hljs-built_in">add</span>(++r);
		&#125;
		<span class="hljs-keyword">while</span> (r &gt; qr) &#123;
			<span class="hljs-built_in">del</span>(r--);
		&#125;

		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;
			<span class="hljs-type">int</span> pos = <span class="hljs-built_in">Rand</span>(l, r);
			<span class="hljs-keyword">if</span> (cnt[a[pos]] &gt; (r - l + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>) &#123;
				ans[id] = <span class="hljs-number">2</span> * cnt[a[pos]] - (r - l + <span class="hljs-number">1</span>);
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (!ans[id]) &#123;
			ans[id] = <span class="hljs-number">1</span>;
		&#125;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;
		cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="day-11">【7.18】 Day 11</h3>
<p>起床了吗？如起。</p>
<p>午饭没吃，起床直接传送到 234 了。</p>
<hr />
<p>下午 5h 队内赛。</p>
<p>前面稳扎稳打，比赛不到一半开了 6 题，自我感觉还是不错的。</p>
<p>然后就急转直下了，后面都在杠 F，怎么大家都会做？</p>
<p>赛后发现原来是我刚看 F 就得出了一个错误的结论 ”边界四个角只能选一个“，因为数据范围比较小后面我就往二分想了。这也太蠢了。</p>
<p>但二分的话最密也只能压缩到 <span class="math inline">\(9\sim10\)</span> 次左右，红晕了。</p>
<p>最后半小时看了下榜随便开了个 K，看样例猜了个 BSGS，不出意料 wa2 了。</p>
<hr />
<p>赛后 Vingying 讲题，思路很清晰鸭，甚至还有回放，爱了！期待下一次 vy 场OwO！</p>
<p>晚上跟 xxx 和 jbx 出去麦。</p>
<p>麦完回来又睡了，虽然很不情愿，一堆题没补，字符串也没看，但还是想打 CF 的时候能精神一点。</p>
<hr />
<p>两个小时醒来 CF 继续唐！B 样例都没读懂代码就写完了，wa2 之后又搞到第 35 分钟才搞对。</p>
<p>C 一个简单 dp，也想了一个来小时。</p>
<p>剩半个小时，看了眼榜感觉 E 有希望，盲猜硬贪什么的。</p>
<p>结果把 xor 看成 or 了，完蛋。赛后发现是原，原题我还 AC 过，唐！</p>
<hr />
<p>先从队内赛开始补，感觉 vy 选的题很有 edu 意义。CF 的题择日吧。</p>
<div class="note note-info">
            <p>【队内赛 8 - C. ズッコケ問答 - gym103469E. Eulerian?】</p><p>题意：交互题。系统隐藏了一个 <span class="math inline">\(n\)</span> 个点的无向连通图 <span class="math inline">\(G\)</span>，保证没有重边和自环。</p><p>你可以进行至多 <span class="math inline">\(60\)</span> 次询问，每次询问 <span class="math inline">\(G\)</span> 中一个点集，系统会返回该点集构成的导出子图的边数。</p><p>你的目标是确定 <span class="math inline">\(G\)</span> 中是否存在一条欧拉回路。交互器不会自适应。</p><p><span class="math inline">\(3 \le n \le 10^4\)</span>，保证 <span class="math inline">\(G\)</span> 中边数不超过 <span class="math inline">\(10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>交互器无法自适应（即 <span class="math inline">\(G\)</span> 不会随着询问而变化）提示我们采用随机化方法。</p><p>一个无向图存在欧拉回路的充要条件是所有顶点的度均为偶数。</p><p>我们考虑将 <span class="math inline">\(G\)</span> 中的顶点随机分成两个集合 <span class="math inline">\(A, B\)</span>。此时 <span class="math inline">\(G\)</span> 中的边被分成了三部分：在 <span class="math inline">\(A\)</span> 的导出子图中，在 <span class="math inline">\(B\)</span> 的导出子图之中，以及横跨在 <span class="math inline">\(A, B\)</span> 两个点集之间。</p><p>如果 <span class="math inline">\(A\)</span> 中的顶点的度均为偶数，那么 <span class="math inline">\(A\)</span> 中所有顶点的度数和也为偶数，又因为在 <span class="math inline">\(A\)</span> 中的边每条贡献 <span class="math inline">\(2\)</span> 的度数，不改变奇偶性，那么横跨在 <span class="math inline">\(A,B\)</span> 之间的边也应该是偶数条。</p><p>故有如下询问方案：</p><ul><li>消耗 <span class="math inline">\(1\)</span> 次询问所有的 <span class="math inline">\(n\)</span> 个点，得到 <span class="math inline">\(G\)</span> 的总边数。</li><li>重复 <span class="math inline">\(29\)</span> 次将 <span class="math inline">\(G\)</span> 随机划分成 <span class="math inline">\(A,B\)</span>。消耗 <span class="math inline">\(29\cdot2\)</span> 次分别询问 <span class="math inline">\(A,B\)</span> 导出子图中的边数，从而用总边数减去它们得到横跨边的数量。</li><li>若至少 <span class="math inline">\(1\)</span> 次询问到了 <span class="math inline">\(A,B\)</span> 间有奇数条横跨边，判定不存在欧拉回路；反之存在。</li></ul><p>正确性证明：横跨边数目为奇数或偶数各占 <span class="math inline">\(\frac{1}{2}\)</span> 概率，<span class="math inline">\(29\)</span> 次判定仍旧失败的概率为 <span class="math inline">\(\frac{1}{2^{29}}\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>


<span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n;
	cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
	&#125;
	cout &lt;&lt; endl;
	cin &gt;&gt; m;

	<span class="hljs-type">int</span> test_case = <span class="hljs-number">29</span>;
	<span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">while</span> (test_case--) &#123;
		vector&lt;<span class="hljs-type">int</span>&gt; A, B;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			<span class="hljs-type">int</span> o = <span class="hljs-built_in">rng</span>() % <span class="hljs-number">2</span>;
			<span class="hljs-keyword">if</span> (o &gt; <span class="hljs-number">0</span>) &#123;
				A.<span class="hljs-built_in">push_back</span>(i);
			&#125; <span class="hljs-keyword">else</span> &#123;
				B.<span class="hljs-built_in">push_back</span>(i);
			&#125;
		&#125;

		cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; A.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : A) &#123;
			cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
		&#125;
		cout &lt;&lt; endl;
		<span class="hljs-type">int</span> cnt1;
		cin &gt;&gt; cnt1;

		cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; B.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : B) &#123;
			cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
		&#125;
		cout &lt;&lt; endl;
		<span class="hljs-type">int</span> cnt2;
		cin &gt;&gt; cnt2;

		<span class="hljs-type">int</span> mid = m - cnt1 - cnt2;
		<span class="hljs-keyword">if</span> (mid &amp; <span class="hljs-number">1</span>) &#123;
			ok = <span class="hljs-literal">false</span>;
			<span class="hljs-keyword">break</span>;
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> (ok) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;! YES&quot;</span> &lt;&lt; endl;
	&#125; <span class="hljs-keyword">else</span> &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;! NO&quot;</span> &lt;&lt; endl;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
		<span class="hljs-comment">// cout.flush();</span>
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 8 - K. 世界のまん中 - gym103469F. Fancy Formulas】</p><p>题意：给定一个质数 <span class="math inline">\(p\)</span>，以及 <span class="math inline">\(q\)</span> 组询问。每次给定两个二元组 <span class="math inline">\((a,b)\)</span> 和 <span class="math inline">\((c,d)\)</span>，保证 <span class="math inline">\(p\nmid (a+b)\)</span>。</p><p>一次操作可以选择如下其一，你可以无限次操作。问是否能将 <span class="math inline">\((a,b)\)</span> 转化为 <span class="math inline">\((c,d)\)</span>。</p><ul><li><span class="math inline">\((a,b):=(2a\bmod p, (b+p-a)\bmod p)\)</span></li><li><span class="math inline">\((a, b):=((a+p-b)\bmod p, 2b\bmod p)\)</span></li></ul><p><span class="math inline">\(2 \le p \le 10^9+7\)</span>，<span class="math inline">\(1\le q\le 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>无论那种操作，操作后的 <span class="math inline">\((a, b)\)</span> 均满足 <span class="math inline">\(s=(a+b)\bmod p\)</span> 不变。</p><p>那么知道 <span class="math inline">\((a,b)\)</span> 中的 <span class="math inline">\(a\)</span> 或 <span class="math inline">\(b\)</span>，另一个也同时确定，<span class="math inline">\((c,d)\)</span> 同理。</p><p>于是不妨将问题转化为：每次将一个整数 <span class="math inline">\(a\)</span> 进行 <span class="math inline">\(a:=2a\)</span> 或 <span class="math inline">\(a:= a-b\)</span> 的操作，能否将 <span class="math inline">\(a\to c\)</span>。</p><p>而 <span class="math inline">\(a:=a-b \Leftrightarrow a:=a-(s-a)\)</span>。即 <span class="math inline">\(a:=2a-s\)</span>。</p><p>但有 <span class="math inline">\(s\)</span> 在仍旧不好处理，考虑给 <span class="math inline">\(a,c\)</span> 都乘上 <span class="math inline">\(s^{-1}\)</span>，此时满足 <span class="math inline">\((a+b)\bmod p = 1\)</span>。</p><p>问题再次转化为每次将一个整数 <span class="math inline">\(a\)</span> 进行 <span class="math inline">\(a:=2a\)</span> 或 <span class="math inline">\(a:=2a-1\)</span> 的操作，能否将 <span class="math inline">\(a\to c\)</span>。</p><p>这样就变成了单变量问题。注意到对 <span class="math inline">\(a\)</span> 进行 <span class="math inline">\(k\)</span> 次操作后得到的数一定在一个区间范围内连续分布，具体的，是 <span class="math inline">\([2^ka-(2^k-1), 2^ka]\)</span>。而当 <span class="math inline">\(k &gt; 30\)</span> 的时候，这个区间的长度会 <span class="math inline">\(\ge p\)</span>，意味着在 <span class="math inline">\(\bmod p\)</span> 意义下拥有 <span class="math inline">\(0\sim p-1\)</span> 中的所有取值，就一定能找到和 <span class="math inline">\(c\bmod p\)</span> 同余的数。</p><p>于是直接枚举 <span class="math inline">\(k\)</span>，当值域区间内第一次存在和 <span class="math inline">\(c\)</span> 同余的数时，对应的 <span class="math inline">\(k\)</span> 就是答案。</p><p>时间复杂度 <span class="math inline">\(O(q\log p)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span> </span>&#123;
	<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % p) &#123;
		<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % p;
	&#125;
	<span class="hljs-keyword">return</span> s;
&#125;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> p, q;
	cin &gt;&gt; p &gt;&gt; q;
	<span class="hljs-keyword">while</span> (q--) &#123;
		<span class="hljs-type">int</span> a, b, c, d;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
		<span class="hljs-keyword">if</span> ((a + b) % p != (c + d) % p) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-type">int</span> s = (a + b) % p;
		a = a * <span class="hljs-built_in">qpow</span>(s, p - <span class="hljs-number">2</span>, p) % p;
		c = c * <span class="hljs-built_in">qpow</span>(s, p - <span class="hljs-number">2</span>, p) % p;
		<span class="hljs-keyword">if</span> (a == c) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-type">int</span> cover = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, l = a, r = a; ; i++) &#123;
			l = l * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;
			r = r * <span class="hljs-number">2</span>;
			<span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span>) &#123;
				l = p - <span class="hljs-number">1</span>;
				r = p;
			&#125;
			<span class="hljs-type">int</span> len = r - l + <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (len &gt;= p) &#123;
				cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
				<span class="hljs-keyword">break</span>;
			&#125;
			<span class="hljs-type">int</span> lp = l % p;
			<span class="hljs-type">int</span> rp = r % p;
			<span class="hljs-keyword">if</span> (lp &lt;= rp &amp;&amp; lp &lt;= c &amp;&amp; c &lt;= rp) &#123;
				cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
				<span class="hljs-keyword">break</span>;
			&#125;
			<span class="hljs-keyword">if</span> (lp &gt; rp &amp;&amp; (c &gt;= lp || c &lt;= rp)) &#123;
				cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 8 - G. 名前をつけてやる - gym102471H. King】</p><p>题意：给定一个质数 <span class="math inline">\(p\)</span>。一个长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span> 被称作 good，当且仅当 <span class="math inline">\(\exists q\in[1,p), \forall i \in[2, n], qa_{i-1}\equiv a_i \pmod{p}\)</span>。</p><p>给定一个序列 <span class="math inline">\(\{b\}\)</span>，设其最长的 good 子序列长度为 <span class="math inline">\(len\)</span>。若 <span class="math inline">\(len \ge \frac{n}{2}\)</span> 输出 <span class="math inline">\(len\)</span>；否则输出 <span class="math inline">\(-1\)</span>。</p><p><span class="math inline">\(2 \le n \le 2 \cdot 10^5\)</span>，<span class="math inline">\(2 \le p \le 10^9+7\)</span>。</p>
          </div>
<div class="note note-success">
            <p>题目中 <span class="math inline">\(len \ge \frac{n}{2}\)</span> 其实是一个随机化暗示。这意味着组成该子序列的元素在原序列中分布的十分密集。</p><p>如果 <span class="math inline">\(n\)</span> 为奇数，那么至少存在一对相邻的数，它们的比值正好是公比（鸽笼原理）。</p><p>如果 <span class="math inline">\(n\)</span> 为偶数，极限情况也是 <span class="math inline">\(\text{xoxoxoxo}\)</span>（<span class="math inline">\(\text{x}\)</span> 代表出现在最长的 good 子序列中），此时正好占到总长度的 <span class="math inline">\(\frac{1}{2}\)</span>。</p><p>那么我们可以进行以下操作若干次以得到正确答案：</p><ul><li>从 <span class="math inline">\(\{b\}\)</span> 中随机选一对数 <span class="math inline">\((x, y)\)</span>，满足 <span class="math inline">\(y = x + 1\)</span> or <span class="math inline">\(y = x + 2\)</span>。</li><li>令公比为 <span class="math inline">\(\dfrac{b_y}{b_x}\)</span>，向 <span class="math inline">\(x\)</span> 左侧和 <span class="math inline">\(y\)</span> 右侧拓展得到满足该公比的最长 good 序列，设长度为 <span class="math inline">\(m\)</span>。</li><li>若 <span class="math inline">\(2 \cdot m \ge n\)</span>，更新答案。</li></ul><p>正确性证明：不是很会，但显然失败概率极低。实际取 <span class="math inline">\(50\)</span> 次左右就能 AC 了。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rand</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">rng</span>() % (r - l + <span class="hljs-number">1</span>) + l;
&#125;

<span class="hljs-type">int</span> modp;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;
		<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;
	&#125;
	<span class="hljs-keyword">return</span> s;
&#125;

<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n &gt;&gt; modp;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">inv</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; b[i];
		inv[i] = <span class="hljs-built_in">qpow</span>(b[i], modp - <span class="hljs-number">2</span>);
	&#125;
	<span class="hljs-type">int</span> test_case = <span class="hljs-number">50</span>;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">while</span> (test_case--) &#123;
		<span class="hljs-type">int</span> x = <span class="hljs-built_in">Rand</span>(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : &#123;x + <span class="hljs-number">1</span>, x + <span class="hljs-number">2</span>&#125;) &#123;
			<span class="hljs-keyword">if</span> (y &gt; n) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-type">int</span> d = b[y] * inv[x] % modp;
			<span class="hljs-type">int</span> res = <span class="hljs-number">2</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = y + <span class="hljs-number">1</span>, lst = y; i &lt;= n; i++) &#123;
				<span class="hljs-keyword">if</span> (b[i] * inv[lst] % modp == d) &#123;
					res++;
					lst = i;
				&#125;
			&#125;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x - <span class="hljs-number">1</span>, lst = x; i &gt;= <span class="hljs-number">1</span>; i--) &#123;
				<span class="hljs-keyword">if</span> (b[lst] * inv[i] % modp == d) &#123;
					res++;
					lst = i;
				&#125;
			&#125;
			<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * res &gt;= n) &#123;
				ans = <span class="hljs-built_in">max</span>(ans, res);
			&#125;
		&#125; 
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 8 - J. ワンターフォゲール - gym102992D. Degree of Spanning Tree】</p><p>题意：给你一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向图，你需要找到它的一个生成树，满足所有节点度数 <span class="math inline">\(\le \frac{n}{2}\)</span>。</p><p><span class="math inline">\(2 \le n \le 10^5\)</span>，<span class="math inline">\(n - 1\le m\le 2\cdot 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>有正常做法，也有随机化做法，这里叙述后者。</p><p>我们先将所有边都连起来，尝试 dfs 找到一棵符合要求的生成树。</p><p>重复以下过程若干次：</p><ul><li>随机一个起点，开始 dfs。</li><li>每到一个未经过的点 <span class="math inline">\(x\)</span>，将 <span class="math inline">\(x\)</span> 的邻接边序列 shuffle 一遍。</li><li>遍历邻接边序列，在 <span class="math inline">\(x\)</span> 不超度数的情况下能连边就连边，递归到点 <span class="math inline">\(y\)</span>。</li><li>若遍历完所有点即找到一个连边方案。</li></ul><p>实测 <span class="math inline">\(50\)</span> 次就能 AC。正确性最不好证明的一集。</p><p>时间复杂度 <span class="math inline">\(O(50n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>



<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>


<span class="hljs-function">mt19937_64 <span class="hljs-title">rng</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; ans;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;
		vis[x] = <span class="hljs-literal">true</span>;
		<span class="hljs-built_in">shuffle</span>(adj[x].<span class="hljs-built_in">begin</span>(), adj[x].<span class="hljs-built_in">end</span>(), rng);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (vis[y] || deg[x] &gt;= n / <span class="hljs-number">2</span>) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;	
			deg[x]++;
			deg[y]++;
			ans.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);
			<span class="hljs-built_in">self</span>(self, y);
		&#125;
	&#125;;

	<span class="hljs-type">int</span> test_case = <span class="hljs-number">100</span>;
	<span class="hljs-keyword">while</span> (test_case--) &#123;
		vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
		deg.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
		ans.<span class="hljs-built_in">clear</span>();
		<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-built_in">rng</span>() % n + <span class="hljs-number">1</span>);
		<span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() == n - <span class="hljs-number">1</span>) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : ans) &#123;
				cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
			&#125;
			<span class="hljs-keyword">return</span> ;
		&#125;
	&#125;
	cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h3 id="day-12">【7.19】 Day 12</h3>
<p>定了 9 点的闹钟，但经典下床继续睡。</p>
<p>中午在基础实验大楼一楼售货机买了一个面包一盒纯牛奶。鉴定为贪睡导致的。</p>
<p>下午是 psk 场，不知道会不会整什么花活（然而并没有）。</p>
<hr />
<p>经典从 M 倒序开题，我超，真是原。这题我怎么感觉在哪里见过啊？但没能想起来，悲。</p>
<p>手算了一下样例，发现样例都算不对。</p>
<p>跟榜过了三道签到。但 lyc 15min 过的 J 我怎么签不出来鸭？第一感觉是直接横坐标 <span class="math inline">\(+1\)</span> 或纵坐标 <span class="math inline">\(+1\)</span>，狂wa，遂放着。</p>
<p>看榜 wbc 过了 D，看了下题，感觉和第三场队内赛的某个题很像，都是中间夹了个回文串，抄了个 manacher 就过了。</p>
<p>然后看 E，观察到一定是 <span class="math inline">\(1/3\)</span> 一组 <span class="math inline">\(2\)</span> 一组，就写了个二分图染色交了上去，怎么又 wa 了鸭。再次确定了一下思路，又捏了几个边界情况，感觉都没问题，就直接对拍启动了。结果拍出来是我 dfs 挂了，不是哥们？</p>
<p>继续看 J，我超为什么不对呢？干脆又写了个对拍。马上拍出来了，原来不一定是端点旁边啊？那我不会了。</p>
<p>看榜 lyc 过了 G，看题这不是逆序对模板题吗？15min 秒了。</p>
<p>怎么 J 和 L 过了一堆了鸭。L 还是推不出样例，J 画了几个图猜了个结论，又 wa。</p>
<p>红温了红温了红温了红温了红温了。直到赛后也没有过 J。</p>
<hr />
<p>没有讲题，就去吃饭了。朝阳￥16 黑椒牛肉，还不错，三星半或者四星。</p>
<p>回 234 补题，但是头晕晕的，不知道什么时候就趴桌子上睡着了。醒来快 9 点半了。</p>
<p>感觉一天什么都没做，倒是欠的题又多了一堆。</p>
<h3 id="day-13">【7.20】 Day 13</h3>
<p>没起，起了。</p>
<p>没吃，吃了。（精神错乱）</p>
<p>下午和 B 搏斗 3h，终于在最后把 B 做出来了，排名鉴定为人口普查，唉。</p>
<hr />
<div class="note note-info">
            <p>【队内赛 10 - Being Meltdown - CF1516D. Cut】</p><p>题意：给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span>，<span class="math inline">\(q\)</span> 次询问。每次询问一段区间 <span class="math inline">\([l, r]\)</span>，问至少要把这个区间分为几个子区间，才能使每个子区间的数的乘积等于这个子区间内所有数的 <span class="math inline">\(\text{Lcm}\)</span>。</p><p><span class="math inline">\(1 \le n,q,a_i \le 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>区间乘积 <span class="math inline">\(=\)</span> 区间 $ $ 区间中的数两两互质。</p><p>那么对于每个询问只需要从左往右扫，如果加上这个数之后区间不满足两两互质，就新开另一个区间。</p><p>考虑优化这个过程，通过枚举质因数，可以预处理出 <span class="math inline">\(nxt_i\)</span> 代表 <span class="math inline">\(i\)</span> 后面第一个不和 <span class="math inline">\(a_i\)</span> 互质的数的位置。</p><p>那么一段区间两两互质等价于右端点是 <span class="math inline">\([l, r]\)</span> 中所有的 <span class="math inline">\(nxt_i-1\)</span> 取 <span class="math inline">\(\min\)</span>。</p><p>具体地，令 <span class="math inline">\(dp_i\)</span> 代表以 <span class="math inline">\(i\)</span> 为左端点时，下一个左端点的位置，即：<span class="math inline">\(dp_i = \min\limits_{j = i}^{nxt_i - 1}nxt_j\)</span>。这个式子可以用 st 表 <span class="math inline">\(O(n\log n)\)</span> 预处理。</p><p>那么每次询问就可以不断跳到下一个左端点的位置，以求出区间数量。</p><p>套路化地，还可以倍增加速：令 <span class="math inline">\(dp_{i, j}\)</span> 代表 <span class="math inline">\(i\)</span> 后面第 <span class="math inline">\(2^j\)</span> 个左端点的位置。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


vector&lt;<span class="hljs-type">int</span>&gt; prime;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">not_prime</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span>(!not_prime[i]) &#123;
			prime.<span class="hljs-built_in">push_back</span>(i);
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j : prime) &#123;
			<span class="hljs-keyword">if</span> (i * j &gt; n) &#123;
				<span class="hljs-keyword">break</span>;
			&#125;
			not_prime[i * j] = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
	&#125;
&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SparseTable</span> &#123;
	<span class="hljs-type">int</span> n;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ST;
	<span class="hljs-built_in">SparseTable</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr) &#123;
		<span class="hljs-keyword">this</span>-&gt;n = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
		ST.<span class="hljs-built_in">resize</span>(n +<span class="hljs-number">1</span> ,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>));
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			ST[i][<span class="hljs-number">0</span>] = arr[i];
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= __lg(n); j++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1LL</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++) &#123;
				ST[i][j] = <span class="hljs-built_in">min</span>(ST[i][j - <span class="hljs-number">1</span>], ST[i + (<span class="hljs-number">1LL</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;
		<span class="hljs-type">int</span> len = __lg(r - l + <span class="hljs-number">1</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ST[l][len], ST[r - (<span class="hljs-number">1LL</span> &lt;&lt; len) + <span class="hljs-number">1</span>][len]);
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, q;
	cin &gt;&gt; n &gt;&gt; q;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-type">int</span> mx = *<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(mx + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> x = a[i];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : prime) &#123;
			<span class="hljs-keyword">if</span> (p * p &gt; x) &#123;
				<span class="hljs-keyword">break</span>;
			&#125;
			<span class="hljs-keyword">if</span> (x % p == <span class="hljs-number">0</span>) &#123;
				b[p].<span class="hljs-built_in">push_back</span>(i);
				<span class="hljs-keyword">while</span> (x % p == <span class="hljs-number">0</span>) &#123;
					x /= p;
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;
			b[x].<span class="hljs-built_in">push_back</span>(i);
		&#125;
	&#125; 

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">2</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= mx; i++) &#123;
		<span class="hljs-keyword">if</span> (b[i].<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; b[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j++) &#123;
			nxt[b[i][j]] = <span class="hljs-built_in">min</span>(nxt[b[i][j]], b[i][j + <span class="hljs-number">1</span>]);
		&#125;
	&#125;
	<span class="hljs-function">SparseTable <span class="hljs-title">st</span><span class="hljs-params">(nxt)</span></span>;
	<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">3</span>, vector&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		dp[i][<span class="hljs-number">0</span>] = st.<span class="hljs-built_in">query</span>(i, <span class="hljs-built_in">min</span>(n, nxt[i] - <span class="hljs-number">1</span>));
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">25</span>; j++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			dp[i][j] = dp[dp[i][j - <span class="hljs-number">1</span>]][j - <span class="hljs-number">1</span>];
		&#125;
	&#125;

	<span class="hljs-keyword">while</span> (q--) &#123;
		<span class="hljs-type">int</span> l, r;
		cin &gt;&gt; l &gt;&gt; r;
		<span class="hljs-type">int</span> pos = l, res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
			<span class="hljs-keyword">if</span> (dp[pos][i] &gt; <span class="hljs-number">0</span> &amp;&amp; dp[pos][i] &lt;= r) &#123;
				res += <span class="hljs-number">1</span> &lt;&lt; i;
				pos = dp[pos][i];
			&#125;
		&#125;
		cout &lt;&lt; res + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-built_in">init_phi</span>(<span class="hljs-number">1e5</span>);
	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<p>晚上 atc，犯病了，E 拉了坨大的，后面发现只要把四周框起来就行了。</p>
<p>CF 继续犯病，D 很快就想到一行里黑色格子的数量大于 <span class="math inline">\(4\)</span> 就直接消行。但剩下的 <span class="math inline">\(n\times 4\)</span> 不会处理，脑子里一直想的状压 dp，一行记作一个状态，结果转移直到比赛结束都没写出来。</p>
<hr />
<div class="note note-info">
            <p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc363/tasks/abc363_e">E - Sinking Land (atcoder.jp)</a></p>
          </div>
<div class="note note-success">
            <p>新建一个超级源点，先用并查集把边框和源点连起来。那么从 <span class="math inline">\(1\sim Y\)</span>，依次遍历海拔高度为 <span class="math inline">\(i\)</span> 的点，看其四周有没有海拔小于等于它的点，有就并起来，那么和源点并起来的点的个数就是被淹没的点的个数。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;
	vector&lt;<span class="hljs-type">int</span>&gt; f, siz;
	<span class="hljs-built_in">DSU</span>() &#123;&#125;
	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
		f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);
		siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;
			f[i] = i;
			siz[i] = <span class="hljs-number">1</span>;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;
		<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		x = <span class="hljs-built_in">find</span>(x);
		y = <span class="hljs-built_in">find</span>(y);
		<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;
			<span class="hljs-built_in">swap</span>(x, y);
		&#125;
		siz[x] += siz[y];
		f[y] = x;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];
	&#125;
&#125;;



<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, t;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;
	<span class="hljs-function">vector <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">2</span>))</span></span>;
	vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">b</span>(t + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
			cin &gt;&gt; a[i][j];
			<span class="hljs-keyword">if</span> (a[i][j] &lt;= t) &#123;
				b[a[i][j]].<span class="hljs-built_in">push_back</span>(&#123;i, j&#125;);
			&#125;
		&#125;
	&#125;
	<span class="hljs-type">int</span> S = (n + <span class="hljs-number">2</span>) * (m + <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;
	<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(S)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m + <span class="hljs-number">2</span>; j++) &#123;
			<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> || i == n + <span class="hljs-number">1</span> || j == m + <span class="hljs-number">1</span>) &#123;
				dsu.<span class="hljs-built_in">merge</span>(S, i * (m + <span class="hljs-number">2</span>) + j);
			&#125;
		&#125;
	&#125;
	<span class="hljs-type">int</span> init = dsu.<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>);
	<span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;
	<span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : b[i]) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;
				<span class="hljs-type">int</span> xx = x + dx[j];
				<span class="hljs-type">int</span> yy = y + dy[j];
				<span class="hljs-keyword">if</span> (a[xx][yy] &lt;= a[x][y]) &#123;
					dsu.<span class="hljs-built_in">merge</span>(x * (m + <span class="hljs-number">2</span>) + y, xx * (m + <span class="hljs-number">2</span>) + yy);
				&#125;
			&#125;
		&#125;
		cout &lt;&lt; n * m - (dsu.<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) - init) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>题意：给定一个 <span class="math inline">\(n\times n\)</span> 的网格，第 <span class="math inline">\(i\)</span> 行前 <span class="math inline">\(a_i\)</span> 个格子是黑色，其余为白色。每一次操作可以选择将一行全部涂白或将一个 <span class="math inline">\(2\times 2\)</span> 的区域全部涂白，问将所有格子涂白所需的最小操作次数。</p><p><span class="math inline">\(1 \le n \le 2\cdot 10^5\)</span>，<span class="math inline">\(0 \le a_i \le n\)</span>。</p>
          </div>
<div class="note note-success">
            <p>首先某一行如果有巨多黑色格子，直接运用第一种操作显然最佳。</p><p>第一个观察：若某行有大于 <span class="math inline">\(4\)</span> 个黑色格子，直接整行涂白。</p><ul><li>证明：大于 <span class="math inline">\(4\)</span> 个格子，那么至少用 <span class="math inline">\(3\)</span> 次 <span class="math inline">\(2\times 2\)</span> 操作，最优情况将这一行连带下一行一起清理完，但如果用涂整行的操作的话仅用 <span class="math inline">\(2\)</span> 次。</li></ul><p>现在问题变为了将 <span class="math inline">\(n\times 4\)</span> 的矩阵涂白的最小操作次数。</p><p>考虑一个逐行的贪心，同时引出第二个观察：若某行剩余黑格数 <span class="math inline">\(&gt; 2\)</span>，直接整行涂白。</p><ul><li>证明：当剩余黑格数 <span class="math inline">\(&gt;2\)</span> 时，说明该行一定没有被上一行连带消去过任何一个格子。此时用 <span class="math inline">\(2\times 2\)</span> 消除至少需要 <span class="math inline">\(2\)</span> 次，最优情况将下一行连带清理完，仍然不如使用 <span class="math inline">\(2\)</span> 次整行涂白。</li></ul><p>综上，设 <code>flag = 0 / 1 / 2</code> 代表该行没被上一行连带消除<span class="math inline">\(/\)</span>被连带消除了 <span class="math inline">\(1\sim2\)</span> 列的黑格<span class="math inline">\(/\)</span>被连带消除了 <span class="math inline">\(3\sim 4\)</span> 列的黑格，逐行贪心即可。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">4</span>) &#123;
			a[i] = <span class="hljs-number">0</span>;
			ans++;
		&#125;
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-comment">// 1~2 cols have colored = 1</span>
	<span class="hljs-comment">// 3~4 cols have colored = 2</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">if</span> (a[i] &lt;= <span class="hljs-number">0</span>) &#123;
			<span class="hljs-keyword">continue</span>;
		&#125;
		ans++;
		<span class="hljs-keyword">if</span> (a[i] &lt;= <span class="hljs-number">2</span>) &#123;
			<span class="hljs-keyword">if</span> (flag[i] == <span class="hljs-number">1</span>) &#123;
				flag[i + <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;
				a[i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<span class="hljs-number">2ll</span>, a[i + <span class="hljs-number">1</span>]);
			&#125; <span class="hljs-keyword">else</span>  &#123;
				flag[i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
				a[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">2</span>;
			&#125;
		&#125;
	&#125;	

	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="day-14">【7.21】 Day 14</h3>
<p>难得的周末，但是在睡梦中度过了。</p>
<p>我越来越喜欢睡觉了，只是有时候事情积压的太多了，只能熬夜去赶进度。</p>
<p>梦里什么都有，只是上一次做梦些许是半个月之前了。梦到了知更鸟，以及一些散装的小剧场。</p>
<p>网上有一种说法是人每次睡觉都会做梦，只是回想不起来罢了。</p>
<p>也许是记忆被抹杀才带来的孤独。</p>
<p>下午才醒，不是很想动，感觉训练对我作用不大，我的智商就摆在这里了。</p>
<p>越来越菜了，高中我也何尝不是这样呢？暑假一轮只剩一周，也许到最后没比赛打，没人愿意和我组队，甚至队都没进。</p>
<p>我努力过了吗？努力的时候不敢说自己努力了，不努力的时候也不敢说自己什么都没干。这么问也就显得乏之无味。</p>
<p>对不起很多人，集训队的大家，青柠工作室，以及嵌入式工作室的大家，他们都很看好我，但我就像不谙世事的孩子一样，又时不时吐露出自己悲哀的那一面。</p>
<p>翻了个身，之后又联想到很多心酸的事实，旁人的责备，又或者是 galgame 里的一段刀子，就像走马灯一样。</p>
<p>当一个人濒临崩溃的时候，它会想些什么呢？</p>
<p>啜泣，心绞痛，干脆继续睡了过去。</p>
<p>希望有羽毛和翅膀。</p>
<hr />
<h3 id="day-15">【7.22】 Day 15</h3>
<p>昨晚直接在基础实验大楼睡了。11 点 30 有人推门我就醒了。</p>
<p>午饭又没吃，是不是只要 5h 场就没吃过午饭，好像真是。</p>
<hr />
<p>下午队内赛，很奇怪的场，怎么我每题必 wa，真是病入膏肓了鸭。</p>
<p>开局 L，我用二进制考虑，结果卡壳了，遂看其它的。</p>
<p>开了三题怎么用了一个多小时啊，最慢的一集。感觉自己状态有问题，情绪被影响了，打字都很佛系。</p>
<p>再开 C，wa，稍微用力的想了下，红温之后想到负数会出问题，加了个判断过了。</p>
<p>L 也会了，宏观的考虑先一直乘 <span class="math inline">\(2\)</span>，看需要减多少，再分配到前面乘 <span class="math inline">\(2\)</span> 的操作之间。</p>
<p>然后开始博弈，上次博弈挂完了，想雪耻。</p>
<p>雪耻失败了，两个小时没做出博弈，只想到 <span class="math inline">\(n\le 3\)</span> 怎么做，<span class="math inline">\(n\)</span> 大了脑子就转不动了。</p>
<p>完败，还好后面红温了也能看清 K，写了个最短路就过了。</p>
<hr />
<p>晚上直接在 234 点了外卖，焖饼炒鸡！一般，三星半。</p>
<div class="note note-info">
            <p>【队内赛 11E - gym105161K. Number Deletion Game】</p><p>题意：给定 <span class="math inline">\(n\)</span> 堆石子，第 <span class="math inline">\(i\)</span> 堆数量 <span class="math inline">\(a_i\)</span>。两名玩家博弈，每轮玩家可以选择拿走最多的一堆石子中的任意个，无法操作则判输。问先手是否有必胜策略。</p>
          </div>
<div class="note note-success">
            <p>典题。结论是：<span class="math inline">\(a_i\)</span> 最大值出现奇数次，先手胜；否则后手胜。</p><p>证明使用归纳法：</p><ul><li><span class="math inline">\(\max = 1\)</span>，显然成立。</li><li>设对 <span class="math inline">\(\max =1\sim k\)</span> 成立，则对 <span class="math inline">\(\max= k+1\)</span>：<ul><li>若 <span class="math inline">\(k+1\)</span> 出现奇数次，则操作最后一个 <span class="math inline">\(k+1\)</span> 的是先手。先手可以决定次大值出现偶数次，这样后手输，先手胜。</li><li>若 <span class="math inline">\(k+1\)</span> 出现偶数次，则操作最后一个 <span class="math inline">\(k+1\)</span> 的是后手，同理后手胜。</li><li>故结论对 <span class="math inline">\(\max=k+1\)</span> 成立，于是对最大值为任意正整数都成立，证毕。</li></ul></li></ul>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());
	<span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, j = n - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j - <span class="hljs-number">1</span>] == a[n - <span class="hljs-number">1</span>]) &#123;
		j--;
		cnt++;
	&#125;
	<span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 11J - CF730J. Bottles】</p><p>题意：有 <span class="math inline">\(n\)</span> 瓶水，第 <span class="math inline">\(i\)</span> 瓶水的水量为 <span class="math inline">\(a_i\)</span>，容量为 <span class="math inline">\(b_i\)</span>。将 <span class="math inline">\(1\)</span> 单位水从一个瓶子转移到另一个瓶子所消耗时间为 <span class="math inline">\(1\)</span> 秒，且可以进行无限次转移。求储存所有水所需最小瓶子数 <span class="math inline">\(k\)</span> 以及该情况下所用最小时间 <span class="math inline">\(t\)</span>。</p><p><span class="math inline">\(1 \le n, a_i, b_i \le 100\)</span>。</p>
          </div>
<div class="note note-success">
            <p><span class="math inline">\(k\)</span> 比较简单，将容量降序排序，之后按顺序取到 <span class="math inline">\(\min\limits_{k}\sum\limits_{i=1}^{k}b_i \ge \sum a_i\)</span> 即可。</p><p>对于求最小时间 <span class="math inline">\(t\)</span>，可以转化为在这 <span class="math inline">\(n\)</span> 个瓶中取 <span class="math inline">\(k\)</span> 个瓶，使得剩余瓶子的水量之和最小，也就是使这 <span class="math inline">\(k\)</span> 个瓶的水量之和最大。</p><p>这是经典的 <span class="math inline">\(01\)</span> 背包问题，令 <span class="math inline">\(dp_{i, j, s}\)</span> 代表前 <span class="math inline">\(i\)</span> 个瓶中选了 <span class="math inline">\(j\)</span> 个瓶，容量之和为 <span class="math inline">\(s\)</span> 时的最大水量，则： <span class="math display">\[dp_{i, j, s} = \max(dp_{i-1, j, s}, dp_{i-1, j-1, s-b_i}+a_i)\]</span> 其中第一维可以滚动，或者倒序枚举压缩掉。</p><p>时间复杂度 <span class="math inline">\(O(n^4)\)</span>，空间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;
	<span class="hljs-type">int</span> water, vol;
	<span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;
		<span class="hljs-keyword">return</span> a.vol &gt; b.vol;
	&#125;;
&#125;;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-type">int</span> sum_water = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i].water;
		sum_water += a[i].water;
	&#125;
	<span class="hljs-type">int</span> sum_vol = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i].vol;
		sum_vol += a[i].vol;
	&#125;
	<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());

	<span class="hljs-type">int</span> ans1 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;
		sum += a[i].vol;
		<span class="hljs-keyword">if</span> (sum &gt;= sum_water) &#123;
			ans1 = i;
			<span class="hljs-keyword">break</span>;
		&#125;
	&#125;

	<span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(ans1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(sum_vol + <span class="hljs-number">1</span>, -inf))</span></span>;
	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = ans1; j &gt;= <span class="hljs-number">1</span>; j--) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = sum_vol; k &gt;= a[i].vol; k--) &#123;
				dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j - <span class="hljs-number">1</span>][k - a[i].vol] + a[i].water);
			&#125;
		&#125;
	&#125;

	<span class="hljs-type">int</span> ans2 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sum_water; i &lt;= sum_vol; i++) &#123;
		ans2 = <span class="hljs-built_in">max</span>(ans2, dp[ans1][i]);
	&#125;
	cout &lt;&lt; ans1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; sum_water - ans2 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-info">
            <p>【队内赛 11D - gym105161B. Area of the Devil】</p><p>题意：给一个半径为 <span class="math inline">\(r\)</span> 的圆上的五段不相交的圆弧，从每个圆弧依次选择一个点然后按顺序连成一个五角星，求五角星的面积并。</p><p><span class="math inline">\(1\le T \le 10^4\)</span>，<span class="math inline">\(1 \le r \le 10^3\)</span>。</p>
          </div>
<div class="note note-success">
            <p>如下图。我们用整个圆的面积减去五个（小三角 <span class="math inline">\(+\)</span> 弓形）的面积即可。</p><p>令 <span class="math inline">\(A_{is}\)</span> 代表第 <span class="math inline">\(i\)</span> 段圆弧的极角最小点，<span class="math inline">\(A_{it}\)</span> 代表第 <span class="math inline">\(i\)</span> 段圆弧的极角最大点。</p><p>以 <span class="math inline">\(\Delta A_{1s}B_{1}A_{5t}\)</span> 为例，<span class="math inline">\(B_1\)</span> 可以通过直线 <span class="math inline">\(A_{2s}A_{5t}\)</span> 和 <span class="math inline">\(A_{1s}A_{4t}\)</span> 求交点得到。知道了三角形三个点的坐标，利用叉积公式即可求得面积。</p><p>弓形 <span class="math inline">\(\overset{\frown}{A_{1s}A_{5t}}\)</span> 也等价于 <span class="math inline">\(S_{\text{扇形}OA_{1s}A_{5t}} - S_{\Delta OA_{1s}A_{5t}}\)</span>。</p><figure><img src="/image/academic/31.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>时间复杂度 <span class="math inline">\(O(T)\)</span>。</p><p>值得注意的是，使用叉积公式时不需要加绝对值，因为我们求的是有向面积。</p><p>如下图（可爱的 xing4c 画出来的！），当出现优弧时，阴影部分的面积应该被加上而不是减去。</p><figure><img src="/image/academic/32.png" alt="xing4c" /><figcaption aria-hidden="true">xing4c</figcaption></figure>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pi acos(-1)</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;
    T x, y;
    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;
    
    Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;
        x += p.x;
        y += p.y;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;
        x -= p.x;
        y -= p.y;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;
        x *= v;
        y *= v;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a += b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a -= b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;
        <span class="hljs-keyword">return</span> a *= b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;
        <span class="hljs-keyword">return</span> b *= a;
    &#125;
    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;
    &#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;
    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;
&#125;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;
    Point&lt;T&gt; a, b;
    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function">Point&lt;T&gt; <span class="hljs-title">lineIntersection</span><span class="hljs-params">(Line&lt;T&gt; l1, Line&lt;T&gt; l2)</span> </span>&#123;
    <span class="hljs-keyword">return</span> l1.a + (l1.b - l1.a) * 
    (<span class="hljs-built_in">cross</span>(l2.b - l2.a, l1.a - l2.a) / 
     <span class="hljs-built_in">cross</span>(l2.b - l2.a, l1.a - l1.b));
&#125;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(vector&lt;Point&lt;T&gt;&gt; a)</span> </span>&#123;
    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();
    <span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
        res += <span class="hljs-built_in">cross</span>(a[i], a[(i + <span class="hljs-number">1</span>) % n]);
    &#125;
    res /= <span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> res;
&#125;



<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> r;
	cin &gt;&gt; r;
	vector&lt;Point&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">5</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">5</span>);
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ori_a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">ori_b</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
		cin &gt;&gt; ori_a[i];
		<span class="hljs-type">double</span> x = r * <span class="hljs-built_in">cos</span>((<span class="hljs-number">1.0</span> * ori_a[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);
		<span class="hljs-type">double</span> y = r * <span class="hljs-built_in">sin</span>((<span class="hljs-number">1.0</span> * ori_a[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);
		a[i] = &#123;x, y&#125;;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
		cin &gt;&gt; ori_b[i];
		<span class="hljs-type">double</span> x = r * <span class="hljs-built_in">cos</span>((<span class="hljs-number">1.0</span> * ori_b[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);
		<span class="hljs-type">double</span> y = r * <span class="hljs-built_in">sin</span>((<span class="hljs-number">1.0</span> * ori_b[i] / <span class="hljs-number">360</span>) * <span class="hljs-number">2</span> * pi);
		b[i] = &#123;x, y&#125;;
	&#125;
	<span class="hljs-type">double</span> circle = <span class="hljs-number">1.0</span> * r * r * pi;
	<span class="hljs-type">double</span> res = circle;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
		<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l1</span><span class="hljs-params">(&#123;a[i], b[(i + <span class="hljs-number">3</span>) % <span class="hljs-number">5</span>]&#125;)</span></span>;
		<span class="hljs-function">Line&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">l2</span><span class="hljs-params">(&#123;a[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>], b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>]&#125;)</span></span>;
		Point&lt;<span class="hljs-type">double</span>&gt; p = <span class="hljs-built_in">lineIntersection</span>(l1, l2);
		res -= <span class="hljs-built_in">area</span>(vector&#123;p, b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>], a[i]&#125;);
		res -= (circle * ((ori_a[i] - ori_b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>] + <span class="hljs-number">360</span>) % <span class="hljs-number">360</span>) / <span class="hljs-number">360</span>) - 
		<span class="hljs-built_in">area</span>(vector&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, b[(i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>], a[i]&#125;);
	&#125;
	cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>) &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<div class="note note-primary">
            <h4 id="后缀自动机sam小记">后缀自动机（SAM）小记</h4><ul><li><p>架构</p><ul><li>不包含后缀链接时是一张有向无环图。</li><li>至多 <span class="math inline">\(2n-1\)</span> 个点，<span class="math inline">\(3n-4\)</span> 条边。</li><li>在线的线性算法。</li></ul></li><li><p>Endpos</p><ul><li><p><span class="math inline">\(\text{endpos}\)</span> 是子串在 <span class="math inline">\(S\)</span> 中结束位置的集合，<span class="math inline">\(\text{endpos}\)</span> 相等的子串归为一个等价类。</p></li><li><p>图上到达该节点的所有路径构成了以该等价类为结尾的所有后缀子串。</p></li><li><p>最长的子串称作 <span class="math inline">\(\text{longest(x)}\)</span>，将 <span class="math inline">\(\text{endpos}\)</span> 等价类中的子串按长度从大到小排序得到了 <span class="math inline">\(\text{longest(x)}\)</span> 长度连续的后缀。</p></li><li><p>原串的每个前缀都是 <span class="math inline">\(\text{longest}\)</span>。</p></li></ul></li><li><p>Link</p><ul><li>一个状态的 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(\text{link(x)}\)</span> 连接到最长的后缀 <span class="math inline">\(y\)</span>，满足 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 拥有属于不同等价类。</li><li>如果满足条件的后缀是空串，会直接连向起始节点。</li><li>SAM 维护的三个信息：<span class="math inline">\(\text{longest(x)}\)</span> 的长度 <span class="math inline">\(\text{len(x)}\)</span>，后缀链接 <span class="math inline">\(\text{link(x)}\)</span>，转移 <span class="math inline">\(\text{nxt(x, c)}\)</span>。</li><li>节点和 <span class="math inline">\(\text{link}\)</span> 构成一棵树，称作 <span class="math inline">\(\text{parent}\)</span> 树。</li></ul></li><li><p>构建</p><ul><li>每插入 <span class="math inline">\(c\)</span> 一定会出现一个新的状态（设为 <span class="math inline">\(\text{cur}\)</span>），且一定是 <span class="math inline">\(\text{longest(lst)}+c = \text{longest(cur)}\)</span>。</li><li>开始时 <span class="math inline">\(\text{cur}\)</span> 只有一个串。让指针从 <span class="math inline">\(\text{lst}\)</span> 开始，通过 <span class="math inline">\(\text{link}\)</span> 往起点的方向跳。对于路径上的状态 <span class="math inline">\(\text{p}\)</span>，如果没有 <span class="math inline">\(\text{nxt(p,c)}\)</span> 的转移，那么 <span class="math inline">\(\text{nxt(p, c) = cur}\)</span>。</li><li>因为 <span class="math inline">\(\text{link}\)</span> 指向的都是 <span class="math inline">\(\text{longest}\)</span> 的后缀，所以自然构成新的子串。</li><li>如果已经存在转移，设当前状态为 <span class="math inline">\(\text{p}\)</span>，<span class="math inline">\(\text{q=nxt(p,c)}\)</span>，存在两种情况：<ul><li>若 <span class="math inline">\(\text{len(q)=len(p)+1}\)</span>，说明 <span class="math inline">\(\text{q}\)</span> 中最长的字符串一定是 <span class="math inline">\(\text{longest(p)+c}\)</span>，故连 <span class="math inline">\(\text{link(cur)=q}\)</span>，退出。</li><li>否则把 <span class="math inline">\(\text{q}\)</span> 拷贝到一个新状态 <span class="math inline">\(\text{clone}\)</span>，<span class="math inline">\(\text{clone}\)</span> 拥有 <span class="math inline">\(\text{link(q)}\)</span> 以及 <span class="math inline">\(q\)</span> 所有的出边。令 <span class="math inline">\(\text{link(clone)=link(p)+1}\)</span>，再把 <span class="math inline">\(\text{q}\)</span> 和 <span class="math inline">\(\text{cur}\)</span> 都 <span class="math inline">\(\text{link}\)</span> 到这个点。</li><li>继续从 <span class="math inline">\(\text{p}\)</span> 向起点跳 <span class="math inline">\(\text{link}\)</span>，若存在指向 <span class="math inline">\(\text{q}\)</span> 的出边，改成指向 <span class="math inline">\(\text{clone}\)</span>；否则退出。</li><li>这么做是因为 <span class="math inline">\(\text{q}\)</span> 原来就存在，但我们不清楚 <span class="math inline">\(\text{q}\)</span> 的最长串是不是 <span class="math inline">\(\text{longest(p)+c}\)</span>，于是将 <span class="math inline">\(\text{longest(p)+c}\)</span> 和其在 <span class="math inline">\(\text{q}\)</span> 中的后缀单独拿出来，形成一个新的节点 <span class="math inline">\(\text{clone}\)</span>，以满足 <span class="math inline">\(\text{link(cur)}\)</span> 的要求。</li></ul></li></ul></li></ul>
          </div>
<h3 id="day-16">【7.23】 Day 16</h3>
<p>要结束了啊，希望今天队内赛能打好一点。</p>
<p>rating 已经排到 20 名开外了，脑子再不发力就真寄了，脑子给点力哇qwq。</p>
<hr />
<p>队内赛12，开题最慢的一次，不是怎么大家都会勾股数？输！</p>
<p>注意到了当 <span class="math inline">\(a\)</span> 是质数的时候 <span class="math inline">\(b,c\)</span> 一定连续，交！wa！</p>
<p>受不了了跟榜看 b，还好是一个简单二分，要不然 1h 过不了一题（</p>
<p>继续看勾股数，不是所有数质因数分解都能有解，比如 <span class="math inline">\(2\)</span> 就没有一组解，又不会了。</p>
<p>继续看榜，K 中位数很有意思，map 搞了一下过了。G，H 都 wa2，2h 了，急急急。</p>
<p>F 有一个人过了，我一看，我趣！这不跑两遍就行了吗，这么简单竟然 2h 才开出来，G 加了特判也过了。</p>
<p>然后终于会勾股数了，特判了一组 <code>8 15 17</code>，<span class="math inline">\(8\)</span> 之后 <span class="math inline">\(2\)</span> 的倍数都这么搞。</p>
<p>H 是个分类讨论，wa119，红温！拍！成了！但改了好久。你说得对但 M 怎么一直过不了鸭。</p>
<p>赛后在群里说，感觉做法没什么问题。结果 wbc 一眼看出我用 <code>lower_bound</code> 搜了一个无序的数组，尼玛！</p>
<div class="note note-warning">
            <p><code>std::lower_bound</code> 需要保证数组有序。</p><p><code>std::erase(std::vector)</code> 就算你指定了在迭代器的哪个位置，删除也是线性的！</p>
          </div>
<hr />
<p>晚上本来想在 234 打 CF 的，外卖都直接点到了 234，暴暴锅好吃捏。</p>
<p>但太累了，支持不住，还是回宿舍睡了。</p>
<hr />
<p>快进到赛后，稳定汤碗。</p>
<p>B2 做了 90min，原来是模拟题，乐。</p>
<p>如果不看 B2 直接看 C 分都会高很多，掐点过样例，气得睡不着觉。</p>
<p>但还是睡了，因为感觉总是上午 11 点起有点那啥了，还是得调整一下。</p>
<h3 id="day-17">【7.24】 Day 17</h3>
<p>8 点下床，怎么又睡了？？不过好在 9 点醒了，不算荒废了很多。</p>
<p>这几天要开始学字符串，学几何，写专题了。毕竟专题不做个五六道真进不了队了。</p>
<p>时间紧，直接把补题停了。</p>
<p>所以之后几天你只能在这篇文章里看到流水账了（</p>
<p>专题解题报告可能也会发到博客上，不过一轮结束前不能够公开。</p>
<p>中午朝阳，鸡扒饭，出品很稳定啊，四星。</p>
<hr />
<p>下午队内赛 13，开局怎么这么顺，上一次 1h 过四题不知道是什么时候了。</p>
<p>心里正乐着结果 J 又开始了，wa3，wa5，wa9，wa11，wa27。</p>
<p>爆了，去看 K，类似生命游戏。直接广搜，搜完发现读错题了，我以为是 “周围有不同颜色的块就变化”。</p>
<p>于是看 H，裸 meet in the middle，一发过。然后 K 发现改一下就行。</p>
<p>J 继续红温，感觉交了得有二十多发。转向 C，写了个割边构造，wa8，没救了！</p>
<p>继续交 J，三十多发了，寄！</p>
<hr />
<p>赛后听芙兰朵和小武说看我代码看乐了，然后才知道我二分图判定直接退出会导致同一个连通块搜两遍。</p>
<p>啊，红温了红温了红温了红温了红温了红温了红温了红温了红温了红温了红温了红温了。</p>
<p>于是和可爱的 xing4c 去汉堡王降温，爽点，爽吃。</p>
<p>菠萝派真的好好吃鸭，还点了个可可味的派，也好吃！</p>
<p>晚上宿舍睡了，然后 10 点多爬起来洗了个澡，看专题。</p>
<h3 id="后日谈">【7.28】后日谈</h3>
<p>真的结束了啊？想起 7.8 的时候还在为暑假哀悼，一转眼就到尾声了。</p>
<p>当然，指的是一轮集训。能否进得了二轮还有待商榷，负责人把最关键的 Rating 排名藏起来了，真是趣味呢。</p>
<p>尝试回忆我经历了什么，第一个想到的就是群主 xcy。</p>
<p>他很贴心，可爱，好说话。集训的时候有一天我因为个人原因没有去，他就来宿舍找我；我听讲座他下来看我，我跟他抱怨除了第一题都没听懂，他也安慰我慢慢来。</p>
<p>也许很多年之后别人问我暑假集训是怎么样的，我也只能说上来这些。</p>
<p>毕竟学到了什么知识，谁讲课讲的特别好，谁的 PPT 又做得根屎一样，都经不住时间的冲刷。</p>
<p>也正是因为这样，记录才有记录的价值。就比如讲课讲得特别好的，徐神，包大✌，vingying，这些都能脱口而出。讲得烂的，啊这是能说的吗？前文已经有了，这里就不重复提了（真没有贬低的意思）。然后队内赛打得牛的，lyc，czz，rzy。尤其 lyc 鸭，经常被 2n，照这个进步速度估计明年就和银牌✌组队了啊！</p>
<p>此外，能想起来的就是集训队的大家。为什么这么说，因为我虽然线下唯唯诺诺，但是事<del>水群糕手</del>。真的是这样，水群水的多，就能记得住集训队的大伙。大伙喜欢什么，爱看什么，经常说什么话，最后都会变成回忆的一部分。</p>
<p>说回集训，时间安排还是十分紧密的。这篇博客本身就能看出很多东西，就比如我不知不觉埋了各式各样的坑，几周前说的 “明天再补吧” 或许今天都没能补的上。但与其说紧吧，感觉也没那么阴沉，因为算法本身我认为就是充满乐趣的。就算我没能进队，我也会继续打 CF，明年暑假集训我还能继续陪跑。</p>
<p>然后不得不说的就是舍友了，jbx，xjj，还有 everflame。因为都是沙河的，所以也聊得来，队内赛打得不好，CF 打挂了都可以相互抱怨，有什么八卦也都可以图一乐。</p>
<p>真的结束了吗？</p>
<hr />
<p><span class="math display">\[
\begin{align}
&amp;\color{Rhodamine}無くなったのか　始まったのか分からないけど\\
&amp;\color{Cerulean}究竟是失去还是开始\\\\
&amp;\color{Rhodamine}行くしか方法は無いんだろう？\\
&amp;\color{Cerulean}可除了前进也没有其它办法了吧？\\\\
&amp;\color{Rhodamine}正解がなんだ　価値なんて無いんだ\\
&amp;\color{Cerulean}正确答案是什么 \ \ 毫无价值可言\\\\
&amp;\color{Rhodamine}あたしは生涯　あたし以外じゃ生きられないよ\\
&amp;\color{Cerulean}我终其一生 \ \ 都无法活成别人的模样\\\\
&amp;\color{Rhodamine}これ以上かき乱しても明日はない\\
&amp;\color{Cerulean}哪怕将一切颠覆搅乱仍不会迎来明天\\\\
&amp;\color{Rhodamine}どう足掻いても明日はない\\
&amp;\color{Cerulean}如何竭力挣扎都不会迎来明天\\\\
&amp;\qquad\qquad\qquad\qquad——\small \text{ GIRLS BAND CRY}\normalsize《空の箱\normalsize》
\end{align}
\]</span></p>
<hr />
<p>UPD：进队了！不知道是不是被群巨捞了QAQ</p>
<p>队友是可爱的 <a target="_blank" rel="noopener" href="https://codeforces.com/profile/everflame">everflame</a> 和可爱的 <a target="_blank" rel="noopener" href="https://codeforces.com/profile/nicnaknic">nicnaknic</a>，队名是 UESTC_EndlessEmbrace！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Competitive-Programming/" class="category-chain-item">Competitive Programming</a>
  
  
    <span>></span>
    
  <a href="/categories/Competitive-Programming/other/" class="category-chain-item">other</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ICPC/" class="print-no-link">#ICPC</a>
      
        <a href="/tags/UESTC/" class="print-no-link">#UESTC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【游记】2024 UESTC 暑假集训 第一轮</div>
      <div>https://kisuraop.github.io/posts/61a1a0ca.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>KisuraOP</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/70be1dc7.html" title="”【题解】2024 UESTC 暑假集训 第二轮“">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">”【题解】2024 UESTC 暑假集训 第二轮“</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/996d8e6.html" title="【NNSZCP2023】南宁三中第13届科技文化节程序设计竞赛 G,H,I">
                        <span class="hidden-mobile">【NNSZCP2023】南宁三中第13届科技文化节程序设计竞赛 G,H,I</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://kisuraop.github.io/" target="_blank" rel="nofollow noopener"><span>KisuraOP</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>








  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
