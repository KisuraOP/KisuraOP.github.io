

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/bg/mugeng.ico">
  <link rel="icon" href="/image/bg/mugeng.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="KisuraOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="越训越菜。">
<meta property="og:type" content="article">
<meta property="og:title" content="【题解】寒假训练日记">
<meta property="og:url" content="https://kisuraop.github.io/posts/abc8fb81.html">
<meta property="og:site_name" content="KisuraOP">
<meta property="og:description" content="越训越菜。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.rmb.bdstatic.com/bjh/5327dc9ab73e4ebc42eb021f40fedf49.jpeg">
<meta property="article:published_time" content="2025-01-19T16:35:35.000Z">
<meta property="article:modified_time" content="2025-01-19T16:35:35.000Z">
<meta property="article:author" content="KisuraOP">
<meta property="article:tag" content="ICPC">
<meta property="article:tag" content="Codeforces">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic.rmb.bdstatic.com/bjh/5327dc9ab73e4ebc42eb021f40fedf49.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【题解】寒假训练日记 - KisuraOP</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_4277703_p4cthydttt.css">
<link rel="stylesheet" href="/css/vemoji.css">
<link rel="stylesheet" href="/css/bg_cover.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kisuraop.github.io","root":"/","version":"1.9.5-a","typing":{"enable":false,"typeSpeed":55,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"c++"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/image/other/loading.mp4","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><script src="https://kisuraop.github.io/js/mouseclick.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>KisuraOPのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/site/">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>收藏夹</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/waiting/">
                <i class="iconfont icon-plan"></i>
                <span>待办</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/example/">
                <i class="iconfont icon-comment"></i>
                <span>留言</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://moe.jitsu.top/img/?sort=pc') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">【题解】寒假训练日记</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        KisuraOP
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-01-20 00:35" pubdate>
          2025年1月20日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【题解】寒假训练日记</h1>
            
            
              <div class="markdown-body">
                
                <p>寒假给自己定的要求是 vp 后补 *2500 以下的题，有些 &gt; 2500 但我感兴趣的题也会补。</p>
<h2 id="cf2048f.-kevin-and-math-class"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2048/problem/F">CF2048F. Kevin and Math Class</a></h2>
<p>*2500 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2048/submission/300486188">Code</a></p>
<p>对于 <span class="math inline">\(b_x\)</span>，找到 <span class="math inline">\(b_x\)</span> 左侧第一个 <span class="math inline">\(l\)</span> 使得 <span class="math inline">\(b_l &lt; b_x\)</span>，右侧第一个 <span class="math inline">\(r\)</span> 使得 <span class="math inline">\(b_r &lt; b_x\)</span>。</p>
<p>那么要让 <span class="math inline">\(b_x\)</span> 当最小值，区间最大就是 <span class="math inline">\([l+1,r-1]\)</span>，又我们肯定是选尽可能大的区间，所以要除 <span class="math inline">\(b_x\)</span> 时肯定是对区间 <span class="math inline">\([l+1,r-1]\)</span> 操作。</p>
<p>于是建出 <span class="math inline">\((i,b_i)\)</span> 的小根笛卡尔树，我们一定是操作笛卡尔树上的区间。</p>
<p>又 <span class="math inline">\(b_i \ge 2\)</span>，所以每个区间操作不会超过 <span class="math inline">\(64\)</span> 次。</p>
<p>令 <span class="math inline">\(dp[x][i]\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树对应的区间，操作 <span class="math inline">\(i\)</span> 次后区间最大值最小是多少。 <span class="math display">\[
\begin{align}
dp[x][k] = \min_{k=i+j}(\max(dp[ls[x]][i],dp[rs[x]][j],a[x]))\\
dp[x+1][k] = \min(dp[x+1][k],\left\lceil\frac{dp[x][k]}{b[x]}\right\rceil)
\end{align}
\]</span> 答案是使 <span class="math inline">\(dp[rt][i]=1\)</span> 的最小的 <span class="math inline">\(i\)</span>。<span class="math inline">\(rt\)</span> 是笛卡尔树的根。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2w)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p>
<p>题解说可以用 <span class="math inline">\(\min-\max\)</span> 卷积优化到 <span class="math inline">\(O(n\log w)\)</span>，但我琢磨了一下不是很会。</p>
<p>实测双 <span class="math inline">\(\log\)</span> 跑了 1.1s &lt; 2s。</p>
<h2 id="cf1976d.-invertible-bracket-sequences"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1976/problem/D">CF1976D. Invertible Bracket Sequences</a></h2>
<p>*2000 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1976/submission/300528983">Code</a></p>
<p>把左括号看成 <span class="math inline">\(1\)</span>，右括号看成 <span class="math inline">\(-1\)</span>，求前缀和，可以作出折线图。</p>
<p>一段折线如果要翻转后也形成合法括号序列，需要满足两个条件：</p>
<ul>
<li>两端纵坐标相等。</li>
<li>翻转后最高点不能越过 <span class="math inline">\(x\)</span> 轴。</li>
</ul>
<p>第一个条件即 <span class="math inline">\(sum_l = sum_r\)</span>，第二个条件即 <span class="math inline">\(\max\limits_{l\le i\le r}sum_{i}\le2sum_l\)</span>。</p>
<p>最大值可以用 ST 表或线段树维护，然后沿 <span class="math inline">\(y\)</span> 轴做扫描线即可。注意对于同一 <span class="math inline">\(y\)</span> 坐标，若有三个点满足 <span class="math inline">\(sum_l=sum_m=sum_r\)</span>，且 <span class="math inline">\([l, m]\)</span> 和 <span class="math inline">\([m,r]\)</span> 满足要求，那么 <span class="math inline">\([l,r]\)</span> 也满足要求。使用一个计数器累加即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf1976e.-splittable-permutations"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1976/problem/E">CF1976E. Splittable Permutations</a></h2>
<p>*2500 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1976/submission/300596121">Code</a></p>
<p>这题最关键的观察：出现在 <span class="math inline">\(l[i]\)</span>，<span class="math inline">\(r[i]\)</span> 中的所有数的相对位置是可以唯一确定的。</p>
<ul>
<li>首先对于一组 <span class="math inline">\((l, r)\)</span>，<span class="math inline">\(l\)</span> 肯定在 <span class="math inline">\(r\)</span> 的左边。倒着扫描序列，每次相当于一次合并。设 <span class="math inline">\(l\)</span> 目前所在的序列为 <span class="math inline">\(a\)</span>，<span class="math inline">\(r\)</span> 目前所在的序列为 <span class="math inline">\(b\)</span>，那么合并后新序列的相对顺序一定是 <span class="math inline">\(b\)</span> 中的元素按顺序拼接在 <span class="math inline">\(a\)</span> 的后面。这个性质可以手玩出来。</li>
</ul>
<p>并查集记录这个数属于哪个连通块，再用双向链表连接，就能求出这个相对顺序。</p>
<p>接着还有一些数没在 <span class="math inline">\(l[i]\)</span>，<span class="math inline">\(r[i]\)</span> 中出现过，我们考虑把它们插进去。</p>
<p>又一个观察：一个数 <span class="math inline">\(x\)</span> 能插进 <span class="math inline">\(A,B\)</span> 之间的必要条件是 <span class="math inline">\(x\le \max(A,B)\)</span>。</p>
<ul>
<li>比较显然。</li>
</ul>
<p>于是从大到小枚举要插的数，用一个计数器统计每次有多少空可以插，乘起来就是答案。</p>
<p>时间复杂度<span class="math inline">\(O(n\alpha)\)</span>。</p>
<h2 id="cf2055d.-scarecrow"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2055/problem/D">CF2055D. Scarecrow</a></h2>
<p>*2000 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2055/submission/301662039">Code</a></p>
<p>设当前使用的时间是 <span class="math inline">\(t\)</span>，乌鸦当前在 <span class="math inline">\(p\)</span>。</p>
<p>首先离 <span class="math inline">\(0\)</span> 最近的稻草人要移到 <span class="math inline">\(0\)</span>，那么令初值 <span class="math inline">\(t = a[0]\)</span>，<span class="math inline">\(p=k\)</span>。</p>
<p>一个观察是：你是被你左边最近的稻草人推着走的，与此同时右边最近的稻草人可以按情况选择左移，不动，或右移来减少你转移到它（也就是被它推着走）的时间。</p>
<p>那么从左到右扫描每个稻草人，做出如下分类讨论：</p>
<ul>
<li><span class="math inline">\(a[i]-t&gt;p\)</span>，即之前的时间都向左移都还在乌鸦的右边时，选择花时间继续向左，与此同时乌鸦也被它左边的稻草人推着向右，所以需要 <span class="math inline">\(t&#39;=(a[i]-t-p)/2\)</span>。那么 <span class="math inline">\(t=t+t&#39;\)</span>，乌鸦转移到 <span class="math inline">\(p=p+t&#39;+k\)</span>。</li>
<li><span class="math inline">\(a[i]-t\le p\)</span> 时，分两种情况。
<ul>
<li><span class="math inline">\(a[i]+t\le p\)</span>，也就是之前的时间一直向右移也在乌鸦的左边，那就取个 <span class="math inline">\(\max\)</span>，即 <span class="math inline">\(p=\max(p,a[i]+t+k)\)</span>。</li>
<li><span class="math inline">\(a[i]+t&gt;p\)</span>，也就是之前的时间足够右移到乌鸦右边了，此时肯定是恰好停在 $ p$ 不用花额外的时间，所以 <span class="math inline">\(p = p+k\)</span>。</li>
</ul></li>
</ul>
<p>最后如果 <span class="math inline">\(p&lt;l\)</span>，就加上 <span class="math inline">\(l-p\)</span>，代表最后一个稻草人把它推向终点。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="cf2057e1e2.-another-exercise-on-graphs"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2057/problem/E2">CF2057E1/E2. Another Exercise on Graphs</a></h2>
<p>*2300 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2057/submission/301679582">Code</a>（E1）</p>
<p>*2500 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2057/submission/301730095">Code1</a> <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2057/submission/301732253">Code2</a>（E2）</p>
<p>先考虑这样一个事情：我们将原图 copy 一份，对于新图上的每条边，如果原图的边权 <span class="math inline">\(\le x\)</span>，则赋值为 <span class="math inline">\(0\)</span>，否则赋值为 <span class="math inline">\(1\)</span>。那么 <span class="math inline">\(a\to b\)</span> 在新图上的最短路为 <span class="math inline">\(w \Longleftrightarrow\)</span> <span class="math inline">\(x\)</span> 为原图中 <span class="math inline">\(a\to b\)</span> 路径上第 <span class="math inline">\(w+1\)</span> 大的边。</p>
<p>那么得到一个暴力做法：从小到大枚举所有的边权 <span class="math inline">\(x\)</span>，按上述规则赋值跑最短路，直到第一个 <span class="math inline">\(w\)</span> 满足 <span class="math inline">\(w+1\le k\)</span>，此时 <span class="math inline">\(x\)</span> 就是答案。</p>
<p>进一步地，<span class="math inline">\(x\)</span> 每次增大都相当于把一些边（即边权等于新 <span class="math inline">\(x\)</span> 的边）由 <span class="math inline">\(1\to 0\)</span>，我们利用 floyd 枚举这些边的两个端点为中转点就可以很快地更新答案。具体地，更新一次是 <span class="math inline">\(O(n^2)\)</span>，更新不超过 <span class="math inline">\(m\)</span> 次。</p>
<p>至于多组询问，用 <span class="math inline">\(dis[a][b][x]\)</span> 表示对 <span class="math inline">\(\le x\)</span> 的边赋值为 <span class="math inline">\(0\)</span>，否则赋值为 <span class="math inline">\(1\)</span> 后 <span class="math inline">\(a\to b\)</span> 的最短路，每次询问就对 <span class="math inline">\(dis[a][b][\cdot]\)</span> 二分出第一个 <span class="math inline">\(\le k-1\)</span> 的值对应的 <span class="math inline">\(x\)</span> 就是答案。</p>
<p>由于要枚举每个边权，时间复杂度 <span class="math inline">\(O(mn^2)\)</span>，能够通过 E1。</p>
<p>注意我们把一些边由 <span class="math inline">\(1\to0\)</span> 的过程，如果对于所有边权为 <span class="math inline">\(x\)</span> 的边 <span class="math inline">\((a,b)\)</span>，<span class="math inline">\(dis[a][b]\)</span> 都已经为 <span class="math inline">\(0\)</span>，那么此次更新就是不必要的，就能省下一个 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>实际上，可以证明这样的更新最多进行 <span class="math inline">\(n\)</span> 次：如果当前边 <span class="math inline">\((a,b)\)</span> 有 <span class="math inline">\(dis[a][b]\neq0\)</span>，那么 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 中的至少一个需要来自之前没更新过的点，而一共就 <span class="math inline">\(n\)</span> 个点，故得证。</p>
<p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>，能够通过 E2。</p>
<p>事实上，回答询问的时候二分并不是必要的。一样是从小到大枚举边权 <span class="math inline">\(x\)</span> 并赋值，但你只需要在 floyd 更新的时候顺便记一下就行了，细节可以阅读 jiangly 的代码。</p>
<h2 id="cf2060e.-graph-composition"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2060/problem/E">CF2060E. Graph Composition</a></h2>
<p>*1500 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2060/submission/301963287">Code</a></p>
<p>很容易想的很复杂，实际上只需要两步：</p>
<ul>
<li>把 <span class="math inline">\(F\)</span> 的一些边断掉使得 <span class="math inline">\(F\)</span> 的任意同一连通分量中的点都在 <span class="math inline">\(G\)</span> 中连通。</li>
<li>把 <span class="math inline">\(F\)</span> 的一些连通分量组合得到 <span class="math inline">\(G\)</span>。</li>
</ul>
<p>第一步只用枚举 <span class="math inline">\(F\)</span> 的每条边 <span class="math inline">\(a\to b\)</span> 然后用并查集看在 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(a,b\)</span> 是否连通，不连通需要花费 <span class="math inline">\(1\)</span> 的代价割掉。</p>
<p>第二步花费的代价一定是 <span class="math inline">\(F\)</span> 的连通分量个数 <span class="math inline">\(-\)</span> <span class="math inline">\(G\)</span> 的连通分量个数。</p>
<p>时间复杂度 <span class="math inline">\(O(n\alpha)\)</span>。</p>
<h2 id="cf2061e.-kevin-and-and"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2061/problem/E">CF2061E. Kevin and And</a></h2>
<p>*2000 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2061/submission/302339557">Code</a></p>
<p>题目要让总和最小，一个容易想到的贪心是：每一步操作都让总和尽可能地变小，也就是每次都采取能让总和变化量最大的操作。在以下叙述中，把减少的量称为收益。</p>
<p>要说明这个贪心是对的，得先证明一个结论：对于一个固定的 <span class="math inline">\(a_i\)</span>，设 <span class="math inline">\(f(j)\)</span> 代表对 <span class="math inline">\(a_i\)</span> 使用 <span class="math inline">\(j\)</span> 次魔法能获得的最大的收益，那么 <span class="math inline">\(f(j)-f(j-1)\)</span> 递减（即 <span class="math inline">\(f(j)\)</span> 是凸的）。</p>
<ul>
<li>感性证明："使用两次魔法相对于使用一次魔法" 带来的收益不可能超过 "使用一次魔法相对于不使用魔法" 带来的收益。否则此时使用一次魔法带来的收益并非是最大的。</li>
</ul>
<p>基于这个结论，我们可以对于每个 <span class="math inline">\(i\in[1,n]\)</span>，把所有的 <span class="math inline">\(f(j)-f(j-1),j\in[1,m]\)</span> 记下来，排序之后选最大的 <span class="math inline">\(k\)</span> 个值相加即最大收益。</p>
<p>代码实现过程中，把 <span class="math inline">\(m\)</span> 个魔法是否使用压缩成一个状态，可以先 <span class="math inline">\(O(2^m\cdot m)\)</span> 求出每种状态的累加效果（即按位与后的结果），再 <span class="math inline">\(O(n\cdot 2^m)\)</span> 对每个 <span class="math inline">\(a_i\)</span> 求出 <span class="math inline">\(f(1\sim m)\)</span>。</p>
<p>时间复杂度：<span class="math inline">\(O(n2^m+nm\log nm)\)</span>。</p>
<p>如果使用 <code>std::nth_element</code> 可以省去最后的 <span class="math inline">\(\log\)</span>。</p>
<h2 id="cf2061f1.-kevin-and-binary-string-easy-version"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2061/problem/F1">CF2061F1. Kevin and Binary String (Easy Version)</a></h2>
<p>*2100 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2061/submission/302357467">Code</a></p>
<p>对于串 <span class="math inline">\(\cdots011001\cdots\)</span>，交换中间的 <span class="math inline">\(11\)</span> 和 <span class="math inline">\(00\)</span>，会让交换后的 <span class="math inline">\(00\)</span> 与左边的 <span class="math inline">\(0\)</span> 粘连，<span class="math inline">\(11\)</span> 与右边的 <span class="math inline">\(1\)</span> 粘连。而一旦粘连，只能一起移动，因此整块的 <span class="math inline">\(1\)</span> 是无法跨越另一个整块的 <span class="math inline">\(1\)</span> 的，整块的 <span class="math inline">\(0\)</span> 也无法跨越另一个整块的 <span class="math inline">\(0\)</span>。</p>
<p>这就说明了 <span class="math inline">\(s\)</span> 要想变成 <span class="math inline">\(t\)</span>，可以进行以下贪心：从左到右扫描，当 <span class="math inline">\(s[i]\neq t[i]\)</span> 时，就从 <span class="math inline">\(i\)</span> 后边找最近的整块的 <span class="math inline">\(t[i]\)</span> 修补。</p>
<p>例如，<span class="math inline">\(s=001\color{Red}0\)</span><span class="math inline">\(1\color{Red}00\)</span><span class="math inline">\(101\)</span>，<span class="math inline">\(t=00\color{Green}000\)</span><span class="math inline">\(1111\)</span>。当 <span class="math inline">\(i=3\)</span> 时，<span class="math inline">\(s[i]\neq t[i]\)</span>，且 <span class="math inline">\(t\)</span> 此时还有连续 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(0\)</span>，故要从 <span class="math inline">\(s[3]\)</span> 后边找 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(0\)</span>。找到第一个 <span class="math inline">\(0\)</span> 块有 <span class="math inline">\(1\)</span> 个 <span class="math inline">\(0\)</span>，还需要找 <span class="math inline">\(2\)</span> 个，再往后找到下一个 <span class="math inline">\(0\)</span> 块就恰好找到 <span class="math inline">\(2\)</span> 个。</p>
<p>而 <span class="math inline">\(s=001\color{Red}0\)</span><span class="math inline">\(1\color{Red}00\)</span><span class="math inline">\(011\)</span>，<span class="math inline">\(t=00\color{Green}000\)</span><span class="math inline">\(1111\)</span> 就无法匹配上，因为往后找只能找到 <span class="math inline">\(1\)</span> 个或 <span class="math inline">\(4\)</span> 个 <span class="math inline">\(0\)</span>，不能补上 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(0\)</span> 的缺口。</p>
<p>具体实现时可以用容器把 <span class="math inline">\(1,0\)</span> 的位置存起来以便快速向后查找，另有若干细节不再赘述。</p>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span> 或 <span class="math inline">\(O(n\log n)\)</span>。（依据实现方式）</p>
<h2 id="cf2056d.-unique-median"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2056/problem/D">CF2056D. Unique Median</a></h2>
<p>*2200 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2056/submission/302570099">Code</a></p>
<p>容斥，用全集 <span class="math inline">\(\frac{n(n+1)}{2}\)</span> 减去中位数不等的子串个数。</p>
<p>注意到值域很小，故枚举两个中位数中较小的那个（记为 <span class="math inline">\(x\)</span>）。将数组中 <span class="math inline">\(\le x\)</span> 的置为 <span class="math inline">\(-1\)</span>，<span class="math inline">\(&gt;x\)</span> 的置为 <span class="math inline">\(1\)</span> 求出前缀和 <span class="math inline">\(pre\)</span>，那么子串 <span class="math inline">\((i,j)\)</span> 中位数不等 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(pre[i-1]=pre[j]\)</span>。</p>
<p>由于 <span class="math inline">\(pre[i-1]=pre[j]\)</span> 时对应的串长定为偶数，所以不用考虑奇数长度的判断。</p>
<p>故我们只需要计数有多少个二元组 <span class="math inline">\((l,r)\)</span> 满足 <span class="math inline">\(pre[l]=pre[r]\)</span> 且区间 <span class="math inline">\([l+1,r]\)</span> 中有 <span class="math inline">\(x\)</span>。</p>
<p>一种方法是枚举 <span class="math inline">\(i=1\cdots n\)</span>，以及一个指针 <span class="math inline">\(j\)</span>，初始 <span class="math inline">\(j=0\)</span>。当 <span class="math inline">\(a[i]=x\)</span> 时，<span class="math inline">\(j\)</span> 就跟上 <span class="math inline">\(i\)</span> 并把路上的 <span class="math inline">\(pre[j]\)</span> 都加进桶里，然后累加桶里 <span class="math inline">\(pre[i]\)</span> 的数目。正确性显然，即这样两个 <span class="math inline">\(x\)</span> 之间的 <span class="math inline">\(pre\)</span> 值无法造成贡献。</p>
<p>时间复杂度 <span class="math inline">\(O(wn\log n)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p>
<h2 id="cf2056e.-nested-segments"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2056/problem/E">CF2056E. Nested Segments</a></h2>
<p>*2500 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2056/submission/302750497">Code</a></p>
<p>观察 <span class="math inline">\(1\)</span>：当 <span class="math inline">\(m=0\)</span> 时最多能向 <span class="math inline">\([1,n]\)</span> 中填 <span class="math inline">\(2n-1\)</span> 条线段。</p>
<ul>
<li>草稿纸画几笔易得。</li>
</ul>
<p>观察 <span class="math inline">\(2\)</span>：当 <span class="math inline">\(m=0\)</span> 时向 <span class="math inline">\([1,n]\)</span> 中填 <span class="math inline">\(2n-1\)</span> 条线段的方案数是 <span class="math inline">\(C_{n-1}\)</span>，其中 <span class="math inline">\(C\)</span> 为卡特兰数。</p>
<ul>
<li>考虑这样一个事情：把 <span class="math inline">\([1,n]\)</span> 当作根节点，<span class="math inline">\([1, 1],[2, 2],\cdots,[n,n]\)</span> 当作叶节点，若 <span class="math inline">\([L,R]\)</span> 包含 <span class="math inline">\([l,r]\)</span> 且 <span class="math inline">\([L, R]\)</span> 极小，就连一条边，最终连成一棵树。同时，当填满 <span class="math inline">\(2n-1\)</span> 条线段时，这一定是一棵满位置二叉树（每个节点有 <span class="math inline">\(0\)</span> 个或 <span class="math inline">\(2\)</span> 个儿子），因为如果有 <span class="math inline">\(&gt;2\)</span> 个儿子，我们一定可以取出两个为其添加一个父亲。</li>
<li>接着套用结论：有 <span class="math inline">\(n\)</span> 个叶子的满位置二叉树数量为 <span class="math inline">\(C_{n-1}\)</span>。末尾的第二个参考链接附有示例。</li>
</ul>
<p>观察 <span class="math inline">\(3\)</span>：当 <span class="math inline">\(m\neq 0\)</span> 时，<span class="math inline">\([1,n]\)</span> 中仍然能填满 <span class="math inline">\(2n-1\)</span> 条线段。</p>
<ul>
<li>虽然题目预先给出了一些线段，但保证了已经给出的是好的。草稿纸再画几笔发现我们仍然能建出一个有 <span class="math inline">\(n\)</span> 个儿子的满位置二叉树。</li>
</ul>
<p>我们可以先把题给线段构成的树建出来（如果没有 <span class="math inline">\([1,n]\)</span> 的话就为它添加），这时的树有些节点（设为 <span class="math inline">\(x\)</span>）有 <span class="math inline">\(&gt;2\)</span> 个儿子，不妨将 <span class="math inline">\(x\)</span> 的儿子设为 <span class="math inline">\([l_1,r_1],[l_2,r_2],\cdots[l_k,r_k]\)</span>。对于 <span class="math inline">\(\forall i\in[1,k)\)</span>，若 <span class="math inline">\(r_i \neq l_{i+1}\)</span>，那么一定可以添加线段 <span class="math inline">\([r_i+1,r_i+1],[r_i+2,r_i+2],\cdots,[l_{i+1}-1,l_{i+1}-1]\)</span> 在中间。</p>
<p>再设如此填充线段后 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(p\)</span> 个儿子，我们的目标就是把这个以 <span class="math inline">\(x\)</span> 为根的子树建成一棵满位置二叉树，而这么做的方案数恰好等价于有 <span class="math inline">\(p\)</span> 个叶子的满位置二叉树数量，即 <span class="math inline">\(C_{p-1}\)</span>。</p>
<p>于是对于每一条线段，它的贡献都是一个卡特兰数，累乘起来就是最终的方案数。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>一些卡特兰数模型：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31317307">Link1</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31526354">Link2</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/609104268">Link3</a>。</p>
<p>记忆：<span class="math inline">\(C_{n}=\binom{2n}{n}-\binom{2n}{n-1}\)</span>。</p>
<h2 id="cf2063f1f2.-counting-is-not-fun"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2063/problem/F2">CF2063F1/F2. Counting Is Not Fun</a></h2>
<p>*2400 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2063/submission/302767057">Code</a>（F1）</p>
<p>*2700 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2063/submission/302848292">Code</a>（F2）</p>
<p>我们将一组 good pair <span class="math inline">\((l,r)\)</span> 看成覆盖 <span class="math inline">\([l,r]\)</span> 的线段，显然任何时候的任意两条线段都要么不交要么完全包含。和这篇文章的上一题及其相似，我们把具有包含关系的线段连边（对于 <span class="math inline">\([l,r]\)</span>，若能找到极小的 <span class="math inline">\([L,R]\)</span> 使其包含 <span class="math inline">\([l,r]\)</span>，就在这两条线段间连一条边），会连成一棵森林。</p>
<p>令 <span class="math inline">\(f[i]\)</span> 表示第 <span class="math inline">\(i\)</span> 条线段去掉两个端点后没有被其儿子覆盖的长度。这个长度内我们可以自由填。</p>
<p>定理：用 <span class="math inline">\(n\)</span> 对括号填满 <span class="math inline">\(2n\)</span> 个位置构成平衡括号序列的方案数为 <span class="math inline">\(C_{n}\)</span>（卡特兰数的第 <span class="math inline">\(n\)</span> 项） 。</p>
<p>于是答案即为 <span class="math inline">\(\prod\limits_{i=1}^m C_{f[i]/2}\)</span>，<span class="math inline">\(m\)</span> 为当前添加的括号组数。</p>
<p>F1 中，我们可以每次添加括号后 <span class="math inline">\(O(n)\)</span> 地去扫这个序列，求出 <span class="math inline">\(f[i]\)</span>。</p>
<p>具体地，把非右括号装进栈，扫到右括号时计数弹出了多少元素。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>F2 需要动态地维护 <span class="math inline">\(f[i]\)</span>，题解给出了一种平衡树做法，但离线是简单的，这里只讲离线怎么做。</p>
<p>倒着操作，相当于每次拿走一组括号，此时只有这条线段本身和其父亲的贡献发生了变化。具体地，设当前为第 <span class="math inline">\(i\)</span> 条线段，父亲为第 <span class="math inline">\(fa_i\)</span> 条线段，那么答案只需要在之前答案的基础上加上 <span class="math inline">\(-C_{f[i]/2}-C_{f[fa_i]/2}+C_{(f[fa_i]+f[i]+2)/2}\)</span>。</p>
<p>快速定位到父亲是哪条线段可以用并查集，时间复杂度 <span class="math inline">\(O(n\log n + n\alpha)\)</span>。</p>
<h2 id="cf2063e.-triangle-tree"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2063/problem/E">CF2063E. Triangle Tree</a></h2>
<p>*2300 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2063/submission/302994147">Code</a></p>
<p>草稿纸画一画，易知： <span class="math display">\[
\begin{align}
f(x,y)&amp;= 2\min(\text{dis}(x,\text{lca}_{x,y}),\text{dis}(y,\text{lca}_{x,y}))-1 \\
&amp;= 2\min(\text{dep}_x,\text{dep}_y)-2\text{dep}_{\text{lca}_{x,y}}-1
\end{align}
\]</span> 前提是 <span class="math inline">\(x,y\)</span> 没有祖先关系。</p>
<p>这样就把贡献拆成了三部分，可以分别计算：</p>
<ul>
<li><span class="math inline">\(\min(\text{dep}_x, \text{dep}_y)\)</span>：枚举 <span class="math inline">\(x\)</span>，则每个深度比 <span class="math inline">\(x\)</span> 大且不在 <span class="math inline">\(x\)</span> 子树中的 <span class="math inline">\(y\)</span> 有 <span class="math inline">\(\text{dep}_x\)</span> 的贡献。令 <span class="math inline">\(d_x\)</span> 表示深度 <span class="math inline">\(\ge x\)</span> 的节点数（可以通过一个后缀和实现），分为两种情况。
<ul>
<li><span class="math inline">\(\text{dep}_x &lt; \text{dep}_y\)</span>：贡献为 <span class="math inline">\((d_{dep_x+1}-(sz_x-1))\times dep_x\)</span>。</li>
<li><span class="math inline">\(\text{dep}_x=\text{dep}_y\)</span>：贡献为 <span class="math inline">\((d_{dep_x}-d_{dep_x+1}-1)\times dep_x\)</span>，最后要除以 <span class="math inline">\(2\)</span> 使无序对 <span class="math inline">\(\to\)</span> 有序对。</li>
</ul></li>
<li><span class="math inline">\(\text{dep}_{\text{lca}_{x,y}}\)</span>：枚举 <span class="math inline">\(\text{lca}\)</span>，对于当前点 <span class="math inline">\(x\)</span>，贡献为 <span class="math inline">\(\sum_{y\in son[x]}sz_y\times (sz_x-1-sz_y)\times dep_x\)</span>。</li>
<li><span class="math inline">\(1\)</span>：即没有祖先关系的 <span class="math inline">\((x,y)\)</span> 组数。对于当前点 <span class="math inline">\(x\)</span>，贡献为 <span class="math inline">\(n-sz_x-dep_x+1\)</span>。</li>
</ul>
<p>第 <span class="math inline">\(2, 3\)</span> 部分最后也需要除以 <span class="math inline">\(2\)</span>，从而只计算有序对。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="cf2060f.-multiplicative-arrays"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2060/problem/F">CF2060F. Multiplicative Arrays</a></h2>
<p>*2200 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2060/submission/303010975">Code</a></p>
<p>首先注意到构造出的 <span class="math inline">\(\{a\}\)</span> 中 <span class="math inline">\(&gt; 1\)</span> 的数不超过 <span class="math inline">\(16\)</span> 个（因为 <span class="math inline">\(2^{17}&gt;10^5\)</span>）。</p>
<p>于是这个计数分为两步：</p>
<ol type="1">
<li><p>算 <span class="math inline">\(&gt;1\)</span> 的数构成 <span class="math inline">\(x\)</span> 有多少种可能。</p></li>
<li><p>算剩下的 <span class="math inline">\(1\)</span> 有多少种插空方法。</p></li>
</ol>
<p>令 <span class="math inline">\(dp[i][j]\)</span> 代表 <span class="math inline">\(i\)</span> 个 <span class="math inline">\(&gt;1\)</span> 的数构成 <span class="math inline">\(j\)</span> 的方案数。</p>
<ul>
<li>初态：<span class="math inline">\(\forall i\in[2,k]\)</span>，<span class="math inline">\(dp[1][i]=1\)</span>。</li>
<li>转移：<span class="math inline">\(dp[i][j] = \sum\limits_{k&gt;1} dp[i-1][\dfrac{j}{k}]\)</span>。</li>
</ul>
<p>令 <span class="math inline">\(ans[x]\)</span> 代表乘积为 <span class="math inline">\(x\)</span> 时的方案数，当 <span class="math inline">\(x=1\)</span> 时显然为 <span class="math inline">\(n\)</span>，当 <span class="math inline">\(x &gt; 1\)</span> 时： <span class="math display">\[
ans[x]=\sum_{i=1}^{n}\sum_{j=1}^{16} dp[j][x]\binom{i}{j}
\]</span> 其中 <span class="math inline">\(i\)</span> 为枚举的序列长度，<span class="math inline">\(\binom{i}{j}\)</span> 代表选出 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(&gt;1\)</span> 的数的位置，继续化简： <span class="math display">\[
\begin{align}
ans[x]&amp;=\sum_{j=1}^{16}\left(dp[j][x]\sum_{i=1}^{n}\binom{i}{j}\right)\\
&amp;=\sum_{j=1}^{16}dp[j][x]\binom{n+1}{j+1}
\end{align}
\]</span> 这里运用了上指标求和公式：<span class="math inline">\(\sum\limits_{i=1}^{n}\binom{i}{j}=\binom{n+1}{j+1}\)</span>，可以借助杨辉三角记忆。</p>
<p>虽然 <span class="math inline">\(n\)</span> 比较大，但 <span class="math inline">\(\binom{n+1}{j+1}\)</span> 可以用定义 <span class="math inline">\(O(\log k)\)</span> 求得，故总时间复杂度 <span class="math inline">\(O(k\log^2k)\)</span>。</p>
<h2 id="cf2007e.-iris-and-the-tree"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2007/problem/E">CF2007E. Iris and the Tree</a></h2>
<p>*1800 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2007/submission/303238809">Code</a></p>
<p>编号是 dfs 序，说明任意一条边都恰好被两条 <span class="math inline">\(i\to i+1\)</span> 的路径经过（初次遍历时至上而下一条，回溯时至下而上一条）。</p>
<p>我们可以暴力地把每条 <span class="math inline">\(i\to i+1\)</span> 的路径经过的点记录下来，由于总长度是 <span class="math inline">\(2n\)</span>，所以是线性的。</p>
<p>当我们给一条边赋值后，我们找到这条边对应的两条路径，此时这两条路径的边权和有两种情况：</p>
<ul>
<li>这条路径上仍然有边权不确定的点。此时可以把剩余的权值全部分配给那条边权不确定的边。</li>
<li>这条路径上所有边都被赋值了。此时边权和是固定的。</li>
</ul>
<p>我们可以记录两个信息以快速计算贡献，分别是已经赋值过的权值和 <span class="math inline">\(add\)</span> 以及未被全部赋值的路径条数 <span class="math inline">\(cnt\)</span>。</p>
<p>此时第二种情况和第一种情况的已赋值部分等价于 <span class="math inline">\(2\cdot add\)</span>，第一种情况的未赋值部分等价于 <span class="math inline">\(cnt\cdot(w-add)\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。带 <span class="math inline">\(\log\)</span> 是因为使用了 <code>std::set</code> 来辅助计算 <span class="math inline">\(cnt\)</span>。</p>
<h2 id="cf2007f.-eri-and-expanded-sets"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2007/problem/F">CF2007F. Eri and Expanded Sets</a></h2>
<p>*2300 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2007/submission/303324539">Code</a></p>
<p>连续意味着排序后相邻两项的差是 <span class="math inline">\(1\)</span>，这引导我们思考差分数组。</p>
<p>结论：对于一个有序序列 <span class="math inline">\(\{a\}\)</span>，它不能再进行 expand 当且仅当它的差分数组 <span class="math inline">\(\{b\}\)</span> 全为奇数且相同。换句话说，<span class="math inline">\(\{a\}\)</span> 是公差为奇数的等差数列。</p>
<ul>
<li>若 <span class="math inline">\(b_i=a_{i+1}-a_i\)</span> 为偶数，则一定有 <span class="math inline">\(c=\frac{a_i+a_{i+1}}{2}\in(a_i,a_{i+1})\)</span> 可以加进 set 里。</li>
<li>若存在相邻两项 <span class="math inline">\(b_i,b_{i+1}\)</span> 为奇数但不同，则 <span class="math inline">\(b_i+b_{i+1}=a_{i+2}-a_{i}\)</span> 为偶数，且 <span class="math inline">\(c=\frac{a_{i+2}+a_i}{2}\in(a_i,a_{i+1})\cup(a_{i+1},a_{i+2})\)</span> 不在序列里，可以再 expand。</li>
</ul>
<p>进一步地，假定 <span class="math inline">\(g=\gcd\limits_{i\in[1,n)}(|a_{i}-a_{i+1}|)\)</span>，<span class="math inline">\(\{a\}\)</span> 的公差为 <span class="math inline">\(d\)</span>，则 <span class="math inline">\(d\)</span> 一定是 <span class="math inline">\(g\)</span> 除以 <span class="math inline">\(2\)</span> 的若干次幂得到。具体地，<span class="math inline">\(d=\dfrac{g}{\text{lowbit}(g)}\)</span>。</p>
<ul>
<li>因为任意两项的差要是公差 <span class="math inline">\(d\)</span> 的倍数，故 <span class="math inline">\(d\)</span> 是相邻两项差的 <span class="math inline">\(\gcd\)</span> 的因数 。而 <span class="math inline">\(g\)</span> 能再分的前提是 <span class="math inline">\(g\)</span> 是偶数，故 <span class="math inline">\(g\)</span> 不断除以 <span class="math inline">\(2\)</span> 直到为奇数就得到 <span class="math inline">\(d\)</span>，写成公式就是上面那样。</li>
</ul>
<p>还需要注意的是这里引入了 <span class="math inline">\(\gcd\)</span>，根据其辗转相减的性质，结论对于无序数组依然成立。</p>
<p>回到题目的要求，连续即 <span class="math inline">\(d=1\)</span>，即：</p>
<p><span class="math display">\[
d=\dfrac{g}{\text{lowbit}(g)}=1\Longrightarrow g=\text{lowbit}(g)\Longrightarrow g=0 \cup g=2^k,k\ge 0
\]</span></p>
<p>转化为求 <span class="math inline">\(\{b\}\)</span> 有多少个子区间的 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(2\)</span> 的幂。</p>
<p>枚举左端点 <span class="math inline">\(L\)</span>，二分找到第一个右端点 <span class="math inline">\(R\)</span> 满足 <span class="math inline">\(\underline{\ }\text{builtin}\underline{}\text{popcount}\left(\gcd\limits_{i\in[L,R]}b_i\right)=1\)</span>。则区间 <span class="math inline">\([L,R], [L,R+1],[L,R+2],\cdots,[L,n]\)</span> 的 <span class="math inline">\(\gcd\)</span> 均为 <span class="math inline">\(2\)</span> 的幂次。这是因为 <span class="math inline">\(2\)</span> 的幂次只有因数 <span class="math inline">\(2\)</span>，与任何数做 <span class="math inline">\(\gcd\)</span> 也只能得到 <span class="math inline">\(2\)</span> 的幂次。</p>
<p>还是通过二分找到最后一个右端点 <span class="math inline">\(R\)</span> 满足 <span class="math inline">\(\gcd\limits_{i\in[L,R]}b_i=0\)</span>，则区间 <span class="math inline">\([L,L],[L,L+1],[L,L+2],\cdots,[L,R]\)</span> 的 <span class="math inline">\(\gcd\)</span> 均为 <span class="math inline">\(0\)</span>，原因显然。</p>
<p>区间 <span class="math inline">\(\gcd\)</span> 可以用 ST 表实现，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf2062d.-balanced-tree"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2062/problem/D">CF2062D. Balanced Tree</a></h2>
<p>*2200 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2062/submission/303333922">Code</a></p>
<p>操作是：选定一个根，再让一个点的子树 <span class="math inline">\(+1\)</span>。</p>
<p>对于一条边，我们只会让它一侧的所有节点 <span class="math inline">\(+1\)</span>（因为两侧都加等价于整棵树加，是没有意义的）。</p>
<p>想象所有点都已经固定点权了，此时肯定是让点权小的一侧的所有点权 <span class="math inline">\(+1\)</span>。边的决策取决于两侧的节点，不妨先随意选定一个根，进行至下而上地贪心。</p>
<p>设 <span class="math inline">\(f[x]\)</span> 为节点 <span class="math inline">\(x\)</span> 的答案，并初始化一个 <span class="math inline">\(delta=0\)</span> 代表全局 tag。对于当前节点 <span class="math inline">\(x\)</span>，若为叶子，选 <span class="math inline">\(L[x]\)</span> 肯定不劣；否则有两种情况：</p>
<ul>
<li><span class="math inline">\(\forall y\in son[x]\)</span>，<span class="math inline">\(f[y]\le r[x]\)</span>。此时选 <span class="math inline">\(\max(l[x],\max\limits_{y\in son[x]} f[y])\)</span> 肯定最优。因为可以让某一个儿子所在的子树变大，儿子之间互不影响。</li>
<li><span class="math inline">\(\exists y\in son[x],f[y]&gt;r[x]\)</span>。此时节点 <span class="math inline">\(x\)</span> 只能选 <span class="math inline">\(r[x]\)</span>，为了让所有节点权值一样只能让 <span class="math inline">\(x\)</span> 沿着根方向的子树 <span class="math inline">\(+1\)</span>。并且对于每个儿子所在的子树，造成的贡献是累加的，即 <span class="math inline">\(delta \leftarrow delta + \sum\limits_{y\in son[x],f[y] &gt; r[x]} (f[y]-r[x])\)</span>。</li>
</ul>
<p>答案即 <span class="math inline">\(f[rt]+delta\)</span>，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="cf2033g.-sakurako-and-chefir"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2033/problem/G">CF2033G. Sakurako and Chefir</a></h2>
<p>*2200 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2033/submission/303354940">Code</a></p>
<p>对于一组询问 <span class="math inline">\((v,k)\)</span>，我们直接跳到 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(k\)</span> 级祖先（设为 <span class="math inline">\(x\)</span>）一定不劣。</p>
<p>那么询问等价于找 <span class="math inline">\(x\)</span> 的子树中距 <span class="math inline">\(v\)</span> 最远的点。</p>
<p>这个最远的点一定是 <span class="math inline">\(x\)</span> 的子树的两个直径端点之一。</p>
<p>问题转化为对树上的每个点 <span class="math inline">\(x\)</span>，求其子树的直径的两个端点。</p>
<p>这仍然是一个套路化的问题，回顾一下做法：</p>
<ul>
<li>至下而上考虑，设当前考虑的节点为 <span class="math inline">\(x\)</span>。</li>
<li>若 <span class="math inline">\(x\)</span> 为叶子，两个直径端点都是它自身。</li>
<li>若 <span class="math inline">\(x\)</span> 恰有一个儿子 <span class="math inline">\(y\)</span>，考虑 <span class="math inline">\(x\)</span> 是否能与 <span class="math inline">\(y\)</span> 的两个端点之一来作为新的直径，不能就直接继承 <span class="math inline">\(y\)</span> 的答案。</li>
<li>若 <span class="math inline">\(x\)</span> 有两个儿子 <span class="math inline">\(y_1,y_2\)</span>，答案为两种情况取 <span class="math inline">\(\max\)</span>：
<ul>
<li>继承自 <span class="math inline">\(y_1\)</span> 或 <span class="math inline">\(y_2\)</span>。</li>
<li>穿过 <span class="math inline">\(x\)</span> 将两段拼起来。此时新的直径端点肯定有一个来自 <span class="math inline">\(y_1\)</span> 的两个端点之一，另一个来自 <span class="math inline">\(y_2\)</span> 的两个端点之一。</li>
</ul></li>
<li>若 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(&gt; 2\)</span> 个儿子，按上一种情况每次合并两个子树，直到合并完为止。</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf1993d.-med-imize"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1993/problem/D">CF1993D. Med-imize</a></h2>
<p>*2200 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1993/submission/303478399">Code</a></p>
<p>答案具有二分性，设二分出的答案为 <span class="math inline">\(mid\)</span>。</p>
<p>中位数套路：<span class="math inline">\(\forall i\in[1,n]\)</span>，令 <span class="math inline">\(b[i]=\begin{cases}1&amp;,a[i]\ge mid \\ -1&amp;,a[i]&lt;mid\end{cases}\ \)</span>，则 <span class="math inline">\(\sum b[i]&gt;0 \Longleftrightarrow mid\le median(a)\)</span>。</p>
<p>题目转化为：给定 <span class="math inline">\(\{b\}\)</span>，每次任选一个长为 <span class="math inline">\(k\)</span> 的段删掉，直到不能删为止，剩下数的和是否 <span class="math inline">\(&gt;0\)</span>。</p>
<p>这里给出其中一种 dp 方案。</p>
<p>令 <span class="math inline">\(dp[i][j]\)</span> 表示前 <span class="math inline">\(i\)</span> 个数选了 <span class="math inline">\(j\)</span> 个长为 <span class="math inline">\(k\)</span> 的段删去后，剩下数和的最大值。</p>
<p>则 <span class="math inline">\(dp[i][j] = \max(dp[i-1][j]+b[i],dp[i-k][j - 1])\)</span>，答案为 <span class="math inline">\(dp[n][\left\lfloor\frac{n-1}{k}\right\rfloor]\)</span>。</p>
<p>考虑到 <span class="math inline">\(0\le i-jk\le k \Longrightarrow j\in\left[\left\lfloor\dfrac{i-1}{k}\right\rfloor,\left\lfloor\dfrac{i}{k}\right\rfloor\right]\)</span>，即 <span class="math inline">\(j\)</span> 只有两种取值。</p>
<p>故不妨令 <span class="math inline">\(dp[i][j=0/1]\)</span> 表示前 <span class="math inline">\(i\)</span> 个数选了 <span class="math inline">\(\left\lfloor\dfrac{i-1}{k}\right\rfloor+j\)</span> 个长为 <span class="math inline">\(k\)</span> 的段删去后，剩下数和的最大值。</p>
<p>使用记忆化搜索转移，时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 是值域。</p>
<p>官方题解里是另一种 dp，我花了半个小时仍未完全理解，希望有生之年能够参悟。</p>
<h2 id="cf1993f1f2.-dyn-scripted-robot"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1993/problem/F2">CF1993F1/F2. Dyn-scripted Robot</a></h2>
<p>*2400 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1993/submission/303822753">Code</a>（F1）</p>
<p>*2800 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1993/submission/303832230">Code</a>（F2）</p>
<p>我们假定一个在没有墙的二维平面中移动的机器人称作 <span class="math inline">\(B\)</span>，题中的机器人称作 <span class="math inline">\(A\)</span>。由于 <span class="math inline">\(B\)</span> 相比 <span class="math inline">\(A\)</span> 取消了墙的限制，移动序列自然不会改变。</p>
<p>结论：<span class="math inline">\(A\)</span> 回到原点的次数 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(B\)</span> 经过点 <span class="math inline">\((x,y),\begin{cases}x\equiv 0\pmod{2w} \\ y\equiv 0 \pmod{2h} \end{cases}\)</span> 的次数。</p>
<ul>
<li>先考虑只存在沿 <span class="math inline">\(y\)</span> 轴方向的移动，当 <span class="math inline">\(A\)</span> 撞到 <span class="math inline">\(y=h\)</span> 后，<span class="math inline">\(A,B\)</span> 运动轨迹沿 <span class="math inline">\(y=h\)</span> 轴对称；而 <span class="math inline">\(A\)</span> 再撞到 <span class="math inline">\(y=0\)</span>（<span class="math inline">\(B\)</span> 撞到 <span class="math inline">\(y=2h\)</span>）后，二者运动方向恢复一致。<span class="math inline">\(x\)</span> 轴方向的运动同理，外推后不难得出该结论。</li>
</ul>
<p>故只需研究 <span class="math inline">\(B\)</span> 的运动即可。设 <span class="math inline">\(x_i\ (i\in[1,n])\)</span> 表示 <span class="math inline">\(B\)</span> 从 <span class="math inline">\((0,0)\)</span> 开始，经过 <span class="math inline">\(i\)</span> 次移动后的横坐标（在 <span class="math inline">\(\bmod 2w\)</span> 同余系下）; <span class="math inline">\(y_i\ (i\in[1,n])\)</span> 表示 <span class="math inline">\(B\)</span> 从 <span class="math inline">\((0, 0)\)</span> 开始，经过 <span class="math inline">\(i\)</span> 次移动后的纵坐标（在 <span class="math inline">\(\bmod 2h\)</span> 同余系下）。</p>
<p>假设 <span class="math inline">\(B\)</span> 已经执行了完整的移动序列 <span class="math inline">\(i\in[0,k)\)</span> 次，并额外移动了 <span class="math inline">\(j\in[1,n]\)</span> 次，那么坐标为 <span class="math inline">\((ix_n+x_j,iy_n+y_j)\)</span>。题目转化为求有序对 <span class="math inline">\((i,j)\)</span> 的数目，满足：</p>
<p><span class="math display">\[
\begin{cases} 
x\equiv 0 \pmod{2w} \\
y\equiv 0 \pmod{2h}
\end{cases}
\Longrightarrow
\begin{cases}
ix_n+x_j\equiv 0 \pmod{2w} \\
iy_n+y_j\equiv 0 \pmod{2h}
\end{cases}
\]</span></p>
<p>对于 F1，将式子变形，得到：</p>
<p><span class="math display">\[
\begin{cases}
x_j\equiv -ix_n \pmod{2w} \\
y_j\equiv -iy_n \pmod{2h}
\end{cases}
\]</span></p>
<p>我们可以把执行一次移动序列经过的点的坐标存到一个 <code>std::map</code> 里，然后枚举 <span class="math inline">\(i\in[0,k)\)</span>，查一下 <code>std::map</code> 中点 <span class="math inline">\((-ix_n,-iy_n)\)</span> 的值即可。时间复杂度 <span class="math inline">\(O(k\log n)\)</span>。</p>
<p>对于 F2，将式子变形，得到：</p>
<p><span class="math display">\[
\begin{cases}
ix_n\equiv -x_j \pmod{2w} \\
iy_n\equiv -y_j \pmod{2h}
\end{cases}
\]</span></p>
<p>在这个方程组中，除了 <span class="math inline">\(i\)</span> 均为已知，于是可以枚举 <span class="math inline">\(x_j\)</span>，用中国剩余定理解 <span class="math inline">\(n\)</span> 遍即可。在此之前，还需要把方程转化为 <span class="math inline">\(x\equiv a\pmod{p}\)</span> 的标准形式。</p>
<p>由于 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(\bmod p\)</span> 下的逆元仅在 <span class="math inline">\(a,p\)</span> 互质时存在，故令 <span class="math inline">\(g=\gcd(2w,x_n)\)</span>，则：</p>
<p><span class="math display">\[
\begin{align}
ix_n&amp;\equiv -x_j \pmod{2w}\\
i\cdot\frac{x_n}{g}&amp;\equiv -\frac{x_j}{g}\pmod{\frac{2w}{g}}\\
i &amp;\equiv -\frac{x_j}{g}\left(\frac{x_n}{g}\right)^{-1}\pmod{\frac{2w}{g}}
\end{align}
\]</span></p>
<p>显然当 <span class="math inline">\(g \nmid x_j\)</span> 时方程无解。另一个方程组同理。</p>
<p>对于一组 <span class="math inline">\((x_j,y_j)\)</span>，用 CRT 解出最小的 <span class="math inline">\(i\)</span> 后，问题转化为 <span class="math inline">\(i,i+M,i+2M,\cdots\)</span> 中有几个在 <span class="math inline">\([0,k-1)\)</span> 范围内，答案是 <span class="math inline">\(\dfrac{k-1-i}{M}+1\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p>
<h2 id="cf1972d.-reverse-card-hard-version"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1972/problem/D2">CF1972D. Reverse Card (Hard Version)</a></h2>
<p>*2200 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1972/submission/303818473">Code</a></p>
<p>题目要求满足 <span class="math inline">\(a\in[1,n]\)</span>，<span class="math inline">\(b\in[1,m]\)</span>，<span class="math inline">\((a+b)\mid b\cdot\gcd(a,b)\)</span> 的有序对 <span class="math inline">\((a,b)\)</span> 的数量。</p>
<p>令 <span class="math inline">\(d=\gcd(a,b)\)</span>，<span class="math inline">\(a=pd\)</span>，<span class="math inline">\(b=qd\)</span>，则 <span class="math inline">\(\gcd(p,q)=1\)</span>。代入得： <span class="math display">\[
\begin{align}
a+b&amp;\mid b\cdot\gcd(a,b)\\ 
\to (p+q)d&amp;\mid qd^2 \\ 
\to \quad \ p+q&amp;\mid qd\\
\to \quad\ p+q&amp;\mid d
\end{align}
\]</span> 最后一步是因为 <span class="math inline">\(\gcd(p,q)=1 \to \gcd(p+q,q)=1\)</span>。</p>
<p>又因为：</p>
<p><span class="math display">\[
\begin{align}
p+q\mid d \to p+q\le d\to p\le d=\dfrac{a}{p}\le \dfrac{n}{p}
\end{align}
\]</span></p>
<p>于是 <span class="math inline">\(p^2 \le n \to p\in[1,\sqrt{n}]\)</span>，同理 <span class="math inline">\(q\in[1,\sqrt{m}]\)</span>。</p>
<p><span class="math inline">\(O(\sqrt{nm})\)</span> 枚举 <span class="math inline">\(p,q\)</span>，当 <span class="math inline">\(\gcd(p,q)=1\)</span> 时，贡献等价于有多少 <span class="math inline">\(d\)</span> 满足 <span class="math inline">\(p+q\mid d\)</span> 且 <span class="math inline">\(d\le \min(\dfrac{n}{p},\dfrac{m}{q})\)</span>，即 <span class="math inline">\(\left\lfloor\dfrac{\min(\dfrac{n}{p},\dfrac{m}{q})}{p+q}\right\rfloor\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf1824b2.-luotianyi-and-the-floating-islands-hard-version"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1824/problem/B2">CF1824B2. LuoTianyi and the Floating Islands (Hard Version)</a></h2>
<p>*2300 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1824/submission/304516792">Code</a></p>
<p>规定有人的点称为黑点，到所有黑点距离和最小的点称为目标点。</p>
<p>结论：目标点构成一个连通块。</p>
<ul>
<li>比较显然。</li>
</ul>
<p>结论：当 <span class="math inline">\(k\)</span> 为奇数时，答案为 <span class="math inline">\(1\)</span>。</p>
<ul>
<li>对于任意一个有奇数个黑点的局面，假定我们已经找到了一个目标点 <span class="math inline">\(x\)</span>。若存在 <span class="math inline">\(x\)</span> 的一个邻居 <span class="math inline">\(y\)</span> 也是目标点，那么 <span class="math inline">\(x\to y\)</span> 移动的过程中理应没有额外贡献，换句话说边 <span class="math inline">\((x,y)\)</span> 两侧黑点数目相同。此时黑点个数定为偶数，矛盾。故对于任意一个奇数个黑点的局面有且仅有一个目标点。</li>
</ul>
<p>接下来考虑将点的贡献放到边上，好处是目标点构成连通块，边的数量总是目标点数量 <span class="math inline">\(-1\)</span>，而且边的贡献容易计算。</p>
<p>当 <span class="math inline">\(k\)</span> 为偶数时，根据上述分析，一条边当且仅当两侧黑点数目相同时有贡献，故贡献为两侧各选 <span class="math inline">\(\dfrac{k}{2}\)</span> 个黑点的方案数。</p>
<p>任选根计算出 <span class="math inline">\(sz[x]\)</span> 为子树大小，那么答案即 <span class="math inline">\(\dfrac{\sum\limits_{x=1}^{n}\sum\limits_{y\in son[x]}\dbinom{sz[y]}{\dfrac{k}{2}}\dbinom{n-sz[y]}{\dfrac{k}{2}}}{\dbinom{n}{k}}+1\)</span> 。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="cf1989d.-smithing-skill"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1989/problem/D">CF1989D. Smithing Skill</a></h2>
<p>*1900 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1989/submission/304548337">Code</a></p>
<p>首先，不同 <span class="math inline">\(c_j\)</span> 互不影响。其次，对于一个 <span class="math inline">\(c_j\)</span>，肯定是选满足 <span class="math inline">\(c_j\ge a_i\)</span> 的武器中 <span class="math inline">\(a_i-b_i\)</span> 最小的武器，并不断地合成再焚毁直到 <span class="math inline">\(c_j &lt; a_i\)</span> 为止。</p>
<p>考虑阈值分治，令 <span class="math inline">\(A=\max a_i\)</span>，可以先对每个 <span class="math inline">\(i\in[1,A]\)</span> 预处理出 <span class="math inline">\(res[i]\)</span> 表示 <span class="math inline">\(i\)</span> 个矿石能够获得的最大经验点数；而对于 <span class="math inline">\(c_j &gt; A\)</span> 的询问，用最小的 <span class="math inline">\(a_i-b_i\)</span> 处理直到 <span class="math inline">\(c_j \le A\)</span>，就能直接查表查到 <span class="math inline">\(res[c_j]\)</span>。</p>
<p>其中 <span class="math inline">\(res[i]\)</span> 的预处理仍然不简单，我们可以定义一个辅助数组 <span class="math inline">\(d[i]\)</span> 表示所有 <span class="math inline">\(a_i \le i\)</span> 的武器里面 <span class="math inline">\(a_i-b_i\)</span> 的最小值。在此基础上，有递推 <span class="math inline">\(res[i]=2+res[i-d[i]]\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n+w+m)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p>
<h2 id="cf1972e.-fenwick-tree"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1972/problem/E">CF1972E. Fenwick Tree</a></h2>
<p>*2300 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1972/submission/304751560">Code</a></p>
<p>首先要知道树状数组的结构是怎么样的，这里引用题解的一张图。</p>
<p><img src="/image/academic/fenwick.png" /></p>
<p>其中 <span class="math inline">\(c_1,c_2,\cdots c_{10}\)</span> 就是迭代一次后的数组，即 <span class="math inline">\(f^{1}(a)\)</span>。</p>
<p>故每次迭代相当于把上一次迭代后的数组作为叶子，再向上合并一遍。</p>
<p>我们考虑对每个 <span class="math inline">\(c_i\)</span>，把它的贡献从它的祖先中除去。</p>
<p>例如，当 <span class="math inline">\(k=1\)</span> 时，对于 <span class="math inline">\(c_1\)</span>，要把 <span class="math inline">\(c_1\)</span> 从 <span class="math inline">\(c_2,c_4,c_8\)</span> 中除去，此时系数显然都是 <span class="math inline">\(1\)</span>。（系数即 "减去几倍的 <span class="math inline">\(c_1\)</span>"）</p>
<p>当 <span class="math inline">\(k=2\)</span> 时，<span class="math inline">\(c_2\)</span> 在第一次迭代的基础上再累加了一遍 <span class="math inline">\(c_1\)</span>，系数是 <span class="math inline">\(1+1=2\)</span>；<span class="math inline">\(c_4\)</span> 累加了 <span class="math inline">\(c_2\)</span>，系数是 <span class="math inline">\(1+2=3\)</span>；<span class="math inline">\(c_8\)</span> 累加了 <span class="math inline">\(c_4\)</span>，系数是 <span class="math inline">\(1+3=4\)</span>。</p>
<p>当 <span class="math inline">\(k=3\)</span> 时，<span class="math inline">\(c_2\)</span> 再累加一遍 <span class="math inline">\(c_1\)</span>，系数是 <span class="math inline">\(2+1=3\)</span>；<span class="math inline">\(c_4\)</span> 累加 <span class="math inline">\(c_2\)</span>，系数是 <span class="math inline">\(3+3=6\)</span>；<span class="math inline">\(c_8\)</span> 累加 <span class="math inline">\(c_4\)</span>，系数是 <span class="math inline">\(4+6=10\)</span>。</p>
<p>可以发现，对于相同的 <span class="math inline">\(k\)</span>，系数只和向上爬升的层数有关，列成一个表。</p>
<p><span class="math inline">\(k=1\to 1,1,1,1,1,\cdots\)</span></p>
<p><span class="math inline">\(k=2\to 2,3,4,5,\cdots\)</span></p>
<p><span class="math inline">\(k=3\to 3,6,10,\cdots\)</span></p>
<p><span class="math inline">\(k=4\to 4,10,\cdots\)</span></p>
<p>将这个三角形摆正，可以发现就是杨辉三角。</p>
<p>其中，第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 项表示 <span class="math inline">\(k=i\)</span> 时向上爬升 <span class="math inline">\(j\)</span> 层需要减去的系数，组合数写出来就是 <span class="math inline">\(\dbinom{i+j-1}{j}\)</span>。</p>
<p>由于树状数组不超过 <span class="math inline">\(\log n\)</span> 层，故时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf1996g.-penacony"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1996/problem/G">CF1996G. Penacony</a></h2>
<p>*2200 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1996/submission/304762843">Code1</a> <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1996/submission/304805042">Code2</a></p>
<p><strong>solution1</strong>：对于一对朋友 <span class="math inline">\((a,b)\)</span>，他们之间有且仅有两条路径，并且这两条路径构成一个环。因此最为关键的观察是 '"只要钦定某一条边是断开的，那么每一对朋友间的路径就是唯一的"。</p>
<p>建一棵 <span class="math inline">\(n\)</span> 个点的线段树，每个位置的值代表对应的道路被几对朋友占用了。一开始，先将所有 <span class="math inline">\([a,b)\)</span> 区间 <span class="math inline">\(+1\)</span>。从左到右枚举每条边并钦定为断开，如遇到左端点就将 <span class="math inline">\([1,a),[b,n]+1\)</span>，<span class="math inline">\([a,b)-1\)</span>；如遇右端点就将 <span class="math inline">\([1,a),[b,n]-1\)</span>，<span class="math inline">\([a,b)+1\)</span>。每次修改完查询 <span class="math inline">\([1,n]\)</span> 中 <span class="math inline">\(0\)</span> 出现的次数就是非必须保留的道路数目。</p>
<p>由于整个修改过程线段树保存的值非负，故 <span class="math inline">\(0\)</span> 出现的次数等价于最小值出现的次数。</p>
<p><strong>solution2</strong>：将这 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(n\)</span> 条边看成一个 <span class="math inline">\(n\)</span> 边形，对于一对朋友 <span class="math inline">\((a,b)\)</span>，在 <span class="math inline">\(a,b\)</span> 间连对角线。</p>
<p>断言：对于任意两条边，如果它们被相同的对角线集合覆盖，那么这两条边可以删去。</p>
<ul>
<li>你可以想象每条对角线都有正反面，正面对应多边形上的边和反面对应多边形上的边被认为是不同的。就一对朋友关系而言，你能且仅能选择两段其一。</li>
</ul>
<p>对于每条对角线，我们不妨把其任一侧的所有边异或上一个固定的值。</p>
<p>利用差分和前缀和，就能 <span class="math inline">\(O(n)\)</span> 求出每条边在 “染色” 后的权值。此时两条边权值相同就等价于被相同的对角线集合覆盖了。</p>
<p>最后，用一个 <code>std::map</code> 统计出现次数最多的权值即可。</p>
<p>两种方法时间复杂度均为 <span class="math inline">\(O(n\log n)\)</span>，后者常数小很多。</p>
<h2 id="cf1983e.-i-love-balls"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1983/problem/E">CF1983E. I Love Balls</a></h2>
<p>*2300 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1983/submission/305424717">Code</a></p>
<p>数学题。令 <span class="math inline">\(special=\dfrac{\sum_{i=1}^{k}v_i}{k}\)</span>，<span class="math inline">\(normal=\dfrac{\sum_{i=k+1}^{n}v_i}{n-k}\)</span>，分别表示特殊球和普通球的期望价值。</p>
<p>考虑将 <span class="math inline">\(k\)</span> 特殊球插进 <span class="math inline">\(n-k+1\)</span> 个普通球的 gap 里面，每个 gap 可以放多个特殊球，这么建立模型的好处是你选中一个 gap 就拿完这个 gap 里的所有球，符合特殊球的机制。</p>
<p>Alice 会选中 <span class="math inline">\(\left\lceil\dfrac{n-k+1}{2}\right\rceil\)</span> 个 gap，每个 gap 里特殊球期望有 <span class="math inline">\(\dfrac{k}{n-k+1}\)</span> 个，故 Alice 选中特殊球价值的期望总和是 <span class="math inline">\(\dfrac{\lceil\frac{n-k+1}{2}\rceil \cdot k}{n-k+1}\cdot special\)</span>。</p>
<p>而 Alice 作为先手会选中 <span class="math inline">\(\left\lceil\dfrac{n-k}{2}\right\rceil\)</span> 个普通球，故他选中普通球价值的期望总和是 <span class="math inline">\(\left\lceil\dfrac{n-k}{2}\right\rceil\cdot normal\)</span>。</p>
<p>根据期望的线性性， 上述两个式子相加就是 Alice 的答案。Bob 的答案即所有球的价值总和减去 Alice 的答案。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="cf1983f.-array-value"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1983/problem/F">CF1983F. array-value</a></h2>
<p>*2500 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1983/submission/305454555">Code</a></p>
<p>二分答案，设二分出的答案是 <span class="math inline">\(mid\)</span>，若至少有 <span class="math inline">\(k\)</span> 个区间的 value <span class="math inline">\(\le mid\)</span>，就往小二分，否则往大二分。</p>
<p>问题转化为判断求有多少个区间的 value <span class="math inline">\(\le mid\)</span>。</p>
<p>不妨枚举右端点 <span class="math inline">\(r\)</span>，此时只需找到最大的 <span class="math inline">\(l\)</span> 满足 <span class="math inline">\(a_l \oplus a_r \le mid\)</span>，那么左端点位于 <span class="math inline">\([1,l]\)</span> 内构成的区间均满足条件。</p>
<p>这是个经典的问题，使用一个 trie 就能维护，步骤如下：</p>
<ul>
<li>对每个 trie 树上的节点 <span class="math inline">\(p\)</span> 维护一个 <span class="math inline">\(mx[p]\)</span> 存储经过这个点的值中下标最大值。</li>
<li>假设当前对 <span class="math inline">\(a_i\)</span> 进行查询，我们要返回一个最大的 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(a_j\oplus a_i \le mid\)</span>。从大到小枚举每一位，设 <span class="math inline">\(a_i\)</span> 当前位为 <span class="math inline">\(x\)</span>，<span class="math inline">\(mid\)</span> 当前位为 <span class="math inline">\(m\)</span>。
<ul>
<li>若 <span class="math inline">\(m=0\)</span>，为了满足 <span class="math inline">\(\le mid\)</span> 的条件，<span class="math inline">\(a_j\)</span> 这一位应和 <span class="math inline">\(x\)</span> 相同，故只能向 <span class="math inline">\(x\)</span> 的方向走。</li>
<li>若 <span class="math inline">\(m=1\)</span>，那么两边都可以走：如果向 <span class="math inline">\(x\)</span> 一侧走，之后无论怎么走得到的 <span class="math inline">\(a_j\)</span> 都会满足 <span class="math inline">\(a_j \oplus a_i \le mid\)</span>，故直接累加 <span class="math inline">\(x\)</span> 一侧的 <span class="math inline">\(mx[p]\)</span>，并转而走向 <span class="math inline">\(x\)</span> 的对侧。</li>
</ul></li>
<li>最后走到底得到的 <span class="math inline">\(a_j\)</span> 一样满足条件，故答案还要和末尾节点的 <span class="math inline">\(mx[p]\)</span> 取 <span class="math inline">\(\max\)</span>。</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(n\log^2w)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p>
<h2 id="cf2004f.-make-a-palindrome"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2004/problem/F">CF2004F. Make a Palindrome</a></h2>
<p>*2600 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2004/submission/305497742">Code</a></p>
<p>结论：两种操作对最小操作次数的影响等价，即任选其中一种操作或两种操作都用得到的答案相同。</p>
<ul>
<li>考虑对于一个 <span class="math inline">\(\{b\}\)</span>，如何计算 <span class="math inline">\(f(b)\)</span>。设 <span class="math inline">\(\{b\}\)</span> 中第一个元素是 <span class="math inline">\(b_1\)</span>，最后一个是 <span class="math inline">\(b_n\)</span>。首先若 <span class="math inline">\(b_1=b_n\)</span>，可以将它们从序列中拿掉，直到 <span class="math inline">\(b_1 \neq b_n\)</span>。此时如果使用分裂操作肯定是选择将 <span class="math inline">\(b_1,b_n\)</span> 中较大的那个分解成较小的那个，不妨设 <span class="math inline">\(b_1 &lt; b_n\)</span>，则相当于耗费一次操作将 <span class="math inline">\(b_1,b_n\)</span> 去掉并在右侧添加一个 <span class="math inline">\(b_n-b_1\)</span>。此时若 <span class="math inline">\(b_n-b_1 \neq b_2\)</span>，那么此次分裂只是单纯把序列元素个数减少了一个，合并操作同样能做到。若 <span class="math inline">\(b_n-b_1=b_2\)</span>，说明此时可以额外将最左侧的 <span class="math inline">\(b_2\)</span> 和最右侧的 <span class="math inline">\(b_n-b_1\)</span> 去掉，一次操作相当于减少了两个元素；但移项可知 <span class="math inline">\(b_1+b_2=b_n\)</span>，说明最开始我们如果在左侧用一次合并生成 <span class="math inline">\(b_1+b_2\)</span> 再和右边的 <span class="math inline">\(b_n\)</span> 抵掉，也是减少了两个元素。于是分裂和合并操作是等价的。</li>
</ul>
<p>接下来我们只讨论合并操作。在最极端的情况下，将长为 <span class="math inline">\(n\)</span> 的序列变成回文需要 <span class="math inline">\(n-1\)</span> 次操作，考虑什么情况能减少操作次数。</p>
<p>结论：对于一个序列，如果其某一个非空前缀和某一个非空后缀的元素和相同，就能减少一次操作。</p>
<ul>
<li>设序列长为 <span class="math inline">\(n\)</span>，若 <span class="math inline">\([1,l]\)</span> 和 <span class="math inline">\([r,n]\)</span> 的元素和相同，说明从两端移去数的过程进行到只剩 <span class="math inline">\(\sum\limits_{i=1}^{l-1}a_i,a_l,a_{l+1},\cdots,a_{r-1},\sum\limits_{i=r}^{n}a_i\)</span> 或 <span class="math inline">\(\sum\limits_{i=1}^{l}a_i,a_{l+1},\cdots,a_{r-1},a_r,\sum\limits_{i=r+1}^{n}a_i\)</span> 时，头两个元素合并或后两个元素合并就能额外减少一个元素，换句话说少用了一次操作，并且操作后序列的结构和操作前一致，可以继续寻找最近的非空前缀和最近的非空后缀。</li>
</ul>
<p>特别地，找到的非空前缀和非空后缀可以相交，如何理解？若有 <span class="math inline">\([1,l]\)</span> 和 <span class="math inline">\([r,n]\)</span> 元素和相等但 <span class="math inline">\(l&gt;r\)</span>，说明一定有 <span class="math inline">\([1,r]\)</span> 和 <span class="math inline">\([l,n]\)</span> 元素和相等而中间 <span class="math inline">\([r,l]\)</span> 的部分共用，此时 <span class="math inline">\([r,l]\)</span> 一定构成回文串而不用删掉。</p>
<p>回到原本的问题上来，我们要计算 <span class="math inline">\(\{a\}\)</span> 所有非空子数组 <span class="math inline">\(\{b\}\)</span> 的 <span class="math inline">\(f(b)\)</span> 之和。假若我们在 <span class="math inline">\(\{a\}\)</span> 中发现了一组 <span class="math inline">\([l_1,r_1]\)</span>，<span class="math inline">\([l_2,r_2]\)</span> 元素和相等，那么这两段如果要作为前后缀只能是对 <span class="math inline">\([l_1,r_2]\)</span> 有 <span class="math inline">\(-1\)</span> 的贡献，对其它区间都没有贡献，故对整个序列的贡献就是 <span class="math inline">\(-1\)</span>。</p>
<p>故题目转化为求 <span class="math inline">\(\{a\}\)</span> 中有多少对非空子区间相等，枚举每个区间存到 <code>std::map</code> 里统计即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p>
<h2 id="cf1821d.-black-cells"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1821/problem/D">CF1821D. Black Cells</a></h2>
<p>*1900 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1821/submission/305852685">Code1</a> <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1821/submission/305851032">Code2</a></p>
<p><strong>solution1</strong>：通过观察能得出结论：选择长度 <span class="math inline">\(\ge 2\)</span> 的区间一定不劣。</p>
<ul>
<li>随便举个例子：假设 <span class="math inline">\(k=4\)</span>，对于 <span class="math inline">\([1,1]\)</span> 和 <span class="math inline">\([4,7]\)</span>，选择两个区间最少消耗 <span class="math inline">\(10\)</span> 次操作，如果只选 <span class="math inline">\([4,7]\)</span> 则最少只消耗 <span class="math inline">\(9\)</span> 次。但若是 <span class="math inline">\([1,2]\)</span> 和 <span class="math inline">\([4,7]\)</span>，无论选择两个区间还是只选 <span class="math inline">\([4,7]\)</span>，最少都是消耗 <span class="math inline">\(9\)</span> 次操作。</li>
</ul>
<p>于是我们记录 <span class="math inline">\(\text{one}\)</span> 和 <span class="math inline">\(\text{sum}\)</span> 分别代表长为 <span class="math inline">\(1\)</span> 的区间个数和长度 <span class="math inline">\(\ge 2\)</span> 的区间的长度和。从左到右扫，分 <span class="math inline">\(\text{sum}\ge k\)</span> 和 <span class="math inline">\(\text{sum}+\text{one}\ge k\)</span> 讨论即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p><strong>solution2：</strong>显然选长度尽可能大的区间更优，故使用反悔贪心。</p>
<p>压入堆中的是已经选择的区间的长度。每当堆中元素和 <span class="math inline">\(\ge k\)</span>，就把最小的元素弹出来。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf1821e.-rearrange-brackets"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1821/problem/E">CF1821E. Rearrange Brackets</a></h2>
<p>*2100 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1821/submission/305857599">Code</a></p>
<p>题意差评，一堆能让人误会的地方。</p>
<p>首先，对于给定的平衡括号序列，得到最小 cost 的方式是每次移除最右侧的相邻括号对。</p>
<p>对于两对括号 <span class="math inline">\(A,B\)</span>，如果 <span class="math inline">\(A\)</span> 包含 <span class="math inline">\(B\)</span>，就连一条 <span class="math inline">\(A\to B\)</span> 的边，建出括号森林。不妨设节点 <span class="math inline">\(1\)</span> 是虚根，这样得到一棵括号树。</p>
<p>那么移除节点 <span class="math inline">\(x\)</span> 的代价就是 <span class="math inline">\(x\)</span> 的非 <span class="math inline">\(1\)</span> 祖先数目。换句话说，对于任意一个点，它子树内的每个点都有 <span class="math inline">\(1\)</span> 的贡献，即这组括号序列的最小 cost 是 <span class="math inline">\(\sum\limits_{i=2} sz[i]-1\)</span>。</p>
<p>考虑移动一个括号，可行的移动方式是 <span class="math inline">\(A(B)C\to A()BC\)</span>，这等价于把一个点 <span class="math inline">\(x\)</span> 的儿子接到父亲上，再把 <span class="math inline">\(x\)</span> 删去。不难发现这个过程是无序的（即只要删除的点集是一样的得到的括号树就一样），你只要将 <span class="math inline">\(sz[i]-1\)</span> 排序后选最大的 <span class="math inline">\(k\)</span> 个删去就行。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。<span class="math inline">\(k\)</span> 的范围十分诈骗。</p>
<h2 id="cf2022e2.-billetes-mxhard-version"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2022/problem/E2">CF2022E2. Billetes MX（Hard Version）</a></h2>
<p>*2600 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2022/submission/305865364">Code</a></p>
<p>结论：对于一个 beautiful 的 <span class="math inline">\(n\times m\)</span> 网格，一定存在长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{X\}\)</span> 和长为 <span class="math inline">\(m\)</span> 的序列 <span class="math inline">\(\{Y\}\)</span> 满足 <span class="math inline">\(a[i][j]=X[i]\oplus Y[j]\)</span>。</p>
<ul>
<li>容易说明，对于一个 beautiful 的网格，我们将任意一行异或上任意一个数后得到的新网格仍然 beautiful。于是我们进行如下操作：将每一行都异或上那行的第一个数，每一列都异或上那列的第一个数。这样我们得到了一个第一行、第一列全为 <span class="math inline">\(0\)</span> 的网格，它仍然 beautiful。</li>
<li>此时 <span class="math inline">\(\forall i\in[2,n],j\in[2,m]\)</span>，有 <span class="math inline">\(a[i][j] \oplus a[1][j]\oplus a[i][1] \oplus a[1][1]=0\)</span>，由于后三项均为 <span class="math inline">\(0\)</span>，则 <span class="math inline">\(a[i][j]=0\)</span>。我们取第一列为序列 <span class="math inline">\(\{X\}\)</span>，第一行为序列 <span class="math inline">\(\{Y\}\)</span>，由 <span class="math inline">\(a[i][j]\)</span> 在异或完 <span class="math inline">\(X[i]\)</span> 和 <span class="math inline">\(Y[j]\)</span> 后为 <span class="math inline">\(0\)</span>，可知 <span class="math inline">\(a[i][j]=X[i]\oplus Y[j]\)</span>。</li>
</ul>
<p>那么，<span class="math inline">\(a[i][j]\)</span> 给定意味着 <span class="math inline">\(X[i] \oplus Y[j]\)</span> 给定，我们建立一个图论模型：一个 <span class="math inline">\(n+m\)</span> 个点的图，点 <span class="math inline">\(1\sim n\)</span> 代表对应的行，点 <span class="math inline">\(n+1\sim n+m\)</span> 代表对应的列，给定 <span class="math inline">\(a[i][j]\)</span> 就连一条 <span class="math inline">\(i \to n+j\)</span> 边权为 <span class="math inline">\(a[i][j]\)</span> 的边。</p>
<p>根据异或的性质，在这个图中所有的环都要满足 "环上的边权异或和为 <span class="math inline">\(0\)</span>"。若不满足，答案就是 <span class="math inline">\(0\)</span>。否则方案数是什么呢？考虑一个没填数的格子，不妨设它的坐标是 <span class="math inline">\((r, c)\)</span>，将它填上相当于将点 <span class="math inline">\(r\)</span> 和点 <span class="math inline">\(n+c\)</span> 连起来了，分两种情况：</p>
<ul>
<li>连之前 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(n+c\)</span> 就在一个连通块里了。此时新加进的这条边能构成一个新环，由于一个环上的边异或和要为 <span class="math inline">\(0\)</span>，这条新边权值自然是固定的，答案 <span class="math inline">\(\times 1\)</span>。</li>
<li>连之前 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(n+c\)</span> 不在一个连通块中。此时新加进的这条边不组成任何一个环，边权就能取任何一个 <span class="math inline">\([0,2^{30}-1]\)</span> 中的值，故答案 <span class="math inline">\(\times 2^{30}\)</span>。</li>
</ul>
<p>也就是说，对于当前的一个局面，有 <span class="math inline">\(cnt\)</span> 个连通块，且所有环都满足边权异或和为 <span class="math inline">\(0\)</span>，答案就是 <span class="math inline">\(2^{30\cdot cnt}\)</span>。</p>
<p>连通块数目用并查集容易维护，只用考虑如何每次修改后都 check 异或和为 <span class="math inline">\(0\)</span> 的条件。</p>
<p>实际上这个问题同样能用并查集维护：我们对图上每个点 <span class="math inline">\(x\)</span> 记录一个 <span class="math inline">\(g[x]\)</span> 表示 <span class="math inline">\(x\)</span> 到它所在连通块的根的距离（这个根也就是并查集里 find 得到的点）。那么并查集 merge 的时候如果发现 <span class="math inline">\(x,y\)</span> 在一个连通块中且 <span class="math inline">\(g[x]\oplus g[y] \neq w\)</span>，就说明我们发现了异或和 <span class="math inline">\(&gt;0\)</span> 的环。</p>
<p><span class="math inline">\(g[x]\)</span> 则通过以下操作维护：</p>
<ul>
<li>find 函数回溯时 <span class="math inline">\(g[x] =g[x]\oplus g[fa[x]]\)</span>。</li>
<li>merge 时假定 <span class="math inline">\(fa[rt_y]=rt_x\)</span>，则 <span class="math inline">\(g[rt_y]=(g[x] \oplus g[y]\oplus w)\)</span>。</li>
</ul>
<p>给一幅图帮助理解，不再赘述。</p>
<p><img src="/image/academic/dsu.png" /></p>
<p>时间复杂度 <span class="math inline">\(O((n+q)\alpha)\)</span>。</p>
<h2 id="cf1972f.-long-way-to-be-non-decreasing"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1972/problem/F">CF1972F. Long Way to be Non-decreasing</a></h2>
<p>*2800 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1972/submission/306070777">Code</a></p>
<p>建图：<span class="math inline">\(\forall i\in [1, m]\)</span>，<span class="math inline">\(i\to b_i\)</span>。</p>
<p>问题转化为：求最小的 <span class="math inline">\(k\)</span>，使得每个 <span class="math inline">\(a_i\)</span> 最多能在图上走 <span class="math inline">\(k\)</span> 步，得到的序列单调不降。</p>
<p>容易发现答案单调，于是二分答案，设二分出的答案是 <span class="math inline">\(mid\)</span>。</p>
<p>考虑一个贪心，对于第一个数而言，肯定是选 <span class="math inline">\(mid\)</span> 步内的权值最小点；第二个数肯定是选 <span class="math inline">\(mid\)</span> 步内权值大于等于第一个数的最小点，以此类推。我们从小到大枚举权值判定能否走到，若能走到，就跳到下一个数；否则继续往大了枚举。</p>
<p>具体地，我们用一个三元组 <span class="math inline">\((S,T,mid)\)</span> 表示一个判定：判定 <span class="math inline">\(S\)</span> 走不超过 <span class="math inline">\(mid\)</span> 步是否能走到 <span class="math inline">\(T\)</span>。 <span class="math inline">\(T\)</span> 显然单调不降，于是我们只需判定 <span class="math inline">\(O(m)\)</span> 次。</p>
<p>判定很简单，只是需要一些码力。首先 <span class="math inline">\(i\to b_i\)</span> 能得到一棵基环内向树，两点间的距离分为环上的一段和子树的一段，维护是朴素的。记录每个点属于哪个环对应的子树以及深度，就能 <span class="math inline">\(O(1)\)</span> 得到距离，再和 <span class="math inline">\(mid\)</span> 比较即可。无解情况是：</p>
<ol type="1">
<li><span class="math inline">\(S, T\)</span> 不在同一棵子树内并且 <span class="math inline">\(T\)</span> 不在环上。</li>
<li><span class="math inline">\(S,T\)</span> 在同一棵子树内但 <span class="math inline">\(T\)</span> 深度大于 <span class="math inline">\(S\)</span> 或二者不是祖先关系。</li>
</ol>
<p>时间复杂度 <span class="math inline">\(O(n\log m)\)</span>。</p>
<h2 id="cf1969d.-shop-game"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1969/problem/D">CF1969D. Shop Game</a></h2>
<p>*1900 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1969/submission/306110742">Code</a></p>
<p>Bob 会从 Alice 选的物品里选 <span class="math inline">\(k\)</span> 个 for free，那他肯定会选 <span class="math inline">\(b[i]\)</span> 最大的 <span class="math inline">\(k\)</span> 个。</p>
<p>我们不妨将物品按 <span class="math inline">\(b[i]\)</span> 降序排序，这样相当于我们要选一个长至少为 <span class="math inline">\(k\)</span> 的子序列，然后把长为 <span class="math inline">\(k\)</span> 的前缀舍去。</p>
<p>这样的好处是要舍去的物品和剩下 Bob 要从 Alice 手里买来的物品有了分界线。我们枚举这个分界线，分界线前我们选 <span class="math inline">\(k\)</span> 个舍去，贪心来讲一定是选 <span class="math inline">\(a[i]\)</span> 最小的 <span class="math inline">\(k\)</span> 个；分界线后我们要获得最大的利润，一定是选所有 <span class="math inline">\(b[i]&gt;a[i]\)</span> 的物品。</p>
<p>分界线前用一个优先队列维护，分界线后预处理一个后缀和作为贡献。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf2067e.-white-magic"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2067/problem/E">CF2067E. White Magic</a></h2>
<p>*1900 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2067/submission/306114621">Code</a></p>
<p>首先，答案序列中最多出现一个 <span class="math inline">\(0\)</span>。</p>
<ul>
<li>若出现两个 <span class="math inline">\(0\)</span>，设下标分别为 <span class="math inline">\(i,j\)</span>。则 <span class="math inline">\(\min(a_1,\cdots,a_i)=0&lt;1\le\text{mex}(a_{i+1},\cdots,a_j=0,\cdots,a_n)\)</span>，矛盾。</li>
</ul>
<p>并且，如果答案序列中有 <span class="math inline">\(0\)</span>，这个 <span class="math inline">\(0\)</span> 一定是左数第一个 <span class="math inline">\(0\)</span>。</p>
<ul>
<li>贪心的想，这样可以让尽可能长的后缀 <span class="math inline">\(\text{mex}\)</span> 为 <span class="math inline">\(0\)</span>，不劣。</li>
</ul>
<p>最后，所有非 <span class="math inline">\(0\)</span> 的数构成的序列一定 magical。</p>
<p>设有 <span class="math inline">\(cnt\)</span> 个 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(a_i&gt;0\)</span>，我们只需检查含有第一个 <span class="math inline">\(0\)</span> 和所有非 <span class="math inline">\(0\)</span> 数的序列。若其 magical，答案是 <span class="math inline">\(cnt+1\)</span>；否则答案是 <span class="math inline">\(cnt\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="cf2067f.-bitwise-slides"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2067/problem/F">CF2067F. Bitwise Slides</a></h2>
<p>*2300 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2067/submission/306240933">Code</a></p>
<p>记 <span class="math inline">\(pre_i=\oplus_{j=1}^{i}a_j\)</span>。</p>
<p>首先，操作 <span class="math inline">\(i\)</span> 次后，有 <span class="math inline">\(P\oplus Q\oplus R=pre_i\)</span>。三个变量 not pairwise distinct 意味着至少有两个变量相等。然而无论有两个还是三个变量相等，都会有至少一个变量等于 <span class="math inline">\(pre_i\)</span>。</p>
<p>不妨设相等的两个变量为 <span class="math inline">\(x\)</span>，操作 <span class="math inline">\(i\)</span> 次后的状态只能是 <span class="math inline">\((pre_i,x,x),(x,pre_i,x),(x,x,pre_i)\)</span> 中的一种。</p>
<p>令 <span class="math inline">\(dp[i][x]\)</span> 表示操作 <span class="math inline">\(i\)</span> 次后达到上述三种状态的方案数。它可以从 <span class="math inline">\((pre_i\oplus a_i,x,x),(x\oplus a_i,pre_i,x),(x\oplus a_i,x,pre_i)\)</span> 转移而来，我们研究转移方程应该长什么样。</p>
<ul>
<li>上一个状态是 <span class="math inline">\((pre_i\oplus a_i,x,x)=(pre_{i-1},x,x)\)</span>。
<ul>
<li>若 <span class="math inline">\(pre_{i-1} \neq x\)</span>，<span class="math inline">\(dp[i][x]=dp[i-1][x]\)</span>。</li>
<li>否则，<span class="math inline">\(dp[i][x]=3\cdot dp[i-1][x]\)</span>。</li>
</ul></li>
<li>上一个状态是 <span class="math inline">\((x\oplus a_i,pre_i,x)\)</span>。由其中两个元素相同得到 <span class="math inline">\(pre_i=x\)</span> 或 <span class="math inline">\(pre_i=x\oplus a_i\to pre_{i-1}=x\)</span>。
<ul>
<li>若 <span class="math inline">\(pre_i=x\)</span>，<span class="math inline">\((x\oplus a_i,pre_i,x)=(pre_{i-1},x,x)\)</span>，故 <span class="math inline">\(dp[i][x]=dp[i-1][x]\)</span>。</li>
<li>若 <span class="math inline">\(pre_{i-1}=x\)</span>，<span class="math inline">\((x\oplus a_i,pre_i,x)=(pre_i,pre_i,pre_{i-1})\)</span>。故 <span class="math inline">\(dp[i][x]=dp[i-1][pre_i]\)</span>。</li>
</ul></li>
<li>上一个状态是 <span class="math inline">\((x\oplus a_i,x,pre_i)\)</span>，同上一种。</li>
</ul>
<p>综上，只有 <span class="math inline">\(pre_{i-1}=x\)</span> 时 <span class="math inline">\(dp[i][x]\)</span> 不从 <span class="math inline">\(dp[i-1][x]\)</span> 转移而来。</p>
<p>此时 <span class="math inline">\(dp[i][x]=3\cdot dp[i-1][x]+2\cdot dp[i-1][pre_i]\)</span>。</p>
<p>把第一维压掉，第二维 <span class="math inline">\(x\)</span> 换成 <span class="math inline">\(pre_{i-1}\)</span>，得到转移方程： <span class="math display">\[
dp[pre_{i-1}]=3\cdot dp[pre_{i-1}]+2\cdot dp[pre_i]
\]</span> 初始 <span class="math inline">\(dp[0]=1\)</span>，用 <code>std::map</code> 作容器，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf2064e.-mycraft-sand-sort"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2064/problem/E">CF2064E. Mycraft Sand Sort</a></h2>
<p>*2400 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2064/submission/307300383">Code</a></p>
<p>首先注意到 <span class="math inline">\(\{c\}\)</span> 的顺序不能换，因为第一列是不会下落的，换了之后第一列肯定不同。</p>
<p>结论：对于一组 <span class="math inline">\(p_i,p_j\)</span>，它们能交换位置当且仅当 <span class="math inline">\(c_i=c_j\)</span> 且 <span class="math inline">\(\max\limits_{k\in (i,j),c_k \neq c_i}p_k &lt; \min(p_i,p_j)\)</span>。</p>
<ul>
<li>若 <span class="math inline">\(c_i \neq c_j\)</span>，交换会改变颜色的相对顺序，一定不合法。</li>
<li>若 <span class="math inline">\(\max\limits_{k\in (i,j),c_k \neq c_i}p_k &gt; \min(p_i,p_j)\)</span>，令 <span class="math inline">\(p_m=\max\limits_{k\in (i,j),c_k \neq c_i}p_k\)</span>，不难想象交换前后在 <span class="math inline">\(p_m\)</span> 上侧颜色 <span class="math inline">\(c_i\)</span> 的数目肯定不同。</li>
</ul>
<p>那么如何计数呢？考虑 <span class="math inline">\(1\sim n\)</span> 的一个排列，每次删去一个数相当于固定的 <span class="math inline">\(\{p\}\)</span> 的一位，删除序列和原排列构成双射，因此我们只用对删数的方式进行计数。</p>
<p>将 <span class="math inline">\(p_i\)</span> 从小到大枚举，统计完之后把 <span class="math inline">\(i\)</span> 这个位置删掉，两端用双向链表连接。这么做的好处是统计到 <span class="math inline">\(p_i\)</span> 时能与 <span class="math inline">\(p_i\)</span> 交换的行一定相邻（不相邻只能是中间夹着更短的，但更短的已经在这之前被删掉了），形成一个连通块。假设此时 <span class="math inline">\(p_i\)</span> 所在的连通块大小是 <span class="math inline">\(t_i\)</span>，依据乘法原理最终答案就是 <span class="math inline">\(\prod t_i\)</span>。</p>
<p>用并查集维护连通块大小。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf2069e.-a-b-ab-and-ba"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2069/problem/E">CF2069E. A, B, AB and BA</a></h2>
<p>*2300 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2069/submission/307315231">Code</a></p>
<p>"AA" 和 "BB" 是不被允许的。我们在相邻的两个 "A"，相邻的两个 "B" 中间划一刀，这样整个序列被分割成若干子串，每个子串是下列四种之一：</p>
<ul>
<li>ABAB...AB;</li>
<li>BABA...BA;</li>
<li>ABAB...ABA;</li>
<li>BABA...BAB.</li>
</ul>
<p>对于长为 <span class="math inline">\(l\)</span> 的第三第四类子串，可以用 <span class="math inline">\(\frac{l-1}{2}\)</span> 个 AB 或 BA 填充，剩下的一定是一个 A（如果是第三类）或者一个 B（如果是第四类）。此时 AB 和 BA 的地位等价。</p>
<p>对于长为 <span class="math inline">\(l\)</span> 的第一类子串，可以用 <span class="math inline">\(\frac{l}{2}\)</span> 个 AB 完全填充，或 <span class="math inline">\(\frac{l}{2}-1\)</span> 个 BA 外加一个 A 和一个 B。此时 AB 的地位显然高于 BA。同理对于第二类子串，BA 的地位高于 AB。</p>
<p>对于第一第二类子串，只有用 AB（或 BA）完全填满才不会浪费，所以我们的决策顺序是：</p>
<ul>
<li>用 AB 填充长度最小的第一类串，直到 AB 不足或没有第一类串了。</li>
<li>用 BA 填充长度最小的第二类串，直到 BA 不足或没有第二类串了。</li>
<li>用 BA，A，B 填充第一类串的剩余部分。</li>
<li>用 AB，A，B 填充第二类串的剩余部分。</li>
<li>用剩下的 AB，BA，A，B 填充第三第四类串。</li>
</ul>
<p>若填充过程缺材料了，就是 NO。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="cf2069f.-graph-inclusion"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2069/problem/F">CF2069F. Graph Inclusion</a></h2>
<p>*2800 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/2069/submission/307327089">Code</a></p>
<p>断言：任何时刻，答案是 <span class="math inline">\(A\)</span> 的连通块数减去 <span class="math inline">\(A\cup B\)</span> 的连通块数。</p>
<ul>
<li>挺显然的。</li>
</ul>
<p>然后就是线段树分治板子了。</p>
<p>时间复杂度 <span class="math inline">\(O(q\log^2 q)\)</span>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Competitive-Programming/" class="category-chain-item">Competitive Programming</a>
  
  
    <span>></span>
    
  <a href="/categories/Competitive-Programming/Diary/" class="category-chain-item">Diary</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ICPC/" class="print-no-link">#ICPC</a>
      
        <a href="/tags/Codeforces/" class="print-no-link">#Codeforces</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【题解】寒假训练日记</div>
      <div>https://kisuraop.github.io/posts/abc8fb81.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>KisuraOP</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年1月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/1e7fc2bd.html" title="【题解】2025 UESTC 寒假集训">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【题解】2025 UESTC 寒假集训</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/4cf2169a.html" title="使用 DOMjudge 从零搭建一场比赛">
                        <span class="hidden-mobile">使用 DOMjudge 从零搭建一场比赛</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://kisuraop.github.io/" target="_blank" rel="nofollow noopener"><span>KisuraOP</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>








  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
