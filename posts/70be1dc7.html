

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/bg/mugeng.ico">
  <link rel="icon" href="/image/bg/mugeng.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="KisuraOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="收录了二轮集训的部分题解。  抛一点链接，方便日后跳转。 7.31 https:&#x2F;&#x2F;codeforces.com&#x2F;gym&#x2F;537696（2024 HDU 多校 6） 8.1 https:&#x2F;&#x2F;codeforces.com&#x2F;gym&#x2F;539789（SEERC 2020） 8.2 https:&#x2F;&#x2F;codeforces.com&#x2F;gym&#x2F;540037（2023 江苏省赛&#x2F; CCPC Hunan） 8.3 ht">
<meta property="og:type" content="article">
<meta property="og:title" content="【题解】2024 UESTC 暑假集训 第二轮">
<meta property="og:url" content="https://kisuraop.github.io/posts/70be1dc7.html">
<meta property="og:site_name" content="KisuraOP">
<meta property="og:description" content="收录了二轮集训的部分题解。  抛一点链接，方便日后跳转。 7.31 https:&#x2F;&#x2F;codeforces.com&#x2F;gym&#x2F;537696（2024 HDU 多校 6） 8.1 https:&#x2F;&#x2F;codeforces.com&#x2F;gym&#x2F;539789（SEERC 2020） 8.2 https:&#x2F;&#x2F;codeforces.com&#x2F;gym&#x2F;540037（2023 江苏省赛&#x2F; CCPC Hunan） 8.3 ht">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.rmb.bdstatic.com/bjh/76b86f9fdad7ee7a8bdac489d9306e0c.jpeg">
<meta property="article:published_time" content="2024-09-01T16:35:35.000Z">
<meta property="article:modified_time" content="2024-09-01T16:35:35.000Z">
<meta property="article:author" content="KisuraOP">
<meta property="article:tag" content="ICPC">
<meta property="article:tag" content="UESTC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic.rmb.bdstatic.com/bjh/76b86f9fdad7ee7a8bdac489d9306e0c.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【题解】2024 UESTC 暑假集训 第二轮 - KisuraOP</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_4277703_p4cthydttt.css">
<link rel="stylesheet" href="/css/vemoji.css">
<link rel="stylesheet" href="/css/bg_cover.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kisuraop.github.io","root":"/","version":"1.9.5-a","typing":{"enable":false,"typeSpeed":55,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"c++"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/image/other/loading.mp4","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><script src="https://kisuraop.github.io/js/mouseclick.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>KisuraOPのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/site/">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>收藏夹</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/waiting/">
                <i class="iconfont icon-plan"></i>
                <span>待办</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/example/">
                <i class="iconfont icon-comment"></i>
                <span>留言</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://moe.jitsu.top/img/?sort=pc') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">【题解】2024 UESTC 暑假集训 第二轮</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        KisuraOP
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-02 00:35" pubdate>
          2024年9月2日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          92k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【题解】2024 UESTC 暑假集训 第二轮</h1>
            
            
              <div class="markdown-body">
                
                <p>收录了二轮集训的部分题解。</p>
<hr />
<p>抛一点链接，方便日后跳转。</p>
<p>7.31 https://codeforces.com/gym/537696（2024 HDU 多校 6）</p>
<p>8.1 https://codeforces.com/gym/539789（SEERC 2020）</p>
<p>8.2 https://codeforces.com/gym/540037（2023 江苏省赛/ CCPC Hunan）</p>
<p>8.3 https://codeforces.com/gym/540187（2020 CCPC Weihai）</p>
<p>8.4 https://codeforces.com/gym/105173（2024 东北四省赛 / CCPC Northeast）</p>
<p>8.5 https://codeforces.com/gym/540735（2023 Nanjing Regional / Ucup 2-11）</p>
<p>8.6 https://codeforces.com/gym/541036（UKIEPC 2023）</p>
<p>8.7 https://codeforces.com/gym/541235（NEERC 2019-2020）</p>
<p>8.8 https://codeforces.com/gym/541365（2024 上海市赛）</p>
<p>8.9 https://codeforces.com/gym/541786（2024 陕西省赛）</p>
<p>8.10 https://codeforces.com/gym/541891（2024 吉林省赛 / CCPC Changchun）</p>
<p>8.11 https://codeforces.com/gym/104976（2023 Hangzhou Regional / Ucup 2-22）</p>
<p>8.12 https://codeforces.com/gym/542320（毒瘤 psk / 998244353）</p>
<p>8.13 https://codeforces.com/gym/541594（SEERC 2022）</p>
<p>8.14 https://codeforces.com/gym/542837（ECNA 2022）</p>
<p>8.15 https://codeforces.com/gym/543029（2022 CCPC Weihai）</p>
<p>8.16 https://codeforces.com/gym/543323（NWERC 2019）</p>
<p>8.17 https://codeforces.com/gym/543433（2020 CCPC Changchun）</p>
<p>8.18 被赶出清水河</p>
<p>8.22 https://codeforces.com/gym/105231（2024 江西省赛）</p>
<p>8.23 https://codeforces.com/gym/102822（2020 CCPC Mianyang）</p>
<p>8.24 https://codeforces.com/gym/102769（2020 CCPC Qinhuangdao）</p>
<p>8.25 https://codeforces.com/gym/104252（2022-2023 Latin American Regional）</p>
<p>8.26 https://codeforces.com/gym/103081（SWERC 2020）</p>
<p>8.28 https://codeforces.com/gym/104064（NWERC 2021）</p>
<p>8.29 https://codeforces.com/gym/104787（2023 CCPC Qinhuangdao / Ucup 2-9）</p>
<p>8.30 https://codeforces.com/gym/104945（SWERC 2023）</p>
<h2 id="hdu-多校-第6场">2024 HDU 多校 第6场</h2>
<h3 id="b.-造花困难版分类讨论">B. 造花（困难版）【分类讨论】</h3>
<div class="note note-info">
            <p>给定一张无重边无自环不保证联通的无向图，若删去某个点后整个图被分为若干菊花图，则称这个点为混沌点。升序输出所有混沌点编号，或报告不存在。</p><p><span class="math inline">\(1 \le n, m \le 2\cdot 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>首先可以暴力 check（通过度数判断）这张图的每个连通分量是不是菊花图。若有两个及以上的连通分量不是菊花图，则无解；否则我们只考虑不是菊花图的那个连通分量。</p><p>分两种情况考虑：</p><ul><li>这个连通分量是一棵树。通过以下步骤可以 <span class="math inline">\(O(n)\)</span> check 每个点是不是混沌点：<ul><li>对于每个点 <span class="math inline">\(x\)</span>，新建变量 <code>sum = 0</code>，遍历 <span class="math inline">\(x\)</span> 的邻接点 <span class="math inline">\(y\)</span>。若 <span class="math inline">\(y\)</span> 的度数为 <span class="math inline">\(2\)</span>，则继续遍历 <span class="math inline">\(y\)</span> 的邻接点 <span class="math inline">\(z\)</span>（<span class="math inline">\(z \neq x\)</span>），<code>sum += deg[z] + 1</code>；否则 <code>sum += deg[y]</code>。若删去 <span class="math inline">\(x\)</span> 该树被分为两个菊花图，那么此时度数统计完全，应有 <code>sum == n - 1</code>。这里 <span class="math inline">\(n\)</span> 是连通分量的大小。</li></ul></li><li>这个联通分量不是树（有环）。此时有两个性质可以手玩出来：<ol type="1"><li>若存在混沌点，该连通分量所有环的大小最多是四元环。</li><li>若有多个环，混沌点只能是所有环的交集。</li></ol></li></ul><p>由结论 <span class="math inline">\(2\)</span>，我们只需要随便从这个连通分量中找一个环，此时所有可能的混沌点都在这个环上。又由结论 <span class="math inline">\(1\)</span>，可以暴力 check 这些可能的混沌点，最多 check 不超过 <span class="math inline">\(4\)</span> 次。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ori_rd</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
		ori_rd[x]++;
		ori_rd[y]++;
	&#125;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cir</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	vector&lt;<span class="hljs-type">int</span>&gt; need_to_check;
	<span class="hljs-type">int</span> cnt_circle = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">auto</span> find_circle = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;
		cir[x] = <span class="hljs-literal">true</span>;
		fa[x] = fath;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fath) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-keyword">if</span> (cir[y]) &#123;
				fa[y] = x;
				<span class="hljs-keyword">if</span> (cnt_circle == <span class="hljs-number">0</span>) &#123;
					cnt_circle = <span class="hljs-number">1</span>;
					need_to_check.<span class="hljs-built_in">push_back</span>(y);
					<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = fa[y]; i != y; i = fa[i]) &#123;
						cnt_circle++;
						need_to_check.<span class="hljs-built_in">push_back</span>(i);
					&#125;					
				&#125;
			&#125;
			<span class="hljs-keyword">if</span> (vis[y]) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			vis[y] = <span class="hljs-literal">true</span>;
			<span class="hljs-built_in">self</span>(self, y, x);
		&#125;
		cir[x] = <span class="hljs-literal">false</span>;
	&#125;;

	<span class="hljs-keyword">auto</span> ok = [&amp;] (<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> A = <span class="hljs-number">0</span>) &#123;
		vector&lt;<span class="hljs-type">int</span>&gt; rd = ori_rd;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-keyword">if</span> (A == <span class="hljs-number">0</span>) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;
				rd[x]--;
			&#125;
			rd[rt] = <span class="hljs-number">0</span>;
			vis[rt] = <span class="hljs-number">1</span>;
		&#125;

		<span class="hljs-type">int</span> rdn;
		<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;
			vis[x] = <span class="hljs-literal">true</span>;
			rdn += rd[x] &gt; <span class="hljs-number">1</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (vis[y]) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				<span class="hljs-built_in">self</span>(self, y);
			&#125;
		&#125;;

		<span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : adj[rt]) &#123;
			<span class="hljs-keyword">if</span> (!vis[x]) &#123;
				rdn = <span class="hljs-number">0</span>;
				<span class="hljs-built_in">dfs</span>(dfs, x);
				<span class="hljs-keyword">if</span> (rdn &gt; <span class="hljs-number">1</span>) &#123;
					flag = <span class="hljs-literal">false</span>;
					<span class="hljs-keyword">break</span>;
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> flag;
	&#125;;

	<span class="hljs-type">int</span> block = <span class="hljs-number">0</span>, block_id = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (!vis[i]) &#123;
			<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>(i, <span class="hljs-number">1</span>)) &#123;
				block++;
				block_id = i;
			&#125;
			cnt_circle = <span class="hljs-number">0</span>;
			<span class="hljs-built_in">find_circle</span>(find_circle, i, <span class="hljs-number">0</span>);
			<span class="hljs-keyword">if</span> (cnt_circle &gt; <span class="hljs-number">4</span>) &#123;
				cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
				<span class="hljs-keyword">return</span> ;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> (block &gt;= <span class="hljs-number">2</span>) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
		<span class="hljs-keyword">return</span> ;
	&#125;

	vector&lt;<span class="hljs-type">int</span>&gt; ans;
	<span class="hljs-keyword">if</span> (need_to_check.<span class="hljs-built_in">empty</span>()) &#123;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-keyword">auto</span> check_tree = [&amp;] (<span class="hljs-type">int</span> A) &#123;
			vector&lt;<span class="hljs-type">int</span>&gt; b;
			<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;
				b.<span class="hljs-built_in">push_back</span>(x);
				vis[x] = <span class="hljs-literal">true</span>;
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
					<span class="hljs-keyword">if</span> (y == fath) &#123;
						<span class="hljs-keyword">continue</span>;
					&#125;
					<span class="hljs-built_in">self</span>(self, y, x);
				&#125;
			&#125;;
			<span class="hljs-built_in">dfs</span>(dfs, A, <span class="hljs-number">0</span>);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;
				<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
					<span class="hljs-keyword">if</span> (ori_rd[y] == <span class="hljs-number">2</span>) &#123;
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> o : adj[y]) &#123;
							<span class="hljs-keyword">if</span> (o == x) &#123;
								<span class="hljs-keyword">continue</span>;
							&#125;
							res += ori_rd[o] + <span class="hljs-number">1</span>;
						&#125;
					&#125; <span class="hljs-keyword">else</span> &#123;
						res += ori_rd[y];
					&#125;
				&#125;
				<span class="hljs-keyword">if</span> (res == b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;
					ans.<span class="hljs-built_in">push_back</span>(x);
				&#125;
			&#125;
		&#125;;
		<span class="hljs-keyword">if</span> (block_id == <span class="hljs-number">-1</span>) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
				<span class="hljs-keyword">if</span> (!vis[i]) &#123;
					<span class="hljs-built_in">check_tree</span>(i);
				&#125;
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-built_in">check_tree</span>(block_id);
		&#125;
	&#125; <span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : need_to_check) &#123;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ok</span>(x)) &#123;
				ans.<span class="hljs-built_in">push_back</span>(x);
			&#125;
		&#125;
	&#125;

	<span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>()) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
		<span class="hljs-keyword">return</span> ;
	&#125;
	<span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;
		cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
	&#125;
	cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="g.-树上-mex-问题dp">G. 树上 MEX 问题【dp】</h3>
<div class="note note-info">
            <p>定义一张图的 MEX 为：图中所有点的点权构成的集合中，最小的没有出现过的非负整数。</p><p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，点有点权 <span class="math inline">\(a_i\)</span>，保证<strong>点权互不相同</strong>。求这棵树的所有联通导出子图的 MEX 之和，对 998244353 取模。</p><p><span class="math inline">\(1 \le n \le 10 ^6\)</span>，<span class="math inline">\(0 \le a_i &lt; n\)</span>。</p>
          </div>
<div class="note note-success">
            <p>设 <span class="math inline">\(T_i\)</span> 为由点权为 <span class="math inline">\(0\sim i\)</span> 的点构成的极小联通子图，<span class="math inline">\(cnt_i\)</span> 为包含 <span class="math inline">\(T_i\)</span> 的联通子图个数。</p><p>则有结论：<span class="math inline">\(ans = \sum_\limits{i = 0}^{n - 1}cnt_i\)</span>。</p><ul><li>证明：子图 <span class="math inline">\(T_i\)</span> 的 mex 为 <span class="math inline">\(i + 1\)</span>，且 <span class="math inline">\(T_i\)</span> 一定包含 <span class="math inline">\(T_0\sim T_{i - 1}\)</span>，故 mex 恰好为 <span class="math inline">\(i + 1\)</span> 的联通子图个数为 <span class="math inline">\(cnt_i - cnt_{i + 1}\)</span>，有： <span class="math display">\[\large \begin{align}ans &amp;=\sum_{i = 0}^{n - 1}(i + 1)(cnt_i-cnt_{i + 1})\\&amp;=(cnt_{0}-cnt_{1})+2(cnt_1 - cnt_2)+3(cnt_2-cnt_3)+\cdots \\&amp;=\sum_{i = 0}^{n - 1}cnt_i\end{align}\]</span></li></ul><p>于是仅需求出 <span class="math inline">\(cnt_i\)</span>。</p><p>接下来考虑如何对连通子图进行计数。</p><p>令 <span class="math inline">\(f_i\)</span> 代表节点 <span class="math inline">\(i\)</span> 可选可不选时以 <span class="math inline">\(i\)</span> 为根的子树中以 <span class="math inline">\(i\)</span> 为根的联通子图个数；</p><p>令 <span class="math inline">\(g_i\)</span> 代表限定节点 <span class="math inline">\(i\)</span> 必须选时以 <span class="math inline">\(i\)</span> 为根的子树中以 <span class="math inline">\(i\)</span> 为根的联通子图个数，则： <span class="math display">\[\large\begin{cases}g_x = \prod_{y\in son_x}f_y\\f_x = g_x + 1\end{cases}\]</span> 显然 <span class="math inline">\(cnt_0=g_0\)</span>。</p><p>再考虑如何从 <span class="math inline">\(cnt_{i - 1}\)</span> 转移到 <span class="math inline">\(cnt_i\)</span>。发现每次由 <span class="math inline">\(T_{i - 1}\)</span> 变为 <span class="math inline">\(T_i\)</span> 时，原来必选的点现在仍然必选，同时多出来了一些必选的点，称为目标点集。不难发现目标点集构成一条链，即点权为 <span class="math inline">\(0\sim {i}\)</span> 的路径上 <span class="math inline">\(T_{i - 1}\)</span> 中的非必选点。</p><p>我们用一个 <code>vis</code> 数组标记已经访问过的点，遍历到 <span class="math inline">\(i\)</span> 时，若 <code>!vis[i]</code>，就一直跳父亲（以点权为 <span class="math inline">\(0\)</span> 的点为根），直到 <code>vis</code> 为 <span class="math inline">\(1\)</span>。途径的点即目标点集。</p><p>每次新增一个必选点 <span class="math inline">\(x\)</span> 时，有 <span class="math inline">\(cnt \leftarrow cnt \times \dfrac{g_x}{f_x}\)</span>，对目标点集中的每个点更新即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log m)\)</span>，<span class="math inline">\(m\)</span> 为模数。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;
		<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;
	&#125;
	<span class="hljs-keyword">return</span> s;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
		id[a[i]] = i;
	&#125;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath) -&gt; <span class="hljs-type">void</span> &#123;
		fa[x] = fath;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fath) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x);
			dp[x] *= (<span class="hljs-number">1</span> + dp[y]);
			dp[x] %= modp;
		&#125;
	&#125;;
	<span class="hljs-type">int</span> rt = id[<span class="hljs-number">0</span>];
	<span class="hljs-built_in">dfs</span>(dfs, rt, <span class="hljs-number">0</span>);

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	vis[rt] = <span class="hljs-number">1</span>;
	<span class="hljs-type">int</span> ans = dp[rt], cur = ans;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> u = id[i];
		<span class="hljs-keyword">if</span> (!vis[u]) &#123;
			vector&lt;<span class="hljs-type">int</span>&gt; b; 
			<span class="hljs-keyword">while</span> (!vis[u]) &#123;
				b.<span class="hljs-built_in">push_back</span>(u);
				u = fa[u];
			&#125;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;
				vis[x] = <span class="hljs-literal">true</span>;
				cur *= dp[x] * <span class="hljs-built_in">qpow</span>(<span class="hljs-number">1</span> + dp[x], modp - <span class="hljs-number">2</span>) % modp;
				cur %= modp;
			&#125;
		&#125;
		ans += cur;
		ans %= modp;
	&#125; 
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="k.-天天爱跑步基环树单调队列线段树">K. 天天爱跑步【基环树，单调队列，线段树】</h3>
<div class="note note-info">
            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的基环树。对 <span class="math inline">\(i\in[1, n]\)</span> 求<strong>经过</strong>第 <span class="math inline">\(i\)</span> 个点的最长简单路径长度。</p><p><span class="math inline">\(1 \le n \le 5\cdot 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>基环树的结构可概括为：一个环，然后环上的每个点向下延伸出子树。</p><p>以下是一些约定：</p><p>令 <span class="math inline">\(h_i\)</span> 代表点 <span class="math inline">\(i\)</span> 属于环上哪个点的子树。</p><p>令 <span class="math inline">\(dep_i\)</span> 代表点 <span class="math inline">\(i\)</span> 在子树内的深度。（<span class="math inline">\(h_i\)</span> 深度为 <span class="math inline">\(1\)</span>）</p><p>令 <span class="math inline">\(a_i\)</span> 代表环上的点 <span class="math inline">\(i\)</span> 向下延伸出的最长链长度。</p><p>令 <span class="math inline">\(len_i\)</span> 代表经过点 <span class="math inline">\(i\)</span> 且仅在 <span class="math inline">\(h_i\)</span> 子树内的最长链长度。</p><p>令 <span class="math inline">\(f_{i, 0/1}\)</span> 代表点 <span class="math inline">\(i\)</span> 向子树内延伸出的最长链/次长链长度。</p><p>令 <span class="math inline">\(g_{i, 0/1}\)</span> 代表点 <span class="math inline">\(i\)</span> 向子树内延伸出的最长链/次长链对应的子节点。</p><p>令 <span class="math inline">\(\text{ano}\text{side}_i\)</span> 代表环上的点 <span class="math inline">\(i\)</span> 向该点子树外延伸出的最长链长度。（包括环上的一段以及环上另一点向其子树延伸出的最长链）</p><p>根据点 <span class="math inline">\(i\)</span> 在基环树中的位置可以分为两种情况：点 <span class="math inline">\(i\)</span> 在环上和点 <span class="math inline">\(i\)</span> 在子树中。</p><p>点 <span class="math inline">\(i\)</span> 在环上时，我们要找的是 <span class="math inline">\(\max(a_i+\text{anoside}_i)=\max(a_i+a_j+i-j)\)</span>。破环成链，则 <span class="math inline">\(i-j\)</span> 代表环上的一段满足 <span class="math inline">\(i-j&lt;m\)</span> 的 <span class="math inline">\([j, i]\)</span>。</p><p>首先，我们可以用单调队列求出这个最大值。具体地，按顺序遍历环，每次往双端队列中压入 <span class="math inline">\(i\)</span>，弹出队首不满足 <span class="math inline">\(i-j&lt; m\)</span> 的 <span class="math inline">\(j\)</span>，弹出队尾不满足 <span class="math inline">\(a_j-j\ge a_i-i\)</span> 的 <span class="math inline">\(j\)</span>。</p><p>求出最大值后，我们可以用线段树维护对应区间 <span class="math inline">\([j,i]\)</span> 上的答案，每次用最大值与这个区间的值取 <span class="math inline">\(\max\)</span>。</p><p>注意，对环上的两个方向都要分别跑单调队列，同样更新答案。</p><p>点 <span class="math inline">\(i\)</span> 在子树中时，答案为： <span class="math display">\[\large \max(len_i,f_{i, 0}+dep_i-1+\text{anoside}_{h_i})\]</span> 前者为不经过环上的点的答案，后者为经过环上的点的答案。</p><p>对于一个子树，<span class="math inline">\(f_{i,0/1}\)</span> 可以一次 dfs 求出，同时处理出 <span class="math inline">\(g_{i,0/1}\)</span> 用于换根，求出 <span class="math inline">\(len_i\)</span>。</p><p>具体地，换根时令 <span class="math inline">\(d_i\)</span> 代表 <span class="math inline">\(i\)</span> 所在的子树外不经过环的最长链，有： <span class="math display">\[\large{d_x=\max\begin{cases}d_{fa}+1\\f_{fa,0}+1 &amp;,g_{fa,0}\neq x\\f_{fa,1}+1 &amp;,g_{fa,0}=x\end{cases}}\]</span> <span class="math display">\[\large{len_x=f_{x,0}+\max(f_{x,1},d_x)}\]</span></p><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sgt</span>&#123;
	<span class="hljs-type">int</span> n;
	vector&lt;<span class="hljs-type">int</span>&gt; tr;

	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span>

	<span class="hljs-built_in">Sgt</span>(<span class="hljs-type">int</span> n) &#123;
		<span class="hljs-keyword">this</span>-&gt;n = n;
		tr.<span class="hljs-built_in">assign</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;
			tr[p] = <span class="hljs-built_in">max</span>(tr[p], x);
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;
			<span class="hljs-built_in">update</span>(ls, l, mid, ql, qr, x);
		&#125;
		<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;
			<span class="hljs-built_in">update</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr, x);
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;
		l++; r++;
		<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (l == r) &#123;
			<span class="hljs-keyword">return</span> tr[p];
		&#125;
		<span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p], <span class="hljs-built_in">query</span>(ls, l, mid, pos));
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p], <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, pos));
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;
		pos++;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos);
	&#125;
&#125;;


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
		deg[x]++;
		deg[y]++;
	&#125;

	<span class="hljs-keyword">auto</span> find_cir = [&amp;] () &#123;
		queue&lt;<span class="hljs-type">int</span>&gt; q;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			<span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">1</span>) &#123;
				q.<span class="hljs-built_in">push</span>(i);
			&#125;
		&#125;
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (--deg[y] == <span class="hljs-number">1</span>) &#123;
					q.<span class="hljs-built_in">push</span>(y);
				&#125;
			&#125;
		&#125;
		vector&lt;<span class="hljs-type">int</span>&gt; o;
		<span class="hljs-keyword">auto</span> get_cir = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> rt) -&gt; <span class="hljs-type">void</span> &#123;
			o.<span class="hljs-built_in">push_back</span>(x);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (y == fa || y == rt || deg[y] &lt;= <span class="hljs-number">1</span>) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				<span class="hljs-built_in">self</span>(self, y, x, rt);
				<span class="hljs-keyword">return</span> ;
			&#125;
		&#125;;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			<span class="hljs-keyword">if</span> (deg[i] &gt; <span class="hljs-number">1</span>) &#123;
				<span class="hljs-built_in">get_cir</span>(get_cir, i, <span class="hljs-number">0</span>, i);
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> o;
	&#125;;
	vector cir = <span class="hljs-built_in">find_cir</span>();

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">h</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>);
 	<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> rt) -&gt; <span class="hljs-type">void</span> &#123;
 		h[x] = rt;
 		dep[x] = dep[fa] + <span class="hljs-number">1</span>;
 		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
 			<span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span>) &#123;
 				<span class="hljs-keyword">continue</span>;
 			&#125;
 			<span class="hljs-built_in">self</span>(self, y, x, rt);
 			<span class="hljs-keyword">if</span> (f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &gt; f[x][<span class="hljs-number">0</span>]) &#123;
 				f[x][<span class="hljs-number">0</span>] = f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
 				g[x][<span class="hljs-number">0</span>] = y;
 			&#125;
 		&#125;
 		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
 			<span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span> || y == g[x][<span class="hljs-number">0</span>]) &#123;
 				<span class="hljs-keyword">continue</span>;
 			&#125;
 			<span class="hljs-keyword">if</span> (f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &gt; f[x][<span class="hljs-number">1</span>]) &#123;
 				f[x][<span class="hljs-number">1</span>] = f[y][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
 				g[x][<span class="hljs-number">1</span>] = y;
 			&#125;
 		&#125;
	&#125;;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">len</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">if</span> (fa) &#123;
			d[x] = d[fa] + <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (g[fa][<span class="hljs-number">0</span>] != x) &#123;
				d[x] = <span class="hljs-built_in">max</span>(d[x], f[fa][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);
			&#125; <span class="hljs-keyword">else</span> &#123;
				d[x] = <span class="hljs-built_in">max</span>(d[x], f[fa][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);
			&#125;
		&#125;
		len[x] = <span class="hljs-built_in">max</span>(f[x][<span class="hljs-number">0</span>] + f[x][<span class="hljs-number">1</span>], f[x][<span class="hljs-number">0</span>] + d[x]);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (y == fa || deg[y] &gt; <span class="hljs-number">1</span>) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-built_in">self</span>(self, y, x);
		&#125;
	&#125;;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;
		<span class="hljs-built_in">dfs1</span>(dfs1, x, <span class="hljs-number">0</span>, x);
		<span class="hljs-built_in">dfs2</span>(dfs2, x, <span class="hljs-number">0</span>);
	&#125;

	<span class="hljs-type">int</span> m = cir.<span class="hljs-built_in">size</span>();
	cir.<span class="hljs-built_in">insert</span>(cir.<span class="hljs-built_in">end</span>(), cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;
		a[i] = f[cir[i]][<span class="hljs-number">0</span>];
	&#125;

	<span class="hljs-function">Sgt <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">2</span> * m)</span></span>;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ano_side</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	deque&lt;<span class="hljs-type">int</span>&gt; q;
	q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span> &gt; m) &#123;
			q.<span class="hljs-built_in">pop_front</span>();
		&#125;
		<span class="hljs-type">int</span> j = q.<span class="hljs-built_in">front</span>();
		seg.<span class="hljs-built_in">update</span>(j, i, a[i] + a[j] + i - j);
		ano_side[cir[i]] = <span class="hljs-built_in">max</span>(ano_side[cir[i]], a[j] + i - j);
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt; a[i] - i) &#123;
			q.<span class="hljs-built_in">pop_back</span>();
		&#125;
		q.<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;
		ans[cir[i]] = <span class="hljs-built_in">max</span>(ans[cir[i]], seg.<span class="hljs-built_in">query</span>(i));
	&#125;

	<span class="hljs-built_in">reverse</span>(cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>());
	<span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());
	q.<span class="hljs-built_in">clear</span>();
	q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - q.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span> &gt; m) &#123;
			q.<span class="hljs-built_in">pop_front</span>();
		&#125;
		<span class="hljs-type">int</span> j = q.<span class="hljs-built_in">front</span>();
		seg.<span class="hljs-built_in">update</span>(<span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - i, <span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - j, a[i] + a[j] + i - j);
		ano_side[cir[i]] = <span class="hljs-built_in">max</span>(ano_side[cir[i]], a[j] + i - j);
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] - q.<span class="hljs-built_in">back</span>() &lt; a[i] - i) &#123;
			q.<span class="hljs-built_in">pop_back</span>();
		&#125;
		q.<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * m; i++) &#123;
		ans[cir[i]] = <span class="hljs-built_in">max</span>(ans[cir[i]], seg.<span class="hljs-built_in">query</span>(<span class="hljs-number">2</span> * m - <span class="hljs-number">1</span> - i));
	&#125;

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		ans[i] = <span class="hljs-built_in">max</span>(&#123;ans[i], len[i], f[i][<span class="hljs-number">0</span>] + dep[i] - <span class="hljs-number">1</span> + ano_side[h[i]]&#125;);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="seerc-2020">SEERC 2020</h2>
<h3 id="b.-reverse-game博弈逆序对">B. Reverse Game【博弈，逆序对】</h3>
<div class="note note-info">
            <p>给定一个 <span class="math inline">\(01\)</span> 串 <span class="math inline">\(s\)</span>，<span class="math inline">\(\text{Alice}\)</span> 和 <span class="math inline">\(\text{Bob}\)</span> 进行回合制博弈。轮到一个人时，该名玩家可以从 <span class="math inline">\(s\)</span> 中任选一个恰为 <span class="math inline">\(10,110,100\)</span> 或 <span class="math inline">\(1010\)</span> 的子串，并将其翻转。无法进行操作的玩家输，问先手是否有必胜策略。</p><p><span class="math inline">\(1 \le |s| \le 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>很考验 Insight 的题。</p><p>注意到 <span class="math inline">\(s\)</span> 的最后形态必然为 <span class="math inline">\(0\cdots01\cdots1\)</span>（因为有 <span class="math inline">\(10\)</span> 就可以翻转），特点是逆序对为 <span class="math inline">\(0\)</span>。</p><p>而每次翻转操作可以将 <span class="math inline">\(s\)</span> 的逆序对数减少 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2\)</span>，并且手玩发现若 <span class="math inline">\(s\)</span> 的逆序对数 <span class="math inline">\(\ge 2\)</span>，则子串中一定有 <span class="math inline">\(110,100,1010\)</span> 中的一种。</p><p>根据必胜必败态定理，后手总存在策略使得一个轮次中 <span class="math inline">\(s\)</span> 的逆序对数减少 <span class="math inline">\(3\)</span>（即先手减 <span class="math inline">\(1\)</span> 后手减 <span class="math inline">\(2\)</span>，先手减 <span class="math inline">\(2\)</span> 后手减 <span class="math inline">\(1\)</span>）。</p><p>因此当 <span class="math inline">\(s\)</span> 的逆序对数 <span class="math inline">\(\bmod 3 = 0\)</span> 时，后手必胜；否则先手必胜。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	string s;
	cin &gt;&gt; s;
	<span class="hljs-type">int</span> tot0 = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
		<span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;
			tot0++;
		&#125; <span class="hljs-keyword">else</span> &#123;
			res += tot0;
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> (res % <span class="hljs-number">3</span>) &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;
	&#125; <span class="hljs-keyword">else</span> &#123;
		cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="a.-archeologists反悔贪心">A. Archeologists【反悔贪心】</h3>
<div class="note note-info">
            <p>你在玩一个寻宝类游戏，一共有 <span class="math inline">\(n\)</span> 个格子，编号为 <span class="math inline">\(1 \sim n\)</span>。你每在第 <span class="math inline">\(i\)</span> 号格子上下挖一层便会获得 <span class="math inline">\(a_i\)</span> 的价值，你需要保证每个格子与其相邻格子的下挖深度不超过 <span class="math inline">\(1\)</span>（注意此时 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n\)</span> 号点最多只能挖一层），求最大价值。</p><p><span class="math inline">\(1 \le n \le 2.5\cdot 10^5\)</span>，<span class="math inline">\(-10^6 \le a_i \le 10^6\)</span>。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jalyemdz.png" /></p>
          </div>
<div class="note note-success">
            <p>有一类用反悔贪心解决的经典问题：有一样物品，第 <span class="math inline">\(i\)</span> 天价值为 <span class="math inline">\(v_i\)</span>，每一天你可以买入一件或卖出一件，问最大收益。</p><p>解决步骤是维护一个小根堆，然后遍历 <span class="math inline">\(v_i\)</span>，若 <span class="math inline">\(v_i\)</span> 比堆顶 <span class="math inline">\(v_u\)</span> 大，则收益加上 <span class="math inline">\(v_i - v_u\)</span>，弹出堆顶，并再向堆中塞入一个 <span class="math inline">\(v_i\)</span>。这样下次再卖出时（假设为第 <span class="math inline">\(j\)</span> 天），若定位到为第 <span class="math inline">\(i\)</span> 天买入，就赚了 <span class="math inline">\(v_j - v_i\)</span>，加上之前赚的 <span class="math inline">\(v_i-v_u\)</span>，一共赚了 <span class="math inline">\(v_j-v_u\)</span>，等价于在第 <span class="math inline">\(u\)</span> 天买入第 <span class="math inline">\(j\)</span> 天卖出。以此涵盖了在任意天买入和卖出的情况。</p><div class="code-wrapper"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;
<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
	<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">top</span>() &lt; a[i]) &#123;
		ans += a[i] - q.<span class="hljs-built_in">top</span>();
		q.<span class="hljs-built_in">pop</span>();
		q.<span class="hljs-built_in">push</span>(a[i]);
	&#125;
	q.<span class="hljs-built_in">push</span>(a[i]);
&#125;
cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;</code></pre></div><p>对于本题，令 <span class="math inline">\(b_i\)</span> 为第 <span class="math inline">\(i\)</span> 个格子的下挖深度，由于相邻项相差不超过 <span class="math inline">\(1\)</span>，因此其差分数组的每一项只可能是 <span class="math inline">\(-1, 0, 1\)</span>。</p><p>将 <span class="math inline">\(1\)</span> 看成一次买入，<span class="math inline">\(-1\)</span> 看成一次卖出，就与经典题等价了。</p><p>将题给的 <span class="math inline">\(a_i\)</span> 求前缀和作为物品的价值，跑反悔贪心即可。</p><p>时间复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
		sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];
	&#125;
	priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">top</span>() &lt; sum[i]) &#123;
			ans += sum[i] - q.<span class="hljs-built_in">top</span>();
			q.<span class="hljs-built_in">pop</span>();
			q.<span class="hljs-built_in">push</span>(sum[i]);
		&#125;
		q.<span class="hljs-built_in">push</span>(sum[i]);
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="h.-and-or线段树位运算">H. AND = OR【线段树，位运算】</h3>
<div class="note note-info">
            <p>对于一个序列 <span class="math inline">\(\{b\}\)</span>，若可以将 <span class="math inline">\(\{b\}\)</span> 划分为两个非空的子序列，满足其中一个子序列中所有元素的 <span class="math inline">\(\text{And}\)</span> 与另一个子序列中所有元素的 <span class="math inline">\(OR\)</span> 相等，则称 <span class="math inline">\(\{b\}\)</span> 是 good 的。</p><p>给定一个长为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(\{a\}\)</span>，以及 <span class="math inline">\(q\)</span> 次询问。每次询问 <span class="math inline">\(\{a\}\)</span> 的一个区间 <span class="math inline">\([l, r]\)</span> 是否 good。</p><p><span class="math inline">\(1 \le n,q \le 10^5\)</span>，<span class="math inline">\(0\le a_i &lt; 2^{30}\)</span>。</p>
          </div>
<div class="note note-success">
            <p>先考虑单个询问。设 <span class="math inline">\([l,r]\)</span> 中的数被划分成 <span class="math inline">\(A,B\)</span> 两个集合，<span class="math inline">\(A\)</span> 集合的 <span class="math inline">\(\text{OR}\)</span> 和 <span class="math inline">\(B\)</span> 集合的 <span class="math inline">\(\text{And}\)</span> 相等，均为 <span class="math inline">\(X\)</span>。</p><p>那么宏观上有：<span class="math inline">\(A\)</span> 中的所有数 <span class="math inline">\(\le X\)</span>，<span class="math inline">\(B\)</span> 中的所有数 <span class="math inline">\(\ge X\)</span>。因此把 <span class="math inline">\([l,r]\)</span> 内的所有数升序排序，<span class="math inline">\(A\)</span> 中的数一定是一段前缀，<span class="math inline">\(B\)</span> 中的数一定是一段后缀，枚举分段点即可。</p><p>还能按位来看：设 <span class="math inline">\(p(x)=\text{popcount}(x)\)</span>，<span class="math inline">\(p(X)=k\)</span>，那么 <span class="math inline">\(\forall x\in A,p(x)\le k\)</span>，<span class="math inline">\(\forall x \in B,p(x)\ge k\)</span>。</p><p>此时可以枚举分段点 <span class="math inline">\(g\)</span>，两种情况：</p><p><span class="math display">\[\Large\begin{cases}\text{And}_{x\in[l, r],p(x)\le g} = \text{Or}_{x\in[l,r],p(x)&gt;g} &amp;, g\in [0,30)\\\text{And}_{x\in[l, r],p(x)\le g}= \text{Or}_{x \in[l,r], p(x)\ge g} &amp;, g \in[0,30]\end{cases}\]</span></p><p>对于第二种情况，可以证明若能划分，那么满足 <span class="math inline">\(p(x)=g\)</span> 的所有 <span class="math inline">\(x\)</span> 必须相等。<span class="math inline">\((\alpha)\)</span></p><ul><li>证明：假设存在 <span class="math inline">\(a,b\)</span> 满足 <span class="math inline">\(p(a)=g,p(b)=g\)</span>，且 <span class="math inline">\(a\)</span> 被划分进 <span class="math inline">\(A\)</span>，<span class="math inline">\(b\)</span> 被划分进 <span class="math inline">\(B\)</span>。那么：</li></ul><p><span class="math display">\[\Large\begin{cases}a \text{ | }X=X \\ b \ \&amp; \  X = X\end{cases}\to a \ \&amp;\  b = b \xrightarrow{p(a)=p(b)} a= b\]</span></p><p>至此，我们可以用 <span class="math inline">\(30\)</span> 个线段树或 <span class="math inline">\(30\)</span> 个 st 表维护二进制下每一位 <span class="math inline">\(\{a\}\)</span> 的区间按位或和区间按位与。对于一个询问 <span class="math inline">\([l,r]\)</span>，查询这个区间每一位的 <span class="math inline">\(\text{Or}\)</span> 值（<span class="math inline">\(\text{Or}[g]\)</span>）和 <span class="math inline">\(\text{And}\)</span> 值（<span class="math inline">\(\text{And}[g]\)</span>），并对前者做前缀和，后者做后缀和（即 <span class="math inline">\(\text{SOr}[g]\)</span> 代表区间内满足 <span class="math inline">\(p(x)\in[0,g]\)</span> 的所有 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(\text{Or}\)</span> 值，<span class="math inline">\(\text{SAnd}[g]\)</span> 代表区间内满足 <span class="math inline">\(p(x)\in[g,30]\)</span> 的所有 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(\text{And}\)</span> 值），对上文两种情况分别 <span class="math inline">\(\text{check}\)</span> 即可。</p><p>此外还要注意 <span class="math inline">\(\text{check}\)</span> 两个集合必须非空，可以对每一位额外维护一个前缀和相同处理。</p><p>而 <span class="math inline">\((\alpha)\)</span> 条件等价于判断 <span class="math inline">\(\text{Or}[g]=\text{And}[g]\)</span>，不用额外处理。</p><p>最开始写的 st 表没卡过，换了线段树过的。时间复杂度 <span class="math inline">\(O(30n+30q\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;
	<span class="hljs-type">int</span> n;
	vector&lt;<span class="hljs-type">int</span>&gt; And, Or;
	<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size) &#123;
		n = size;
		And.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);
		Or.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);
	&#125;

	<span class="hljs-meta">#<span class="hljs-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>

	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		And[p] = And[ls] &amp; And[rs];
		Or[p] = Or[ls] | Or[rs];
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">int</span>&gt; &amp;po, <span class="hljs-type">int</span> k)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (l == r) &#123;
			<span class="hljs-keyword">if</span> (po[l] == k) &#123;
				And[p] = Or[p] = nums[l];
			&#125; <span class="hljs-keyword">else</span> &#123;
				And[p] = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>; 
				Or[p] = <span class="hljs-number">0</span>;
			&#125;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-built_in">in_build</span>(ls, l, mid, nums, po, k);
		<span class="hljs-built_in">in_build</span>(rs, mid + <span class="hljs-number">1</span>, r, nums, po, k);
		<span class="hljs-built_in">pushup</span>(p);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query_And</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;
			<span class="hljs-keyword">return</span> And[p];
		&#125;
		<span class="hljs-type">int</span> res = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;
			res &amp;= <span class="hljs-built_in">range_query_And</span>(ls, l, mid, ql, qr);
		&#125;
		<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;
			res &amp;= <span class="hljs-built_in">range_query_And</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_query_Or</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;
			<span class="hljs-keyword">return</span> Or[p];
		&#125;
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;
			res |= <span class="hljs-built_in">range_query_Or</span>(ls, l, mid, ql, qr);
		&#125;
		<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;
			res |= <span class="hljs-built_in">range_query_Or</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;

	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">int</span>&gt; &amp;po, <span class="hljs-type">int</span> k)</span> </span>&#123;
		<span class="hljs-built_in">in_build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, nums, po, k);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_And</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query_And</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_Or</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">range_query_Or</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);
	&#125;
&#125;;


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, q;
	cin &gt;&gt; n &gt;&gt; q;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
		p[i] = __builtin_popcount(a[i]);
	&#125;
	<span class="hljs-function">vector <span class="hljs-title">st_Sum</span><span class="hljs-params">(<span class="hljs-number">31</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">30</span>; k++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			st_Sum[k][i] = st_Sum[k][i - <span class="hljs-number">1</span>] + (p[i] == k ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
		&#125;
	&#125;
	<span class="hljs-function">vector&lt;SegmentTree&gt; <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">31</span>, SegmentTree(n))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;
		seg[i].<span class="hljs-built_in">build</span>(a, p, i);
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span>, <span class="hljs-title">And</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span>, <span class="hljs-title">Or</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span></span>; 
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span>, <span class="hljs-title">preOr</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span>, <span class="hljs-title">sufAnd</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span>;
	<span class="hljs-keyword">while</span> (q--) &#123;
		<span class="hljs-type">int</span> l, r;
		cin &gt;&gt; l &gt;&gt; r;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;
			Sum[i] = st_Sum[i][r] - st_Sum[i][l - <span class="hljs-number">1</span>];
			And[i] = seg[i].<span class="hljs-built_in">query_And</span>(l, r);
			Or[i] = seg[i].<span class="hljs-built_in">query_Or</span>(l, r);
		&#125;
		preSum[<span class="hljs-number">0</span>] = Sum[<span class="hljs-number">0</span>];
		preOr[<span class="hljs-number">0</span>] = Or[<span class="hljs-number">0</span>];
		sufAnd[<span class="hljs-number">31</span>] = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) - <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;
			preSum[i] = preSum[i - <span class="hljs-number">1</span>] + Sum[i];
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;
			preOr[i] = preOr[i - <span class="hljs-number">1</span>] | Or[i];
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
			sufAnd[i] = sufAnd[i + <span class="hljs-number">1</span>] &amp; And[i];
		&#125;
		<span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;
			<span class="hljs-keyword">if</span> (preOr[i] == sufAnd[i + <span class="hljs-number">1</span>] &amp;&amp; preSum[i] &amp;&amp; preSum[i] &lt; preSum[<span class="hljs-number">30</span>]) &#123;
				flag = <span class="hljs-literal">true</span>;
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (!flag) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;
				<span class="hljs-keyword">if</span> (preOr[i] == sufAnd[i] &amp;&amp; Or[i] == And[i] &amp;&amp; Sum[i] &gt; <span class="hljs-number">1</span>) &#123;
					flag = <span class="hljs-literal">true</span>;
					<span class="hljs-keyword">break</span>;
				&#125;
			&#125;
		&#125;
		cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES\n&quot;</span> : <span class="hljs-string">&quot;NO\n&quot;</span>);
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);
	<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;test.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);
	<span class="hljs-built_in">solve</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="江苏省赛-ccpc-hunan">2023 江苏省赛/ CCPC Hunan</h2>
<h3 id="b.-honkai-in-taikula拆点缩点全源最短路">B. Honkai in TAIKULA【拆点，缩点，全源最短路】</h3>
<div class="note note-info">
            <p>给定一张 <span class="math inline">\(n\)</span> 个节点 <span class="math inline">\(m\)</span> 条边的有向带权图，对每个节点，报告是否存在经过该点的奇权圈（可经过重复顶点、重复边、若经过重复边，边权计多次）。若存在，输出最小奇权圈的权值（或报告为负无穷）。</p><p><span class="math inline">\(1\le n \le 1000\)</span>，<span class="math inline">\(1 \le m \le 10^4\)</span>，<span class="math inline">\(0\le x_i,y_i &lt; n\)</span>，<span class="math inline">\(|w_i| \le 10^7\)</span>。</p>
          </div>
<div class="note note-success">
            <p>处理带权图的边权奇偶性问题常用缩点：把一个点 <span class="math inline">\(x\)</span> 拆成一个奇点 <span class="math inline">\(\text{Odd}_x\)</span>、一个偶点 <span class="math inline">\(\text{Even}_x\)</span>。</p><ul><li>若存在 <span class="math inline">\(x\xrightarrow{w} y\)</span>，<span class="math inline">\(w\)</span> 为奇数。则连 <span class="math inline">\(\text{Odd}_x \to \text{Even}_y\)</span>，<span class="math inline">\(\text{Even}_x \to \text{Odd}_y\)</span>。</li><li>若存在 <span class="math inline">\(x \xrightarrow{w} y\)</span>，<span class="math inline">\(w\)</span> 为偶数。则连 <span class="math inline">\(\text{Odd}_x\to \text{Odd}_y\)</span>，<span class="math inline">\(\text{Even}_x\to \text{Even}_y\)</span>。</li></ul><p>若存在一个经过点 <span class="math inline">\(x\)</span> 的奇权圈，等价于存在一条 <span class="math inline">\(\text{Odd}_x \to \text{Even}_x\)</span> 的路径。（或 <span class="math inline">\(\text{Even}_x \to \text{Odd}_x\)</span>，钦定一种即可）</p><p>接着，由于环只存在于单个强连通分量内，所以考虑缩点得到一张有向无环图 <span class="math inline">\(G\)</span>。</p><p>注意到只要存在一条路径从 <span class="math inline">\(x\)</span> 出发，经过负环，再回到 <span class="math inline">\(x\)</span>。那么最小奇权圈的权值就是负无穷，因为可以再负环上无限绕再返回 <span class="math inline">\(x\)</span>。所以对 <span class="math inline">\(G\)</span> 中每个点代表的子图都跑 SPFA 算法判断负环。</p><p>设 <span class="math inline">\(\text{Odd}_x\)</span> 和 <span class="math inline">\(\text{Even}_x\)</span> 所在的 SCC 编号分别为 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>。利用 dfs 判断 <span class="math inline">\(G\)</span> 中是否存在 <span class="math inline">\(A\to B\)</span> 的路径，路径上又是否有标记为负环的点即可完成无解和负无穷解的判断。</p><p>接下来是有解的情况。在未缩点的原图上跑 Johnson 全源最短路即可，注意避开 “位于被标记负环的 SCC 中” 的所有点。</p><p>时间复杂度 <span class="math inline">\(O(nm\log m)\)</span>。</p>
          </div>
<div class="note note-warning">
            <p>Funfact：有人拓扑图上 dfs 不用标记数组标记走过的点，狂 T 两小时QAQ。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> _node vector<span class="hljs-string">&lt;vector&lt;array&lt;int, 2&gt;</span>&gt;&gt;</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Johnson</span> &#123;
	<span class="hljs-type">int</span> n;
	_node adj;
	vector&lt;<span class="hljs-type">int</span>&gt; h, dis, A;
	<span class="hljs-built_in">Johnson</span>(_node Adj, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B) &#123;
		adj = Adj;
		A = B;
		<span class="hljs-keyword">this</span>-&gt;n = Adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
		<span class="hljs-built_in">init</span>();
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
		h.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
		dis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			adj[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;i, <span class="hljs-number">0</span>&#125;);
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">circle</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
		h.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);
		queue&lt;<span class="hljs-type">int</span>&gt; q;
		vis[s] = <span class="hljs-literal">true</span>;
		h[s] = <span class="hljs-number">0</span>;
		q.<span class="hljs-built_in">push</span>(s);
		<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();
			q.<span class="hljs-built_in">pop</span>();
			vis[x] = <span class="hljs-literal">false</span>;
			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (!A[y]) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				<span class="hljs-keyword">if</span>(h[y] &gt; h[x] + w) &#123;
					h[y] = h[x] + w;
					<span class="hljs-keyword">if</span>(!vis[y]) &#123;
						<span class="hljs-keyword">if</span>(++circle[y] &gt;= n + <span class="hljs-number">1</span>) &#123;
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						&#125;
						vis[y] = <span class="hljs-literal">true</span>;
						q.<span class="hljs-built_in">push</span>(y);
					&#125;
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;	
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;
		priority_queue&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; q;
		dis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
		dis[s] = <span class="hljs-number">0</span>;
		q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);
		<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>()[<span class="hljs-number">1</span>];
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">if</span>(vis[x]) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			vis[x] = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (!A[y]) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				<span class="hljs-keyword">if</span>(dis[y] &gt; dis[x] + w) &#123;
					dis[y] = dis[x] + w;
					q.<span class="hljs-built_in">push</span>(&#123;-dis[y], y&#125;);
				&#125;
			&#125;
		&#125;
	&#125;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">work</span>() &#123;
		<span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, -inf))</span></span>;
		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(<span class="hljs-number">0</span>)) &#123;
			<span class="hljs-keyword">return</span> ans;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= n; x++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[y, w] : adj[x]) &#123;
				w += h[x] - h[y];
			&#125;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			<span class="hljs-built_in">dijkstra</span>(i);
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;
				<span class="hljs-keyword">if</span> (dis[j] == inf) &#123;
					ans[i][j] = inf; 
				&#125; <span class="hljs-keyword">else</span> &#123;
					ans[i][j] = dis[j] + (h[j] - h[i]);
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> ans;
	&#125;
&#125;;



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; E;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> x, y, w;
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
		x++; y++;
		<span class="hljs-keyword">if</span> (w % <span class="hljs-number">2</span>) &#123;
			adj[x].<span class="hljs-built_in">push_back</span>(&#123;y + n, w&#125;);
			adj[x + n].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);
			E.<span class="hljs-built_in">push_back</span>(&#123;x, y + n, w&#125;);
			E.<span class="hljs-built_in">push_back</span>(&#123;x + n, y, w&#125;);
		&#125; <span class="hljs-keyword">else</span> &#123;
			adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);
			adj[x + n].<span class="hljs-built_in">push_back</span>(&#123;y + n, w&#125;);
			E.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);
			E.<span class="hljs-built_in">push_back</span>(&#123;x + n, y + n, w&#125;);
		&#125;
	&#125;

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfn</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">low</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">stack_</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">VIS</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">scc</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
	<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;
	function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; tarjan = [&amp;](<span class="hljs-type">int</span> x) &#123;
		dfn[x] = low[x] = ++tim;
		VIS[x] = <span class="hljs-literal">true</span>;
		stack_[++top] = x;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (!dfn[y]) &#123;
				<span class="hljs-built_in">tarjan</span>(y);
				low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]);
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VIS[y]) &#123;
				low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]);
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (dfn[x] == low[x]) &#123;
			<span class="hljs-type">int</span> now; ++cnt;
			<span class="hljs-keyword">do</span> &#123;
				now = stack_[top--];
				VIS[now] = <span class="hljs-literal">false</span>;
				c[now] = cnt;
				scc[cnt].<span class="hljs-built_in">push_back</span>(now);
			&#125; <span class="hljs-keyword">while</span>(x != now);
		&#125;
	&#125;;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">Adj</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">auto</span> shrinkPoint = [&amp;]() &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">2</span> * n; x++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, _] : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (c[x] == c[y]) <span class="hljs-keyword">continue</span>;
				Adj[c[x]].<span class="hljs-built_in">push_back</span>(c[y]);
			&#125;
		&#125;
	&#125;;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++)
		<span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);
	<span class="hljs-built_in">shrinkPoint</span>();

	
	vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">G</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>; 
	<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>;
	<span class="hljs-keyword">auto</span> spfa = [&amp;](<span class="hljs-type">int</span> s) &#123;
		dis.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, inf);
		vis.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
		num.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
		dis[s] = <span class="hljs-number">0</span>;
		vis[s] = <span class="hljs-literal">true</span>;
		priority_queue&lt;<span class="hljs-type">int</span>&gt; q;
		q.<span class="hljs-built_in">push</span>(s);
		num[s]++;
		<span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>();
			q.<span class="hljs-built_in">pop</span>();
			vis[x] = <span class="hljs-literal">false</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, z] : G[x]) &#123;
				<span class="hljs-keyword">if</span>(dis[y] &gt; dis[x] + z) &#123;
					dis[y] = dis[x] + z;
					<span class="hljs-keyword">if</span> (!vis[y]) &#123;
						vis[y] = <span class="hljs-literal">true</span>;
						q.<span class="hljs-built_in">push</span>(y);
						<span class="hljs-keyword">if</span> (++num[y] &gt; scc[c[s]].<span class="hljs-built_in">size</span>()) &#123;
							<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
						&#125;
					&#125;
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;;


	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">have_circle</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> rt : scc[i]) &#123;
			exist[rt] = <span class="hljs-number">1</span>;
		&#125;
		G.<span class="hljs-built_in">clear</span>();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : E) &#123;
			<span class="hljs-keyword">if</span> (exist[x] &amp;&amp; exist[y]) &#123;
				G[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">spfa</span>(scc[i][<span class="hljs-number">0</span>])) &#123;
			have_circle[i] = <span class="hljs-literal">true</span>;
		&#125;
	&#125;


	<span class="hljs-type">int</span> T, success;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis2</span><span class="hljs-params">(cnt + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> flag) -&gt; <span class="hljs-type">bool</span> &#123;
		<span class="hljs-keyword">if</span> (have_circle[x]) &#123;
			flag = <span class="hljs-number">1</span>;
		&#125;
		<span class="hljs-keyword">if</span> (x == T) &#123;
			<span class="hljs-keyword">if</span>(flag) &#123;
				success = <span class="hljs-literal">true</span>;
			&#125;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : Adj[x]) &#123;
			<span class="hljs-keyword">if</span> (vis2[y]) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			vis2[y] = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>(self, y, flag)) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;;


	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		T = c[i + n];
		success = <span class="hljs-number">0</span>;
		<span class="hljs-type">int</span> res = <span class="hljs-built_in">dfs</span>(dfs, c[i], <span class="hljs-number">0</span>);
		<span class="hljs-keyword">if</span> (!res) &#123;
			ans[i] = <span class="hljs-number">-1</span>;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (success) &#123;
			ans[i] = inf;
		&#125; 
	&#125; 

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>; 
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;
		<span class="hljs-keyword">if</span> (!have_circle[i]) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : scc[i]) &#123;
				A[x] = <span class="hljs-literal">true</span>;
			&#125;
		&#125;
	&#125;

	<span class="hljs-function">Johnson <span class="hljs-title">H</span><span class="hljs-params">(adj, A)</span></span>;
	vector diss = H.<span class="hljs-built_in">work</span>();

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (ans[i] == <span class="hljs-number">-1</span>) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;Battle with the crazy Honkai\n&quot;</span>;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans[i] == inf) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;Haha, stupid Honkai\n&quot;</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			cout &lt;&lt; diss[i][i + n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
		&#125;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="l.-architect思维扫描线">L. Architect【思维，扫描线】</h3>
<div class="note note-info">
            <p>给定 <span class="math inline">\(n\)</span> 个长方体，询问其是否能拼接成一个 <span class="math inline">\(W\times H\times L\)</span> 的立方体，没有重叠和空隙，所有长方体都要用到。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(1\le W, H, L \le 10^9\)</span>。</p>
          </div>
<div class="note note-success">
            <p>一种绝世聪明的想法是 “只需判断 <span class="math inline">\(n\)</span> 个立方体的体积和是否 <span class="math inline">\(=\)</span> <span class="math inline">\(W\times H\times L\)</span>，且八个角的出现次数是否是偶数次即可”。</p><p>体积一样限定了这 <span class="math inline">\(n\)</span> 个立方体不能有重叠。</p><p>八个角出现了偶数次限定了这 <span class="math inline">\(n\)</span> 个立方体与大立方体间没有空隙。</p><p>注意 <span class="math inline">\(10^9\cdot 10^9\cdot 10^9=10^{27}\)</span>，需要开 <code>__int128</code>。</p><p>时间复杂度 <span class="math inline">\(O(8n\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int __int128</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>
istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, __int128 &amp;n) &#123;
    string s;
    is &gt;&gt; s;
    n = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123; 
    	n = n * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);
    &#125;
    <span class="hljs-keyword">return</span> is;
&#125;
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, __int128 n) &#123;
	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-number">0</span>;
	&#125;
	string s;
	<span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123; 
		s += <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;0&#x27;</span> + n % <span class="hljs-number">10</span>); 
		n /= <span class="hljs-number">10</span>;
	&#125;
	<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());
	<span class="hljs-keyword">return</span> os &lt;&lt; s;
&#125;


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> W, H, L, n;
	cin &gt;&gt; W &gt;&gt; H &gt;&gt; L &gt;&gt; n;
	<span class="hljs-type">int</span> All = W * H * L, all = <span class="hljs-number">0</span>;

	map&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;, <span class="hljs-type">int</span>&gt; mp;
	<span class="hljs-keyword">auto</span> ins = [&amp;] (<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> z0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> z1) &#123;
		mp[&#123;x0, y0, z0&#125;]++;
		mp[&#123;x0, y0, z1&#125;]++;
		mp[&#123;x0, y1, z0&#125;]++;
		mp[&#123;x0, y1, z1&#125;]++;
		mp[&#123;x1, y0, z0&#125;]++;
		mp[&#123;x1, y0, z1&#125;]++;
		mp[&#123;x1, y1, z0&#125;]++;
		mp[&#123;x1, y1, z1&#125;]++;
	&#125;;
	<span class="hljs-built_in">ins</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, L);
	<span class="hljs-keyword">while</span> (n--) &#123;
		<span class="hljs-type">int</span> x0, y0, z0, x1, y1, z1;
		cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; z0 &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1;
		all += (x1 - x0) * (y1 - y0) * (z1 - z0);
		<span class="hljs-built_in">ins</span>(x0, y0, z0, x1, y1, z1);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, x] : mp) &#123;
		<span class="hljs-keyword">if</span> (x &amp; <span class="hljs-number">1</span>) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;
			<span class="hljs-keyword">return</span> ;
		&#125;
	&#125;
	cout &lt;&lt; (all == All ? <span class="hljs-string">&quot;Yes\n&quot;</span> : <span class="hljs-string">&quot;No\n&quot;</span>);
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class="note note-success">
            <p>另一种朴素但也颇具技巧性的方法是扫描线。</p><p>先将 <span class="math inline">\(n\)</span> 个小立方体的底面看作 <span class="math inline">\(1\)</span>，顶面看作 <span class="math inline">\(-1\)</span>；大立方体的底面看作 <span class="math inline">\(-1\)</span>，顶面看作 <span class="math inline">\(1\)</span>。</p><p>如果每个表面紧紧贴合，那么代数和为 <span class="math inline">\(0\)</span>。</p><p>接着不断降维，同样的思想能判断线是否紧密贴合，点是否紧密贴合。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>



<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check2</span><span class="hljs-params">(vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; a)</span> </span>&#123;
	map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x1, x2, flag] : a) &#123;
		mp[x1] += flag;
		mp[x2] += -flag;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;
		<span class="hljs-keyword">if</span> (v) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt;&gt; a)</span> </span>&#123;
	map&lt;<span class="hljs-type">int</span>, vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt;&gt; mp;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x1, y1, x2, y2, flag] : a) &#123;
		mp[y1].<span class="hljs-built_in">push_back</span>(&#123;x1, x2, flag&#125;);
		mp[y2].<span class="hljs-built_in">push_back</span>(&#123;x1, x2, -flag&#125;);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;
		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check2</span>(v)) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> W, H, L;
	cin &gt;&gt; W &gt;&gt; H &gt;&gt; L;

	map&lt;<span class="hljs-type">int</span>, vector&lt;array&lt;<span class="hljs-type">int</span>, 5&gt;&gt;&gt; mp;
	mp[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, <span class="hljs-number">-1</span>&#125;);
	mp[L].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, W, H, <span class="hljs-number">1</span>&#125;);

	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x1, y1, z1, x2, y2, z2;
		cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2;
		mp[z1].<span class="hljs-built_in">push_back</span>(&#123;x1, y1, x2, y2, <span class="hljs-number">1</span>&#125;);
		mp[z2].<span class="hljs-built_in">push_back</span>(&#123;x1, y1, x2, y2, <span class="hljs-number">-1</span>&#125;);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : mp) &#123;
		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(v)) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;
			<span class="hljs-keyword">return</span> ;
		&#125;
	&#125;
	cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="ccpc-weihai">2020 CCPC Weihai</h2>
<h3 id="b.-labyrinthbfs">B. Labyrinth【bfs】</h3>
<div class="note note-info">
            <p>给定一个 <span class="math inline">\(n\times m\)</span> 的网格图，有 <span class="math inline">\(k\)</span> 个格子有障碍不能通行。<span class="math inline">\(q\)</span> 次询问，每次询问两点间的最短路长度。</p><p><span class="math inline">\(1\le n,m\le2\cdot 10^5\)</span>，<span class="math inline">\(1\le n\cdot m\le 2\cdot 10^5\)</span>，<span class="math inline">\(0\le k \le 42\)</span>，<span class="math inline">\(1\le q\le 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>对于一组询问，假设询问的两个点是 <span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2, y_2)\)</span>。</p><p>那么当 <span class="math inline">\((x_1,y_1)\)</span> 和 <span class="math inline">\((x_2,y_2)\)</span> 作为对角线的两个端点围成的矩形中没有一个障碍时，答案就是这两点间的曼哈顿距离；否则可以想象到最短路一定经过某个障碍周围四格中的某一格。</p><p>把所有障碍的四联通预处理出来并去重，以每个点为起点跑 bfs 求出其到所有格子的最短路。</p><p>询问时枚举一下这 <span class="math inline">\(O(4k)\)</span> 个点作为中转点的最短路，取 <span class="math inline">\(\min\)</span> 即可。</p><p>时间复杂度 <span class="math inline">\(O(knm)-O(k)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(<span class="hljs-string">&quot;Ofast&quot;</span>)</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span>




<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, k, Q;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; Q;
	<span class="hljs-function">vector <span class="hljs-title">bomb</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		bomb[x][y] = <span class="hljs-number">1</span>;
	&#125;
	vector sum = bomb;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
			sum[i][j] += sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
		&#125;
	&#125;
	<span class="hljs-keyword">auto</span> query = [&amp;] (<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy) &#123;
		<span class="hljs-keyword">return</span> sum[fx][fy] - sum[sx - <span class="hljs-number">1</span>][fy] - sum[fx][sy - <span class="hljs-number">1</span>] + sum[sx - <span class="hljs-number">1</span>][sy - <span class="hljs-number">1</span>];
	&#125;;
	<span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;
	<span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; waiting;
	<span class="hljs-function">vector <span class="hljs-title">VIS</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
			<span class="hljs-keyword">if</span> (bomb[i][j]) &#123;
				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;
					<span class="hljs-type">int</span> x = i + dx[k];
					<span class="hljs-type">int</span> y = j + dy[k];
					<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">1</span> || x &gt; n || y &gt; m || bomb[x][y] || VIS[x][y]) &#123;
						<span class="hljs-keyword">continue</span>;
					&#125;
					VIS[x][y] = <span class="hljs-literal">true</span>;
					waiting.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);
				&#125;
			&#125;
		&#125;
	&#125;
	<span class="hljs-type">int</span> all = waiting.<span class="hljs-built_in">size</span>();
	<span class="hljs-function">vector <span class="hljs-title">dis</span><span class="hljs-params">(all, vector(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, inf)))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>; id &lt; all; id++) &#123;
		<span class="hljs-keyword">auto</span> [sx, sy] = waiting[id];
		queue&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; q;
		q.<span class="hljs-built_in">push</span>(&#123;sx, sy, <span class="hljs-number">0</span>&#125;);
		<span class="hljs-function">vector <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;
		vis[sx][sy] = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-keyword">auto</span> [x, y, lst_dis] = q.<span class="hljs-built_in">front</span>();
			dis[id][x][y] = lst_dis;
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;
				<span class="hljs-type">int</span> xx = x + dx[i];
				<span class="hljs-type">int</span> yy = y + dy[i];
				<span class="hljs-keyword">if</span> (xx &lt; <span class="hljs-number">1</span> || yy &lt; <span class="hljs-number">1</span> || xx &gt; n || yy &gt; m || bomb[xx][yy] || vis[xx][yy]) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				vis[xx][yy] = <span class="hljs-literal">true</span>;
				<span class="hljs-type">int</span> cur_dis = lst_dis + <span class="hljs-number">1</span>;
				q.<span class="hljs-built_in">push</span>(&#123;xx, yy, cur_dis&#125;);
			&#125;
		&#125;
	&#125;

	<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy) &#123;

	&#125;;

	<span class="hljs-keyword">while</span> (Q--) &#123;
		<span class="hljs-type">int</span> sx, sy, fx, fy;
		cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;
		<span class="hljs-keyword">if</span> (bomb[sx][sy] || bomb[fx][fy]) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-keyword">if</span> (sx == fx &amp;&amp; sy == fy) &#123;
			cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;
			<span class="hljs-keyword">continue</span>;
		&#125;

		<span class="hljs-type">int</span> lx = <span class="hljs-built_in">min</span>(sx, fx);
		<span class="hljs-type">int</span> ly = <span class="hljs-built_in">min</span>(sy, fy);
		<span class="hljs-type">int</span> rx = <span class="hljs-built_in">max</span>(sx, fx);
		<span class="hljs-type">int</span> ry = <span class="hljs-built_in">max</span>(sy, fy);
		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">query</span>(lx, ly, rx, ry)) &#123;
			cout &lt;&lt; <span class="hljs-built_in">abs</span>(sx - fx) + <span class="hljs-built_in">abs</span>(sy - fy) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = inf;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; all; i++) &#123;
			<span class="hljs-keyword">if</span> (dis[i][sx][sy] == inf || dis[i][fx][fy] == inf) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = dis[i][sx][sy] + dis[i][fx][fy];
			ans = <span class="hljs-built_in">min</span>(ans, res);
		&#125;
		<span class="hljs-keyword">if</span> (ans == inf) &#123;
			ans = <span class="hljs-number">-1</span>;
		&#125;
		cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="c.-rencontre结论期望">C. Rencontre【结论，期望】</h3>
<div class="note note-info">
            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，边有边权 <span class="math inline">\(w_i\)</span>。给定三个点集，从三个点集中分别随机选出 <span class="math inline">\(u_1,u_2,u_3\)</span>，问以下式子的期望： <span class="math display">\[f(u_1,u_2,u_3)=\min_{i\in[1,n]}(dis(u_1,i)+dis(u_2,i)+dis(u_3,i))\]</span> 其中 <span class="math inline">\(dis(x,y)\)</span> 代表点 <span class="math inline">\(x,y\)</span> 间的树上距离。</p><p><span class="math inline">\(1\le n \le 2 \cdot 10^5\)</span>，<span class="math inline">\(1\le w \le 1000\)</span>。</p>
          </div>
<div class="note note-success">
            <p>结论题。所给式子等价于： <span class="math display">\[f(u_1,u_2,u_3)=\frac{1}{2}(dis(u_1,u_2)+dis(u_2,u_3)+dis(u_1,u_3))\]</span> 根据期望的线性性，只需分别求出这三项每一项的期望再相加。</p><p>以 <span class="math inline">\(dis(u_1,u_2)\)</span> 举例，考虑拆贡献：对于一条边 <span class="math inline">\(x\leftrightarrow y\)</span>，设 <span class="math inline">\(x\)</span> 一侧有 <span class="math inline">\(A_x\)</span> 个点属于点集一，<span class="math inline">\(B_x\)</span> 个点属于点集二；<span class="math inline">\(y\)</span> 一侧有 <span class="math inline">\(A_y\)</span> 个点属于点集一，<span class="math inline">\(B_y\)</span> 个点属于点集二。</p><p>那么该条边的贡献为 <span class="math inline">\(w\cdot \dfrac{A_x B_y+A_yB_x}{|A||B|}\)</span>，<span class="math inline">\(|A|\)</span> 和 <span class="math inline">\(|B|\)</span> 分别为点集一和点集二的大小。最终贡献就是所有边的贡献之和。</p><p>dfs 简单处理，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">//-------------- templates above --------------</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y, w;
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
		adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);
		adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);
	&#125;
	vector&lt;<span class="hljs-type">int</span>&gt; A, B, C;
	<span class="hljs-type">int</span> An, Bn, Cn;
	cin &gt;&gt; An;
	<span class="hljs-keyword">while</span> (An--) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		A.<span class="hljs-built_in">push_back</span>(x);
	&#125;
	cin &gt;&gt; Bn;
	<span class="hljs-keyword">while</span> (Bn--) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		B.<span class="hljs-built_in">push_back</span>(x);
	&#125;
	cin &gt;&gt; Cn;
	<span class="hljs-keyword">while</span> (Cn--) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		C.<span class="hljs-built_in">push_back</span>(x);
	&#125;
	<span class="hljs-keyword">auto</span> calc = [&amp;] (vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;
		vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">isa</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">isb</span>(n + <span class="hljs-number">1</span>);
		<span class="hljs-type">int</span> asz = <span class="hljs-number">0</span>, bsz = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;
			isa[x] = <span class="hljs-literal">true</span>;
			asz++;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : b) &#123;
			isb[x] = <span class="hljs-literal">true</span>;
			bsz++;
		&#125;
		vector f = isa, g = isb;
		<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (y == fa) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				<span class="hljs-built_in">self</span>(self, y, x);
				f[x] += f[y];
				g[x] += g[y];
			&#125;
		&#125;;
		<span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
		<span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (y == fa) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				<span class="hljs-type">double</span> t = <span class="hljs-number">1.0</span> * f[y] * (bsz - g[y]);
				t += <span class="hljs-number">1.0</span> * g[y] * (asz - f[y]);
				res += <span class="hljs-number">1.0</span> * w * t;
				<span class="hljs-built_in">self</span>(self, y, x);
			&#125;
		&#125;;
		<span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
		res /= (asz * bsz);
		<span class="hljs-keyword">return</span> res;
	&#125;;
	<span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;
	ans += <span class="hljs-built_in">calc</span>(A, B);
	ans += <span class="hljs-built_in">calc</span>(B, C);
	ans += <span class="hljs-built_in">calc</span>(A, C);
	ans /= <span class="hljs-number">2</span>;
	cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>) &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="g.-caesar-cipher线段树维护哈希值">G. Caesar Cipher【线段树维护哈希值】</h3>
<div class="note note-info">
            <p>维护一个序列 <span class="math inline">\(\{a\}\)</span>，支持两种操作：</p><ul><li><code>1 l r</code>：<span class="math inline">\(\forall i\in[l, r]\)</span>，<span class="math inline">\(a_i=(a_i+1)\bmod 65536\)</span>.</li><li><code>2 x y L</code>：询问区间 <span class="math inline">\([x,x+L-1]\)</span> 和区间 <span class="math inline">\([y,y+L-1]\)</span> 是否完全相同。</li></ul><p><span class="math inline">\(1\le n,q\le 5\cdot10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>经典题，线段树维护哈希值。</p><p>预处理出 <code>pow[i]</code> 代表 <span class="math inline">\(\text{base}^i\)</span>，<code>pre[i]</code> 代表 <span class="math inline">\(\sum_{j=0}^{i}\text{base}^j\)</span>。</p><p>区间合并时，左区间的哈希值需要乘 <code>pow[r - mid]</code> 再加上右区间的哈希值。</p><p>区间修改时，相当于区间加 <code>pre[r - l]</code>。</p><p>区间查询时，合并答案需要左区间答案乘 <code>pow[max(0, min(r, qr) - mid)]</code> 再加上右区间答案。</p><p>这道题的创新点是操作一需要模一个数。</p><p>注意到值溢出（即 <span class="math inline">\(\ge 65536\)</span>）的次数不超过 <span class="math inline">\(\frac{nq}{65536}\approx 4\cdot10^6\)</span> 次，可以维护区间最大值，每次定位到那个溢出的点然后单点修改。</p><p>时间复杂度 <span class="math inline">\(O(\frac{nq\log n}{65536}+q\log n)\)</span>。时限给了 10s，实际上 1s 多一点就跑完了。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> base = <span class="hljs-number">65536</span>;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1145141</span>;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sgt</span>&#123;
	<span class="hljs-type">int</span> n;
	vector&lt;<span class="hljs-type">int</span>&gt; h, mx, Add;
	vector&lt;<span class="hljs-type">int</span>&gt; pow, pre;
	<span class="hljs-built_in">Sgt</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">h</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), <span class="hljs-built_in">mx</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), 
	<span class="hljs-built_in">Add</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>), <span class="hljs-built_in">pow</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">pre</span>(n + <span class="hljs-number">1</span>) &#123;
		pow[<span class="hljs-number">0</span>] = pre[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			pow[i] = pow[i - <span class="hljs-number">1</span>] * base % mod;
			pre[i] = (pre[i - <span class="hljs-number">1</span>] + pow[i]) % mod;
		&#125;
	&#125;

	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span>

	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
		h[p] = (h[ls] * pow[r - mid] % mod + h[rs]) % mod;
		mx[p] = <span class="hljs-built_in">max</span>(mx[ls], mx[rs]);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (Add[p]) &#123;
			h[ls] = (h[ls] + Add[p] * pre[mid - l] % mod) % mod; 
			h[rs] = (h[rs] + Add[p] * pre[r - mid - <span class="hljs-number">1</span>] % mod) % mod;
			mx[ls] += Add[p];
			mx[rs] += Add[p];
			Add[ls] += Add[p];
			Add[rs] += Add[p];
			Add[p] = <span class="hljs-number">0</span>;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (l == r) &#123;
			h[p] = a[l];
			mx[p] = a[l];
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-built_in">build</span>(ls, l, mid, a);
		<span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r, a);
		<span class="hljs-built_in">pushup</span>(p, l, r);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;
		<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;
			h[p] = (h[p] + pre[r - l]) % mod;
			Add[p]++;
			mx[p]++;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-built_in">pushdown</span>(p, l, r);
		<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;
			<span class="hljs-built_in">update</span>(ls, l, mid, ql, qr);
		&#125;
		<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;
			<span class="hljs-built_in">update</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);
		&#125;
		<span class="hljs-built_in">pushup</span>(p, l, r);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_mod</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (mx[p] &lt; base) &#123;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-keyword">if</span> (l == r) &#123;
			h[p] -= base;
			mx[p] -= base;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-built_in">pushdown</span>(p, l, r);
		<span class="hljs-keyword">if</span> (mx[ls] &gt;= base) &#123;
			<span class="hljs-built_in">update_mod</span>(ls, l, mid);
		&#125;
		<span class="hljs-keyword">if</span> (mx[rs] &gt;= base) &#123;
			<span class="hljs-built_in">update_mod</span>(rs, mid + <span class="hljs-number">1</span>, r);
		&#125;
		<span class="hljs-built_in">pushup</span>(p, l, r);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_mod</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-built_in">update_mod</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;
			<span class="hljs-keyword">return</span> h[p];
		&#125;
		<span class="hljs-built_in">pushdown</span>(p, l, r);
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> (ql &lt;= mid) &#123;
			<span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, <span class="hljs-built_in">min</span>(r, qr) - mid);
			res = (res + <span class="hljs-built_in">query</span>(ls, l, mid, ql, qr) * pow[len] % mod) % mod;
		&#125;
		<span class="hljs-keyword">if</span> (qr &gt; mid) &#123;
			res = (res + <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr)) % mod;
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);
	&#125;
&#125;;


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, q;
	cin &gt;&gt; n &gt;&gt; q;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-function">Sgt <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;
	seg.<span class="hljs-built_in">build</span>(a);
	<span class="hljs-keyword">while</span> (q--) &#123;
		<span class="hljs-type">int</span> opt;
		cin &gt;&gt; opt;
		<span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) &#123;
			<span class="hljs-type">int</span> l, r;
			cin &gt;&gt; l &gt;&gt; r;
			seg.<span class="hljs-built_in">update</span>(l, r);
			seg.<span class="hljs-built_in">update_mod</span>();
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-type">int</span> x, y, L;
			cin &gt;&gt; x &gt;&gt; y &gt;&gt; L;
			<span class="hljs-type">int</span> h1 = seg.<span class="hljs-built_in">query</span>(x, x + L - <span class="hljs-number">1</span>);
			<span class="hljs-type">int</span> h2 = seg.<span class="hljs-built_in">query</span>(y, y + L - <span class="hljs-number">1</span>);
			cout &lt;&lt; (h1 == h2 ? <span class="hljs-string">&quot;yes\n&quot;</span> : <span class="hljs-string">&quot;no\n&quot;</span>);
		&#125;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="j.-steinsgame博弈sg函数线性基">J. Steins;Game【博弈，SG函数，线性基】</h3>
<div class="note note-info">
            <p>现定义一种博弈游戏：有 <span class="math inline">\(n\)</span> 堆石子，每堆石子被涂成了黑色或白色。双方轮流从以下两种取石子方式中选择一种并操作：</p><ul><li>从石子数最少的黑色堆中取任意个石子。这里“最少”是与其它黑色堆比较。</li><li>从任意白色堆中取任意个石子。</li></ul><p>轮到某一方时无石子可取则败。</p><p>现在这 <span class="math inline">\(n\)</span> 堆石子每一堆的数量 <span class="math inline">\(a_i\)</span> 固定，但并未上色。</p><p>求有多少种上色方案，使得先手必败。方案数对 <span class="math inline">\(10^9+7\)</span> 取模。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(1 \le a_i \le 10^{18}\)</span>。</p>
          </div>
<div class="note note-success">
            <p>将白色堆和黑色堆分开来看，称为白色游戏和黑色游戏。</p><p>当白色游戏的 SG 值和黑色游戏的 SG 值异或为 <span class="math inline">\(0\)</span> 时，先手必败。</p><p>白色游戏即 nim 游戏——当所有白色堆石子数目的异或和为 <span class="math inline">\(0\)</span> 时，先手必败。</p><p>接着尝试求出黑色游戏的 SG 值，可以打表找规律。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        bruteforce
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">//-------------- templates above --------------</span>



<span class="hljs-meta">#<span class="hljs-keyword">define</span> node priority_queue<span class="hljs-string">&lt;int, vector&lt;int&gt;</span>, greater<span class="hljs-string">&lt;int&gt;</span>&gt;</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n = <span class="hljs-number">7</span>, mx = <span class="hljs-number">8</span>;
	map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; mp;
	<span class="hljs-keyword">auto</span> sg = [&amp;] (<span class="hljs-keyword">auto</span> self, node q) -&gt; <span class="hljs-type">int</span> &#123;
		<span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		&#125;
		vector&lt;<span class="hljs-type">int</span>&gt; A;
		node o_q = q;
		<span class="hljs-keyword">while</span> (!o_q.<span class="hljs-built_in">empty</span>()) &#123;
			A.<span class="hljs-built_in">push_back</span>(o_q.<span class="hljs-built_in">top</span>());
			o_q.<span class="hljs-built_in">pop</span>();
		&#125;
		<span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(A)) &#123;
			<span class="hljs-keyword">return</span> mp[A];
		&#125;
		<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
		<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>();
		q.<span class="hljs-built_in">pop</span>();
		vis[<span class="hljs-built_in">self</span>(self, q)] = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; x; i++) &#123;
			<span class="hljs-keyword">auto</span> tmp = q;
			tmp.<span class="hljs-built_in">push</span>(i);
			vis[<span class="hljs-built_in">self</span>(self, tmp)] = <span class="hljs-literal">true</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;
			<span class="hljs-keyword">if</span> (!vis[i]) &#123;
				<span class="hljs-keyword">return</span> mp[A] = i;
			&#125;
		&#125;
	&#125;;
	vector&lt;<span class="hljs-type">int</span>&gt; a;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> lst) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">if</span> (dep == n) &#123;
			node q;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;
				q.<span class="hljs-built_in">push</span>(x);
				cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
			&#125;
			cout &lt;&lt; <span class="hljs-string">&quot; sg = &quot;</span> &lt;&lt; <span class="hljs-built_in">sg</span>(sg, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lst; i &lt;= mx; i++) &#123;
			<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
				a.<span class="hljs-built_in">push_back</span>(i);
			&#125;
			<span class="hljs-built_in">self</span>(self, dep + <span class="hljs-number">1</span>, i);
			<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
				a.<span class="hljs-built_in">pop_back</span>();
			&#125;
		&#125;
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class="note note-success">
            <p>结论是： <span class="math display">\[\text{SG}_{黑色游戏}=\text{最小堆石子数量}-(有多少堆石子数最少+[所有堆石子数相同])\bmod2\]</span> 然后是计数。将 <span class="math inline">\(a_i\)</span> 排序，预处理出前缀异或和 <span class="math inline">\(\text{pre}_i\)</span>，后缀异或和 <span class="math inline">\(\text{suf}_i\)</span>，有 <span class="math inline">\(\text{tot}_i\)</span> 堆石子数为 <span class="math inline">\(i\)</span>，以及第 <span class="math inline">\(i\sim n\)</span> 堆中有 <span class="math inline">\(\text{same}_i\)</span> 堆石子数为 <span class="math inline">\(a_i\)</span>。在以下过程中，相同石子数的堆可以先被当成无标号来做，最后再乘上组合数转为有标号。</p><p>从后向前扫 <span class="math inline">\(\{a\}\)</span>，设当前扫到第 <span class="math inline">\(i\)</span> 堆，钦定第 <span class="math inline">\(i\)</span> 堆为黑色且在黑色堆中石子数量最少。此时第 <span class="math inline">\(1\sim (i-1)\)</span> 堆只能是黑色，异或和为 <span class="math inline">\(X=\text{pre}_{i-1}\)</span>。然后分 "所有黑色堆石子数是否相同" 来讨论第 <span class="math inline">\((i + 1) \sim n\)</span> 堆。</p><p>若选出的黑色堆要满足石子数相同，则第 <span class="math inline">\(i\sim (i+\text{same}_i-1)\)</span> 堆为黑色（因为是从后往前扫，所以涵盖了该连续段所有后缀为黑色堆的情况），第 <span class="math inline">\((i+\text{same}_i)\sim n\)</span> 堆为白色。它们的 SG 值可以用上述公式以及后缀异或和快速求。</p><p>若选出的黑色堆不需要满足石子数相同，那么黑色游戏的 SG 为 <span class="math inline">\(Y=a_{i}-\text{same}_i \bmod 2\)</span>。此时需要从后面的堆中选出若干白色堆使得它们的异或和是 <span class="math inline">\(X\oplus Y\)</span>，方案数可以用线性基求出。</p><p>具体地，设线性基 <span class="math inline">\(S\)</span> 的大小为 <span class="math inline">\(|S|\)</span>，此前插入了 <span class="math inline">\(x\)</span> 个数。若 <span class="math inline">\(X\oplus Y\)</span> 能被线性基表示出来，则方案数为 <span class="math inline">\(2^{x-|S|}\)</span>。</p><p>最后，别忘了乘组合数 <span class="math inline">\(\dbinom{\text{tot}_i}{\text{same}_i}\)</span> 再累加到答案中。</p><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 为值域。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % modp) &#123;
		<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % modp;
	&#125;
	<span class="hljs-keyword">return</span> s;
&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
	<span class="hljs-type">int</span> n, tot, all;
	vector&lt;<span class="hljs-type">int</span>&gt; p;
	<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tot</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">all</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">p</span>(_n + <span class="hljs-number">1</span>) &#123;&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		all++;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
			<span class="hljs-keyword">if</span> (!(x &gt;&gt; i)) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-keyword">if</span> (!p[i]) &#123;
				p[i] = x;
				tot++;
				<span class="hljs-keyword">break</span>;
			&#125;
			x ^= p[i];
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
			<span class="hljs-keyword">if</span> ((res ^ p[i]) &gt; res) &#123;
				res ^= p[i];
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
			<span class="hljs-keyword">if</span> (x &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;
				x ^= p[i];
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getways</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">count</span>(x)) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, all - tot);
	&#125;
&#125;;

  
vector&lt;<span class="hljs-type">int</span>&gt; frac, inv;
  
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
  	frac.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
  	inv.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
  
  	frac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
  	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
  		frac[i] = frac[i - <span class="hljs-number">1</span>] * i % modp;
  	&#125;
  	inv[n] = <span class="hljs-built_in">qpow</span>(frac[n], modp - <span class="hljs-number">2</span>);
  	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;
  		inv[i - <span class="hljs-number">1</span>] = inv[i] * i % modp;
  	&#125;
&#125;
  
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;
  	<span class="hljs-keyword">if</span> (n &lt; m || m &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;
  	<span class="hljs-keyword">return</span> frac[n] * inv[m] % modp * inv[n - m] % modp;
&#125;


<span class="hljs-comment">//-------------- templates above --------------</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-comment">// SG = 最小堆的石子数 - (最小堆数量 + [所有堆石子数相同]) % 2</span>
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-built_in">init</span>(n + <span class="hljs-number">1</span>);

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
		mp[a[i]]++;
	&#125; 
	<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">same</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		pre[i] = pre[i - <span class="hljs-number">1</span>] ^ a[i];
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;
		suf[i] = suf[i + <span class="hljs-number">1</span>] ^ a[i];
		same[i] = (a[i] == a[i + <span class="hljs-number">1</span>] ? same[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
	&#125;

	<span class="hljs-function">Node <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">60</span>)</span></span>;
	<span class="hljs-type">int</span> ans = (pre[n] == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;

		<span class="hljs-type">int</span> X = pre[i - <span class="hljs-number">1</span>];
		<span class="hljs-type">int</span> Y = a[i] - (same[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;
		<span class="hljs-type">int</span> Z = suf[i + same[i]];
		<span class="hljs-keyword">if</span> ((X ^ Y ^ Z) == <span class="hljs-number">0</span>) &#123;
			res++;
			res %= modp;
		&#125;

		Y = a[i] - same[i] % <span class="hljs-number">2</span>;
		<span class="hljs-type">int</span> need = X ^ Y;
		res += t.<span class="hljs-built_in">getways</span>(need);

		<span class="hljs-keyword">if</span> ((need ^ Z) == <span class="hljs-number">0</span>) &#123;
			res = (res - <span class="hljs-number">1</span> + modp) % modp;
		&#125;

		<span class="hljs-keyword">if</span> (same[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-number">1</span>) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; same[i]; j++) &#123;
				t.<span class="hljs-built_in">insert</span>(a[i]);
			&#125;
		&#125;

		res *= <span class="hljs-built_in">C</span>(mp[a[i]], same[i]);
		res %= modp;
		ans += res;
		ans %= modp;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="东北四省赛-ccpc-northeast">2024 东北四省赛 / CCPC Northeast</h2>
<h3 id="h.-meet树上差分分类讨论">H. Meet【树上差分，分类讨论】</h3>
<div class="note note-info">
            <p>给定一棵 <span class="math inline">\(n\)</span> 个点的树，以及 <span class="math inline">\(m\)</span> 组点对构成的集合 <span class="math inline">\(S\)</span>。你需要选定一个点作为根节点，使得 <span class="math inline">\(\max_\limits{(x, y)\in S} \max(\text{dis}(x, \text{lca}_{x, y}), \text{dis}(y, \text{lca}_{x, y}))\)</span> 最小，输出这个最小值。</p><p><span class="math inline">\(1 \le n, m \le 10^5\)</span>。</p>
          </div>
<div class="note note-success">
            <p>二分答案，设二分出的答案为 <span class="math inline">\(d\)</span>。</p><p>对于每一组点对 <span class="math inline">\((x, y)\)</span>，可以确定一个点集（一个树上连通块），使得以该点集中的点为根时，答案 <span class="math inline">\(\le d\)</span>。接着只需要用树上差分判断这 <span class="math inline">\(m\)</span> 个点集是否有交即可。</p><p>需要纸上分几种情况讨论，红温了挺久。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optmize(<span class="hljs-string">&quot;Ofast&quot;</span>)</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">RMQ_LCA</span> &#123;
	<span class="hljs-type">int</span> n, tim;
	vector&lt;<span class="hljs-type">int</span>&gt; dfn, lg, twdep;
	vector&lt;<span class="hljs-type">int</span>&gt; dep, st;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj, fa, A, B;
	<span class="hljs-built_in">RMQ_LCA</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;Adj) &#123;
		<span class="hljs-keyword">this</span>-&gt;n = Adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
		adj = Adj;
		<span class="hljs-built_in">init</span>();
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
		dfn.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
		lg.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
		twdep.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);
		dep.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
		st.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
		tim = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;
			lg[i] = lg[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fath, <span class="hljs-type">int</span> d)</span> </span>&#123;
		st[x] = ++tim;
		dfn[tim] = x;
		twdep[tim] = d;

		dep[x] = dep[fath] + <span class="hljs-number">1</span>;
		fa[x][<span class="hljs-number">0</span>] = fath;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lg[dep[x]] + <span class="hljs-number">1</span>; i++) &#123;
			fa[x][i] = fa[fa[x][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];
		&#125;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (!st[y]) &#123;
				<span class="hljs-built_in">dfs</span>(y, x, d + <span class="hljs-number">1</span>);
				dfn[++tim] = x;
				twdep[tim] = d;
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span> </span>&#123;
		fa.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">25</span>));
		<span class="hljs-built_in">dfs</span>(rt, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);

		A.<span class="hljs-built_in">resize</span>(<span class="hljs-number">25</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>));
		B.<span class="hljs-built_in">resize</span>(<span class="hljs-number">25</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>));
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= tim; i++) &#123;
			A[<span class="hljs-number">0</span>][i] = twdep[i];
			B[<span class="hljs-number">0</span>][i] = dfn[i];
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lg[tim]; i++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j + (<span class="hljs-number">1LL</span> &lt;&lt; i) - <span class="hljs-number">1</span> &lt;= tim; j++) &#123;
				<span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>][j] &lt; A[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)]) &#123;
					A[i][j] = A[i - <span class="hljs-number">1</span>][j];
					B[i][j] = B[i - <span class="hljs-number">1</span>][j];
				&#125; <span class="hljs-keyword">else</span> &#123;
					A[i][j] = A[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)];
					B[i][j] = B[i - <span class="hljs-number">1</span>][j + (<span class="hljs-number">1LL</span> &lt;&lt; i - <span class="hljs-number">1</span>)];
				&#125;
			&#125;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-type">int</span> l = <span class="hljs-built_in">min</span>(st[x], st[y]);
		<span class="hljs-type">int</span> r = <span class="hljs-built_in">max</span>(st[x], st[y]);
		<span class="hljs-type">int</span> k = lg[r - l + <span class="hljs-number">1</span>];
		<span class="hljs-keyword">if</span> (A[k][l] &lt; A[k][r + <span class="hljs-number">1</span> - (<span class="hljs-number">1LL</span> &lt;&lt; k)]) &#123;
			<span class="hljs-keyword">return</span> B[k][l];
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">return</span> B[k][r + <span class="hljs-number">1</span> - (<span class="hljs-number">1LL</span> &lt;&lt; k)];
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-keyword">return</span> dep[x] + dep[y] - <span class="hljs-number">2</span> * dep[<span class="hljs-built_in">LCA</span>(x, y)];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> len)</span> </span>&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">24</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
			<span class="hljs-keyword">if</span> (len &gt;&gt; i &amp; <span class="hljs-number">1</span>) &#123;
				x = fa[x][i];
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> x;
	&#125;
&#125;;


<span class="hljs-comment">/*ooooooooooooooooooooo</span>
<span class="hljs-comment">o   templates above   o</span>
<span class="hljs-comment">oooooooooooooooooooooo*/</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		adj[x].<span class="hljs-built_in">push_back</span>(y);
		adj[y].<span class="hljs-built_in">push_back</span>(x);
	&#125;
	<span class="hljs-function">RMQ_LCA <span class="hljs-title">G</span><span class="hljs-params">(adj)</span></span>;
	G.<span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>);
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">people</span>(m);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		people[i] = &#123;x, y&#125;;
	&#125;

	<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> goal) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : people) &#123;
			<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * goal &lt; G.<span class="hljs-built_in">dist</span>(x, y)) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			&#125;
		&#125;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">del</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-type">int</span> A = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : people) &#123;
			<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, y) &lt;= goal) &#123;
				A++;
				<span class="hljs-keyword">continue</span>;
			&#125;

			<span class="hljs-type">int</span> lca = G.<span class="hljs-built_in">LCA</span>(x, y);
			<span class="hljs-type">int</span> tx, ty;
			<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(lca, x) &gt;= goal) &#123;
				tx = G.<span class="hljs-built_in">jump</span>(x, goal);
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-type">int</span> res = goal - G.<span class="hljs-built_in">dist</span>(lca, x);
				tx = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(lca, y) - res);
			&#125;
			<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(lca, y) &gt;= goal) &#123;
				ty = G.<span class="hljs-built_in">jump</span>(y, goal);
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-type">int</span> res = goal - G.<span class="hljs-built_in">dist</span>(lca, y);
				ty = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(lca, x) - res);
			&#125;

			<span class="hljs-type">int</span> <span class="hljs-type">lca_t</span> = G.<span class="hljs-built_in">LCA</span>(tx, ty);
			<span class="hljs-keyword">if</span> (lca == x || lca == y) &#123;
				del[<span class="hljs-type">lca_t</span>]++;
				<span class="hljs-type">int</span> son;
				<span class="hljs-keyword">if</span> (lca == x) &#123;
					son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, <span class="hljs-type">lca_t</span> == tx ? ty : tx) - <span class="hljs-number">1</span>);
				&#125; <span class="hljs-keyword">else</span> &#123;
					son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, <span class="hljs-type">lca_t</span> == tx ? ty : tx) - <span class="hljs-number">1</span>);
				&#125;	
				del[son]--;
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-keyword">if</span> (lca == <span class="hljs-type">lca_t</span>) &#123;
					del[<span class="hljs-number">1</span>]++;
					<span class="hljs-type">int</span> son_x, son_y;
					<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, tx) &lt;= G.<span class="hljs-built_in">dist</span>(x, ty)) &#123;
						son_x = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, tx) - <span class="hljs-number">1</span>);
						son_y = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, ty) - <span class="hljs-number">1</span>);
					&#125; <span class="hljs-keyword">else</span> &#123;
						son_x = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, ty) - <span class="hljs-number">1</span>);
						son_y = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, tx) - <span class="hljs-number">1</span>);
					&#125;
					del[son_x]--;
					del[son_y]--;
				&#125; <span class="hljs-keyword">else</span> &#123;
					<span class="hljs-type">int</span> son;
					<span class="hljs-keyword">if</span> (G.<span class="hljs-built_in">dist</span>(x, tx) &lt;= G.<span class="hljs-built_in">dist</span>(x, lca)) &#123;
						<span class="hljs-keyword">if</span> (G.dep[tx] &lt; G.dep[ty]) &#123;
							del[tx]++;
							son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, ty) - <span class="hljs-number">1</span>);
						&#125; <span class="hljs-keyword">else</span> &#123;
							del[ty]++;
							son = G.<span class="hljs-built_in">jump</span>(x, G.<span class="hljs-built_in">dist</span>(x, tx) - <span class="hljs-number">1</span>);
						&#125;
					&#125; <span class="hljs-keyword">else</span> &#123;
						<span class="hljs-keyword">if</span> (G.dep[tx] &lt; G.dep[ty]) &#123;
							del[tx]++;
							son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, ty) - <span class="hljs-number">1</span>);
						&#125; <span class="hljs-keyword">else</span> &#123;
							del[ty]++;
							son = G.<span class="hljs-built_in">jump</span>(y, G.<span class="hljs-built_in">dist</span>(y, tx) - <span class="hljs-number">1</span>);
						&#125;
					&#125;
					del[son]--;
				&#125;
			&#125;
		&#125;

		<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span> &#123;
			del[x] += del[fa];
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (y == fa) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				<span class="hljs-built_in">self</span>(self, y, x);
			&#125;
		&#125;;
		<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
			<span class="hljs-keyword">if</span> (del[i] == m - A) &#123;
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;;

	<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, ans = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">while</span> (l &lt;= r) &#123;
		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;
			ans = mid;
			r = mid - <span class="hljs-number">1</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			l = mid + <span class="hljs-number">1</span>;
		&#125;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="k.-tasks贪心">K. Tasks【贪心】</h3>
<div class="note note-info">
            <p>有 <span class="math inline">\(n\)</span> 个区间，定义一个区间的烦躁度等于所有包含它的区间的最大烦躁值 <span class="math inline">\(+1\)</span>（如果没有包含它的区间，则烦躁值为 <span class="math inline">\(0\)</span>）。</p><p>现在你知道这 <span class="math inline">\(n\)</span> 个区间的左端点 <span class="math inline">\(l_i\)</span> 和烦躁值 <span class="math inline">\(b_i\)</span>，你需要构造对应的右端点以满足条件，或报告 <span class="math inline">\(-1\)</span>。</p><p>特别规定给出的构造需要满足没有两个完全相同的区间且没有一个右端点 <span class="math inline">\(&gt; 10^6\)</span>。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(1 \le l_i \le 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>把 <span class="math inline">\(b_i\)</span> 相同的区间看作一层，从 <span class="math inline">\(b_i=0\)</span> 开始从低层向高层构造。</p><p>对于同一层，若存在两个区间左端点相同，那么无解；否则必要条件是每个区间都要被一个上一层的区间包含。</p><p>那么有如下贪心的构造：从右向左考虑当前层的左端点，设当前左端点为 <span class="math inline">\(l\)</span>，那肯定是选上一层中左端点 <span class="math inline">\(&lt;l\)</span> 且离 <span class="math inline">\(l\)</span> 最近的区间来被包含。若有多个左端点满足，则选右端点最靠右的，这样能给下一层留够最多的空间。这个过程可以通过 <code>std::lower_bound</code> 简单实现。</p><p>如遇区间完全相同，右端点向左缩一位即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>




<span class="hljs-comment">//-------------- templates above --------------</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">2</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> l, b;
		cin &gt;&gt; l &gt;&gt; b;
		a[b + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(&#123;l, i&#125;);
	&#125;
	a[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	r[<span class="hljs-number">0</span>] = <span class="hljs-number">1e6</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;
		<span class="hljs-built_in">sort</span>(a[i].<span class="hljs-built_in">begin</span>(), a[i].<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j + <span class="hljs-number">1</span> &lt; a[i].<span class="hljs-built_in">size</span>(); j++) &#123;
			<span class="hljs-keyword">if</span> (a[i][j][<span class="hljs-number">0</span>] == a[i][j + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;
				cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
				<span class="hljs-keyword">return</span> ;
			&#125;
		&#125;
		<span class="hljs-type">int</span> R = <span class="hljs-number">1e6</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [l, id] : a[i]) &#123;
			<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>(), array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;&#123;l + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);
			<span class="hljs-keyword">if</span> (it == a[i - <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>()) &#123;
				cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
				<span class="hljs-keyword">return</span> ;
			&#125;
			it = <span class="hljs-built_in">prev</span>(it);
			<span class="hljs-keyword">auto</span> [lstL, lstid] = *it;
			R = <span class="hljs-built_in">min</span>(R, r[lstid]);
			<span class="hljs-keyword">if</span> (l == lstL &amp;&amp; R == r[lstid]) &#123;
				R--;
			&#125;
			<span class="hljs-keyword">if</span> (R &lt; l) &#123;
				cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
				<span class="hljs-keyword">return</span> ;
			&#125;
			r[id] = R;
			R--;
		&#125;
		<span class="hljs-built_in">sort</span>(a[i].<span class="hljs-built_in">begin</span>(), a[i].<span class="hljs-built_in">end</span>());
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cout &lt;&lt; r[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="b.-charging-station最大权闭合子图">B. Charging Station【最大权闭合子图】</h3>
<div class="note note-info">
            <p>有 <span class="math inline">\(3n\)</span> 个能源站，分为三级，每级 <span class="math inline">\(n\)</span> 个，从高级向低级编号为 <span class="math inline">\(1\sim n\)</span>，<span class="math inline">\(n\sim 2n\)</span>，<span class="math inline">\(2n\sim 3n\)</span>。</p><p>每个能源站有三种状态：不工作、供能、吸能。供能有供能功率 <span class="math inline">\(a_i\)</span>，吸能有吸能功率 <span class="math inline">\(b_i\)</span>。</p><p>有 <span class="math inline">\(m\)</span> 个限制关系，每一条形如 “能源站 <span class="math inline">\(x\)</span> 要处于供能状态当且仅当低一级的能源站 <span class="math inline">\(y\)</span> 在吸能状态”。</p><p>问最大总供能功率。</p><p><span class="math inline">\(1\le n, m\le 10^5\)</span>，<span class="math inline">\(1\le a_i,b_i\le 10^9\)</span>。</p>
          </div>
<div class="note note-success">
            <p>假设只有两级，并且低级能源站都处于吸能状态，那么就是经典的最大权闭合子图问题。</p><p>具体地，将供能站视作左部点，吸能站视作右部点。</p><p>源点 <span class="math inline">\(S\)</span> 向左部点连收益大小的边，左部点向右部点连正无穷的边，右部点向汇点 <span class="math inline">\(T\)</span> 连代价大小的边，最大供能功率就是 <strong>左部点权值之和 <span class="math inline">\(-\)</span> 最小割</strong>。</p><p>现在考虑这个三级模型。最高级的能源站只能处在供能或不工作状态，最低级的能源站只能处在供能或吸能状态（不工作还不如供能），中级能源站的状态则取决于上下两级。</p><p>假设这么一个初始状态：中级能源站供能，高级能源站不工作，低级能源站吸能。</p><p>当低级能源站由吸能 <span class="math inline">\(\to\)</span> 供能时，中级能源站只能供能 <span class="math inline">\(\to\)</span> 不工作；当高级能源站由不工作 <span class="math inline">\(\to\)</span> 供能时，中级能源站只能不工作 <span class="math inline">\(\to\)</span> 吸能。</p><p>于是我们把中级能源站拆成两个点，分别为 "供能 <span class="math inline">\(\to\)</span> 不工作" 和 "不工作 <span class="math inline">\(\to\)</span> 吸能"，对应的代价恰好为 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span>。建图如下：</p><p><img src="/image/academic/111.png" alt="id" style="zoom:50%;" /></p><p>其中，<span class="math inline">\(S\)</span> 向低级能源站连 <span class="math inline">\(a_i+b_i\)</span> 的边是因为只考虑从吸能状态转换为供能状态带来的总收益。</p><p>时间复杂度 <span class="math inline">\(O(m\sqrt{n})\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span> &#123;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;
		<span class="hljs-type">int</span> x, cap;
		<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cap) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">cap</span>(cap) &#123;&#125; 
	&#125;;
	<span class="hljs-type">int</span> n;
	vector&lt;Edge&gt; e;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;
	vector&lt;<span class="hljs-type">int</span>&gt; dep, cur;
	<span class="hljs-built_in">Dinic</span>(<span class="hljs-type">int</span> size) &#123;
		<span class="hljs-keyword">this</span>-&gt;n = size;
		adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cap)</span> </span>&#123;
		adj[x].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());
		e.<span class="hljs-built_in">push_back</span>(&#123;y, cap&#125;);
		adj[y].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());
		e.<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>&#125;);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;
		dep.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);
		queue&lt;<span class="hljs-type">int</span>&gt; q;
		q.<span class="hljs-built_in">push</span>(S);
		dep[S] = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : adj[x]) &#123;
				<span class="hljs-keyword">auto</span> [y, cap] = e[i];
				<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == <span class="hljs-number">-1</span>) &#123;
					dep[y] = dep[x] + <span class="hljs-number">1</span>;
					<span class="hljs-keyword">if</span> (y == T) &#123;
						<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
					&#125;
					q.<span class="hljs-built_in">push</span>(y);
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> T, <span class="hljs-type">int</span> limit)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (x == T) &#123;
			<span class="hljs-keyword">return</span> limit;
		&#125;
		<span class="hljs-type">int</span> r = limit;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i = cur[x]; i &lt; adj[x].<span class="hljs-built_in">size</span>(); i++) &#123;
			<span class="hljs-type">const</span> <span class="hljs-type">int</span> j = adj[x][i];
			<span class="hljs-keyword">auto</span> [y, cap] = e[j];
			<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dep[y] == dep[x] + <span class="hljs-number">1</span>) &#123;
				<span class="hljs-type">int</span> t = <span class="hljs-built_in">dfs</span>(y, T, <span class="hljs-built_in">min</span>(r, cap));
				e[j].cap -= t;
				e[j ^ <span class="hljs-number">1</span>].cap += t;
				r -= t;
				<span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;
					<span class="hljs-keyword">return</span> limit;
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> limit - r;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;
		<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(S, T)) &#123;
			cur.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
			flow += <span class="hljs-built_in">dfs</span>(S, T, inf); 
		&#125; 
		<span class="hljs-keyword">return</span> flow;
	&#125;
&#125;;


<span class="hljs-comment">//-------------- templates above --------------</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span> * n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span> * n; i++) &#123;
		cin &gt;&gt; b[i];
	&#125;
	<span class="hljs-comment">// 1 ~ n：一级	3n ~ 4n：三级</span>
	<span class="hljs-comment">// n ~ 2n：二级供能 -&gt; 不工作</span>
	<span class="hljs-comment">// 2n ~ 3n：二级不工作 -&gt; 吸能</span>
	<span class="hljs-type">int</span> S = <span class="hljs-number">4</span> * n + <span class="hljs-number">1</span>;
	<span class="hljs-type">int</span> T = <span class="hljs-number">4</span> * n + <span class="hljs-number">2</span>;
	<span class="hljs-function">Dinic <span class="hljs-title">G</span><span class="hljs-params">(T)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		G.<span class="hljs-built_in">add</span>(S, i, a[i]);
		G.<span class="hljs-built_in">add</span>(S, i + <span class="hljs-number">3</span> * n, a[i + <span class="hljs-number">2</span> * n] + b[i + <span class="hljs-number">2</span> * n]);
		G.<span class="hljs-built_in">add</span>(i + n, T, a[i + n]);
		G.<span class="hljs-built_in">add</span>(i + <span class="hljs-number">2</span> * n, T, b[i + n]);
	&#125;
	<span class="hljs-type">int</span> m;
	cin &gt;&gt; m;
	<span class="hljs-keyword">while</span> (m--) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		<span class="hljs-keyword">if</span> (x &lt;= n) &#123;
			G.<span class="hljs-built_in">add</span>(x, y, inf);
			G.<span class="hljs-built_in">add</span>(x, y + n, inf);
		&#125; <span class="hljs-keyword">else</span> &#123;
			G.<span class="hljs-built_in">add</span>(y + n, x, inf);
		&#125;
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0ll</span>);
	ans -= G.<span class="hljs-built_in">dinic</span>(S, T);
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="g.-diamond根号分治">G. Diamond【根号分治】</h3>
<div class="note note-info">
            <p>给定一个长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span>。有 <span class="math inline">\(m\)</span> 次询问，每次指定 <span class="math inline">\(l, r, p, q\)</span> 四个参数，问若只保留下标在 <span class="math inline">\([l, r]\)</span> 内且值为 <span class="math inline">\(p\)</span> 或者 <span class="math inline">\(q\)</span> 的数，其它数全部删除，此时剩下序列的逆序对数量。询问间相互独立。</p><p><span class="math inline">\(2\le n \le 10^5\)</span>，<span class="math inline">\(1 \le m \le 10^5\)</span>，<span class="math inline">\(1\le a_i \le n\)</span>。</p>
          </div>
<div class="note note-success">
            <p>较为明显的根号分治。把每个数的出现位置存到 <code>std::vector</code> 中，记为 <code>pos</code>。</p><p>若 <span class="math inline">\(p,q\)</span> 的出现次数都 <span class="math inline">\(\le\sqrt{n}\)</span>，直接在 <code>pos</code> 上暴跳计算贡献，<span class="math inline">\(O(\sqrt{n})\)</span>。</p><p>否则 <span class="math inline">\(p, q\)</span> 中至少有一个出现次数 <span class="math inline">\(&gt;\sqrt{n}\)</span>。由于这样的数（设为 <span class="math inline">\(X\)</span>）不超过 <span class="math inline">\(\dfrac{n}{\sqrt{n}}=\sqrt{n}\)</span> 个，我们可以对 <span class="math inline">\(1\sim n\)</span> 的每一个位置 <span class="math inline">\(i\)</span> 处理出 <code>count[i][j]</code> 代表 <span class="math inline">\(1\sim i\)</span> 中值 <span class="math inline">\(j\in X\)</span> 出现了多少次。</p><p>那么对于一个区间 <span class="math inline">\([l, r]\)</span>，不妨设 <span class="math inline">\(p&lt;q\)</span>，答案就是： <span class="math display">\[\left(\sum_{i\in[l,r],a[i]=p}\text{count}[i][q]\right)-\text{occ}[l-1][q]\times\left(\text{occ}[r][p]-\text{occ}[l-1][p]\right)\]</span> 其中 <code>occ[i][j]</code> 代表 <span class="math inline">\(1\sim i\)</span> 中 <span class="math inline">\(j\in[1,n]\)</span> 的出现次数，这里只是为方便说明，实际存不下，可修改为 <code>occ[i]</code> 代表 <span class="math inline">\(1\sim i\)</span> 中 <span class="math inline">\(a[i]\)</span> 的出现次数，然后二分查询。</p><p>至于第一项，可以预处理出 <code>count[i][j]</code> 的前缀和，然后二分出 <span class="math inline">\(j\)</span> 在 <span class="math inline">\([l, r]\)</span> 中第一次出现和最后一次出现的位置 <span class="math inline">\(O(1)\)</span> 回答。</p><p>那如果 <span class="math inline">\(p&gt;q\)</span> 且 <span class="math inline">\(q\)</span> 的出现次数 <span class="math inline">\(\le \sqrt{n}\)</span> 呢？我们没处理出这样的 <code>count[i][q]</code>，但可以把 <span class="math inline">\(p,q\)</span> swap 一下求出顺序对的数量，然后容斥。</p><p>时间复杂度 <span class="math inline">\(O((n+q)\sqrt{n})\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> Block = <span class="hljs-number">320</span>;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pos</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
		cnt[a[i]]++;
		pos[a[i]].<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-type">int</span> tim = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (cnt[i] &gt; Block) &#123;
			id[i] = ++tim;
		&#125;
	&#125;
	<span class="hljs-function">vector <span class="hljs-title">count</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(tim + <span class="hljs-number">1</span>))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		count[i] = count[i - <span class="hljs-number">1</span>];
		<span class="hljs-keyword">if</span> (cnt[a[i]] &gt; Block) &#123;
			count[i][id[a[i]]]++;
		&#125;
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (pos[i].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) &#123;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; pos[i].<span class="hljs-built_in">size</span>(); j++) &#123;
			pre[pos[i][j]] = pos[i][j - <span class="hljs-number">1</span>];
		&#125;
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">occ</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		occ[i] = occ[pre[i]] + <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= tim; j++) &#123;
			count[i][j] += count[pre[i]][j];
		&#125;
	&#125;

	<span class="hljs-keyword">auto</span> calc_1 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q) &#123;
		<span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">lower_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), l);
		<span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">lower_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), l);
		<span class="hljs-keyword">if</span> (it1 == pos[p].<span class="hljs-built_in">end</span>() || it2 == pos[q].<span class="hljs-built_in">end</span>()) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;
		&#125;	
		<span class="hljs-type">int</span> A = it1 - pos[p].<span class="hljs-built_in">begin</span>();
		<span class="hljs-type">int</span> B = it2 - pos[q].<span class="hljs-built_in">begin</span>();
		<span class="hljs-keyword">if</span> (pos[p][A] &gt; r || pos[q][B] &gt; r) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;
		&#125;
		<span class="hljs-type">int</span> big = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
			<span class="hljs-type">int</span> posA = (A &gt;= pos[p].<span class="hljs-built_in">size</span>() ? r + <span class="hljs-number">1</span> : pos[p][A]);
			<span class="hljs-type">int</span> posB = (B &gt;= pos[q].<span class="hljs-built_in">size</span>() ? r + <span class="hljs-number">1</span> : pos[q][B]);
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(posA, posB) &gt; r) &#123;
				<span class="hljs-keyword">break</span>;
			&#125;
			<span class="hljs-keyword">if</span> (posA &lt; posB) &#123;
				res += big;
				A++;
			&#125; <span class="hljs-keyword">else</span> &#123;
				big++;
				B++;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;;

	<span class="hljs-keyword">auto</span> calc_2 = [&amp;] (<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q) &#123;
		<span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">lower_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), l);
		<span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">upper_bound</span>(pos[p].<span class="hljs-built_in">begin</span>(), pos[p].<span class="hljs-built_in">end</span>(), r);
		<span class="hljs-keyword">auto</span> it3 = <span class="hljs-built_in">lower_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), l);
		<span class="hljs-keyword">auto</span> it4 = <span class="hljs-built_in">upper_bound</span>(pos[q].<span class="hljs-built_in">begin</span>(), pos[q].<span class="hljs-built_in">end</span>(), r);
		<span class="hljs-keyword">if</span> (it1 == pos[p].<span class="hljs-built_in">end</span>() || it3 == pos[q].<span class="hljs-built_in">end</span>()) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;
		&#125;
		<span class="hljs-type">int</span> A = it1 - pos[p].<span class="hljs-built_in">begin</span>();
		<span class="hljs-type">int</span> B = it2 - pos[p].<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;
		<span class="hljs-type">int</span> C = it3 - pos[q].<span class="hljs-built_in">begin</span>();
		<span class="hljs-type">int</span> D = it4 - pos[q].<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (pos[p][A] &gt; r || pos[q][C] &gt; r) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;
		&#125;
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> (cnt[q] &gt; Block) &#123;
			res += count[pos[p][B]][id[q]] - (A &gt; <span class="hljs-number">0</span> ? count[pos[p][A - <span class="hljs-number">1</span>]][id[q]] : <span class="hljs-number">0</span>);
			<span class="hljs-keyword">if</span> (C &gt; <span class="hljs-number">0</span>) &#123;
				res -= (occ[pos[p][B]] - (A &gt; <span class="hljs-number">0</span> ? occ[pos[p][A - <span class="hljs-number">1</span>]] : <span class="hljs-number">0</span>)) * occ[pos[q][C - <span class="hljs-number">1</span>]];
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			res += count[pos[q][D]][id[p]] - (C &gt; <span class="hljs-number">0</span> ? count[pos[q][C - <span class="hljs-number">1</span>]][id[p]] : <span class="hljs-number">0</span>);
			<span class="hljs-keyword">if</span> (A &gt; <span class="hljs-number">0</span>) &#123;
				res -= (occ[pos[q][D]] - (C &gt; <span class="hljs-number">0</span> ? occ[pos[q][C - <span class="hljs-number">1</span>]] : <span class="hljs-number">0</span>)) * occ[pos[p][A - <span class="hljs-number">1</span>]];
			&#125;
			<span class="hljs-type">int</span> all = B - A + <span class="hljs-number">1</span> + D - C + <span class="hljs-number">1</span>;
			all = all * (all - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
			all -= (B - A + <span class="hljs-number">1</span>) * (B - A) / <span class="hljs-number">2</span>;
			all -= (D - C + <span class="hljs-number">1</span>) * (D - C) / <span class="hljs-number">2</span>;
			res = all - res;
		&#125;

		<span class="hljs-keyword">return</span> res;
	&#125;;

	<span class="hljs-keyword">while</span> (m--) &#123;
		<span class="hljs-type">int</span> l, r, p, q;
		cin &gt;&gt; l &gt;&gt; r &gt;&gt; p &gt;&gt; q;
		<span class="hljs-keyword">if</span> (cnt[p] &lt;= Block &amp;&amp; cnt[q] &lt;= Block) &#123;
			cout &lt;&lt; <span class="hljs-built_in">calc_1</span>(l, r, p, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			cout &lt;&lt; <span class="hljs-built_in">calc_2</span>(l, r, p, q) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
		&#125;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="nanjing-regional-ucup-2-11">2023 Nanjing Regional / Ucup 2-11</h2>
<h3 id="m.-trapping-rain-water吉司机线段树">M. Trapping Rain Water【吉司机线段树】</h3>
<div class="note note-info">
            <p>给定长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span>，有 <span class="math inline">\(q\)</span> 次修改，每次将 <span class="math inline">\(a_{x_i}\)</span> 加上 <span class="math inline">\(v_i\)</span>。令 <span class="math inline">\(f_i=\max(a_1,a_2,\cdots,a_i)\)</span>，<span class="math inline">\(g_i=\max(a_i,a_{i + 1},\cdots,a_n)\)</span>，你需要在每次修改后回答： <span class="math display">\[\sum_{i=1}^{n}(\min(f_i,g_i)-a_i)\]</span> <span class="math inline">\(1\le n, q \le 10^6\)</span>，<span class="math inline">\(1\le a_i \le 10^6\)</span>，<span class="math inline">\(1\le v_i \le 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>这题最关键的观察是 <span class="math inline">\(\max(f_i,g_i)=\max a_i\)</span>，即 <span class="math inline">\(\min(f_i,g_i)=f_i+g_i-\max a_i\)</span>。</p><p>于是式子化为 <span class="math inline">\(\sum f_i+\sum g_i -n\cdot\max a_i-\sum a_i\)</span>.</p><p>后两项在修改时很容易维护，主要考虑前两项，这里以 <span class="math inline">\(\sum f_i\)</span> 为例。</p><p>根据 <span class="math inline">\(f_i\)</span> 的定义，设当前将 <span class="math inline">\(a_i\)</span> 增加至 <span class="math inline">\(x\)</span>，则相当于给 <span class="math inline">\(f_{i\sim n}\)</span> 中的每一项与 <span class="math inline">\(x\)</span> 取 <span class="math inline">\(\max\)</span>。</p><p>吉司机线段树处理即可。</p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;
	vector&lt;<span class="hljs-type">int</span>&gt; sum, mx, mn;
	vector&lt;<span class="hljs-type">int</span>&gt; tc, ta, L, R;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> N 4 * n + 5</span>
	<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">sum</span>(N), <span class="hljs-built_in">mx</span>(N), <span class="hljs-built_in">mn</span>(N), <span class="hljs-built_in">tc</span>(N), <span class="hljs-built_in">ta</span>(N), <span class="hljs-built_in">L</span>(N), <span class="hljs-built_in">R</span>(N) &#123;&#125; 

	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (L[p] + R[p] &gt;&gt; 1)</span>

	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		sum[p] = sum[ls] + sum[rs];
		mx[p] = <span class="hljs-built_in">max</span>(mx[ls], mx[rs]);
		mn[p] = <span class="hljs-built_in">min</span>(mn[ls], mn[rs]);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cover</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> w)</span> </span>&#123;
		sum[p] = (R[p] - L[p] + <span class="hljs-number">1</span>) * w;
		mx[p] = mn[p] = tc[p] = w;
		ta[p] = <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> w)</span> </span>&#123;
		sum[p] += (R[p] - L[p] + <span class="hljs-number">1</span>) * w;
		mx[p] += w;
		mn[p] += w;
		ta[p] += w;
	&#125; 
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (tc[p] != inf) &#123;
			<span class="hljs-built_in">Cover</span>(ls, tc[p]);
			<span class="hljs-built_in">Cover</span>(rs, tc[p]);
			tc[p] = inf;
		&#125;
		<span class="hljs-keyword">if</span> (ta[p]) &#123;
			<span class="hljs-built_in">Add</span>(ls, ta[p]);
			<span class="hljs-built_in">Add</span>(rs, ta[p]);			
			ta[p] = <span class="hljs-number">0</span>;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;
		L[p] = l;
		R[p] = r;
		tc[p] = inf;
		<span class="hljs-keyword">if</span> (l == r) &#123;
			sum[p] = mx[p] = mn[p] = a[l];
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-built_in">build</span>(ls, l, mid, a);
		<span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r, a);
		<span class="hljs-built_in">pushup</span>(p);
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (l &lt;= L[p] &amp;&amp; r &gt;= R[p]) &#123;
			<span class="hljs-keyword">return</span> sum[p];
		&#125;
		<span class="hljs-built_in">pushdown</span>(p);	
		<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> (l &lt;= mid) &#123;
			res += <span class="hljs-built_in">get_sum</span>(ls, l, r);
		&#125;
		<span class="hljs-keyword">if</span> (r &gt; mid) &#123;
			res += <span class="hljs-built_in">get_sum</span>(rs, l, r);
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_max</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> w)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (mn[p] &gt;= w) &#123;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-keyword">if</span> (l &lt;= L[p] &amp;&amp; r &gt;= R[p] &amp;&amp; mx[p] &lt;= w) &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">Cover</span>(p, w);
		&#125;
		<span class="hljs-built_in">pushdown</span>(p);
		<span class="hljs-keyword">if</span> (l &lt;= mid) &#123;
			<span class="hljs-built_in">modify_max</span>(ls, l, r, w);
		&#125;
		<span class="hljs-keyword">if</span> (r &gt; mid) &#123;
			<span class="hljs-built_in">modify_max</span>(rs, l, r, w);
		&#125;
		<span class="hljs-built_in">pushup</span>(p);
	&#125;
&#125;;


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-type">int</span> q;
	cin &gt;&gt; q;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">qry</span>(q);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;
		<span class="hljs-type">int</span> pos, x;
		cin &gt;&gt; pos &gt;&gt; x;
		qry[i] = &#123;pos, x&#125;;
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">g</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		f[i] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>], a[i]);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;
		g[i] = <span class="hljs-built_in">max</span>(g[i + <span class="hljs-number">1</span>], a[i]);
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ansf</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ansg</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ans_mx</span><span class="hljs-params">(q)</span>, <span class="hljs-title">ans_sum</span><span class="hljs-params">(q)</span></span>;

	<span class="hljs-type">int</span> Sum = <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);
	<span class="hljs-type">int</span> Mx = *<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());

	vector b = a;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;
		<span class="hljs-keyword">auto</span> [pos, x] = qry[i];
		a[pos] += x;

		Sum += x;
		ans_sum[i] = Sum;
		Mx = <span class="hljs-built_in">max</span>(Mx, a[pos]);
		ans_mx[i] = Mx;
	&#125;

	a = b;
	<span class="hljs-function">Node <span class="hljs-title">t</span><span class="hljs-params">(n)</span></span>;
	t.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, f);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;
		<span class="hljs-keyword">auto</span> [pos, x] = qry[i];
		a[pos] += x;
		t.<span class="hljs-built_in">modify_max</span>(<span class="hljs-number">1</span>, pos, n, a[pos]);
		ansf[i] = t.<span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
	&#125;

	a = b;
	t = <span class="hljs-built_in">Node</span>(n);
	t.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, g);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;
		<span class="hljs-keyword">auto</span> [pos, x] = qry[i];
		a[pos] += x;
		t.<span class="hljs-built_in">modify_max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, pos, a[pos]);
		ansg[i] = t.<span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
	&#125;

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;
		<span class="hljs-type">int</span> res = ansf[i] + ansg[i] - n * ans_mx[i] - ans_sum[i];
		cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="d.-red-black-treedp凸序列">D. Red Black Tree【dp，凸序列】</h3>
<p>现存网上的任何一篇题解都看得不是很明白，占坑。</p>
<hr />
<h3 id="e.-extending-distance网络流对偶图">E. Extending Distance【网络流，对偶图】</h3>
<div class="note note-info">
            <p>有一个 <span class="math inline">\(n\)</span> 行 <span class="math inline">\(m\)</span> 列的网格图，相邻格点之间有边，边有边权。</p><p>你可以进行任意次操作，每次操作可以使某条边的边权增加 <span class="math inline">\(1\)</span>。</p><p>求一种操作次数最少的方案使得从第一列任意一个点出发到最后一列任意一个点的最短路恰好增加 <span class="math inline">\(K\)</span>，输出方案。</p><p><span class="math inline">\(1 \le n\cdot m \le 5000\)</span>，<span class="math inline">\(1 \le K\le 100\)</span>。</p>
          </div>
<div class="note note-success">
            <p>网格图是一种特殊的平面图。所谓平面图，是指能画在平面上，满足任何两条边没有交叉。</p><p>将平面图 <span class="math inline">\(G\)</span> 的每个面看作一个点，<span class="math inline">\(G\)</span> 中每条边两侧的两个面（可以是同一个面）进行连边，就得到了一个对偶图。</p><p>一个经典的题目是 “P4001 狼抓兔子”，它展示了一种<strong>平面图最小割</strong>转<strong>对偶图最短路</strong>的思想，不再赘述。</p><p>同样地，对本题中的网格图进行对偶，那么<strong>原图的最短路</strong>等价于<strong>对偶图的最小割</strong>。</p><p>建图，将原图中的边费用设为 <span class="math inline">\(0\)</span>，流量设为边权；再对每条边建费用为 <span class="math inline">\(1\)</span>，流量为 <span class="math inline">\(+\infty\)</span> 的额外边。</p><p>此时题目等价于找一条流量为 <span class="math inline">\(D+K\)</span> 的费用最小的流，其中 <span class="math inline">\(D\)</span> 为原图的最短路。</p><p>分两步处理：</p><ul><li>先只连费用为 <span class="math inline">\(0\)</span> 的边，不连额外边。跑从源点 <span class="math inline">\(S\)</span> 流向汇点 <span class="math inline">\(T\)</span> 的最大流。</li><li>对每条边连额外边，再连一条从 super 源点 <span class="math inline">\(P\)</span> 向源点 <span class="math inline">\(S\)</span> 费用为 <span class="math inline">\(0\)</span> 流量为 <span class="math inline">\(K\)</span> 的边。跑从 super 源点 <span class="math inline">\(P\)</span> 流向汇点 <span class="math inline">\(T\)</span> 的最大流。此时跑出来的费用即为最小操作次数。</li></ul><p>至于方案，可以遍历残量网络上费用为 <span class="math inline">\(1\)</span> 的边，检查剩余流量。这条边的操作次数就是原始流量和剩余流量的差。</p><p>时间复杂度 <span class="math inline">\(O(n^2m^2k)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dinic</span> &#123;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;
		<span class="hljs-type">int</span> x, cap, cost, all;
		<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> cost) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">cap</span>(cap), <span class="hljs-built_in">cost</span>(cost), <span class="hljs-built_in">all</span>(cap) &#123;&#125;
	&#125;;
	<span class="hljs-type">int</span> n;
	vector&lt;Edge&gt; e;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;
	vector&lt;<span class="hljs-type">int</span>&gt; dis, pre, vis;
	vector&lt;<span class="hljs-type">int</span>&gt; h;
	<span class="hljs-built_in">Dinic</span>(<span class="hljs-type">int</span> size) &#123;
		<span class="hljs-keyword">this</span>-&gt;n = size;
		adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> f)</span> </span>&#123;
		adj[x].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());
		e.<span class="hljs-built_in">push_back</span>(&#123;y, w, f&#125;);
		adj[y].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>());
		e.<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>, -f&#125;);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;
		dis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, inf);
		vis.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);
		pre.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);
		<span class="hljs-meta">#<span class="hljs-keyword">define</span> Pair pair<span class="hljs-string">&lt;int, int&gt;</span></span>
		priority_queue&lt;Pair, vector&lt;Pair&gt;, greater&lt;Pair&gt;&gt; q;
		dis[S] = <span class="hljs-number">0</span>;
		q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);
		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>().second;
			q.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">if</span> (vis[x]) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			vis[x] = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : adj[x]) &#123;
				<span class="hljs-keyword">auto</span> [y, cap, cost, _] = e[i];
				<span class="hljs-keyword">if</span> (cap &gt; <span class="hljs-number">0</span> &amp;&amp; dis[y] &gt; dis[x] + h[x] - h[y] + cost) &#123;
					dis[y] = dis[x] + h[x] - h[y] + cost;
					pre[y] = i;
					q.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> (dis[T] != inf);
	&#125;
	<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T)</span> </span>&#123;
		<span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>, cost = <span class="hljs-number">0</span>;
		h.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
		<span class="hljs-keyword">while</span> (<span class="hljs-built_in">dijkstra</span>(S, T)) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
				h[i] += dis[i];
			&#125;
			<span class="hljs-type">int</span> res = inf;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>].x) &#123;
				res = <span class="hljs-built_in">min</span>(res, e[pre[i]].cap);
			&#125;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>].x) &#123;
				e[pre[i]].cap -= res;
				e[pre[i] ^ <span class="hljs-number">1</span>].cap += res;
			&#125;
			flow += res;
			cost += res * h[T];

		&#125;
		<span class="hljs-keyword">return</span> &#123;flow, cost&#125;;
	&#125;
&#125;;


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, k;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

	<span class="hljs-type">int</span> S = (n - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;
	<span class="hljs-type">int</span> T = S + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">auto</span> id = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;
		<span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;
			<span class="hljs-keyword">return</span> S;
		&#125; 
		<span class="hljs-keyword">if</span> (x == n) &#123;
			<span class="hljs-keyword">return</span> T;
		&#125;
		<span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + y;
	&#125;;

	<span class="hljs-function">vector <span class="hljs-title">A</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(m))</span></span>;
	<span class="hljs-function">vector <span class="hljs-title">B</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>))</span></span>;
	<span class="hljs-function">Dinic <span class="hljs-title">G</span><span class="hljs-params">(T)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;
			<span class="hljs-type">int</span> w;
			cin &gt;&gt; w;
			A[i][j] = w;
			<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);
			<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);
			G.<span class="hljs-built_in">add</span>(x, y, w, <span class="hljs-number">0</span>);
			G.<span class="hljs-built_in">add</span>(y, x, w, <span class="hljs-number">0</span>);
		&#125;
	&#125;	
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
			<span class="hljs-type">int</span> w;
			cin &gt;&gt; w;
			B[i][j] = w;
			<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);
			<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);
			G.<span class="hljs-built_in">add</span>(x, y, w, <span class="hljs-number">0</span>);
			G.<span class="hljs-built_in">add</span>(y, x, w, <span class="hljs-number">0</span>);
		&#125;
	&#125;
	<span class="hljs-keyword">auto</span> res1 = G.<span class="hljs-built_in">dinic</span>(S, T);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;
			<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);
			<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);
			G.<span class="hljs-built_in">add</span>(x, y, inf, <span class="hljs-number">1</span>);
			G.<span class="hljs-built_in">add</span>(y, x, inf, <span class="hljs-number">1</span>);
		&#125;
	&#125;	
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
			<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);
			<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);
			G.<span class="hljs-built_in">add</span>(x, y, inf, <span class="hljs-number">1</span>);
			G.<span class="hljs-built_in">add</span>(y, x, inf, <span class="hljs-number">1</span>);
		&#125;
	&#125;
	G.<span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, S, k, <span class="hljs-number">0</span>);
	<span class="hljs-keyword">auto</span> res2 = G.<span class="hljs-built_in">dinic</span>(<span class="hljs-number">0</span>, T);
	cout &lt;&lt; res2[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;

	<span class="hljs-function">vector <span class="hljs-title">flow</span><span class="hljs-params">(T + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-type">int</span>&gt;(T + <span class="hljs-number">1</span>))</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt;= T; x++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> id : G.adj[x]) &#123;
			<span class="hljs-keyword">auto</span> [y, cap, cost, all] = G.e[id];
			cap = all - cap;
			<span class="hljs-keyword">if</span> (cost == <span class="hljs-number">1</span> &amp;&amp; cap) &#123;
				flow[x][y] += cap;
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;
			<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);
			<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);
			A[i][j] += flow[x][y] + flow[y][x];
			cout &lt;&lt; A[i][j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m - <span class="hljs-number">1</span>];
		&#125;
	&#125;	
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
			<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);
				<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);
				B[i][j] += flow[x][y] + flow[y][x];
			&#125;
			cout &lt;&lt; B[i][j] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == m];
		&#125;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class="note note-warning">
            <p>一种较为简洁的网格图转对偶图建图方法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> id = [&amp;] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;
	<span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> S;
	&#125; 
	<span class="hljs-keyword">if</span> (x == n) &#123;
		<span class="hljs-keyword">return</span> T;
	&#125;
	<span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) * (m - <span class="hljs-number">1</span>) + y;
&#125;;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123;
		<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i - <span class="hljs-number">1</span>, j);
		<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);
        <span class="hljs-comment">// x -&gt; y</span>
	&#125;
&#125;	
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;
		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == m) &#123;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-type">int</span> x = <span class="hljs-built_in">id</span>(i, j - <span class="hljs-number">1</span>);
		<span class="hljs-type">int</span> y = <span class="hljs-built_in">id</span>(i, j);
        <span class="hljs-comment">// x -&gt; y</span>
	&#125;
&#125;</code></pre></div>
          </div>
<h2 id="ukiepc-2023">UKIEPC 2023</h2>
<h3 id="g.-glacier-travel计算几何">G. Glacier Travel【计算几何】</h3>
<div class="note note-info">
            <p>给定平面上 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((x_i,y_i)\)</span>，按顺序依次连成折线段。两个人一前一后沿着折线移动，它们的路程差固定为 <span class="math inline">\(s\)</span>，问移动过程中两人的最短距离。</p><p><span class="math inline">\(2\le n\le 10^6\)</span>，<span class="math inline">\(-10^6\le x_i,y_i\le 10^6\)</span>，<span class="math inline">\(1\le s \le 1000\)</span>。</p>
          </div>
<div class="note note-success">
            <p>可以从折线段的起点开始维护一对双指针，每次从状态 <span class="math inline">\(\{(x_A,y_A),(x_B,y_B)\}\)</span> 转移到状态 <span class="math inline">\(\{(x_A&#39;,y_A&#39;),(x_B&#39;,y_B&#39;)\}\)</span> 当且仅当 <span class="math inline">\((x_A&#39;,y_A&#39;)\)</span> 或 <span class="math inline">\((x_B&#39;,y_B&#39;)\)</span> 为某条线段的一个端点。</p><p>至于计算距离，有一个能使码量简单许多的转化：相对速度。</p><p>首先，两个人在同一条线段上移动肯定不优。否则假定 <span class="math inline">\(A\)</span> 不动，根据速度的合成法则，此时 <span class="math inline">\(B\)</span> 的运动轨迹是一条线段，于是可以三分或直接运用点到线段的距离公式计算。</p><p>具体地，答案是点 <span class="math inline">\((0,0)\)</span> 到线段 <span class="math inline">\((x_B-x_A,y_B-y_A)\sim(x_B&#39;-x_A&#39;,y_B&#39;-y_A&#39;)\)</span> 的距离。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;
    T x, y;
    <span class="hljs-built_in">Point</span>(T x_ = <span class="hljs-number">0</span>, T y_ = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x_), <span class="hljs-built_in">y</span>(y_) &#123;&#125;
    
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;
    <span class="hljs-keyword">operator</span> <span class="hljs-built_in">Point</span>&lt;U&gt;() &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>&lt;U&gt;(<span class="hljs-built_in">U</span>(x), <span class="hljs-built_in">U</span>(y));
    &#125;
    Point &amp;<span class="hljs-keyword">operator</span>+=(Point p) &amp; &#123;
        x += p.x;
        y += p.y;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point &amp;<span class="hljs-keyword">operator</span>-=(Point p) &amp; &#123;
        x -= p.x;
        y -= p.y;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point &amp;<span class="hljs-keyword">operator</span>*=(T v) &amp; &#123;
        x *= v;
        y *= v;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;
    Point <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(-x, -y);
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>+(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a += b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>-(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a -= b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(Point a, T b) &#123;
        <span class="hljs-keyword">return</span> a *= b;
    &#125;
    <span class="hljs-keyword">friend</span> Point <span class="hljs-keyword">operator</span>*(T a, Point b) &#123;
        <span class="hljs-keyword">return</span> b *= a;
    &#125;
    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Point a, Point b) &#123;
        <span class="hljs-keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;
    &#125;
    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, Point &amp;p) &#123;
        <span class="hljs-keyword">return</span> is &gt;&gt; p.x &gt;&gt; p.y;
    &#125;
    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, Point p) &#123;
        <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;
    &#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function">T <span class="hljs-title">dot</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;
    <span class="hljs-keyword">return</span> a.x * b.x + a.y * b.y;
&#125;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function">T <span class="hljs-title">cross</span><span class="hljs-params">(Point&lt;T&gt; a, Point&lt;T&gt; b)</span> </span>&#123;
    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;
&#125;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dist</span><span class="hljs-params">(Point&lt;T&gt; p1, Point&lt;T&gt; p2)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrtl</span>(<span class="hljs-number">1.0</span> * (p1.x - p2.x) * (p1.x - p2.x) + <span class="hljs-number">1.0</span> * (p1.y - p2.y) * (p1.y - p2.y));
&#125;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;
    Point&lt;T&gt; a, b;
    <span class="hljs-built_in">Line</span>(Point&lt;T&gt; a_ = <span class="hljs-built_in">Point</span>&lt;T&gt;(), Point&lt;T&gt; b_ = <span class="hljs-built_in">Point</span>&lt;T&gt;()) : <span class="hljs-built_in">a</span>(a_), <span class="hljs-built_in">b</span>(b_) &#123;&#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distToLine</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">cross</span>(p - l.a, l.b - l.a)) / <span class="hljs-built_in">dist</span>(l.a, l.b);
&#125;

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; </span>
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distToSegment</span><span class="hljs-params">(Point&lt;T&gt; p, Line&lt;T&gt; l)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (l.a == l.b) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.a, p);
    &#125;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(p - l.a, l.b - l.a) &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.a, p);
    &#125;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(p - l.b, l.b - l.a) &gt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(l.b, p);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">distToLine</span>(p, l);
&#125;



<span class="hljs-keyword">using</span> P = Point&lt;<span class="hljs-type">double</span>&gt;;
<span class="hljs-keyword">using</span> L = Line&lt;<span class="hljs-type">double</span>&gt;;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-type">double</span> s;
    cin &gt;&gt; s;
    <span class="hljs-type">int</span> n;
    cin &gt;&gt; n;
    <span class="hljs-function">vector&lt;P&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    P X = a[<span class="hljs-number">0</span>], Y = a[<span class="hljs-number">0</span>];
    <span class="hljs-type">int</span> ptr_x = <span class="hljs-number">1</span>, ptr_y = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (s &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-type">double</span> d = <span class="hljs-built_in">dist</span>(a[ptr_y], Y);
        <span class="hljs-keyword">if</span> (d &lt; s) &#123;
            s -= d;
            Y = a[ptr_y++];
        &#125; <span class="hljs-keyword">else</span> &#123;
            Y += (a[ptr_y] - Y) * s * (<span class="hljs-number">1.0</span> / <span class="hljs-built_in">dist</span>(a[ptr_y], Y));
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;

    <span class="hljs-type">double</span> ans = <span class="hljs-built_in">dist</span>(X, Y);
    <span class="hljs-keyword">while</span> (ptr_y &lt; n) &#123;
        <span class="hljs-type">double</span> d1 = <span class="hljs-built_in">dist</span>(a[ptr_x], X);
        <span class="hljs-type">double</span> d2 = <span class="hljs-built_in">dist</span>(a[ptr_y], Y);
        P nxt_X, nxt_Y;
        <span class="hljs-keyword">if</span> (d1 &lt; d2) &#123;
            nxt_X = a[ptr_x++];
            nxt_Y = Y + (a[ptr_y] - Y) * d1 * (<span class="hljs-number">1.0</span> / d2);
            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">distToSegment</span>(P&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, L&#123;Y - X, nxt_Y - nxt_X&#125;));
        &#125; <span class="hljs-keyword">else</span> &#123;
            nxt_X = X + (a[ptr_x] - X) * d2 * (<span class="hljs-number">1.0</span> / d1);
            nxt_Y = a[ptr_y++];
            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">distToSegment</span>(P&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, L&#123;Y - X, nxt_Y - nxt_X&#125;));
        &#125;
        X = nxt_X;
        Y = nxt_Y;
    &#125;   
    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">7</span>) &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (T--) &#123;
        <span class="hljs-built_in">solve</span>();
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="h.-history-in-numbers线段树">H. History in Numbers【线段树】</h3>
<div class="note note-info">
            <p>维护长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a\}\)</span>，并有 <span class="math inline">\(m\)</span> 次操作，每次可能是以下两种之一。</p><p><code>update l r d</code>：<span class="math inline">\(\forall i\in [l, r]\)</span>，<span class="math inline">\(a_i := a_i+d\)</span>。</p><p><code>check l r</code>：查询区间 <span class="math inline">\([l, r]\)</span> 的局部最小值序列是否严格递增。</p><p>区间 <span class="math inline">\([l,r]\)</span> 的局部最小值序列：将 <span class="math inline">\([l, r]\)</span> 中相邻且相同的元素只保留一个后，数值上小于两侧元素的数构成的集合。</p><p><span class="math inline">\(1 \le n,m \le 3\cdot 10^5\)</span>，<span class="math inline">\(-10^8\le a_i,d\le 10^8\)</span>。</p>
          </div>
<div class="note note-success">
            <p>线段树板题，就是维护起来细节比较多。</p><p>线段树维护七个值：</p><ul><li><code>l1</code>：区间左起第一个数。</li><li><code>l2</code>：区间左起和 <code>l1</code> 不同的第二个数。</li><li><code>r1</code>：区间右起第一个数。</li><li><code>r2</code>：区间右起和 <code>r1</code> 不同的第二个数。</li><li><code>f1</code>：区间左起第一个局部最小值的值。</li><li><code>f2</code>：区间右起第一个局部最小值的值。</li><li><code>ok</code>：该区间的局部最小值序列是否递增。</li></ul><p>然后就是分类讨论了，代码里我分区间去重后只有一个值，只有两个值，超过两个值讨论了一下。</p><p>注意区间左右两侧的边界情况需要特判。</p><p>时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazySegmentTree</span> &#123;
    <span class="hljs-type">int</span> n;
    vector&lt;Info&gt; tr;
    vector&lt;Tag&gt; tag;
    <span class="hljs-built_in">LazySegmentTree</span>(vector&lt;Info&gt; &amp;a) &#123;
        n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = (<span class="hljs-number">4</span> &lt;&lt; __lg(n + <span class="hljs-number">1</span>)) + <span class="hljs-number">5</span>;
        tr.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Info</span>());
        tag.<span class="hljs-built_in">assign</span>(N, <span class="hljs-built_in">Tag</span>());
        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a);
    &#125;
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls (p &lt;&lt; 1)</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;Info&gt; &amp;a)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (l == r) &#123;
            tr[p] = a[l];
            <span class="hljs-keyword">return</span> ;
        &#125;
        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">build</span>(ls, l, m, a);
        <span class="hljs-built_in">build</span>(rs, m + <span class="hljs-number">1</span>, r, a);
        <span class="hljs-built_in">pushup</span>(p);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
        tr[p] = tr[ls] + tr[rs];
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;
        tr[p].<span class="hljs-built_in">apply</span>(x);
        tag[p].<span class="hljs-built_in">apply</span>(x);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
        <span class="hljs-built_in">apply</span>(ls, tag[p]);
        <span class="hljs-built_in">apply</span>(rs, tag[p]);
        tag[p] = <span class="hljs-built_in">Tag</span>();
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (l == r) &#123;
            tr[p] = x;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">pushdown</span>(p);
        <span class="hljs-keyword">if</span> (pos &lt;= m) &#123;
            <span class="hljs-built_in">modify</span>(ls, l, m, pos, x);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, pos, x);
        &#125;
        <span class="hljs-built_in">pushup</span>(p);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">const</span> Info &amp;x)</span> </span>&#123;
        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, x);
    &#125;
    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;
            <span class="hljs-keyword">return</span> tr[p];
        &#125;
        <span class="hljs-built_in">pushdown</span>(p);
        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (qr &lt;= m) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ql &gt;= m + <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls, l, m, ql, qr) + <span class="hljs-built_in">query</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr);
        &#125;
    &#125;
    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;
            <span class="hljs-keyword">return</span> ;
        &#125;
        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;
            <span class="hljs-built_in">apply</span>(p, x);
            <span class="hljs-keyword">return</span> ;
        &#125;
        <span class="hljs-built_in">pushdown</span>(p);
        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">modify</span>(ls, l, m, ql, qr, x);
        <span class="hljs-built_in">modify</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, x);
        <span class="hljs-built_in">pushup</span>(p);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, <span class="hljs-type">const</span> Tag &amp;x)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, x);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span>
<span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-keyword">if</span> (l == r) &#123;
            <span class="hljs-keyword">return</span> l;
        &#125;
        <span class="hljs-built_in">pushdown</span>(p);
        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findFirst</span>(ls, l, m, ql, qr, pred);
        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;
            res = <span class="hljs-built_in">findFirst</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span>
<span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFirst</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span>
<span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (l &gt; qr || r &lt; ql) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r &amp;&amp; !<span class="hljs-built_in">pred</span>(tr[p])) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-keyword">if</span> (l == r) &#123;
            <span class="hljs-keyword">return</span> l;
        &#125;
        <span class="hljs-built_in">pushdown</span>(p);
        <span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> res = <span class="hljs-built_in">findLast</span>(rs, m + <span class="hljs-number">1</span>, r, ql, qr, pred);
        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;
            res = <span class="hljs-built_in">findLast</span>(ls, l, m, ql, qr, pred);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F&gt;</span>
<span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr, F &amp;&amp;pred)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findLast</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr, pred);
    &#125;
&#125;;
 
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tag</span> &#123;
    <span class="hljs-type">int</span> add = <span class="hljs-number">0</span>;

    <span class="hljs-built_in">Tag</span>() &#123;&#125;
    <span class="hljs-built_in">Tag</span>(<span class="hljs-type">int</span> A) &#123;
        add = A;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;
        add += t.add;
    &#125;
&#125;;
 
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;
    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> l1 = inf;
    <span class="hljs-type">int</span> l2 = inf;
    <span class="hljs-type">int</span> r1 = inf;
    <span class="hljs-type">int</span> r2 = inf;
    <span class="hljs-type">int</span> f1 = inf;
    <span class="hljs-type">int</span> f2 = inf;
	<span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;

    <span class="hljs-built_in">Info</span>() &#123;&#125;
    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B) &#123;
        l1 = r1 = A;
        l = r = B;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-type">const</span> Tag &amp;t)</span> &amp; </span>&#123;
        l1 += t.add;
        r1 += t.add;
        <span class="hljs-keyword">if</span> (l2 != inf) &#123;
            l2 += t.add;
        &#125;
        <span class="hljs-keyword">if</span> (r2 != inf) &#123;
            r2 += t.add;
        &#125;
        <span class="hljs-keyword">if</span> (f1 != inf) &#123;
            f1 += t.add;
        &#125;
        <span class="hljs-keyword">if</span> (f2 != inf) &#123;
            f2 += t.add;
        &#125;
    &#125;
&#125;;

pair&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;, <span class="hljs-type">bool</span>&gt; <span class="hljs-built_in">check</span>(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> b1, <span class="hljs-type">int</span> b2) &#123;
    <span class="hljs-keyword">if</span> (d == inf) &#123;
        <span class="hljs-keyword">if</span> (a1 == inf) &#123;
            <span class="hljs-keyword">return</span> &#123;&#123;b1, b2&#125;, <span class="hljs-literal">true</span>&#125;;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b1 == inf) &#123;
            <span class="hljs-keyword">return</span> &#123;&#123;a1, a2&#125;, <span class="hljs-literal">true</span>&#125;;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> &#123;&#123;a1, b2&#125;, a2 &lt; b1&#125;;
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">if</span> (a1 == inf &amp;&amp; b1 == inf) &#123;
            <span class="hljs-keyword">return</span> &#123;&#123;d, d&#125;, <span class="hljs-literal">true</span>&#125;;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a1 == inf) &#123;
            <span class="hljs-keyword">return</span> &#123;&#123;d, b2&#125;, d &lt; b1&#125;;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b1 == inf) &#123;
            <span class="hljs-keyword">return</span> &#123;&#123;a1, d&#125;, a2 &lt; d&#125;;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> &#123;&#123;a1, b2&#125;, a2 &lt; d &amp;&amp; d &lt; b1&#125;;
        &#125;
    &#125;
&#125;

Info <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Info &amp;a, <span class="hljs-type">const</span> Info &amp;b) &#123;
    Info c;
    <span class="hljs-keyword">if</span> (a.l2 == inf &amp;&amp; b.l2 == inf) &#123;
        <span class="hljs-keyword">if</span> (a.l1 == b.l1) &#123;
            c = a;
        &#125; <span class="hljs-keyword">else</span> &#123;
            c.l1 = a.l1;
            c.l2 = b.l1;
            c.r1 = b.r1;
            c.r2 = a.r1;
        &#125;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.l2 == inf) &#123;
        c = b;
        <span class="hljs-keyword">if</span> (a.r1 != b.l1) &#123;
            c.l1 = a.r1;
            c.l2 = b.l1;
            <span class="hljs-keyword">if</span> (a.r1 &gt; b.l1 &amp;&amp; b.l1 &lt; b.l2) &#123;
                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, b.l1, b.f1, b.f2);
                c.f1 = res[<span class="hljs-number">0</span>];
                c.f2 = res[<span class="hljs-number">1</span>];
                c.ok &amp;= t;
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b.l2 == inf) &#123;
        c = a;
        <span class="hljs-keyword">if</span> (a.r1 != b.l1) &#123;
            c.r1 = b.l1;
            c.r2 = a.r1;
            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; a.r1 &lt; b.l1) &#123;
                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, a.r1, b.f1, b.f2);
                c.f1 = res[<span class="hljs-number">0</span>];
                c.f2 = res[<span class="hljs-number">1</span>];
                c.ok &amp;= t;
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        c.l1 = a.l1;
        c.l2 = a.l2;
        c.r1 = b.r1;
        c.r2 = b.r2;
        c.ok = (a.ok &amp;&amp; b.ok);
        <span class="hljs-type">int</span> d = inf;
        <span class="hljs-keyword">if</span> (a.r1 == b.l1) &#123;
            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; b.l1 &lt; b.l2) &#123;
                d = a.r1;
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (a.r2 &gt; a.r1 &amp;&amp; a.r1 &lt; b.l1) &#123;
                d = a.r1;
            &#125;
            <span class="hljs-keyword">if</span> (a.r1 &gt; b.l1 &amp;&amp; b.l1 &lt; b.l2) &#123;
                d = b.l1;
            &#125;
        &#125;
        <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(a.f1, a.f2, d, b.f1, b.f2);
        c.f1 = res[<span class="hljs-number">0</span>];
        c.f2 = res[<span class="hljs-number">1</span>];
        c.ok &amp;= t;
    &#125;
    c.l = <span class="hljs-built_in">min</span>(a.l, b.l);
    c.r = <span class="hljs-built_in">max</span>(a.r, b.r);
    <span class="hljs-keyword">return</span> c;
&#125;


<span class="hljs-comment">//-------------- templates above --------------</span>



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;Info&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		a[i] = <span class="hljs-built_in">Info</span>(x, i);
	&#125;
	<span class="hljs-function">LazySegmentTree&lt;Info, Tag&gt; <span class="hljs-title">seg</span><span class="hljs-params">(a)</span></span>;
	<span class="hljs-type">int</span> q;
	cin &gt;&gt; q;
	<span class="hljs-keyword">while</span> (q--) &#123;
		string s;
		<span class="hljs-type">int</span> l, r;
		cin &gt;&gt; s &gt;&gt; l &gt;&gt; r;
		<span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;update&quot;</span>) &#123;
			<span class="hljs-type">int</span> x;
			cin &gt;&gt; x;
            seg.<span class="hljs-built_in">modify</span>(l, r, Tag&#123;x&#125;);
		&#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">auto</span> cur = seg.<span class="hljs-built_in">query</span>(l, r);
            <span class="hljs-keyword">if</span> (cur.l1 &lt; cur.l2) &#123;
                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(inf, inf, cur.l1, cur.f1, cur.f2);
                cur.f1 = res[<span class="hljs-number">0</span>];
                cur.f2 = res[<span class="hljs-number">1</span>];
                cur.ok &amp;= t;
            &#125;
            <span class="hljs-keyword">if</span> (cur.r1 &lt; cur.r2) &#123;
                <span class="hljs-keyword">auto</span> [res, t] = <span class="hljs-built_in">check</span>(cur.f1, cur.f2, cur.r1, inf, inf);
                cur.f1 = res[<span class="hljs-number">0</span>];
                cur.f2 = res[<span class="hljs-number">1</span>];
                cur.ok &amp;= t;
            &#125;
            cur.ok |= cur.l2 == inf;
            cout &lt;&lt; (cur.ok ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
		&#125;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="neerc-2019-2020">NEERC 2019-2020</h2>
<h3 id="l.-lengths-and-periods后缀自动机">L. Lengths and Periods【后缀自动机】</h3>
<p>SAM 真是人类智慧的结晶啊！占坑。</p>
<h2 id="上海市赛">2024 上海市赛</h2>
<h3 id="f.-羁绊大师bitset-优化背包">F. 羁绊大师【bitset 优化背包】</h3>
<div class="note note-info">
            <p>有 <span class="math inline">\(n\)</span> 个英雄，每个英雄有 <span class="math inline">\(a_i,b_i\)</span> 两种羁绊，且不存在 <span class="math inline">\(i,j\in[1,n]\)</span> 使得 <span class="math inline">\(a_i=a_j\land b_i=b_j\)</span>。</p><p>共有 <span class="math inline">\(m\)</span> 种羁绊，每种羁绊至多只有两个英雄拥有。当上阵英雄中有两个英雄拥有此羁绊时，该羁绊为激活状态。</p><p>对 <span class="math inline">\(k\in[1,n]\)</span> 分别回答当有 <span class="math inline">\(k\)</span> 个英雄上阵时，激活羁绊的最大数量。</p><p><span class="math inline">\(1\le n \le 10^5\)</span>，<span class="math inline">\(n \le m \le 2n\)</span>，<span class="math inline">\(1\le a_i &lt; b_i \le m\)</span>。</p>
          </div>
<div class="note note-success">
            <p>将英雄看成点，羁绊看成边，拥有相同羁绊的两个英雄连边，问题转化为对 <span class="math inline">\(k\in [1,n]\)</span> 分别回答选中 <span class="math inline">\(k\)</span> 个点时导出子图的最大边数。</p><p>这个图具有特殊性质——每个点的度数至多是 <span class="math inline">\(2\)</span>，因此图中只包含环或链。</p><p>对于同样数目的点，选环比选链更具性价比，而对于两条链，优先选更长的链肯定也不劣。于是推断出以下策略：</p><ul><li>选择一些环使得这些环的总点数 <span class="math inline">\(x\le k\)</span> 且 <span class="math inline">\(x\)</span> 尽可能大。</li><li>按链的长度降序选择直到剩下的 <span class="math inline">\(k-x\)</span> 个点用完。</li></ul><p>第一步可以做 <span class="math inline">\(01\)</span> 背包 <span class="math inline">\(O(n^2)\)</span> 地解决。又因为这是存在性背包，于是可以用 <code>std::bitset</code> 优化到 <span class="math inline">\(O(\frac{n^2}{w})\)</span>。</p><p>第二步用一个指针维护当前选择的边数即可。</p><p>时间复杂度 <span class="math inline">\(O(\frac{n^2}{w})\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">//-------------- templates above --------------</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">bel</span>(m + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		bel[x].<span class="hljs-built_in">push_back</span>(i);
		bel[y].<span class="hljs-built_in">push_back</span>(i);
	&#125;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;
		<span class="hljs-keyword">if</span> (bel[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;
			<span class="hljs-type">int</span> x = bel[i][<span class="hljs-number">0</span>];
			<span class="hljs-type">int</span> y = bel[i][<span class="hljs-number">1</span>];
			adj[x].<span class="hljs-built_in">push_back</span>(y);
			adj[y].<span class="hljs-built_in">push_back</span>(x);
		&#125;
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	vector&lt;<span class="hljs-type">int</span>&gt; cir, line;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> len) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-type">bool</span> end = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-keyword">if</span> (vis[y]) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			vis[y] = <span class="hljs-literal">true</span>;
			end = <span class="hljs-literal">false</span>;
			<span class="hljs-built_in">self</span>(self, y, len + <span class="hljs-number">1</span>);
		&#125;
		<span class="hljs-keyword">if</span> (end) &#123;
			<span class="hljs-keyword">if</span> (adj[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;
				line.<span class="hljs-built_in">push_back</span>(len - <span class="hljs-number">1</span>);
			&#125; <span class="hljs-keyword">else</span> &#123;
				cir.<span class="hljs-built_in">push_back</span>(len);
			&#125;
		&#125;
	&#125;; 
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; adj[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;
			vis[i] = <span class="hljs-literal">true</span>;
			<span class="hljs-built_in">dfs</span>(dfs, i, <span class="hljs-number">1</span>);
		&#125;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; adj[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;
			vis[i] = <span class="hljs-literal">true</span>;
			<span class="hljs-built_in">dfs</span>(dfs, i, <span class="hljs-number">1</span>);
		&#125;
	&#125;

	bitset&lt;N&gt; dp;
	dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : cir) &#123;
		dp |= dp &lt;&lt; x;
	&#125;

	<span class="hljs-built_in">sort</span>(line.<span class="hljs-built_in">begin</span>(), line.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());
	<span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(cir.<span class="hljs-built_in">begin</span>(), cir.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);
	<span class="hljs-type">int</span> ptr = <span class="hljs-number">0</span>, ex = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (dp[i]) &#123;
			cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
			ex = <span class="hljs-number">0</span>;
			res = i;
			<span class="hljs-keyword">continue</span>;
		&#125;
		ex++;
		<span class="hljs-keyword">if</span> (i &lt;= sum) &#123;
			cout &lt;&lt; (ex &gt;= <span class="hljs-number">2</span> ? i - <span class="hljs-number">1</span> : res) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-keyword">if</span> (ptr &gt;= line.<span class="hljs-built_in">size</span>()) &#123;
			cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-keyword">if</span> (ex &gt; line[ptr]) &#123;
			res += line[ptr];
			ptr++;
			ex = <span class="hljs-number">0</span>;
		&#125;
		cout &lt;&lt; res + (ex &gt;= <span class="hljs-number">2</span> ? ex - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="d.-咸鱼跑酷线段树">D. 咸鱼跑酷【线段树】</h3>
<div class="note note-info">
            <p>长为 <span class="math inline">\(n\)</span> 的操作序列，每个位置有两种操作，形如 <code>+x</code> 或 <code>*x</code>。</p><p>给定 <span class="math inline">\(q\)</span> 组询问，每次给定 <code>u l r</code>，问以初值 <span class="math inline">\(u\)</span>，执行 <span class="math inline">\(l\to r\)</span> 的操作序列，每个位置可以选择两种给定操作中的一种，最后能得到的最大数值。答案对 998244353 取模。</p><p><span class="math inline">\(1\le n,q \le 10^5\)</span>，<span class="math inline">\(1\le x,u \le 10^9\)</span>。</p>
          </div>
<div class="note note-success">
            <p>对于一个位置，如果都是 <code>+</code> 或都是 <code>*</code>，那么一定选数字大的那个；否则一加一乘，且只有乘的数 <span class="math inline">\(&gt;1\)</span> 时才有选择的可能，我们称这样的位置为关键位置。</p><p>注意到 <span class="math inline">\(1\le x \le 10^9\)</span>，故当当前 <span class="math inline">\(u&gt;10^9\)</span> 时，选乘一定比选加更优。</p><p>又因为每次经过一个关键位置，数字大小至少<span class="math inline">\(\times 2\)</span>，故经过 <span class="math inline">\(O(\log W)\)</span> 个关键位置之后当前数字就会超过临界值。</p><p>于是我们预处理出下一个关键位置的坐标，暴力跳 <span class="math inline">\(O(\log W)\)</span> 个段。由于段间都为 <code>+</code> 操作，故维护一个前缀和即可。</p><p>当跳到数值 <span class="math inline">\(&gt;10^9\)</span>，之后的选择就固定了。用线段树维护一段区间累计乘了多少，累计加了多少，就能快速计算。</p><p>pushup 的方式：</p><div class="code-wrapper"><pre><code class="hljs c++">Mul[p] = Mul[p &lt;&lt; <span class="hljs-number">1</span>] * Mul[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]
Add[p] = Add[p &lt;&lt; <span class="hljs-number">1</span>] * Mul[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] + Add[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]</code></pre></div><p>时间复杂度 <span class="math inline">\(O(n\log n+q\log(nW))\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> modp = <span class="hljs-number">998244353</span>;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegmentTree</span> &#123;
	<span class="hljs-type">int</span> n;
	vector&lt;<span class="hljs-type">int</span>&gt; Add, Mul;
	<span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> size) &#123;
		n = size;
		Add.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);
		Mul.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r &gt;&gt; 1)</span>
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
		Mul[p] = Mul[ls] * Mul[rs] % modp;
		Add[p] = (Add[ls] * Mul[rs] + Add[rs]) % modp;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &amp;val)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (l == r) &#123;
        	Mul[p] = val[<span class="hljs-number">0</span>];
        	Add[p] = val[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">return</span> ;
        &#125;
        <span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;
        	<span class="hljs-built_in">modify</span>(ls, l, mid, pos, val);
        &#125; <span class="hljs-keyword">else</span> &#123;
        	<span class="hljs-built_in">modify</span>(rs, mid + <span class="hljs-number">1</span>, r, pos, val);
        &#125;
        <span class="hljs-built_in">pushup</span>(p);
    &#125;
	<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">if</span>(ql &lt;= l &amp;&amp; qr &gt;= r) &#123;
			<span class="hljs-keyword">return</span> &#123;Mul[p], Add[p]&#125;;
		&#125;
		array&lt;<span class="hljs-type">int</span>, 2&gt; res = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;
		<span class="hljs-keyword">if</span>(ql &lt;= mid) &#123;
			<span class="hljs-keyword">auto</span> o = <span class="hljs-built_in">query</span>(ls, l, mid, ql, qr);
			res[<span class="hljs-number">0</span>] = res[<span class="hljs-number">0</span>] * o[<span class="hljs-number">0</span>] % modp;
			res[<span class="hljs-number">1</span>] = (res[<span class="hljs-number">1</span>] * o[<span class="hljs-number">0</span>] + o[<span class="hljs-number">1</span>]) % modp;
		&#125;
		<span class="hljs-keyword">if</span>(qr &gt; mid) &#123;
			<span class="hljs-keyword">auto</span> o = <span class="hljs-built_in">query</span>(rs, mid + <span class="hljs-number">1</span>, r, ql, qr);
			res[<span class="hljs-number">0</span>] = res[<span class="hljs-number">0</span>] * o[<span class="hljs-number">0</span>] % modp;
			res[<span class="hljs-number">1</span>] = (res[<span class="hljs-number">1</span>] * o[<span class="hljs-number">0</span>] + o[<span class="hljs-number">1</span>]) % modp;
		&#125;
		<span class="hljs-keyword">return</span> res;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; val)</span> </span>&#123;
        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, pos, val);
    &#125;
	<span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, ql, qr);
	&#125;
&#125;;

<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;
			string s;
			cin &gt;&gt; s;
			<span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;
				add[i] = <span class="hljs-built_in">max</span>(add[i], <span class="hljs-built_in">stoll</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>)));
			&#125; <span class="hljs-keyword">else</span> &#123;
				mul[i] = <span class="hljs-built_in">max</span>(mul[i], <span class="hljs-built_in">stoll</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>)));
			&#125;
		&#125;
	&#125;
	<span class="hljs-function">SegmentTree <span class="hljs-title">seg</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">if</span> (mul[i] == <span class="hljs-number">1</span>) &#123;
			seg.<span class="hljs-built_in">modify</span>(i, &#123;<span class="hljs-number">1</span>, add[i]&#125;);
		&#125; <span class="hljs-keyword">else</span> &#123;
			seg.<span class="hljs-built_in">modify</span>(i, &#123;mul[i], <span class="hljs-number">0</span>&#125;);
		&#125;
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		pre[i] = pre[i - <span class="hljs-number">1</span>] + add[i];
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;
		nxt[i] = mul[i] &gt; <span class="hljs-number">1</span> ? i : nxt[i + <span class="hljs-number">1</span>];
	&#125;
	<span class="hljs-type">int</span> q;
	cin &gt;&gt; q;
	<span class="hljs-keyword">while</span> (q--) &#123;
		<span class="hljs-type">int</span> u, l, r;
		cin &gt;&gt; u &gt;&gt; l &gt;&gt; r;
		<span class="hljs-type">int</span> pl = l;
		<span class="hljs-keyword">while</span> (pl &lt;= r &amp;&amp; u &lt; <span class="hljs-number">1e9</span>) &#123;
			<span class="hljs-type">int</span> pr = <span class="hljs-built_in">min</span>(r, nxt[pl] - <span class="hljs-number">1</span>);
			u += pre[pr] - pre[pl - <span class="hljs-number">1</span>];
			pl = pr + <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (u &gt;= <span class="hljs-number">1e9</span> || pl &gt; r) &#123;
				<span class="hljs-keyword">break</span>;
			&#125;
			u = <span class="hljs-built_in">max</span>(u + add[pl], u * mul[pl]);
			pl++;
		&#125;
		<span class="hljs-keyword">auto</span> [Mul, Add] = seg.<span class="hljs-built_in">query</span>(pl, r);
		<span class="hljs-type">int</span> ans = (u % modp * Mul % modp + Add) % modp;
		cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="seerc-2022">SEERC 2022</h2>
<h3 id="i.-inadequate-operation贪心单调栈">I. Inadequate Operation【贪心、单调栈】</h3>
<div class="note note-info">
            <p>给定长为 <span class="math inline">\(n\)</span> 的非负序列 <span class="math inline">\(\{a\}\)</span>，每次操作你可以选择一个 <span class="math inline">\(i\in[1,n)\)</span>，满足 <span class="math inline">\(\max(a_i,a_{i+1}) &gt;0\)</span>，然后用 <span class="math inline">\(\max(a_i,a_{i + 1})-1\)</span> 替换 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span>。问使得序列所有元素变为 <span class="math inline">\(0\)</span> 的最小操作次数。</p><p><span class="math inline">\(2 \le n \le 2\cdot 10^5\)</span>，<span class="math inline">\(0\le a_i\le 10^9\)</span>。</p>
          </div>
<div class="note note-success">
            <p>略微诈骗。因为这个操作每次最多让两个位置 <span class="math inline">\(-1\)</span>（即 <span class="math inline">\(a_i=a_{i+1}\)</span> 时），就算你让一个位置 <span class="math inline">\(-1\)</span>，另一个位置被拉高，你继续操作这个下标操作次数也不会更劣。于是策略就是贪心地从大到小删。</p><p>对于一个相同高度长为 <span class="math inline">\(L\)</span> 的连续段，删掉它需要 <span class="math inline">\(\lceil \frac{L}{2}\rceil\)</span> 次操作。形式化地，答案是： <span class="math display">\[\sum_{i=1}^{mx}\left(\left\lceil\frac{L_{i1}}{2}\right\rceil +\left\lceil\frac{L_{i2}}{2}\right\rceil +\cdots\right)\]</span> 其中 <span class="math inline">\(L_i\)</span> 是指考虑所有 <span class="math inline">\(\ge i\)</span> 的元素，它们形成的若干连续段长度。</p><p>进一步地，记 <span class="math inline">\(l_i\)</span> 为 <span class="math inline">\(i\)</span> 左侧第一个 <span class="math inline">\(&lt;a_i\)</span> 的位置，<span class="math inline">\(r_i\)</span> 为 <span class="math inline">\(i\)</span> 右侧第一个 <span class="math inline">\(&lt;a_i\)</span> 的位置。式子可以化成： <span class="math display">\[\sum_{i=1}^{n}\left\lceil\frac{r_i-l_i-1}{2}\right\rceil(a_i-\max(a_{l_i},a_{r_i}))\]</span> 实现的时候，可以维护一个内部递增的单调栈，扫一遍就能求出 <span class="math inline">\(l_i\)</span> 和 <span class="math inline">\(r_i\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        并查集ver.
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;
	vector&lt;<span class="hljs-type">int</span>&gt; f, siz;
	<span class="hljs-built_in">DSU</span>() &#123;&#125;
	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) &#123; <span class="hljs-built_in">init</span>(n);&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
		f.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);
		siz.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;
			f[i] = i;
			siz[i] = <span class="hljs-number">1</span>;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (x == f[x]) <span class="hljs-keyword">return</span> x;
		<span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
		x = <span class="hljs-built_in">find</span>(x);
		y = <span class="hljs-built_in">find</span>(y);
		<span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (siz[x] &lt; siz[y]) &#123;
			<span class="hljs-built_in">swap</span>(x, y);
		&#125;
		siz[x] += siz[y];
		f[y] = x;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
		<span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];
	&#125;
&#125;;



<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i][<span class="hljs-number">0</span>];
		a[i][<span class="hljs-number">1</span>] = i;
	&#125;
	<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n, lst = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;
		<span class="hljs-type">int</span> j = i;
		<span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j][<span class="hljs-number">0</span>] == a[i][<span class="hljs-number">0</span>]) &#123;
			j--;
		&#125;
		<span class="hljs-type">int</span> len = lst;
		<span class="hljs-type">int</span> del = a[i][<span class="hljs-number">0</span>] - (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : a[j][<span class="hljs-number">0</span>]);

		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt;= i; k++) &#123;
			<span class="hljs-type">int</span> pos = a[k][<span class="hljs-number">1</span>];
			vis[pos] = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">if</span> (vis[pos - <span class="hljs-number">1</span>]) &#123;
				len -= (dsu.<span class="hljs-built_in">size</span>(pos - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
				dsu.<span class="hljs-built_in">merge</span>(pos, pos - <span class="hljs-number">1</span>);
			&#125;
			<span class="hljs-keyword">if</span> (vis[pos + <span class="hljs-number">1</span>]) &#123;
				len -= (dsu.<span class="hljs-built_in">size</span>(pos + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
				dsu.<span class="hljs-built_in">merge</span>(pos, pos + <span class="hljs-number">1</span>);
			&#125;
			len += (dsu.<span class="hljs-built_in">size</span>(pos) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
		&#125;
		ans += len * del;
		lst = len;
		i = j + <span class="hljs-number">1</span>;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;

	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        单调栈ver.
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">stk</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; a[stk.<span class="hljs-built_in">back</span>()] &gt;= a[i]) &#123;
			r[stk.<span class="hljs-built_in">back</span>()] = i;
			stk.<span class="hljs-built_in">pop_back</span>();
		&#125;
		<span class="hljs-keyword">if</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;
			l[i] = stk.<span class="hljs-built_in">back</span>();
		&#125;
		stk.<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		ans += (r[i] - l[i]) / <span class="hljs-number">2</span> * (a[i] - <span class="hljs-built_in">max</span>(a[l[i]], a[r[i]]));
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<hr />
<h3 id="k.-knowledge-testing-problem整体二分">K. Knowledge Testing Problem【整体二分】</h3>
<div class="note note-info">
            <p>给定一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向图，边有边权 <span class="math inline">\(w_i\)</span>。其中任意一条边 <span class="math inline">\(x_i\to y_i\)</span> 都满足 <span class="math inline">\(|x_i-y_i|\le 10\)</span>。给定 <span class="math inline">\(q\)</span> 组询问，每次询问两个点问最短路。</p><p><span class="math inline">\(1 \le n \le 10^5\)</span>，<span class="math inline">\(1\le m \le 2\cdot 10^5\)</span>，<span class="math inline">\(1\le q \le 2.5\cdot 10^4\)</span>，<span class="math inline">\(1 \le w_i \le 10^9\)</span>。</p>
          </div>
<div class="note note-success">
            <p>考虑整体二分。</p><p>对于当前区间 <span class="math inline">\([l, r]\)</span>，设中点为 <span class="math inline">\(m\)</span>，取中点周围 <span class="math inline">\([m-4,m+5]\)</span> 共 <span class="math inline">\(10\)</span> 个点，并以这些点为起点跑单源最短路（经过的点必须在 <span class="math inline">\([l,r]\)</span> 内，即只连两个端点都在 <span class="math inline">\([l, r]\)</span> 内的边），然后再以这些点为中转点分治下去。</p><p>对于一个询问 <span class="math inline">\(x,y\)</span>，若 <span class="math inline">\(\max(x,y)&lt;m-4\)</span>，就把它放到 <span class="math inline">\([l,m-4)\)</span> 里继续更新；若 <span class="math inline">\(\min(x,y)&gt;m+5\)</span>，就把它放到 <span class="math inline">\((m+5,r]\)</span> 里继续更新；否则此次更新完后不用继续更新，因为必然以 <span class="math inline">\(x,y\)</span> 中的至少一个点为起点跑了单源最短路。</p><p>保证正确性的根据是：对于一个询问 <span class="math inline">\(x,y\)</span>（不妨设 <span class="math inline">\(x&lt;y&lt;m-4\)</span>），如果最短路需要经过 <span class="math inline">\(m+5\)</span> 右侧的点，就必然经过 <span class="math inline">\([m-4,m+5]\)</span> 中的某一个（因为任意一条边两侧的点编号相差 <span class="math inline">\(\le 10\)</span>），故以这 <span class="math inline">\(10\)</span> 个点为中转点更新出的最短路能覆盖所有的情况。</p><p>假设 <span class="math inline">\(n,m\)</span> 同级，时间复杂度 <span class="math inline">\(O(nd\log^2n)\)</span>，<span class="math inline">\(d=10\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m, q;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; E, Q;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> x, y, w;
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
		E.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		Q.<span class="hljs-built_in">push_back</span>(&#123;x, y, i&#125;);
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q, inf)</span></span>;
	vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);

	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, inf)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> dijkstra = [&amp;] (<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;
			dis[i] = inf;
			vis[i] = <span class="hljs-literal">false</span>;
		&#125;
		<span class="hljs-meta">#<span class="hljs-keyword">define</span> P pair<span class="hljs-string">&lt;int, int&gt;</span></span>
		priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq;
		pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, S&#125;);
		dis[S] = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-keyword">auto</span> [dist, x] = pq.<span class="hljs-built_in">top</span>();
			pq.<span class="hljs-built_in">pop</span>();
			<span class="hljs-keyword">if</span> (vis[x]) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			vis[x] = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [y, w] : adj[x]) &#123;
				<span class="hljs-keyword">if</span> (dis[y] &gt; dist + w) &#123;
					dis[y] = dist + w;
					pq.<span class="hljs-built_in">push</span>(&#123;dis[y], y&#125;);
				&#125;
			&#125;
		&#125;
	&#125;;
	
	<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, 
	vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; &amp;vE, vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&gt; &amp;vQ) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">if</span> (l &gt; r) &#123;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;
			adj[i].<span class="hljs-built_in">clear</span>();
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : vE) &#123;
			adj[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);
			adj[y].<span class="hljs-built_in">push_back</span>(&#123;x, w&#125;);
		&#125;
		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">max</span>(l, mid - <span class="hljs-number">4</span>); i &lt;= <span class="hljs-built_in">min</span>(r, mid + <span class="hljs-number">5</span>); i++) &#123;
			<span class="hljs-built_in">dijkstra</span>(i, l, r);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, id] : vQ) &#123;
				ans[id] = <span class="hljs-built_in">min</span>(ans[id], dis[x] + dis[y]);
			&#125;
		&#125;
		vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; lE, rE, lQ, rQ;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, w] : vE) &#123;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(x, y) &lt;= mid - <span class="hljs-number">5</span>) &#123;
				lE.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(x, y) &gt;= mid + <span class="hljs-number">6</span>) &#123;
				rE.<span class="hljs-built_in">push_back</span>(&#123;x, y, w&#125;);
			&#125;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y, id] : vQ) &#123;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(x, y) &lt;= mid - <span class="hljs-number">5</span>) &#123;
				lQ.<span class="hljs-built_in">push_back</span>(&#123;x, y, id&#125;);
			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(x ,y) &gt;= mid + <span class="hljs-number">6</span>) &#123;
				rQ.<span class="hljs-built_in">push_back</span>(&#123;x, y, id&#125;);
			&#125;
		&#125;
		<span class="hljs-built_in">self</span>(self, l, mid - <span class="hljs-number">5</span>, lE, lQ);
		<span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">6</span>, r, rE, rQ);
	&#125;;

	<span class="hljs-built_in">calc</span>(calc, <span class="hljs-number">1</span>, n, E, Q);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;
		cout &lt;&lt; (x == inf ? <span class="hljs-number">-1</span> : x) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="nwerc-2021">NWERC 2021</h2>
<h3 id="h.-heating-up双向链表">H. Heating Up【双向链表】</h3>
<div class="note note-info">
            <p>有 <span class="math inline">\(n\)</span> 个辣椒，第 <span class="math inline">\(i\)</span> 个辣度为 <span class="math inline">\(a_i\)</span>，排成环形（即 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n\)</span> 看作相邻）。你要吃光这些辣椒，你可以任意选择一个辣椒开始，并在之后每一步选择"已选择辣椒"中的一个相邻辣椒吃下。你初始有忍耐度 <span class="math inline">\(f\)</span>，你吃下一个辣度为 <span class="math inline">\(k\)</span> 的辣椒当且仅当 <span class="math inline">\(f\ge k\)</span>，并且当你吃掉它后你的忍耐值会增加 <span class="math inline">\(k\)</span> 个单位。问吃光所有辣椒所需的最小初始忍耐值。</p><p><span class="math inline">\(3\le n \le 5\cdot 10^5\)</span>，<span class="math inline">\(0\le a_i \le 10^{13}\)</span>。</p>
          </div>
<div class="note note-success">
            <p>二分答案，设二分出的答案为 <span class="math inline">\(s\)</span>，问题转化为判定初始忍耐值为 <span class="math inline">\(s\)</span> 时是否能吃完所有辣椒。</p><p>拆环成链，用一个双向链表操作以下过程：</p><ul><li>遍历 <span class="math inline">\(i\in[1,2n]\)</span>，若 <span class="math inline">\(a_i&gt;s\)</span>，跳过；否则以点 <span class="math inline">\(i\)</span> 为中心向两侧尝试扩张。</li><li>对每一个连续段维护这个段 <span class="math inline">\(a_i\)</span> 的最小值 <span class="math inline">\(b\)</span>，当忍耐值不小于这个值时，就可以吞并这个段，新的 <span class="math inline">\(b\)</span> 即两段取 <span class="math inline">\(\min\)</span>。</li><li>这个被合并的段有贡献 <span class="math inline">\(\sum a_i\)</span>，合并时可以另开一个数组 <span class="math inline">\(c\)</span> 维护。</li><li>判定成功当且仅当链表合并到最后只剩一个元素，即删除了 <span class="math inline">\(2n-1\)</span> 个元素。</li></ul><p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>，<span class="math inline">\(w\)</span> 为二分值域。具体实现见代码。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cin &gt;&gt; a[i];
		a[i + n] = a[i];
	&#125;
	a[<span class="hljs-number">0</span>] = a[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>] = inf;

	<span class="hljs-keyword">auto</span> check = [&amp;] (<span class="hljs-type">int</span> st) &#123;
		vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">L</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>), <span class="hljs-built_in">R</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;
			L[i] = i - <span class="hljs-number">1</span>;
			R[i] = i + <span class="hljs-number">1</span>;
		&#125;
		<span class="hljs-type">int</span> cnt = <span class="hljs-number">2</span> * n;
		<span class="hljs-keyword">auto</span> del = [&amp;] (<span class="hljs-keyword">auto</span> pos) &#123;
			L[R[pos]] = L[pos];
			R[L[pos]] = R[pos];
			cnt--;
		&#125;;
		vector b = a, c = a;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i = R[i]) &#123;
			<span class="hljs-keyword">if</span> (b[i] &gt; st) &#123;
				<span class="hljs-keyword">continue</span>;
			&#125;
			<span class="hljs-type">int</span> cur = st + b[i];
			<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
				<span class="hljs-keyword">if</span> ((L[i] &lt; <span class="hljs-number">1</span> || b[L[i]] &gt; cur) &amp;&amp; (R[i] &gt; <span class="hljs-number">2</span> * n || b[R[i]] &gt; cur)) &#123;
					<span class="hljs-keyword">break</span>;
				&#125;
				<span class="hljs-keyword">if</span> (L[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; b[L[i]] &lt;= cur) &#123;
					cur += c[L[i]];
					c[i] += c[L[i]];
					b[i] = <span class="hljs-built_in">min</span>(b[i], b[L[i]]);
					<span class="hljs-built_in">del</span>(L[i]);
				&#125;
				<span class="hljs-keyword">if</span> (R[i] &lt;= <span class="hljs-number">2</span> * n &amp;&amp; b[R[i]] &lt;= cur) &#123;
					cur += c[R[i]];
					c[i] += c[R[i]];
					b[i] = <span class="hljs-built_in">min</span>(b[i], b[R[i]]);
					<span class="hljs-built_in">del</span>(R[i]);
				&#125;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> cnt == <span class="hljs-number">1</span>;
	&#125;;

	<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e13</span>, ans = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">while</span> (l &lt;= r) &#123;
		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;
			ans = mid;
			r = mid - <span class="hljs-number">1</span>;
		&#125; <span class="hljs-keyword">else</span> &#123;
			l = mid + <span class="hljs-number">1</span>;
		&#125;
	&#125;
	cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="swerc-2023">SWERC 2023</h2>
<h3 id="g.-favourite-dish凸包">G. Favourite Dish【凸包】</h3>
<div class="note note-info">
            <p>有 <span class="math inline">\(n\)</span> 道菜，第 <span class="math inline">\(i\)</span> 道菜有属性 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span>。有 <span class="math inline">\(m\)</span> 个客人，第 <span class="math inline">\(i\)</span> 个人有属性 <span class="math inline">\(c_{i}\)</span> 和 <span class="math inline">\(d_i\)</span>。</p><p>第 <span class="math inline">\(i\)</span> 个人对第 <span class="math inline">\(j\)</span> 道菜的喜爱度为 <span class="math inline">\(\dfrac{c_ia_j+d_ib_j}{c_i+d_i}\)</span>，即加权平均值。你需要对每个人求出他最喜欢的菜品编号（若对两道菜的喜爱度相同，取编号较小者）。保证有序对 <span class="math inline">\((a_i,b_i)\)</span> 两两不同，<span class="math inline">\((c_i,d_i)\)</span> 两两不同。</p><p><span class="math inline">\(1\le n,m\le 5\cdot 10^5\)</span>，<span class="math inline">\(0\le a_i,b_i,c_i,d_i\le 10^6\)</span>。</p>
          </div>
<div class="note note-success">
            <p>把每个人看作一个询问。对于单个询问，<span class="math inline">\(c+d\)</span> 固定，衡量指标是 <span class="math inline">\(ac+bd\)</span>。</p><p>问题转化为给定 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((a, b)\)</span>，每次询问一个 <span class="math inline">\((c, d)\)</span>，问 <span class="math inline">\(ac+bd\)</span> 取到最大值时对应点的编号。</p><p>这是一个经典问题。令 <span class="math inline">\(w=ac+bd\)</span>，两边除以 <span class="math inline">\(d\)</span>： <span class="math display">\[\frac{w}{d}=\frac{ac}{d}+b\longrightarrow b=(-\frac{c}{d})a+\frac{w}{d}\]</span> 这是一个 <span class="math inline">\(y=kx+b\)</span> 形式的直线方程，让 <span class="math inline">\(w\)</span> 最大，即让这条直线的截距 <span class="math inline">\((\frac{w}{d})\)</span> 最大。</p><p>由于 <span class="math inline">\(a,b,c,d\)</span> 均为非负整数，我们可以求出这 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((a, b)\)</span> 在第一象限的上凸壳，将询问按斜率 <span class="math inline">\((-\frac{c}{d})\)</span> 排序，用一对双指针即可维护。（一个在凸壳上顺时针扫，一个按直线斜率从大到小扫）</p><p>时间复杂度 <span class="math inline">\(O(n\log n+m\log m)\)</span>。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; cout.flush();&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">a</span>(n);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-type">int</span> x, y;
		cin &gt;&gt; x &gt;&gt; y;
		a[i] = &#123;x, y, i&#125;;
	&#125;
	<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), [&amp;] (array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; i, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt; j) &#123;
		<span class="hljs-keyword">return</span> i[<span class="hljs-number">0</span>] == j[<span class="hljs-number">0</span>] ? i[<span class="hljs-number">1</span>] &gt; j[<span class="hljs-number">1</span>] : i[<span class="hljs-number">0</span>] &lt; j[<span class="hljs-number">0</span>];
	&#125;);
	<span class="hljs-keyword">auto</span> getk = [&amp;] (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;
		<span class="hljs-built_in">return</span> (<span class="hljs-type">double</span>)(a[j][<span class="hljs-number">1</span>] - a[i][<span class="hljs-number">1</span>]) / (a[j][<span class="hljs-number">0</span>] - a[i][<span class="hljs-number">0</span>]);
	&#125;;
	vector&lt;<span class="hljs-type">int</span>&gt; h&#123;<span class="hljs-number">0</span>&#125;;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">while</span> (h.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">getk</span>(h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>], h.<span class="hljs-built_in">back</span>()) &lt; <span class="hljs-built_in">getk</span>(h[h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>], i)) &#123;
			h.<span class="hljs-built_in">pop_back</span>();
		&#125;
		h.<span class="hljs-built_in">push_back</span>(i);
	&#125;
	vector&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt; l;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> c, d;
		cin &gt;&gt; c &gt;&gt; d;
		l.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">-1.0L</span> * c / d, i&#125;);
	&#125;
	<span class="hljs-built_in">sort</span>(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>());
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, res = inf; i &lt; m; i++) &#123;
		<span class="hljs-keyword">auto</span> [k, id] = l[i];
		<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; k == l[i - <span class="hljs-number">1</span>].first) &#123;
			ans[id] = res;
			<span class="hljs-keyword">continue</span>;
		&#125;
		<span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; h.<span class="hljs-built_in">size</span>() &amp;&amp; k &lt; <span class="hljs-built_in">getk</span>(h[j], h[j + <span class="hljs-number">1</span>])) &#123;
			j++;
		&#125;
		res = a[h[j]][<span class="hljs-number">2</span>];
		<span class="hljs-keyword">while</span> (j + <span class="hljs-number">1</span> &lt; h.<span class="hljs-built_in">size</span>() &amp;&amp; k == <span class="hljs-built_in">getk</span>(h[j], h[j + <span class="hljs-number">1</span>])) &#123;
			j++;
			res = <span class="hljs-built_in">min</span>(res, a[h[j]][<span class="hljs-number">2</span>]);
		&#125;
		ans[id] = res;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;
		cout &lt;&lt; x + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<div class="note note-warning">
            <p><span class="math inline">\(1.0\cdot \text{int}=\text{double}\)</span></p><p><span class="math inline">\(1.0L\cdot \text{int}=\text{long double}\)</span></p><p>望周知 (QwQ)。</p>
          </div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Competitive-Programming/" class="category-chain-item">Competitive Programming</a>
  
  
    <span>></span>
    
  <a href="/categories/Competitive-Programming/other/" class="category-chain-item">other</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ICPC/" class="print-no-link">#ICPC</a>
      
        <a href="/tags/UESTC/" class="print-no-link">#UESTC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【题解】2024 UESTC 暑假集训 第二轮</div>
      <div>https://kisuraop.github.io/posts/70be1dc7.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>KisuraOP</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/a57ce1e5.html" title="【游记】2024 CCPC 网络预选赛">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【游记】2024 CCPC 网络预选赛</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/61a1a0ca.html" title="【游记】2024 UESTC 暑假集训 第一轮">
                        <span class="hidden-mobile">【游记】2024 UESTC 暑假集训 第一轮</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://kisuraop.github.io/" target="_blank" rel="nofollow noopener"><span>KisuraOP</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>








  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
