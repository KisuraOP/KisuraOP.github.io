

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/bg/mugeng.ico">
  <link rel="icon" href="/image/bg/mugeng.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="KisuraOP">
  <meta name="keywords" content="">
  
    <meta name="description" content="如梦似幻。 【7.9】 2025 上海市赛 Contest Link 用了 1h 意识到树形背包是 \(O(n^2)\) 的，太神奇了树形背包。 C. 饺子 Code 令 \(f(x)\) 表示恰好吃 \(x\) 个饺子，能得到的最大愉悦值（忽略额外愉悦值 \(val\)）。 容易看出，\(f(x)\) 是一个上凸函数，答案只能取在 \(0,m\) 和极值点三者之一。 对于某个取值点，可以使用 W">
<meta property="og:type" content="article">
<meta property="og:title" content="【题解】2025 UESTC 暑假集训（div.1）">
<meta property="og:url" content="https://kisuraop.github.io/posts/80517353.html">
<meta property="og:site_name" content="KisuraOP">
<meta property="og:description" content="如梦似幻。 【7.9】 2025 上海市赛 Contest Link 用了 1h 意识到树形背包是 \(O(n^2)\) 的，太神奇了树形背包。 C. 饺子 Code 令 \(f(x)\) 表示恰好吃 \(x\) 个饺子，能得到的最大愉悦值（忽略额外愉悦值 \(val\)）。 容易看出，\(f(x)\) 是一个上凸函数，答案只能取在 \(0,m\) 和极值点三者之一。 对于某个取值点，可以使用 W">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.rmb.bdstatic.com/bjh/60ace5d38359edea13a361fff5643eed.jpeg">
<meta property="article:published_time" content="2025-07-09T10:17:15.000Z">
<meta property="article:modified_time" content="2025-07-09T10:17:15.000Z">
<meta property="article:author" content="KisuraOP">
<meta property="article:tag" content="UESTC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic.rmb.bdstatic.com/bjh/60ace5d38359edea13a361fff5643eed.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【题解】2025 UESTC 暑假集训（div.1） - KisuraOP</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_4277703_p4cthydttt.css">
<link rel="stylesheet" href="/css/vemoji.css">
<link rel="stylesheet" href="/css/bg_cover.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kisuraop.github.io","root":"/","version":"1.9.5-a","typing":{"enable":false,"typeSpeed":55,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"c++"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/image/other/loading.mp4","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><script src="https://kisuraop.github.io/js/mouseclick.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>KisuraOPのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/site/">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>收藏夹</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/waiting/">
                <i class="iconfont icon-plan"></i>
                <span>待办</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/example/">
                <i class="iconfont icon-comment"></i>
                <span>留言</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://moe.jitsu.top/img/?sort=pc') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">【题解】2025 UESTC 暑假集训（div.1）</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        KisuraOP
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-09 18:17" pubdate>
          2025年7月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【题解】2025 UESTC 暑假集训（div.1）</h1>
            
            
              <div class="markdown-body">
                
                <p>如梦似幻。</p>
<h2 id="上海市赛">【7.9】 2025 上海市赛</h2>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/contest/2238">Contest Link</a></p>
<p>用了 1h 意识到树形背包是 <span class="math inline">\(O(n^2)\)</span> 的，太神奇了树形背包。</p>
<h3 id="c.-饺子">C. 饺子</h3>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/submission/1147422">Code</a></p>
<p>令 <span class="math inline">\(f(x)\)</span> 表示恰好吃 <span class="math inline">\(x\)</span> 个饺子，能得到的最大愉悦值（忽略额外愉悦值 <span class="math inline">\(val\)</span>）。</p>
<p>容易看出，<span class="math inline">\(f(x)\)</span> 是一个上凸函数，答案只能取在 <span class="math inline">\(0,m\)</span> 和极值点三者之一。</p>
<p>对于某个取值点，可以使用 WQS 二分。二分斜率，对于一根固定斜率 <span class="math inline">\(k\)</span> 的直线，找到与凸包的切点等价于最大化直线的截距，即 <span class="math inline">\(f(x)-kx\)</span>。</p>
<p>而 <span class="math inline">\(f(x)=v_1+v_2+\cdots+v_x\)</span>，其中 <span class="math inline">\(v_i\)</span> 为某个饺子带来的愉悦值，那么最大化 <span class="math inline">\(f(x)-kx=(v_1-k)+(v_2-k)+\cdots+(v_x-k)\)</span> 也就等价于只取 <span class="math inline">\((v_i-k)\ge 0\to v_i\ge k\)</span> 的饺子。</p>
<p>计算所有愉悦值 <span class="math inline">\(\ge k\)</span> 的饺子带来的愉悦值之和，即为切点的纵坐标。</p>
<p>再考虑额外愉悦值 <span class="math inline">\(val\)</span>，这等价于将这个上凸函数的其中一段拉高，此时答案的取值点只可能增加了 <span class="math inline">\(l, r\)</span> 两个点，同上求解。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p>
<h3 id="e.-djangle-的数据结构">E. Djangle 的数据结构</h3>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/submission/1147725">Code</a></p>
<p>线段树维护：区间和，区间 <span class="math inline">\(\text{lcm}\)</span>，以及一个懒标记用于区间赋值。</p>
<p>可以说明，<span class="math inline">\(\gcd\)</span> 操作时经过以下两个剪枝，复杂度就是对的：</p>
<ul>
<li>如果 <span class="math inline">\(x\)</span> 是当前区间 <span class="math inline">\(\text{lcm}\)</span> 的倍数，此时直接返回区间和。因为 <span class="math inline">\(\gcd(a_i,x)=a_i\)</span>。</li>
<li>如果区间所有数全相等（为 <span class="math inline">\(d\)</span>），转换为区间赋值 <span class="math inline">\(\gcd(d,x)\)</span>。</li>
</ul>
<p>这是因为每次 <span class="math inline">\(\gcd\)</span> 操作，<span class="math inline">\(a_i\)</span> 的值至少减半，所以全局上看区间覆盖操作成功执行的次数的上界是 <span class="math inline">\(O(n\log w)\)</span>。</p>
<p>而算上求 <span class="math inline">\(\gcd\)</span>，单次修改的成本是 <span class="math inline">\(O(\log n\log w)\)</span>，所以一共就 <span class="math inline">\(O(n\log n\log^2w)\)</span>。</p>
<p>要更加严谨的话需要势能分析。</p>
<h2 id="icpc-jinan-regional">【7.10】2020 ICPC Jinan Regional</h2>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/contest/2181">Contest Link</a></p>
<p>只会 ez。</p>
<h2 id="icpc-nac">【7.11】2025 ICPC NAC</h2>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/contest/2041">Contest Link</a></p>
<h3 id="j.-popping-balloons">J. Popping Balloons</h3>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/submission/1151853">Code</a></p>
<p>蓝色看成 <span class="math inline">\(0\)</span>，黄色看成 <span class="math inline">\(1\)</span>，红色看成 <span class="math inline">\(2\)</span>，问题变为每秒从序列中随机移除一个值，让序列变得有序的期望时间。</p>
<p>设随机变量 <span class="math inline">\(X\)</span> 表示序列有序后剩下来的长度，则 <span class="math display">\[
P(X\ge k)=\dfrac{f(k)}{\binom{n}{k}}
\]</span> 其中 <span class="math inline">\(f(k)\)</span> 表示序列中长为 <span class="math inline">\(k\)</span> 的非降子序列数量。</p>
<p>进一步 <span class="math display">\[
E[X]=\sum_{k=1}^{n}P(x\ge k)
\]</span> 最终题目的答案就是 <span class="math inline">\(n-E[X]\)</span>。</p>
<p>现在，问题只剩如何对 <span class="math inline">\(k\in [1,n]\)</span> 求出 <span class="math inline">\(f(k)\)</span>。</p>
<p>尝试用多项式描述信息。定义多项式 <span class="math inline">\(F_{L,R,i,j}(x)\)</span>，它 <span class="math inline">\(x^k\)</span> 项的系数表示 "区间 <span class="math inline">\([L,R]\)</span> 中，以 <span class="math inline">\(i\)</span> 开头，<span class="math inline">\(j\)</span> 结尾 <span class="math inline">\((0\le i\le j\le 2)\)</span>，长为 <span class="math inline">\(k\)</span> 的非降子序列数量"。</p>
<p>这么定义的好处是，两个多项式相乘，<span class="math inline">\(x^i\)</span> 的系数和 <span class="math inline">\(x^j\)</span> 的系数会累加到新多项式 <span class="math inline">\(x^{i+j}\)</span> 的系数上，意义就是两个区间合并，长为 <span class="math inline">\(i\)</span> 的非降子序列和长为 <span class="math inline">\(j\)</span> 的非降子序列会拼接成长为 <span class="math inline">\(i+j\)</span> 的非降子序列。</p>
<p>先考虑基态。对于 <span class="math inline">\(a_i=x\ (x\in \{0,1,2\})\)</span>，<span class="math inline">\([x^1]F_{i,i,x,x}=1\)</span>，其它项均为 <span class="math inline">\(0\)</span>。</p>
<p>再考虑合并。假设我们已经知道了区间 <span class="math inline">\([l,m]\)</span> 的答案 <span class="math inline">\(F_{l,m,i,j}\)</span> 和区间 <span class="math inline">\([m+1,r]\)</span> 的答案 <span class="math inline">\(F_{m+1,r,i,j}\)</span>（我们得到的是所有 <span class="math inline">\(i,j\)</span> 的答案，换句话说，是一个 <span class="math inline">\(3\times 3\)</span> 的多项式矩阵），那么 <span class="math display">\[
\large F_{l,r,i,j}=\sum_{i\le p_1\le p_2\le j} F_{l,m,i,p_1}F_{m+1,r,p_2,j}+F_{l,m,i,j}+F_{m+1,r,i,j}
\]</span> 第一项表示拼接，后两项表示继承两侧区间的非降子序列数量。</p>
<p>分治 NTT 即可，最终 <span class="math inline">\(f(k)=\sum\limits_{i=0}^{2}\sum\limits_{j=0}^{2}[x^k]F_{1,n,i,j}\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<h2 id="毒瘤场-1">【7.12】毒瘤场 1</h2>
<p>难炸了。</p>
<h2 id="牛客多校-1">【7.15】牛客多校 1</h2>
<h2 id="毒瘤场-2">【7.16】毒瘤场 2</h2>
<p>难炸了。</p>
<h2 id="牛客多校-2">【7.17】牛客多校 2</h2>
<h2 id="杭电多校-1">【7.18】杭电多校 1</h2>
<h3 id="b.-夜世界">B. 夜世界</h3>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/contest/view-code?cid=1172&amp;rid=26547">Code</a></p>
<p>有回溯操作，考虑可持久化线段树。</p>
<p>区间维护三个值：</p>
<ul>
<li><span class="math inline">\(sum\)</span>：这一段的净收益（<span class="math inline">\(a_i-b_i\)</span>）。</li>
<li><span class="math inline">\(mn\)</span>：净收益（<span class="math inline">\(sum\)</span>）的前缀最小值。</li>
<li><span class="math inline">\(add\)</span>：从金矿获得的收益之和（<span class="math inline">\(a_i\)</span>）。</li>
</ul>
<p>操作一和操作二就是普通的单点修改，操作三回溯，主要是操作四。</p>
<p>给出的 <span class="math inline">\(k\)</span> 座金矿将 <span class="math inline">\([1,n]\)</span> 划分成了 <span class="math inline">\(k + 1\)</span> 段。</p>
<p>对一段区间 <span class="math inline">\([l,r]\)</span>，我们要解决：给一个初始金币数 <span class="math inline">\(x\)</span>，问从 <span class="math inline">\(l\)</span> 走到 <span class="math inline">\(r\)</span>，手上的金币数变成了多少。</p>
<p>分两种情况：</p>
<ul>
<li><span class="math inline">\(x+mn\ge 0\)</span>。说明走在这段区间里手里一直有钱，走完后 <span class="math inline">\(x\)</span> 变成 <span class="math inline">\(x+sum\)</span>。</li>
<li><span class="math inline">\(x+mn&lt;0\)</span>。说明存在某个时刻手里没钱归零了，设此时在第 <span class="math inline">\(p\)</span> 座金矿，最后手上的金币数就是 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(r\)</span> 之间的净收益，数值上等价于 <span class="math inline">\(sum-mn\)</span>。</li>
</ul>
<p>解决了段内金币数怎么变，端点处金币数减半可以暴力修改。</p>
<p>最后，交给哥布林的金币数，就是当前版本下金矿的收益之和减去手上剩下的金币数。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m+k)\log n)\)</span>。</p>
<h2 id="ucup2-20-ōokayama">【7.19】Ucup2-20 Ōokayama</h2>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/contest/1499">Contest Link</a></p>
<p>再也不想打小日子的场了。</p>
<h2 id="杭电多校-2">【7.21】杭电多校 2</h2>
<h3 id="k.-10010">K. 10010</h3>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/contest/view-code?cid=1173&amp;rid=22770">Code</a></p>
<p>题面给的非常抽象。转化之后等价于：设当前询问区间为 <span class="math inline">\([l, r]\)</span>，区间内从右到左 <span class="math inline">\(1\)</span> 的位置分别为 <span class="math inline">\(p_1,p_2,p_3,\ldots\)</span>，令 <span class="math inline">\(g_1=r-p_1\)</span>，<span class="math inline">\(g_2=p_1-p_2-1\)</span>，<span class="math inline">\(g_3=p_2-p_3-1\)</span>，<span class="math inline">\(\ldots\)</span>，则这段区间的得分为 <span class="math display">\[
\large f([l, r])=g_1+\max_{g_1,g_2,\ldots,g_i\ \textbf{形成等差数列} }\ 3\cdot (i-1)
\]</span> 线段树，每个区间维护如下值。</p>
<ul>
<li><p><span class="math inline">\(l\)</span>：左起第一个 <span class="math inline">\(1\)</span> 的绝对坐标。</p></li>
<li><p><span class="math inline">\(r\)</span>：右起第一个 <span class="math inline">\(1\)</span> 的绝对坐标。</p></li>
<li><p><span class="math inline">\(g\)</span>：右起第一个 <span class="math inline">\(1\)</span> 和右起第二个 <span class="math inline">\(1\)</span> 之间的间隔。</p></li>
<li><p><span class="math inline">\(ans\)</span>：右起构成等差数列的 <span class="math inline">\(1\)</span> 的个数。</p></li>
<li><p><span class="math inline">\(cont\)</span>：区间里所有的 <span class="math inline">\(1\)</span> 是否都属于右起的那个等差数列。</p></li>
</ul>
<p>转移的时候，对于 <span class="math inline">\([l_1,r_1]\)</span> 和 <span class="math inline">\([l_2,r_2]\)</span>，看 <span class="math inline">\(l_2-r_1-1\)</span> 是否能作为一个间隔连接两段等差数列。</p>
<p>细节非常多，我写完之后对拍了很久才过。</p>
<p>ps：如果你维护了 "<span class="math inline">\(r\)</span> 右侧 <span class="math inline">\(0\)</span> 的个数"，那么大概率逻辑是不对的（</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="牛客多校-3">【7.22】牛客多校 3</h2>
<h3 id="p4389.-付公主的背包">P4389. 付公主的背包</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/226206057">Code</a></p>
<p>考虑生成函数。其中 <span class="math inline">\(x^k\)</span> 项的系数代表 "凑出体积为 <span class="math inline">\(k\)</span> 的方案数"。</p>
<p>对于一个体积为 <span class="math inline">\(V\)</span> 的物品，它能凑出的体积是 <span class="math inline">\(0,V,2V,3V,\cdots\)</span>，用多项式表示就是 <span class="math display">\[
f_V(x)=x^0+x^V+x^{2V}+x^{3V}+\cdots
\]</span> 写成封闭形式（利用等比数列求和），就是 <span class="math inline">\(f_V(x)=\dfrac{1}{1-x^{V}}\)</span>。</p>
<p>现在有 <span class="math inline">\(n\)</span> 种体积为 <span class="math inline">\(v_1,v_2,\ldots,v_n\)</span> 的物品，每种无限个，它们任意组合，凑出体积为 <span class="math inline">\(k\)</span> 的方案数就是 <span class="math display">\[
[x^k]\prod_{i=1}^{n}\frac{1}{1-x^{v_i}}
\]</span> 令 <span class="math inline">\(F(x)=\prod\limits_{i=1}^{n}\dfrac{1}{1-x^{v_i}}\)</span>，要算出 <span class="math inline">\(F(x)\)</span> 前 <span class="math inline">\(m\)</span> 项的系数，暴力把 <span class="math inline">\(n\)</span> 个多项式乘起来是 <span class="math inline">\(O(nm\log m)\)</span> 的。需要更快的方法。</p>
<p>令 <span class="math inline">\(G(x)=\ln F(x)\)</span>，也就是 <span class="math display">\[
G(x)=\ln\prod\limits_{i=1}^{n}\dfrac{1}{1-x^{v_i}}=\sum_{i=1}^{n}\ln \left(\dfrac{1}{1-x^{v_i}}\right)=-\sum_{i=1}^{n}\ln(1-x^{v_i})
\]</span> 但如果把 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(1-x^{v_i}\)</span> 做多项式 <span class="math inline">\(\ln\)</span>，还是 <span class="math inline">\(O(nm\log m)\)</span> 的。</p>
<p>这么转换的优势在，可以运用泰勒公式 <span class="math inline">\(\ln(1-u)=-(u+\frac{u^2}{2}+\frac{u^3}{3}+\cdots)=-\sum\limits_{i=1}^{\infty}\dfrac{u^i}{i}\)</span>。</p>
<p>令 <span class="math inline">\(u=x^{v_i}\)</span>，有 <span class="math display">\[
G(x)=-\sum_{i=1}^{n}\left(-\sum_{j=1}^{\infty}\frac{x^{j\cdot v_i}}{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{\infty}\dfrac{x^{j\cdot v_i}}{j}
\]</span> 对于一个体积为 <span class="math inline">\(v_i\)</span> 的物品，它给 <span class="math inline">\(x^{v_i}\)</span> 的系数贡献了 <span class="math inline">\(1\)</span>，给 <span class="math inline">\(x^{2v_i}\)</span> 的系数贡献了 <span class="math inline">\(\dfrac{1}{2}\)</span>，给 <span class="math inline">\(x^{3v_i}\)</span> 的系数贡献了 <span class="math inline">\(\dfrac{1}{3}\)</span>，以此类推。</p>
<p>我们记录有几种物品的体积为 <span class="math inline">\(v_i\)</span>，设为 <span class="math inline">\(p[v_i]\)</span>。枚举 <span class="math inline">\([1,m]\)</span> 内的每一种体积 <span class="math inline">\(i\)</span>，枚举 <span class="math inline">\(i\)</span> 的倍数 <span class="math inline">\(j\)</span>，<span class="math inline">\(x^{j}\)</span> 的系数就加上 <span class="math inline">\(p[i]\cdot i\)</span>。这样一来，我们就在调和级数复杂度下计算出了 <span class="math inline">\(G(x)\)</span> 前 <span class="math inline">\(m\)</span> 项的所有系数。</p>
<p>利用多项式 <span class="math inline">\(\text{exp}\)</span> 即可在 <span class="math inline">\(O(m\log m)\)</span> 内还原出 <span class="math inline">\(F(x)\)</span>。</p>
<h3 id="i.-infinity">I. Infinity</h3>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78426715">Code</a></p>
<p><span class="math inline">\(\nu(\sigma)\)</span> 表示和 <span class="math inline">\(\sigma\)</span> 共轭的置换的数量。</p>
<p>两个置换共轭，当且仅当它们拥有相同的轮换结构。</p>
<p>记 <span class="math inline">\(\lambda_i\)</span> 表示 <span class="math inline">\(\sigma\)</span> 长度为 <span class="math inline">\(i\)</span> 的轮换个数，<span class="math inline">\(\sum\limits_{i=1}^{n}i\cdot \lambda_i=n\)</span>。那么 <span class="math display">\[
\nu(\sigma)=\frac{n!}{\prod\limits_{i=1}^{n}i^{\lambda_i}\cdot \lambda_i!}
\]</span> 其中 <span class="math inline">\(n!\)</span> 是全集。对于 <span class="math inline">\(\lambda_i\)</span> 个长度为 <span class="math inline">\(i\)</span> 的轮换，每种轮换都有 <span class="math inline">\(i\)</span> 种写法，比如 <span class="math inline">\((1\  2\  3)\)</span>，<span class="math inline">\((2\ 3\ 1)\)</span>，<span class="math inline">\((3\ 1\ 2)\)</span> 实际上是相同的轮换，所以要除掉 <span class="math inline">\(i^{\lambda_i}\)</span>。又因为这 <span class="math inline">\(\lambda_i\)</span> 种轮换本身是不可区分的，所以还要除个 <span class="math inline">\(\lambda_i!\)</span>。</p>
<p>那么，对于所有 <span class="math inline">\(n\)</span> 阶置换构成的集合 <span class="math inline">\(S_n\)</span>，我们枚举每一种轮换结构 <span class="math inline">\(\{\lambda_i\}\)</span>，设这个轮换结构对应的置换是 <span class="math inline">\(\sigma_1,\sigma_2,\ldots \sigma_{\nu(\sigma)}\)</span>，其中 <span class="math inline">\(\nu(\sigma_1)=\nu(\sigma_2)=\ldots=\nu(\sigma_{\nu(\sigma)})\)</span>，取一个代表元 <span class="math inline">\(\sigma_1\)</span>，该轮换结构下所有置换的 <span class="math inline">\(\nu(\sigma_i)^k\)</span> 之和，就是 <span class="math inline">\(\nu(\sigma_1)^{k+1}\)</span>。</p>
<p>于是，答案为 <span class="math display">\[
\sum_{\sum\limits_{i=1}^{n} i\cdot \lambda_i=n,\ 0\le \lambda_i\le n}\left(\dfrac{n!}{\prod\limits_{i=1}^{n}i^{\lambda_i}\cdot \lambda_i!}\right)^{k+1}
\]</span> 进一步，类似生成函数的组合意义，我们可以转换为多个幂级数相乘。 <span class="math display">\[
(n!)^{k+1}[x^n]\prod_{i=1}^{n}\left(\sum_{j=0}^\infty \frac{x^{ij}}{(i^jj!)^{k+1}}\right)
\]</span> 相当于将所有 <span class="math inline">\(i\cdot j=n\)</span> 的项取出来进行组合。</p>
<p>注意到 <span class="math display">\[
\sum_{j=0}^\infty \frac{x^{ij}}{(i^jj!)^{k+1}}
=
\sum_{j=0}^\infty \frac{\left(\dfrac{x^i}{i^{k+1}}\right)^j}{(j!)^{k+1}}
\]</span> 故令 <span class="math display">\[
F(x)=\sum_{j=0}^\infty \frac{x^j}{(j!)^{k+1}}
\]</span> 那么，答案是 <span class="math display">\[
(n!)^{k+1}[x^n]\prod_{i=1}^{n}F\left(\dfrac{x^i}{i^{k+1}}\right)
\]</span> 现在，<span class="math inline">\(k\)</span> 是固定的，有 <span class="math inline">\(t\)</span> 次询问，每次问一个 <span class="math inline">\(1\le n\le 2\cdot 10^5\)</span>。以下直接令 <span class="math inline">\(n=2\cdot 10^5\)</span>。</p>
<p>令 <span class="math display">\[
H(x)=\prod_{i=1}^{n}F\left(\dfrac{x^i}{i^{k+1}}\right)
\]</span> 我们肯定是想把 <span class="math inline">\(H(x)\)</span> 构造出来，然后 <span class="math inline">\(O(1)\)</span> 取它前 <span class="math inline">\(n\)</span> 项的系数。</p>
<p>观察 <span class="math inline">\(H(x)\)</span>，是 <span class="math inline">\(n\)</span> 个多项式相乘，就算每个多项式截断到 <span class="math inline">\(x^n\)</span>，乘起来也是 <span class="math inline">\(O(n^2\log n)\)</span> 的。</p>
<p>类似付公主的背包，我们取 <span class="math inline">\(L(x)=\ln H(x)\)</span>，<span class="math inline">\(G(x)=\ln F(x)\)</span>，那么 <span class="math display">\[
L(x) = \ln\prod_{i=1}^{n}F\left(\dfrac{x^i}{i^{k+1}}\right)=\sum_{i=1}^{n}\ln F\left(\dfrac{x^i}{i^{k+1}}\right)=\sum_{i=1}^{n}G\left(\dfrac{x^i}{i^{k+1}}\right)
\]</span> 其中，<span class="math inline">\(G(x)=\sum\limits_{i=0}^{n}g_ix^i\)</span>，有 <span class="math display">\[
L(x)=
\sum_{i=1}^{n}\sum_{j=0}^{n}g_j\left(\frac{x^{i}}{i^{k+1}}\right)^j
=
\sum_{i=1}^{n}\sum_{j=0}^{n}g_j\frac{x^{ij}}{i^{(k+1)\cdot j}}
\]</span> 到这里，我们就可以算出 <span class="math inline">\(L(x)\)</span> 的前 <span class="math inline">\(n\)</span> 项系数了。</p>
<p>对于每一对 <span class="math inline">\(i\cdot j=n\)</span>，为 <span class="math inline">\(x^{ij}\)</span> 的系数贡献了 <span class="math inline">\(g_j \cdot i^{-j(k+1)}\)</span>。而枚举每一对 <span class="math inline">\(i,j\)</span> 的过程，是调和级数复杂度。</p>
<p>多项式 <span class="math inline">\(\text{exp}\)</span> 即可求出 <span class="math inline">\(H(x)\)</span> 的前 <span class="math inline">\(n\)</span> 项系数。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="毒瘤场-3">【7.23】毒瘤场 3</h2>
<p>终于可以看别人受苦了。</p>
<h2 id="牛客多校-4">【7.24】牛客多校 4</h2>
<p>烂完了。</p>
<h3 id="i.-i-box">I. I, Box</h3>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78455039">Code</a></p>
<p>先判有无解。对于每一个连通块，如果 <code>@</code> 的数目不等于 <code>*</code> 的数目，就无解，否则肯定有解。</p>
<p>策略是：每次选择一个 <code>@</code>，BFS 找到离它最近的 <code>*</code>。把这条路径拿出来，路径上可能还包括了多个 <code>@</code> 和 <code>!</code>，这些箱子按先后顺序编号为 <span class="math inline">\(a_1,a_2,\ldots,a_l\)</span>。我们只需要将 <span class="math inline">\(a_{l-1}\)</span> 移动到 <span class="math inline">\(a_l\)</span>，<span class="math inline">\(a_{l-2}\)</span> 移动到 <span class="math inline">\(a_{l-1}\)</span>，<span class="math inline">\(\ldots\)</span>，<span class="math inline">\(a_{1}\)</span> 移动到 <span class="math inline">\(a_2\)</span>。</p>
<p>每次操作，推到位的箱子数都会多一个。不断这么操作，直到所有箱子都到位，时间复杂度显然不会超过 <span class="math inline">\(O(n^2m^2)\)</span>。</p>
<h2 id="杭电多校-3">【7.25】杭电多校 3</h2>
<h3 id="d.-三带一">D. 三带一</h3>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/contest/view-code?cid=1174&amp;rid=22676">Code</a></p>
<p>二分答案，设二分出的答案是 <span class="math inline">\(mid\)</span>。</p>
<p>设第 <span class="math inline">\(i\)</span> 堆有 <span class="math inline">\(b_i\)</span> 个形如 "XXX" 被使用，剩下 <span class="math inline">\(c_i=a_i-3b_i\)</span> 个 "X"。</p>
<p>令 <span class="math inline">\(A=\sum a_i\)</span>，<span class="math inline">\(B=\sum b_i=mid\)</span>，<span class="math inline">\(C=\sum c_i=A-3\cdot mid\)</span>。</p>
<p>首先，显然有</p>
<ul>
<li><span class="math inline">\(\forall i\in [1,n]\)</span>，<span class="math inline">\(b_i\le \left\lfloor\dfrac{a_i}{3}\right\rfloor\)</span>。</li>
</ul>
<p>进一步，每个 "XXX" 都要匹配一个 "Y"（"X" <span class="math inline">\(\neq\)</span> "Y"），那么</p>
<ul>
<li><span class="math inline">\(\forall i\in [1,n]\)</span>，<span class="math inline">\(b_i\le \sum\limits_{j=1,j\neq i}^{n}c_j=C-c_i\)</span>。</li>
</ul>
<p>代入 <span class="math inline">\(c_i=a_i-3\cdot b_i\)</span>，得 <span class="math inline">\(b_i\ge \left\lceil\dfrac{a_i-(A-3\cdot mid)}{2}\right\rceil\)</span>。</p>
<p>并且，还需要满足 <span class="math inline">\(B\le C\)</span>，即 <span class="math inline">\(mid\le A-3\cdot mid\)</span>，得 <span class="math inline">\(mid\le \left\lfloor\dfrac{A}{4}\right\rfloor\)</span>。</p>
<p>综合一下，有 <span class="math display">\[
\left[mid\le \left\lfloor\dfrac{A}{4}\right\rfloor\right]\land \left[\forall i\in [1,n],\ \left\lceil\dfrac{a_i-(A-3\cdot mid)}{2}\right\rceil\le b_i\le \left\lfloor\dfrac{a_i}{3}\right\rfloor\right]
\]</span></p>
<p>对每一个 <span class="math inline">\(b_i\)</span> 都能求出下界 <span class="math inline">\(l_i\)</span> 和上界 <span class="math inline">\(r_i\)</span>。</p>
<p>若 <span class="math inline">\(\exists i\)</span>，<span class="math inline">\(l_i&gt;r_i\)</span>，或 <span class="math inline">\(mid&lt;\sum l_i\)</span>，或 <span class="math inline">\(mid&gt;\sum r_i\)</span>，就判定失败；否则判定成功。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log w)\)</span>。</p>
<h2 id="ucup-3-3.-ukraine">【7.26】Ucup 3-3. Ukraine</h2>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/contest/1714">Contest Link</a></p>
<h3 id="h.-highway-hoax">H. Highway Hoax</h3>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/submission/1183581">Code</a></p>
<p>任选一个点为根。</p>
<p>注意到对于一个点 <span class="math inline">\(u\)</span>，<span class="math inline">\(u\)</span> 子树内 <span class="math inline">\(S\)</span> 的个数当且仅当边 <span class="math inline">\((fa[u], u)\)</span> 反转时会发生变化。</p>
<p>令 <span class="math inline">\(dp[u][0/1]\)</span> 表示，在以 <span class="math inline">\(u\)</span> 为根的子树中，有多少种合法的标号方案，使得边 <span class="math inline">\((fa[u], u)\)</span> 保持初始方向 <span class="math inline">\(/\)</span> 反转。</p>
<p>设 <span class="math inline">\(u\)</span> 的儿子为 <span class="math inline">\(v_1,v_2,v_3,\ldots, v_m\)</span>，转移时，我们关注以所有 <span class="math inline">\(v_i\)</span> 为根的子树中 <span class="math inline">\(S\)</span> 的和。</p>
<p>假设我们已经求出了 <span class="math inline">\(dp[v][0/1]\)</span>，直接树形背包的时间复杂度显然无力应对，考虑生成函数。</p>
<p>尝试将 <span class="math inline">\(x^k\ (k\in \{-1,0,1\})\)</span> 的系数表示为子树中 <span class="math inline">\(S\)</span> 变化 <span class="math inline">\(k\)</span> 个的方案数。举个具体的例子：</p>
<ul>
<li>如果初始边 <span class="math inline">\((u,v_i)\)</span> 的方向为 <span class="math inline">\(u\to v_i\)</span>，不反转 <span class="math inline">\(S\)</span> 变化 <span class="math inline">\(0\)</span> 个，反转后 <span class="math inline">\(S\)</span> 变化 <span class="math inline">\(+1\)</span> 个。</li>
<li>如果初始边 <span class="math inline">\((u,v_i)\)</span> 的方向为 <span class="math inline">\(v_i\to u\)</span>，不反转 <span class="math inline">\(S\)</span> 变化 <span class="math inline">\(0\)</span> 个，反转后 <span class="math inline">\(S\)</span> 变化 <span class="math inline">\(-1\)</span> 个。</li>
</ul>
<p>那么对于 <span class="math inline">\(u\to v_i\)</span> 的情况，生成函数为 <span class="math inline">\(G_i(x)=dp[v_i][0]+dp[v_i][1]\cdot x\)</span>。</p>
<p>对于 <span class="math inline">\(v_i\to u\)</span> 的情况，生成函数为 <span class="math inline">\(G_i(x)=dp[v_i][0]+dp[v_i][1]\cdot x^{-1}\)</span>。</p>
<p>这里有妙手，我们提一个 <span class="math inline">\(x^{-1}\)</span> 出来，就变成 <span class="math inline">\(G_i(x)=x^{-1}(dp[v_i][1]+dp[v_i][0]\cdot x)\)</span>，这样两种情况形式就统一了。即，只需记一下乘了多少个 <span class="math inline">\(x^{-1}\)</span>（或者说有多少条边方向是 <span class="math inline">\(v_i\to u\)</span>，记为 <span class="math inline">\(cnt\)</span>），后面乘的时候就不用带上 <span class="math inline">\(x^{-1}\)</span> 了。</p>
<p>令 <span class="math inline">\(F(x)=\prod\limits_{i=1}^{m}G_i(x)\)</span>，<span class="math inline">\(x^k\)</span> 的系数就表示所有 <span class="math inline">\(v_i\)</span> 的子树一共增加了 <span class="math inline">\(k+cnt\)</span> 个 <span class="math inline">\(S\)</span> 的方案数。这一步用分治 NTT 容易求出。</p>
<p>现在考虑状态转移。依靠的是 "<span class="math inline">\(u\)</span> 的子树中 <span class="math inline">\(S\)</span> 的变化量 <span class="math inline">\(=\)</span> 节点 <span class="math inline">\(u\)</span> 自身 <span class="math inline">\(S\)</span> 的变化量（根据 <span class="math inline">\((fa[u],u)\)</span> 是否反转可以是 <span class="math inline">\(-1,\ 0,\ 1\)</span>）<span class="math inline">\(+\)</span> 所有 <span class="math inline">\(v_i\)</span> 的子树中 <span class="math inline">\(S\)</span> 的变化量之和"。</p>
<p>后者就是 <span class="math inline">\(F(x)\)</span> 中的对应系数，分 "<span class="math inline">\(fa[u]\)</span> 原本是 <span class="math inline">\(S\)</span> 还是 <span class="math inline">\(F\)</span> " 和 "<span class="math inline">\((fa[u],u)\)</span> 是否反转" 进行转移即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h2 id="杭电多校-4">【7.28】杭电多校 4</h2>
<h3 id="hdu7503.-rikka-与子集-iv">HDU7503. Rikka 与子集 IV</h3>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=7503">Problem Link</a></p>
<p>任选一个点为根，比如 <span class="math inline">\(1\)</span>。</p>
<p>令 <span class="math inline">\(dp[x][i]\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树内，包含 <span class="math inline">\(x\)</span> 且大小为 <span class="math inline">\(i\)</span> 的连通子图个数，那么 <span class="math display">\[
dp[x][i]=\sum_{i=j+k} dp[x][j]\cdot dp[y][k]
\]</span> 树形背包大多都能用生成函数优化。尝试将 <span class="math inline">\([x^j]F_i(x)\)</span> 刻画为以 <span class="math inline">\(i\)</span> 为根的子树中，包含 <span class="math inline">\(i\)</span> 且大小为 <span class="math inline">\(j\)</span> 的连通子图个数。那么 <span class="math display">\[
F_i(x)=1+x\prod_{j\in \text{son}(i)}F_j(x)
\]</span> 开头加的 <span class="math inline">\(1\)</span> 对应 <span class="math inline">\(dp[x][0]=1\)</span>，表示不选。</p>
<p>再令 <span class="math inline">\(S_i(x)=\sum\limits_{j\in \text{subtree}(i),\ j\neq i}F_j(x)\)</span>，答案就是 <span class="math inline">\([x^k](F_1(x)+S_1(x))\)</span>。</p>
<p>直接算仍旧是 <span class="math inline">\(O(n^2\log n)\)</span>，考虑重链剖分。</p>
<p>令 <span class="math inline">\(s_i\)</span> 表示点 <span class="math inline">\(i\)</span> 的重儿子，我们的目标是找到 <span class="math inline">\(\{F_i(x),S_i(x)\}\)</span> 和 <span class="math inline">\(\{F_{s_i}(x),S_{s_i}(x)\}\)</span> 之间的递推关系。</p>
<p>令 <span class="math inline">\(G_i(x)=\prod\limits_{j\in \text{light}(i)}F_j(x)\)</span>，<span class="math inline">\(T_i(x)=\sum\limits_{j\in \text{light}(i)}(F_j(x)+S_j(x))\)</span>，那么</p>
<p><span class="math display">\[
\begin{align}
F_i(x)&amp;=1+x G_i(x) F_{s_i}(x)\\
S_i(x)&amp;=T_i(x)+F_{s_i}(x)+S_{s_i}(x)
\end{align}
\]</span></p>
<p>写成矩阵形式，有 <span class="math display">\[
\pmatrix{F_i(x) \\ 1\\ S_i(x)}=\pmatrix{xG_i(x) &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 1 &amp; T_i(x) &amp; 1}\pmatrix{F_{s_i}(x) \\ 1 \\ S_{s_i}(x)}
\]</span> 边界情况是 <span class="math inline">\(F_{\text{leaf}}(x)=1+x\)</span>，<span class="math inline">\(S_{\text{leaf}}(x)=0\)</span>。</p>
<p>于是，我们的策略是：</p>
<ul>
<li>从根开始 dfs，一直走轻边，走到底回溯，首先叶子的 <span class="math inline">\(F\)</span> 和 <span class="math inline">\(S\)</span> 是知道的。</li>
<li>回溯的时候，对每个点 <span class="math inline">\(i\)</span>，分治 NTT 合并它所有轻儿子的 <span class="math inline">\(F\)</span>，得 <span class="math inline">\(G_i(x)\)</span>。而 <span class="math inline">\(T_i(x)\)</span> 也能通过普通的多项式加减得到。</li>
<li>如此一来，对于一条重链，我们知道了其上所有点的 <span class="math inline">\(G_i(x)\)</span> 和 <span class="math inline">\(T_i(x)\)</span>。换句话说，知道了重链上每个点的转移矩阵。</li>
<li>两个矩阵相乘相当于若干次多项式乘法。再次用分治 NTT 将这条重链上的所有矩阵合并。这一步基于矩阵具有结合律。</li>
</ul>
<p>这样就求得了每条重链链顶的 <span class="math inline">\(F\)</span> 和 <span class="math inline">\(S\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^3 n)\)</span>。</p>
<p>HDU 的 submission 貌似只能看自己的，代码就贴下面好了。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fre(x) freopen(#x<span class="hljs-string">&quot;.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin); freopen(#x<span class="hljs-string">&quot;.out&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ck(x)  &#123; cout &lt;&lt; <span class="hljs-string">&quot;check &quot;</span> &lt;&lt; x &lt;&lt; endl;&#125;</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffffffffffff</span>

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> G = <span class="hljs-number">3</span>; <span class="hljs-comment">// 原根</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> ( ; n; n &gt;&gt;= <span class="hljs-number">1</span>, k = k * k % mod) &#123;
		<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) s = s * k % mod;
	&#125;
	<span class="hljs-keyword">return</span> s;
&#125;

<span class="hljs-comment">// ---------- 多项式乘法 (NTT) ---------- </span>

vector&lt;<span class="hljs-type">int</span>&gt; rev;
vector&lt;<span class="hljs-type">int</span>&gt; rt&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;
	<span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();
	<span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)rev.<span class="hljs-built_in">size</span>() != n) &#123;
		<span class="hljs-type">int</span> k = __builtin_ctz(n) - <span class="hljs-number">1</span>;
		rev.<span class="hljs-built_in">resize</span>(n);
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
			rev[i] = rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span> | (i &amp; <span class="hljs-number">1</span>) &lt;&lt; k;
		&#125;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		<span class="hljs-keyword">if</span> (rev[i] &lt; i) &#123;
			<span class="hljs-built_in">swap</span>(a[i], a[rev[i]]);
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)rt.<span class="hljs-built_in">size</span>() &lt; n) &#123;
		<span class="hljs-type">int</span> k = __builtin_ctz(rt.<span class="hljs-built_in">size</span>());
		rt.<span class="hljs-built_in">resize</span>(n);
		<span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; k) &lt; n) &#123;
			<span class="hljs-type">int</span> e = <span class="hljs-built_in">qpow</span>(G, (mod - <span class="hljs-number">1</span>) &gt;&gt; (k + <span class="hljs-number">1</span>));
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>); i &lt; (<span class="hljs-number">1</span> &lt;&lt; k); i++) &#123;
				rt[<span class="hljs-number">2</span> * i] = rt[i];
				rt[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = rt[i] * e % mod;
			&#125;
			k++;
		&#125;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; n; k *= <span class="hljs-number">2</span>) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span> * k) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;
				<span class="hljs-type">int</span> u = a[i + j];
				<span class="hljs-type">int</span> v = a[i + j + k] * rt[k + j] % mod;
				a[i + j] = (u + v) % mod;
				a[i + j + k] = (u - v + mod) % mod;
			&#125;
		&#125;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;
	<span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();
	<span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">end</span>());
	<span class="hljs-built_in">dft</span>(a);
	<span class="hljs-type">int</span> inv = <span class="hljs-built_in">qpow</span>(n, mod - <span class="hljs-number">2</span>);
	inv = (inv + mod) % mod;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
		a[i] *= inv;
		a[i] %= mod;
	&#125;
&#125;
vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">operator</span>*(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;
	<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>() || b.<span class="hljs-built_in">empty</span>()) &#123;
		<span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>&#125;;
	&#125;
	<span class="hljs-type">int</span> sz = <span class="hljs-number">1</span>, tot = a.<span class="hljs-built_in">size</span>() + b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (sz &lt; tot) &#123;
		sz &lt;&lt;= <span class="hljs-number">1</span>;
	&#125;
	a.<span class="hljs-built_in">resize</span>(sz);
	b.<span class="hljs-built_in">resize</span>(sz);
	<span class="hljs-built_in">dft</span>(a);
	<span class="hljs-built_in">dft</span>(b);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;
		a[i] *= b[i];
		a[i] %= mod;
	&#125;
	<span class="hljs-built_in">idft</span>(a);
	a.<span class="hljs-built_in">resize</span>(tot);
	<span class="hljs-keyword">return</span> a;
&#125;

<span class="hljs-comment">// ---------- 多项式加减、求导、积分 ----------</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shrink</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;
	<span class="hljs-keyword">while</span> (a.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; a.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;
		a.<span class="hljs-built_in">pop_back</span>();
	&#125;
	<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) &#123;
		a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
	&#125;
&#125;
vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">operator</span>+(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;
	a.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">size</span>(), b.<span class="hljs-built_in">size</span>()));
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); i++) &#123;
		a[i] += b[i];
		a[i] %= mod;
	&#125;
	<span class="hljs-built_in">shrink</span>(a);
	<span class="hljs-keyword">return</span> a;
&#125;
vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">operator</span>-(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b) &#123;
	a.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">max</span>(a.<span class="hljs-built_in">size</span>(), b.<span class="hljs-built_in">size</span>()));
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); i++) &#123;
		a[i] -= b[i];
		a[i] = (a[i] + mod) % mod;
	&#125;
	<span class="hljs-built_in">shrink</span>(a);
	<span class="hljs-keyword">return</span> a;
&#125;
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_deriv</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) &#123;
		<span class="hljs-keyword">return</span> &#123;&#125;;
	&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;
		a[i] = a[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;
	&#125;
	a.<span class="hljs-built_in">pop_back</span>();
	<span class="hljs-built_in">shrink</span>(a);
	<span class="hljs-keyword">return</span> a;
&#125;
vector&lt;<span class="hljs-type">int</span>&gt; invt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_inv</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (invt.<span class="hljs-built_in">empty</span>()) &#123;
        invt.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);
        invt[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-type">int</span> sz = invt.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">if</span> (n &lt;= sz) &#123;
    	<span class="hljs-keyword">return</span>;
    &#125;
    invt.<span class="hljs-built_in">resize</span>(n);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sz; i &lt; n; i++) &#123;
        invt[i] = (mod - invt[mod % i] * (mod / i) % mod) % mod;
    &#125;
&#125;
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_integral</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) &#123;
		<span class="hljs-keyword">return</span> &#123;&#125;;
	&#125;
    <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();
    <span class="hljs-built_in">pre_inv</span>(n + <span class="hljs-number">1</span>);
	a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i--) &#123;
		a[i] = a[i - <span class="hljs-number">1</span>] * invt[i] % mod;
	&#125;
	a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
	<span class="hljs-built_in">shrink</span>(a);
	<span class="hljs-keyword">return</span> a;
&#125;

<span class="hljs-comment">// ---------- 多项式求逆 (牛顿迭代法) ----------</span>

<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_inv</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> &#123;&#125;;
	&#125;
	vector&lt;<span class="hljs-type">int</span>&gt; b = &#123;<span class="hljs-built_in">qpow</span>(a[<span class="hljs-number">0</span>], mod - <span class="hljs-number">2</span>)&#125;;
	<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (k &lt; n) &#123;
		k &lt;&lt;= <span class="hljs-number">1</span>;
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(a.begin(), a.begin() + min((<span class="hljs-type">int</span>)a.size(), k))</span></span>;
		c = c * b;
		c.<span class="hljs-built_in">resize</span>(k);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : c) &#123;
			x = mod - x;
		&#125;
		c[<span class="hljs-number">0</span>] = (c[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>) % mod;
		b = b * c;
		b.<span class="hljs-built_in">resize</span>(k);
	&#125;
	b.<span class="hljs-built_in">resize</span>(n);
	<span class="hljs-keyword">return</span> b;
&#125;

<span class="hljs-comment">// ---------- 多项式除法、取模、单点求值 ----------</span>

pair&lt;vector&lt;<span class="hljs-type">int</span>&gt;, vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">poly_div</span>(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;
	<span class="hljs-built_in">shrink</span>(a);
	<span class="hljs-built_in">shrink</span>(b);
	<span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();
	<span class="hljs-type">int</span> m = b.<span class="hljs-built_in">size</span>();
	<span class="hljs-keyword">if</span> (n &lt; m) &#123;
		<span class="hljs-keyword">return</span> &#123;&#123;<span class="hljs-number">0</span>&#125;, a&#125;;
	&#125;
	<span class="hljs-keyword">auto</span> ar = a, br = b;
	<span class="hljs-built_in">reverse</span>(ar.<span class="hljs-built_in">begin</span>(), ar.<span class="hljs-built_in">end</span>());
	<span class="hljs-built_in">reverse</span>(br.<span class="hljs-built_in">begin</span>(), br.<span class="hljs-built_in">end</span>());
	<span class="hljs-type">int</span> len = n - m + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">auto</span> br_inv = <span class="hljs-built_in">poly_inv</span>(br, len);
	<span class="hljs-keyword">auto</span> qr = ar * br_inv;
	qr.<span class="hljs-built_in">resize</span>(len);
	<span class="hljs-built_in">reverse</span>(qr.<span class="hljs-built_in">begin</span>(), qr.<span class="hljs-built_in">end</span>());
	<span class="hljs-keyword">auto</span> qb = qr * b;
	<span class="hljs-keyword">auto</span> r = a - qb;
	<span class="hljs-built_in">shrink</span>(qr);
	<span class="hljs-built_in">shrink</span>(r);
	<span class="hljs-keyword">return</span> &#123;qr, r&#125;;
&#125;
vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-keyword">operator</span>%(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b) &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">poly_div</span>(a, b).second;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;F, <span class="hljs-type">int</span> x)</span> </span>&#123;
	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = F.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
		res = (res * x + F[i]) % mod;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// ---------- 多项式对数函数 O(NlogN) ----------</span>

<span class="hljs-comment">// 要求: a[0] == 1</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_log</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-built_in">assert</span>(!a.<span class="hljs-built_in">empty</span>() &amp;&amp; a[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>);
	a.<span class="hljs-built_in">resize</span>(n);
	<span class="hljs-keyword">auto</span> deriv_a = <span class="hljs-built_in">poly_deriv</span>(a);
	<span class="hljs-keyword">auto</span> inv_a = <span class="hljs-built_in">poly_inv</span>(a, n);
	<span class="hljs-keyword">auto</span> res = deriv_a * inv_a;
	res.<span class="hljs-built_in">resize</span>(n);
	res = <span class="hljs-built_in">poly_integral</span>(res);
	res.<span class="hljs-built_in">resize</span>(n);
	<span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// ---------- 多项式指数函数 O(NlogN) ----------</span>

<span class="hljs-comment">// 要求: a[0] == 0</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_exp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-built_in">assert</span>(a.<span class="hljs-built_in">empty</span>() || a[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>);
	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;
		<span class="hljs-keyword">return</span> &#123;&#125;;
	&#125;
	vector&lt;<span class="hljs-type">int</span>&gt; b = &#123;<span class="hljs-number">1</span>&#125;;
	a.<span class="hljs-built_in">resize</span>(n);
	<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (k &lt; n) &#123;
		k &lt;&lt;= <span class="hljs-number">1</span>;
		<span class="hljs-keyword">auto</span> log_b = <span class="hljs-built_in">poly_log</span>(b, k);
		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(a.begin(), a.begin() + min((<span class="hljs-type">int</span>)a.size(), k))</span></span>;
		c.<span class="hljs-built_in">resize</span>(k, <span class="hljs-number">0</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;
			c[i] = (c[i] - log_b[i] + mod) % mod;
		&#125;
		c[<span class="hljs-number">0</span>] = (c[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) % mod;
		b = b * c;
		b.<span class="hljs-built_in">resize</span>(k);
	&#125;
	b.<span class="hljs-built_in">resize</span>(n);
	<span class="hljs-keyword">return</span> b;
&#125;

<span class="hljs-comment">// ---------- 多项式快速幂 O(NlogN) ----------</span>

<span class="hljs-comment">// 计算 A(x)^k mod x^n</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">poly_pow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;
	<span class="hljs-built_in">shrink</span>(a);
    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>() || a.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; a[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);
    &#125;
	<span class="hljs-type">int</span> d = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;
		<span class="hljs-keyword">if</span> (a[i] != <span class="hljs-number">0</span>) &#123;
			d = i;
			<span class="hljs-keyword">break</span>;
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> (d == <span class="hljs-number">-1</span> || d * k &gt;= n) &#123;
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-type">int</span> c = a[d];
	<span class="hljs-type">int</span> c_inv = <span class="hljs-built_in">qpow</span>(c, mod - <span class="hljs-number">2</span>);
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ap</span><span class="hljs-params">(a.size() - d)</span></span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ap.<span class="hljs-built_in">size</span>(); i++) &#123;
		ap[i] = a[i + d] * c_inv % mod;
	&#125;
	ap = <span class="hljs-built_in">poly_log</span>(ap, n);
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x : ap) &#123;
		x = x * k % mod;
	&#125;
	ap = <span class="hljs-built_in">poly_exp</span>(ap, n);
	<span class="hljs-type">int</span> ck = <span class="hljs-built_in">qpow</span>(c, k);
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + d * k &lt; n &amp;&amp; i &lt; ap.<span class="hljs-built_in">size</span>(); i++) &#123;
		res[i + d * k] = ap[i] * ck % mod;
	&#125;
	<span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-comment">// ---------- 多项式多点求值 O(Mlog^2M) ----------</span>

vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ptr;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_ptr</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (l == r) &#123;
		ptr[p] = &#123;(mod - A[l]) % mod, <span class="hljs-number">1</span>&#125;;
		<span class="hljs-keyword">return</span> ;
	&#125;
	<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
	<span class="hljs-built_in">build_ptr</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, A);
	<span class="hljs-built_in">build_ptr</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, A);
	ptr[p] = ptr[p &lt;&lt; <span class="hljs-number">1</span>] * ptr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc_ptr</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; F, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (r - l &lt; <span class="hljs-number">64</span>) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;
			res[i] = <span class="hljs-built_in">eval</span>(F, A[i]);
		&#125;
		<span class="hljs-keyword">return</span> ;
	&#125;
	F = F % ptr[p];
	<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
	<span class="hljs-built_in">calc_ptr</span>(F, p &lt;&lt; <span class="hljs-number">1</span>, l, mid, A, res);
	<span class="hljs-built_in">calc_ptr</span>(F, p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, A, res);
&#125;
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">multi_eval</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;F, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">empty</span>()) &#123;
		<span class="hljs-keyword">return</span> &#123;&#125;;
	&#125;
	<span class="hljs-type">int</span> m = A.<span class="hljs-built_in">size</span>();
	ptr.<span class="hljs-built_in">assign</span>(<span class="hljs-number">4</span> * m, &#123;&#125;);
	<span class="hljs-built_in">build_ptr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, A);
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m)</span></span>;
	<span class="hljs-built_in">calc_ptr</span>(F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>, A, res);
	<span class="hljs-keyword">return</span> res;
&#125;



<span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span> &#123;
	<span class="hljs-type">int</span> n, m;
	vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; a;
	<span class="hljs-built_in">matrix</span>() &#123;&#125;
	<span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">m</span>(m), <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>(m, vector&lt;<span class="hljs-type">int</span>&gt;&#123;&#125;)) &#123;&#125;
&#125;;
matrix <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> matrix &amp;x, <span class="hljs-type">const</span> matrix &amp;y) &#123;
	<span class="hljs-built_in">assert</span>(x.m == y.n);
	<span class="hljs-function">matrix <span class="hljs-title">z</span><span class="hljs-params">(x.n, y.m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; x.m; k++) &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.n; i++) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; y.m; j++) &#123;
				<span class="hljs-keyword">if</span> (x.a[i][k].<span class="hljs-built_in">empty</span>() || y.a[k][j].<span class="hljs-built_in">empty</span>()) &#123;
					<span class="hljs-keyword">continue</span>;
				&#125;
				z.a[i][j] = z.a[i][j] + x.a[i][k] * y.a[k][j];
			&#125;
		&#125;
	&#125;
	<span class="hljs-keyword">return</span> z;
&#125;


<span class="hljs-comment">//-------------- templates above --------------</span>


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n;
	cin &gt;&gt; n;
	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		adj[x].<span class="hljs-built_in">push_back</span>(i);
	&#125;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">son</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
	<span class="hljs-keyword">auto</span> dfs1 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-type">int</span> cnt = <span class="hljs-number">-1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[x]) &#123;
			<span class="hljs-built_in">self</span>(self, y);
			sz[x] += sz[y];
			<span class="hljs-keyword">if</span> (sz[y] &gt; cnt) &#123;
				cnt = sz[y];
				son[x] = y;
			&#125;	
		&#125;
	&#125;; 
	<span class="hljs-built_in">dfs1</span>(dfs1, <span class="hljs-number">1</span>);

	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">F</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">S</span>(n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">auto</span> dfs2 = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i = son[i]) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[i]) &#123;
				<span class="hljs-keyword">if</span> (y != son[i]) &#123;
					<span class="hljs-built_in">self</span>(self, y);
				&#125;
			&#125;
		&#125;
		vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; set_G, set_T;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i = son[i]) &#123;
			vector&lt;<span class="hljs-type">int</span>&gt; T; 
			vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; set_F;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : adj[i]) &#123;
				<span class="hljs-keyword">if</span> (y != son[i]) &#123;
					T = T + F[y];
					T = T + S[y];
					set_F.<span class="hljs-built_in">push_back</span>(F[y]);
				&#125;
			&#125;
			<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; vector&lt;<span class="hljs-type">int</span>&gt; &#123;
				<span class="hljs-keyword">if</span> (l == r) &#123;
					<span class="hljs-keyword">return</span> set_F[l];
				&#125;
				<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>(self, l, mid) * <span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">1</span>, r);
			&#125;;
			vector&lt;<span class="hljs-type">int</span>&gt; G;
			<span class="hljs-keyword">if</span> (set_F.<span class="hljs-built_in">empty</span>()) &#123;
				G = &#123;<span class="hljs-number">1</span>&#125;;
			&#125; <span class="hljs-keyword">else</span> &#123;
				G = <span class="hljs-built_in">calc</span>(calc, <span class="hljs-number">0</span>, set_F.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
			&#125;
			set_G.<span class="hljs-built_in">push_back</span>(G);
			set_T.<span class="hljs-built_in">push_back</span>(T);
		&#125;
		<span class="hljs-keyword">auto</span> calc = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) -&gt; matrix &#123;
			<span class="hljs-keyword">if</span> (l == r) &#123;
				matrix <span class="hljs-built_in">res</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);
				res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = set_G[l];
				res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);
				res.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>&#125;;
				res.a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>&#125;;
				res.a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>&#125;;
				res.a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = set_T[l];
				res.a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>&#125;;
				<span class="hljs-keyword">return</span> res;	
			&#125;
			<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>(self, l, mid) * <span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">1</span>, r); 
		&#125;;
		<span class="hljs-function">matrix <span class="hljs-title">leaf</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)</span></span>;
		leaf.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;
		leaf.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>&#125;;

		matrix res;
		<span class="hljs-keyword">if</span> (set_G.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;
			res = leaf;
		&#125; <span class="hljs-keyword">else</span> &#123;
			res = <span class="hljs-built_in">calc</span>(calc, <span class="hljs-number">0</span>, set_G.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) * leaf;
		&#125;

		F[x] = res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
		S[x] = res.a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>];
	&#125;;
	<span class="hljs-built_in">dfs2</span>(dfs2, <span class="hljs-number">1</span>);

	<span class="hljs-keyword">auto</span> res = F[<span class="hljs-number">1</span>] + S[<span class="hljs-number">1</span>];
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		cout &lt;&lt; (i &lt; res.<span class="hljs-built_in">size</span>() ? res[i] : <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];
	&#125;
&#125;


<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">fre</span>(test);
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);

	<span class="hljs-type">int</span> T;
	cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		<span class="hljs-built_in">solve</span>();
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

    </div>
</div>
<h2 id="牛客多校-5">【7.29】牛客多校 5</h2>
<h3 id="c.-array-deletion-game">C. Array Deletion Game</h3>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78535003">Code</a></p>
<p>结论：若 <span class="math inline">\(\sum\limits_{i=l+1}^{r-1}&gt;s\)</span>，那么 <span class="math inline">\((l, r)\)</span> 与 <span class="math inline">\((l+1, r-1)\)</span> 胜负态相同。</p>
<ul>
<li>若 <span class="math inline">\((l, r)\)</span> 是必胜态 <span class="math inline">\(\to\)</span> <span class="math inline">\(\{\)</span>要么 <span class="math inline">\((l,r-1)\)</span> 必败<span class="math inline">\(\}\)</span> <span class="math inline">\((1)\)</span>，<span class="math inline">\(\{\)</span>要么 <span class="math inline">\((l+1,r)\)</span> 必败<span class="math inline">\(\}\)</span> <span class="math inline">\((2)\)</span>。
<ul>
<li><span class="math inline">\((1)\)</span> 和 <span class="math inline">\((2)\)</span> 都能推出 <span class="math inline">\((l+1,r-1)\)</span> 必胜。</li>
</ul></li>
<li>若 <span class="math inline">\((l, r)\)</span> 是必败态 <span class="math inline">\(\to\)</span> <span class="math inline">\(\{(l+1,r)\)</span> 必胜<span class="math inline">\(\}\)</span> <span class="math inline">\((3)\)</span>，且 <span class="math inline">\(\{(l,r-1)\)</span> 必胜<span class="math inline">\(\}\)</span> <span class="math inline">\((4)\)</span>。
<ul>
<li><span class="math inline">\((3)\)</span> 推出 <span class="math inline">\(\{\)</span>要么 <span class="math inline">\((l+1,r-1)\)</span> 必败，要么 <span class="math inline">\((l+2,r)\)</span> 必败<span class="math inline">\(\}\)</span> <span class="math inline">\((5)\)</span>。</li>
<li><span class="math inline">\((4)\)</span> 推出 <span class="math inline">\(\{\)</span>要么 <span class="math inline">\((l+1,r-1)\)</span> 必败，要么 <span class="math inline">\((l,r-2)\)</span> 必败<span class="math inline">\(\}\)</span> <span class="math inline">\((6)\)</span>。</li>
<li>如果 <span class="math inline">\((5)\)</span> 和 <span class="math inline">\((6)\)</span> 中第一个子句有一个成立，那么 <span class="math inline">\((l+1,r-1)\)</span> 必败。</li>
<li>否则 <span class="math inline">\(\{(l+2,r)\)</span> 必败<span class="math inline">\(\}\)</span> <span class="math inline">\((7)\)</span>，且 <span class="math inline">\(\{(l,r-2)\)</span> 必败<span class="math inline">\(\}\)</span> <span class="math inline">\((8)\)</span>。</li>
<li><span class="math inline">\((7)\)</span> 推出 <span class="math inline">\(\{(l+2,r-1)\)</span> 必胜<span class="math inline">\(\}\)</span> <span class="math inline">\((9)\)</span>，<span class="math inline">\((8)\)</span> 推出 <span class="math inline">\(\{(l+1,r-2)\)</span> 必胜<span class="math inline">\(\}\)</span> <span class="math inline">\((10)\)</span>。</li>
<li>假设 <span class="math inline">\((l+1,r-1)\)</span> 是必胜态，那么推出 <span class="math inline">\(\{(l+2,r-1)\)</span> 必败，或 <span class="math inline">\((l+1,r-2)\)</span> 必败<span class="math inline">\(\}\)</span>，这与 <span class="math inline">\((9)(10)\)</span> 矛盾。</li>
<li>因此，<span class="math inline">\((l+1,r-1)\)</span> 必败。</li>
</ul></li>
</ul>
<p>得证。</p>
<p>因此，我们可以不断把序列两端各砍掉一个，直到当前 <span class="math inline">\(l&#39;, r&#39;\)</span> 满足 <span class="math inline">\(\sum\limits_{i=l&#39;+1}^{r&#39;-1}\le s\)</span>，即再两边砍一个就寄。</p>
<p>此时玩家只能不断从一边取数，胜负态确定。</p>
<p>具体的，设 <span class="math inline">\(fl\)</span> 表示最大的下标，满足拿掉 <span class="math inline">\(fl\)</span> 后 <span class="math inline">\((fl+1,r&#39;)\)</span> 这一段就 <span class="math inline">\(\le s\)</span>；设 <span class="math inline">\(fr\)</span> 表示最小的下标，满足拿掉 <span class="math inline">\(fr\)</span> 后 <span class="math inline">\((l&#39;, fr-1)\)</span> 这一段就 <span class="math inline">\(\le s\)</span>。<span class="math inline">\((l&#39;,r&#39;)\)</span> 先手必胜当且仅当 <span class="math inline">\(fl-l&#39;\)</span> 是奇数或者 <span class="math inline">\(r&#39;-fr\)</span> 是奇数。</p>
<p>对于一次询问，先一遍二分找出 <span class="math inline">\((l&#39;,r&#39;)\)</span>，再两遍二分找出 <span class="math inline">\(fl,fr\)</span>。时间复杂度 <span class="math inline">\(O(q\log n)\)</span>。</p>
<h2 id="nwerc-2024">【7.30】NWERC 2024</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/626008">Contest Link</a></p>
<p>放松场，做的貌似全是签到。剩个 B，队友补了就是我补了（确信</p>
<h2 id="牛客多校-6">【7.31】牛客多校 6</h2>
<p>发烧了，头很痛，没打。去校医院开了两盒药，一觉睡到晚上，随手点开题解里的一个 easy-mid，发现榜上只过了 20+，没绷住。</p>
<h2 id="ucup3-18.-seerc-2024">【8.1】Ucup3-18. SEERC 2024</h2>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/contest/1849">Contest Link</a></p>
<p>感觉没 hdu 有意思，先补一下 hdu。</p>
<h3 id="lutece3353.-a-boring-game">Lutece3353. A Boring Game</h3>
<p><a target="_blank" rel="noopener" href="https://cdoj.site/d/lutece/record/688cc1ce385b3643f339badf">Code</a></p>
<p>今日 hdu 的 A 题弱化，先写一下这题。</p>
<p>建出一棵 <span class="math inline">\((i,a_i)\)</span> 大根笛卡尔树。</p>
<p>假设当前在点 <span class="math inline">\(i\)</span>，那么点 <span class="math inline">\(i\)</span> 子树里的点肯定都能被攻破，相当于每次看 "利用当前子树里的所有资源，能否向根节点前进一步"。</p>
<p>具体的，令 <span class="math inline">\(S_x=\sum\limits_{y\in\text{subtree}(x)} b_y\)</span>，那么 <span class="math inline">\(x\)</span> 能走到 <span class="math inline">\(fa_x\)</span> 当且仅当 <span class="math inline">\(v+S_x\ge a_{fa_x}\)</span>，其中 <span class="math inline">\(v\)</span> 表示角色的初始攻击力。</p>
<p>也就是说，当 <span class="math inline">\(a_{fa_x}-S_x&gt; v\)</span> 时，角色就无法继续移动了。对于一个询问 <span class="math inline">\((p,v)\)</span>，我们找到 <span class="math inline">\(p\)</span> 到根节点的路径上第一个满足 <span class="math inline">\(a_{fa_x}-S_x&gt;v\)</span> 的点 <span class="math inline">\(x\)</span>，答案就是 <span class="math inline">\(v+S_x\)</span>。而找到 <span class="math inline">\(x\)</span> 的过程可以用倍增实现。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="a.-一个更无聊的游戏">A. 一个更无聊的游戏</h3>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/contest/view-code?cid=1176&amp;rid=14865">Code</a></p>
<p>上一题放到了树上。我们仍旧考虑建出 <span class="math inline">\((i,a_i)\)</span> 大根笛卡尔树。</p>
<p>类似点分治的过程，找到最大的 <span class="math inline">\(a_i\)</span>，划分为若干子树，然后递归下去。</p>
<p>比较巧妙的做法是类似今年四川省赛，倒着考虑，按 <span class="math inline">\(a_i\)</span> 从小到大枚举 <span class="math inline">\(i\)</span>，遍历 <span class="math inline">\(i\)</span> 的邻居 <span class="math inline">\(j\)</span>，如果 <span class="math inline">\(j\)</span> 被遍历过，就把 <span class="math inline">\(i\)</span> 设为 <span class="math inline">\(j\)</span> 所在连通块的根的祖先。</p>
<p>建出笛卡尔树后就和上一题无异了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="ptz-winter-camp-2021-day-8">【8.2】Ptz Winter Camp 2021 Day 8</h2>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/contest/536">Contest Link</a></p>
<p>今天脑子有点好，感觉写了很多题，不过还是没搞出 E，可惜。</p>
<h3 id="f.-border-similarity-undertaking">F. Border Similarity Undertaking</h3>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/submission/1200136">Code</a></p>
<p>分治。设当前处理的矩形为 <span class="math inline">\([l_1,r_1]\times [l_2,r_2]\)</span>。如果 <span class="math inline">\(r_1-l_1&gt;r_2-l_2\)</span>，我们就把矩形转一下，保证矩形的宽度大于高度，接着在中间砍一刀，分成 <span class="math inline">\([l_1,r_1]\times [l_2,mid]\)</span> 和 <span class="math inline">\([l_1,r_l]\times [mid+1,r_2]\)</span> 两部分，如此递归下去。</p>
<p>每次，我们计数 "左边界小于等于 <span class="math inline">\(y=mid\)</span>" 且 "右边界大于等于 <span class="math inline">\(y=mid+1\)</span>" 的矩形。</p>
<p><span class="math inline">\(\forall i\in [l_1,r_1]\)</span>，扫描这一行，找到最小的 <span class="math inline">\(L[i]\)</span> 和最大的 <span class="math inline">\(R[i]\)</span>，其中 <span class="math inline">\(l_2\le L[i]\le mid &lt; R[i]\le r_2\)</span>，满足 <span class="math inline">\((i,L[i])\sim (i,R[i])\)</span> 为同种字母。同样的，还要处理出 <span class="math inline">\(D[i][j]\)</span> 表示 <span class="math inline">\((i,j)\)</span> 向下最多能延伸多少格。</p>
<p>在中心线上，我们枚举待计数矩形的上下边界，贡献可以用前缀和 or 树状数组加速计算。</p>
<p>时间复杂度 <span class="math inline">\(O(nm\log nm)\)</span>。代码里我图方便写的双 <span class="math inline">\(\log\)</span>，同样跑得飞快。</p>
<h2 id="杭电多校-6">【8.4】杭电多校 6</h2>
<p>前期题做的太慢了，1005 其实很简单但最后一小时二择的时候选了 1012。</p>
<h3 id="钥匙迷宫">1005. 钥匙迷宫</h3>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/contest/view-code?cid=1177&amp;rid=12268">Code</a></p>
<p>用大写字母表示锁，小写字母表示钥匙。</p>
<p>对于一组 <span class="math inline">\((X,x)\)</span>，容易看出：以 <span class="math inline">\(x\)</span> 为根时，<span class="math inline">\(X\)</span> 子树里的点的答案均为 <span class="math inline">\(0\)</span>。可以用树上差分标记所有不能作为起点的 <span class="math inline">\(x\)</span>。此时，剩下的能作为起点的 <span class="math inline">\(x\)</span> 一定形成一个连通块（连通块里只有钥匙没有锁）。</p>
<p>从这些点出发 bfs，模拟开锁的过程，看是否能遍历完图上所有点。若能，则这些起点答案为 <span class="math inline">\(1\)</span>，其余为 <span class="math inline">\(0\)</span>；否则，答案全为 <span class="math inline">\(0\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="cats-的加减乘除">1012. cats 的加减乘除</h3>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/contest/view-code?cid=1177&amp;rid=13817">Code</a></p>
<p>首先，一个符号位填入 <code>+</code> 和 <code>-</code> 的概率是均等的。意味着任何一段接在加减后的仅包含乘除的连续段，期望为 <span class="math inline">\(0\)</span>。因此，整个表达式的期望等于从头开始的乘除连续段的期望。</p>
<p>分两步，第一步计算所有方案对应的表达式的值之和，第二步计算方案数（即有多少种不同的表达式），二者相除就是期望。</p>
<p>第二步是简单的，令 <span class="math inline">\(c=\sum [p_i=-1]\)</span>，答案是 <span class="math inline">\(c!\cdot 4^{n-1}\)</span>。</p>
<p>对于第一步，枚举长度 <span class="math inline">\(i\)</span>，表示从头开始仅包含乘除的段的长度。设所有长为 <span class="math inline">\(i\)</span> 的这样的段的表达式值之和为 <span class="math inline">\(\text{ans}[i]\)</span>，答案就是 <span class="math inline">\(\text{ans}[i]\times 2\times 4^{n-i-1}\)</span>。意为这段紧接的是 <code>+</code> 或 <code>-</code>，而之后的符号随便填。</p>
<p>现在，题目转化为，对每个 <span class="math inline">\(i\in [1, n]\)</span>，求 <span class="math inline">\(\text{ans}[i]\)</span>。</p>
<p>如果没有 <span class="math inline">\(p_i=-1\)</span>，则 <span class="math inline">\(\text{ans}[k]=a_1\prod\limits_{i=2}^{k}\left(a_i+\dfrac{1}{a_i}\right)\)</span>。</p>
<p>如果存在 <span class="math inline">\(p_i=-1\)</span>，设有 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(-1\)</span>，这 <span class="math inline">\(m\)</span> 个位置需要填入序列中没有的数，设这些将要填入的数分别为 <span class="math inline">\(b_1,b_2,\ldots,b_m\)</span>。</p>
<p>发现如果 <span class="math inline">\(p_1=-1\)</span>，那将是特殊的，因为 <span class="math inline">\(p_1\)</span> 不能是除数。</p>
<p>分类讨论。当 <span class="math inline">\(p_1\neq -1\)</span> 时，令 <span class="math display">\[
F(x)=\prod_{i=1}^{m}\left(1+\left(b_i+\dfrac{1}{b_i}\right)x\right)
\]</span> 填入 <span class="math inline">\(m\)</span> 项中的 <span class="math inline">\(s\)</span> 项，所有表达式的值之和即为 <span class="math inline">\([x^s]F(x)\)</span>。这部分用分治 NTT 容易计算。</p>
<p>若 <span class="math inline">\(p_1=-1\)</span>，我们只能钦定 <span class="math inline">\(p_1\)</span> 是什么，枚举所有 <span class="math inline">\(p_1\)</span> 的可能取值并求和，答案是 <span class="math display">\[
[x^s]\sum_{i=1}^{m}\dfrac{b_ix}{\left(1+(b_i+\frac{1}{b_i})x\right)}\prod_{i=1}^{m}\left(1+\left(b_j+\dfrac{1}{b_j}\right)x\right)\tag{*}
\]</span> 我们重点关注前面那个和式怎么算。</p>
<p>这个和式是 <span class="math inline">\(m\)</span> 个一次分式相加，我们可以将其通分，具体的 <span class="math display">\[
\dfrac{F_1(x)}{G_1(x)}+\dfrac{F_2(x)}{G_2(x)}=\dfrac{F_1(x)G_2(x)+F_2(x)G_1(x)}{G_1(x)G_2(x)}
\]</span> 等价于三次多项式乘法。我们可以沿用分治 NTT 的方法，将每个一次分式作为叶子，回溯时合并上去。</p>
<p>最后通分完分母可以与 <span class="math inline">\((*)\)</span> 式右侧约去，只剩下分子。当然就算你没注意到也只不过多一次多项式求逆而已。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<h2 id="牛客多校-7">【8.5】牛客多校 7</h2>
<p>今天过题过得特别快，剩个 H，队友补了就是我补了（确信</p>
<h2 id="ucup3-35.-kraków">【8.6】Ucup3-35. Kraków</h2>
<p>F 挺有意思，但是不太会，等 dwdyy 会了教我（躺</p>
<h2 id="牛客多校-8">【8.7】牛客多校 8</h2>
<div class="note note-primary">
            <p>【整体二分】</p><p>适用：单个询问可以二分解决，询问能离线，询问间没有顺序依赖。</p><p>做法：对值域二分，通常是四元组 <span class="math inline">\((l, r, \{p\},\{q\})\)</span>，表示当前研究的询问的答案在 <span class="math inline">\([l, r]\)</span> 内，<span class="math inline">\(\{p\}\)</span> 是当前要考虑的元素/修改操作的集合，<span class="math inline">\(\{q\}\)</span> 是当前要考虑的询问集合。</p><p>很难说得清怎么做。下面是静态区间第 <span class="math inline">\(k\)</span> 小的板子。</p>
          </div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        静态区间第 k 小
    </div>
    <div class='spoiler-content'>
        <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-type">int</span> n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; p;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
		<span class="hljs-type">int</span> x;
		cin &gt;&gt; x;
		p.<span class="hljs-built_in">push_back</span>(&#123;x, i&#125;);
	&#125;
	vector&lt;array&lt;<span class="hljs-type">int</span>, 4&gt;&gt; q;
	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
		<span class="hljs-type">int</span> l, r, k;
		cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
		q.<span class="hljs-built_in">push_back</span>(&#123;l, r, k, i&#125;);
	&#125;
	<span class="hljs-function">Fenwick <span class="hljs-title">fen</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-keyword">auto</span> dfs = [&amp;] (<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, 
					vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;&gt; &amp;p, 
					vector&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">4</span>&gt;&gt; &amp;q) -&gt; <span class="hljs-type">void</span> &#123;
		<span class="hljs-keyword">if</span> (l == r || q.<span class="hljs-built_in">empty</span>()) &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, __, k, i] : q) &#123;
				ans[i] = l;
			&#125;
			<span class="hljs-keyword">return</span> ;
		&#125;
		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
		vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; pl, pr;
		vector&lt;array&lt;<span class="hljs-type">int</span>, 4&gt;&gt; ql, qr;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;cur : p) &#123;
			<span class="hljs-keyword">auto</span> &amp;[val, i] = cur; 
			<span class="hljs-keyword">if</span> (val &lt;= mid) &#123;
				pl.<span class="hljs-built_in">push_back</span>(cur);
				fen.<span class="hljs-built_in">add</span>(i, <span class="hljs-number">1</span>);
			&#125; <span class="hljs-keyword">else</span> &#123;
				pr.<span class="hljs-built_in">push_back</span>(cur);
			&#125;
		&#125;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;cur : q) &#123;
			<span class="hljs-keyword">auto</span> &amp;[L, R, k, i] = cur;
			<span class="hljs-type">int</span> res = fen.<span class="hljs-built_in">query</span>(L, R);
			<span class="hljs-keyword">if</span> (k &lt;= res) &#123;
				ql.<span class="hljs-built_in">push_back</span>(cur);
			&#125; <span class="hljs-keyword">else</span> &#123;
				k -= res;
				qr.<span class="hljs-built_in">push_back</span>(cur);
			&#125;
		&#125;
		fen.<span class="hljs-built_in">clear</span>();
		<span class="hljs-built_in">self</span>(self, l, mid, pl, ql);
		<span class="hljs-built_in">self</span>(self, mid + <span class="hljs-number">1</span>, r, pr, qr);
	&#125;;
	<span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">1e9</span>, p, q);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;
		cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	&#125;
&#125;</code></pre></div>

    </div>
</div>
<h3 id="h.-区间-lru">H. 区间 LRU</h3>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78738981">Code</a></p>
<p>令 <span class="math inline">\(pre[i]\)</span> 表示 <span class="math inline">\(a_i\)</span> 上一次出现的位置，<span class="math inline">\(f[i]\)</span> 表示区间 <span class="math inline">\([pre[i]+1,i-1]\)</span> 中不同的数的个数。</p>
<p>运用树状数组容易预处理出全部的 <span class="math inline">\(f[i]\)</span>，详见 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1972">Link</a>。</p>
<p>对于第一种类型的询问，相当于问 <span class="math inline">\([l, r]\)</span> 中有多少个 <span class="math inline">\(i\)</span>，满足 <span class="math inline">\(pre[i]\ge l\)</span> 且 <span class="math inline">\(f[i]&lt;k\)</span>。</p>
<p>对于第二种类型的询问，相当于问 <span class="math inline">\([l, r]\)</span> 中 <span class="math inline">\(f_i\)</span> 的第 <span class="math inline">\(k\)</span> 小值。</p>
<p>整体二分，对于当前四元组 <span class="math inline">\((l,r, \{p\},\{q\})\)</span>，按右端点 <span class="math inline">\(r\)</span> 升序遍历所有询问，将所有 <span class="math inline">\(p[i]\le r\)</span>，<span class="math inline">\(f[p[i]]\le mid\)</span> 的 <span class="math inline">\(i\)</span> 对应的 <span class="math inline">\(pre[i]\)</span> 加进树状数组。后面就是标准的处理了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<h2 id="杭电多校-7">【8.8】杭电多校 7</h2>
<p>倒闭 +1。</p>
<h3 id="qoj9904.-最小生成树">QOJ9904. 最小生成树</h3>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/submission/1213030">Code</a></p>
<p>很有意思的题。</p>
<p>暴力的做法是：将 <span class="math inline">\(a_i\)</span> 从小到大排序，假设当前为 <span class="math inline">\(a_k\)</span>，我们可以用并查集将所有 <span class="math inline">\(i+j=k\)</span> 且不在一个连通块的 <span class="math inline">\((i, j)\)</span> 连起来，支付 <span class="math inline">\(a_k\)</span> 的代价。</p>
<p>我们考虑加速这个过程。对于一个固定的 <span class="math inline">\(k\)</span>，所有 <span class="math inline">\(i+j=k\)</span> 的 <span class="math inline">\((i,j)\)</span> 需要满足 <span class="math inline">\(1\le i\le n,\ 1\le j=k-i\le n\)</span>，也就是 <span class="math inline">\(\max(1,k-n)\le i\le \min(n,k-1)\)</span>，我们将这个区间称作 <span class="math inline">\([l,r]\)</span>。</p>
<p>在这个区间里，每一对 <span class="math inline">\((i,j)\)</span> 都关于 <span class="math inline">\(\dfrac{k}{2}\)</span> 对称，也就是 <span class="math inline">\((l, r)\)</span>，<span class="math inline">\((l+1,r-1)\)</span>，<span class="math inline">\((l+2,r-2)\)</span>，<span class="math inline">\(\ldots\)</span> 这样组合。</p>
<p>做最小生成树时，我们会用并查集连边，令 <span class="math inline">\(f_i\)</span> 表示点 <span class="math inline">\(i\)</span> 所在连通块的根。</p>
<p>观察：将所有 <span class="math inline">\(i+j=k\)</span> 的 <span class="math inline">\((i,j)\)</span> 全连起来后，区间 <span class="math inline">\([l, r]\)</span> 对应的 <span class="math inline">\(f\)</span> 数组回文。</p>
<p>我们反复 check 区间 <span class="math inline">\([l, r]\)</span>，如果不回文，就二分找到第一个不回文的位置，并查集连起来，累加 <span class="math inline">\(a_k\)</span> 的贡献。</p>
<p>具体的，线段树维护正串哈希值和反串哈希值，二分一个固定的长度 <span class="math inline">\(p\)</span>，判断 <span class="math inline">\([l, r]\)</span> 内长为 <span class="math inline">\(p\)</span> 的前缀的正串和长为 <span class="math inline">\(p\)</span> 的后缀的反串是否相等。</p>
<p>因为生成树只用连 <span class="math inline">\(n - 1\)</span> 次，只会执行 <span class="math inline">\(O(n)\)</span> 次二分，每次线段树 check，总复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<p>另有单 <span class="math inline">\(\log\)</span> 的做法，占坑。</p>
<h3 id="切披萨">1011. 切披萨</h3>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/contest/view-code?cid=1178&amp;rid=17840">Code</a></p>
<p>离线整体二分。</p>
<p>为了方便之后切上凸壳，预先对点集（以下称 <span class="math inline">\(\{p\}\)</span>）按 <span class="math inline">\(x\)</span> 坐标从小到大排序，询问（直线集合，下称 <span class="math inline">\(\{q\}\)</span>）按斜率 <span class="math inline">\((-\dfrac{A}{B})\)</span> 从小到大排序，斜率相同优先截距 <span class="math inline">\((\dfrac{C}{B})\)</span> 大的。</p>
<p>对于当前四元组 <span class="math inline">\((l,r,\{p\},\{q\})\)</span>，将编号小于等于 <span class="math inline">\(mid\)</span> 的询问分进 <span class="math inline">\(\{ql\}\)</span>，否则分进 <span class="math inline">\(\{qr\}\)</span>。</p>
<p>问题是 <span class="math inline">\(\{p\}\)</span> 要如何划分。一个点被分进 <span class="math inline">\(\{pl\}\)</span> 当且仅当它在某一条 <span class="math inline">\(\{ql\}\)</span> 内的线段下方。</p>
<p>单调栈切出 <span class="math inline">\(\{ql\}\)</span> 的上凸壳，不仅记录组成上凸壳的每条直线的信息，还要处理出上凸壳上每个交点的横坐标，这样就可以按 <span class="math inline">\(x\)</span> 坐标从小到大遍历 <span class="math inline">\(\{p\}\)</span> 中的每个点，双指针移动到凸壳上对应的直线，判断当前点是否满足 <span class="math inline">\(Ax+By\le C\)</span>。满足的分到 <span class="math inline">\(\{pl\}\)</span>，否则分到 <span class="math inline">\(\{pr\}\)</span>。</p>
<p>算交点横坐标时，可以直接取整数，因为 <span class="math inline">\(\{p\}\)</span> 中均为整点。举个例子，若真实的 <span class="math inline">\(x=5.7\)</span>，你取 <span class="math inline">\(x’=5\)</span>，那么满足 <span class="math inline">\(y\le x\)</span> 的 <span class="math inline">\(y\)</span> 也满足 <span class="math inline">\(y\le x&#39;\)</span>；满足 <span class="math inline">\(y&gt;x\)</span> 的 <span class="math inline">\(y\)</span> 也满足 <span class="math inline">\(y&gt;x&#39;\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。注意不要输出行末空格，问就是 hduoj 特性。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Competitive-Programming/" class="category-chain-item">Competitive Programming</a>
  
  
    <span>></span>
    
  <a href="/categories/Competitive-Programming/other/" class="category-chain-item">other</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/UESTC/" class="print-no-link">#UESTC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【题解】2025 UESTC 暑假集训（div.1）</div>
      <div>https://kisuraop.github.io/posts/80517353.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>KisuraOP</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年7月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/a62f5f49.html" title="【题解】六月训练日记">
                        <span class="hidden-mobile">【题解】六月训练日记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://kisuraop.github.io/" target="_blank" rel="nofollow noopener"><span>KisuraOP</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>








  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
